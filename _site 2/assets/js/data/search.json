[
  
  {
    "title": "CartAppTest",
    "url": "/posts/ObjectTest/",
    "categories": "Study, TourApp",
    "tags": "",
    "date": "2024-11-14 08:33:00 +0900",
    





    
    "snippet": "어제 @ObservableObject, @StateObject와 관련된 글을 작성하면서 뭔가 테스트를 해보고싶어서 간단한 앱을 하나 만들어보려한다.장바구니 앱이며, https://dummyjson.com/products/1 사이트를 사용해서 DummyData가 있는 api를 호출하여 맘에드는 것을 담고,장바구니를 초기화할때 @ObservableObje...",
    "content": "어제 @ObservableObject, @StateObject와 관련된 글을 작성하면서 뭔가 테스트를 해보고싶어서 간단한 앱을 하나 만들어보려한다.장바구니 앱이며, https://dummyjson.com/products/1 사이트를 사용해서 DummyData가 있는 api를 호출하여 맘에드는 것을 담고,장바구니를 초기화할때 @ObservableObject, @StateObject의 차이를 통해 보여지는 화면이 다를것으로 판단이 들어서 그걸 확인해보려한다.우선 파일구조는 다음과 같다.1. 모델링struct WishModel: Codable {    let id: Int    let title, description, category: String    let price, discountPercentage, rating: Double    let stock: Int    let tags: [String]    let brand: String    let reviews: [Review]    let thumbnail: String}// MARK: - Reviewstruct Review: Codable {    let rating: Int    let comment, date, reviewerName, reviewerEmail: String}우선은 이렇게 해두었다.사실 간단한 테스트용이라 빼도 되는게 몇개 있긴한데 이정도만 살려두었다.2. 화면구성화면구성은 좀 심플하게 하려고한다.탭바를 통해 2개의 화면을 구성한다.1. TabView 구성파일명은 MainView로 하였고 여기에 TabView를 사용 하여 Tabbar를 만든다.struct MainView: View {    var body: some View {        TabView {            Tab(\"Display\", systemImage: \"eye\") {                DisplayView()            }            Tab(\"cart\", systemImage: \"cart\") {                CartView()            }        }    }}이전에는DisplayView()        .tabItem {                Text(\"Display\")                Image(systemName: \"eye\")                }CartView()        .tabItem {                Text(\"cart\")                Image(systemName: \"cart\")                }이런식으로 했지만 사용하려고하면 Deprecated 되었기에 써도 무관하지만 새롭게 사용하는 방식으로 하였다.다만 2개를 혼용하여 사용하지는 못한다.2. 첫번째 화면파일명은 DisplayView로 하였다.1. ToolBar상단에 장바구니 버튼을 누르면 menu를 띄워 추가, 전체삭제 이렇게 두개를 구성var body: some View {        NavigationStack {            NavigationView {                            }            .navigationBarItems(trailing: Button(action: {                            }, label: {                Image(systemName: \"cart\")            }))        }            }하지만 navigationBarItems 역시 Deprecated 되었다.struct DisplayView: View {    var body: some View {        NavigationStack {            Text(\"\")                .toolbar {                    ToolbarItem(placement: .navigationBarTrailing) {                        Button {                            print(\"test\")                        } label: {                            Image(systemName: \"cart\")                        }                    }            }                        NavigationView {                                            }        }            }}다만 toolBar를 사용하려면 Modifier개념으로 들어가기에 Text를 넣어주었다.2. ItemView가운데 화면에 제품설명제품설명은 센터에 이미지, 하단에 제품명, 제품설명, 가격 이정도로 심플하게이후에 위에 모델링한것들을 할지는 생각ItemView라는 새로운 파일을 만들어 주었다.struct ItemView: View {        @State var imageUrl: String = \"\"    @State var title: String = \"\"    @State var description: String = \"\"    @State var price: Double = 0        var body: some View {        VStack(spacing: 20) {            AsyncImage(url: URL(string: imageUrl)) { image in                image                    .resizable()                    .scaledToFit()            } placeholder: {                Image(systemName: \"photo\")                    .resizable()            }            .frame(width: UIScreen.main.bounds.width * 0.6, height: UIScreen.main.bounds.height * 0.4)            Text(title)            Text(description)                .padding(.horizontal, 20)            HStack {                Spacer()                Text(price.dollarAdd())            }            .padding(.horizontal, 25)        }    }}이렇게 세팅을 완료이때 가격이 타입이 Double이라서 앞에 $표시를 간단하게 붙이게 하기위해 Extension을 사용하여 Function을 하나 만들어 준다.extension Double {    func dollarAdd() -&gt; String {        return (\"$\\(self)\")    }}이렇게 만들면 굳이 \"$\\(price)\" 이런식으로 번거롭게 할 필요가 없어진다.현재는 이렇게 나온다.Navigation Toolbar를 처음에 버튼으로 했다가. 생각해보니 메뉴로 보이게 하는게 좋을듯 해서 바꾼다. ToolbarItem(placement: .navigationBarTrailing) {                        Menu {                            Button {                                print(\"added\")                            } label: {                                Text(\"추가하기\")                                Image(systemName: \"cart.badge.plus\")                            }                            Button {                                print(\"deleted\")                            } label: {                                Text(\"장바구니 비우기\")                                Image(systemName: \"cart.badge.minus\")                            }                        } label: {                            Image(systemName: \"cart\")                        }                    }그리고 아래에도 버튼을 만들어 주었다. HStack {                Button {                    print(\"next\")                } label: {                    Text(\"다음\")                        .fontWeight(.bold)                        .font(.headline)                        .foregroundStyle(.black)                        .frame(width: UIScreen.main.bounds.width * 0.45, height: UIScreen.main.bounds.height * 0.05)                        .background(RoundedRectangle(cornerRadius: 10, style: .continuous)                            .foregroundStyle(.blue)                            .opacity(0.5))                }                Button {                    print(\"add\")                } label: {                    Text(\"추가\")                        .fontWeight(.bold)                        .font(.headline)                        .foregroundStyle(.black)                        .frame(width: UIScreen.main.bounds.width * 0.45, height: UIScreen.main.bounds.height * 0.05)                        .background(RoundedRectangle(cornerRadius: 10, style: .continuous)                            .foregroundStyle(.green)                            .opacity(0.5))                }            }            .padding(.horizontal, 15)완료Menu에서는 장바구니 비우기 하나만 두기로 결정Menu {        Button {            cartViewModel.deleteAllData()        } label: {            Text(\"장바구니 비우기\")            Image(systemName: \"cart.badge.minus\")        }    } label: {        Image(systemName: \"cart\")    }현재는 이렇게 두었다.3. 두번째 화면리스트를 사용해서 어떤 물건이 등록되었는지 보여주기SwipeAction을 사용하여 개별 제거 가능.파일명은 CartView로 하였다.아직 데이터가 정확하게 들어오지 않았으므로 우선은 심플하게 뼈대만var body: some View {        VStack {            List() { cart in                HStack {                    Text(\"상품명\")                    Spacer()                    Text(\"가격자리\")                }            }        }    }3. Api 관련 코드작성이전에 했던것처럼 Generic을 사용해서 해볼것이다.enum NetworkError: Error {    case badUrl    case invalidRequest    case badResponse    case badStatus    case failedToDecodeResponse}class WishService {    func downLoadData&lt;T: Codable&gt;(url: String) async -&gt; T? {        do {            guard let url = URL(string: url) else { throw NetworkError.badUrl }            let (data, response) = try await URLSession.shared.data(from: url)            guard let response = response as? HTTPURLResponse else { throw NetworkError.badResponse }            guard response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300 else { throw NetworkError.badStatus }            guard let decodedData = try? JSONDecoder().decode(T.self, from: data) else { throw NetworkError.failedToDecodeResponse }                        return decodedData                    } catch NetworkError.badUrl {            print(\"There was an error creating the URL\")        } catch NetworkError.badResponse {            print(\"Did not get a valid response\")        } catch NetworkError.badStatus {            print(\"Did not get a 2xx status code from the response\")        } catch NetworkError.failedToDecodeResponse {            print(\"Failed to decode response into the given type\")        } catch {            print(\"An error occured downloading the data\")        }                return nil    }}이렇게 만들어 준다.이번엔 이전과 달리 decode에도 T를 사용함으로써 Generic을 유지한다.class WishViewModel: ObservableObject {    @Published var wishList: [WishModel] = []        init() {            Task {                await fetchWishList()            }        }    func fetchWishList() async {        let randomNumber: Int = Int.random(in: 1...100)        let url: String = \"https://dummyjson.com/products/\\(randomNumber)\"        guard let list: WishModel = await WishService().downLoadData(url: url) else { return }                wishList = [list]    }}4. Api 호출하기여기서 선택지가 주어진다ViewModel에 대해 @ObservedObject 또는 @StateObject 를 사용하는건데지금은 크게 상관이 없어서 둘중 아무거나쓰고 나중에 비교할때 다시 관련 헤더를 만들어서 작성해보는걸로ItemView에서 호출을 해보도록하자.@ObservedObject var wishViewModel = WishViewModel()        var body: some View {        VStack(spacing: 20) {            AsyncImage(url: URL(string: wishViewModel.wishList!.thumbnail))이런식으로 해주었다.데이터가 있어서 강제 언래핑을 하긴했지만 에러가 발생아무래도 제대로 호출이 안된듯하다.문제는 여기를 찍고 다음을 넘기게되면 바로 에러가뜨는곳으로 넘어가게 된다.우선 뭐가 잘못되었는지 다시 코드를 봐야할듯하다.우선 빼먹은건 ViewModel에서 @MainActor를 빼먹었다.하지만 이게 문제는 아니었다.관련된 뷰를 전부 주석으로 잡고guard let url = URL(string: url) else { throw NetworkError.badUrl }let (data, response) = try await URLSession.shared.data(from: url)print(data)print(response)guard let response = response as? HTTPURLResponse else { throw NetworkError.badResponse }guard response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300 else { throw NetworkError.badStatus }guard let decodedData = try? JSONDecoder().decode(T.self, from: data) else { throw NetworkError.failedToDecodeResponse }return decodedData이렇게 해본결과1757 bytes&lt;NSHTTPURLResponse: 0x6000002e9280&gt; { URL: https://dummyjson.com/products/89 } { Status Code: 200, Headers {생략}Failed to decode response into the given type1757bytes이기때문에 데이터도 제대로 받아왔다.왜냐면 코드가 200이기 때문이다.즉 호출은 제대로 되었고, 문제는 type이었다.Generic을 사용했는데 어디서 문제인지 확인이 필요해보인다.guard let decodedData = try? JSONDecoder().decode(WishModel.self, from: data) else { throw NetworkError.failedToDecodeResponse }우선 여기를 그냥 모델로했을때는 출력이 된다.즉 Generic사용에서 문제가 생겼다는것을 알 수 있다.하지만 이건 문제 해결과정에서 내가 고치다가 잘못된것이었고 처음에는 func fetchWishList() async {        let randomNumber: Int = Int.random(in: 1...194)        let url: String = \"https://dummyjson.com/products/\\(randomNumber)\"        guard let list: WishModel = await WishService().downLoadData(url: url) else { return }                wishList = [list]    }이렇게 되어있었기에 크게 문제가 안된다.다시 주석을 풀고 실행을 해보니 역시나 문제가 발생뭔가 ViewModel을 가져와서 init을 했음에도 불구하고 data, response 부분에서 바로 계속 AsyncImage로 넘어가는게 이상하다.아무래도 api를 호출하면서 View가 먼저 렌더링 되기에 발생하는 문제로 보인다.아무래도 초기에 데이터값을 주어야하나보다.그래서VStack(spacing: 20) {            AsyncImage(url: URL(string: wishViewModel.wishList.first?.thumbnail ?? \"\")) { image in                image                    .resizable()                    .scaledToFit()            } placeholder: {                Image(systemName: \"photo\")                    .resizable()            }            .frame(width: UIScreen.main.bounds.width * 0.6, height: UIScreen.main.bounds.height * 0.4)            Text(wishViewModel.wishList.first?.title ?? \"\")            Text(wishViewModel.wishList.first?.description ?? \"\")                .padding(.horizontal, 20)            HStack {                Spacer()                Text(wishViewModel.wishList.first?.price.dollarAdd() ?? \"$\")            }            .padding(.horizontal, 25)            HStack {                Button {                    print(\"next\")                } label: {                    Text(\"다음\")                        .fontWeight(.bold)                        .font(.headline)                        .foregroundStyle(.black)                        .frame(width: UIScreen.main.bounds.width * 0.45, height: UIScreen.main.bounds.height * 0.05)                        .background(RoundedRectangle(cornerRadius: 10, style: .continuous)                            .foregroundStyle(.blue)                            .opacity(0.5))                }                Button {                    print(\"add\")                } label: {                    Text(\"추가\")                        .fontWeight(.bold)                        .font(.headline)                        .foregroundStyle(.black)                        .frame(width: UIScreen.main.bounds.width * 0.45, height: UIScreen.main.bounds.height * 0.05)                        .background(RoundedRectangle(cornerRadius: 10, style: .continuous)                            .foregroundStyle(.green)                            .opacity(0.5))                }            }            .padding(.horizontal, 15)        }        .onAppear {            if wishViewModel.wishList.isEmpty {                Task {                    await wishViewModel.fetchWishList()                }            }        }    }옵셔널 체이닝을 통해 값을 주었다.그제서야 해결….그러면서 어떤 애들은 또 디코딩 에러가 나길래struct WishModel: Codable {    let id: Int    let title, description: String    let price: Double    let thumbnail: String}모델을 대폭 축소화한다.이미지도 약간 사이즈마다 다른듯해서.scaledToFill() 이걸로 바꿔준다.지금 다음을 눌렀을때 새롭게 가져오는건Button {                    Task {                        await wishViewModel.fetchWishList()                    }                } label: {                    Text(\"다음\")버튼에 이렇게 다시 fetch를 하도록 해두었기 때문.5. Cart 기능 구현SwiftData와 CoreData 둘중 뭘해볼까 고민을 하다 구글링을 했는데질문글이 있어서 읽어보니 뭐 그렇다고 한다.그래서 CoreData를 간만에 다시 써보는걸로,물론 UIKit에서는 AppDelegate에서 Container설정을 했는데 그부분은 좀 달라서 알아두면 좋긴 할듯하다.이후 내가 작성한 글을 다시 읽어보다가 SwiftData도 조금 더 사용해볼겸 한프로젝트에 다시 사용해보는것도 좋을듯해서 만들어 보기로 결정. [11.16 수정]1. Model 만들기여기는 좀 심플하게 List에만 보여주고 클릭시 새롭게 정보를 보여주는 용도는 아니라 가볍게 만든다.struct CartModel: Identifiable {    let id: Int    let title: String    let price: Double}간단하게 이름과 가격만으로 설정을 해둔다.이때 list에 들어갈것이라 Identifiable 프로토콜을 채택해준다.그래서 id도 같이 해준다.SwiftUI에서 List를 사용할때는 데이터의 무결성을 중요시하므로 채택을 해주도록 하자.2. CoreData 사용UIKit을 사용할때는 AppDelegate에서 Container를 사용했는데Youtube를 참고하여 구현해보았다.1. 모델링여기서 생성을 해주자.이때 파일명을 정하고 생성을 누르니 이런 창이 뜬다.이전에 없었던것같은데, GPT에게 차이를 물어보았다..xcdatamodel vs .xcdatamodeld 확장자 차이Core Data에서 데이터 모델 파일을 생성할 때, 다음 두 가지 확장자를 사용할 수 있다:  .xcdatamodel  .xcdatamodeldXcode에서는 올바른 확장자 사용을 권장하며, 아래는 두 확장자의 차이점이다.📝 차이점 요약            확장자      설명      사용 시기                  .xcdatamodel      단일 데이터 모델 파일이다. 하나의 데이터 모델만 포함한다.      이전 버전의 Core Data 프로젝트              .xcdatamodeld      데이터 모델 파일의 패키지이다. 여러 개의 .xcdatamodel 파일을 포함할 수 있다.      현재 버전의 Core Data 프로젝트      📌 .xcdatamodel  단일 모델 파일로, Core Data의 초기 버전에서 사용되었다.  버전 관리 기능이 없다.  이 확장자를 사용하면, 데이터 모델 변경 시 버전 관리가 불가능해 문제가 발생할 수 있다.📌 .xcdatamodeld  패키지 디렉토리로, 여러 개의 .xcdatamodel 파일을 포함할 수 있다.  Core Data의 버전 관리 기능을 지원한다.          예를 들어, V1.xcdatamodel, V2.xcdatamodel처럼 여러 버전의 모델을 저장할 수 있다.        현재 Xcode에서는 표준 확장자로 .xcdatamodeld를 사용하며, 데이터 모델의 버전 관리를 위해 권장된다.⚠️ Xcode 알림 설명Xcode에서 .xcdatamodel 확장자를 사용해 파일을 생성하려고 하면, .xcdatamodeld 확장자를 권장하는 알림이 나타난다.  “Use .xcdatamodel”: 단일 모델 파일을 사용하겠다는 의미로, 버전 관리가 불가능하다.  “Use .xcdatamodeld”: 패키지 확장자를 사용하며, 버전 관리 기능을 사용할 수 있다.  “Cancel”: 파일 생성을 취소한다.✅ 권장 사항  현재 프로젝트에서는 .xcdatamodeld 확장자를 사용하는 것이 권장된다.  이를 통해 Core Data의 버전 관리 기능을 활용할 수 있으며, 데이터 모델 변경 시 문제가 줄어든다.따라서, 창에서 “Use .xcdatamodeld” 옵션을 선택하는 것이 올바른 선택이다.이렇게 모델링 그대로 설정을 해준다.이때 Entity 명은 Cart로 해준다2. Container 생성 및 함수 구현ViewModel에 Container를 생성하고 이때 init을 통해 ViewModel 객체가 만들어질때 자연스럽게 Container를 생성하는 방식으로 이루어 진다.1. Container 만들기let container: NSPersistentContainer        @Published var cart: [Cart] = []        init() {        container = NSPersistentContainer(name: \"Cart\")        container.loadPersistentStores { (description, error) in            if let error = error {                fatalError(\"Failed to load persistent stores: \\(error)\")            }        }    }이렇게 만들어 준다.Container를 만들면서 init에 집어넣음으로써,ViewModel이 만들어지면서 Container가 만들어지게 된다.2. Fetch 함수 구현func fetchRequest() {    let request = NSFetchRequest&lt;Cart&gt;(entityName: \"Cart\")        do {        cart = try container.viewContext.fetch(request)    } catch {        print(\"Fetch failed: \\(error)\")    }}뭐 사실 크게 이질적인 부분은 없는듯 하다.가끔 CoreData의 Entity가 만들어지지 않아 Cart를 적어도 없다고 뜨는경우엔 Xcode를 재실행하면 만들어진다.3. 장바구니 담기 구현func addCart(model: WishModel) {    let item = Cart(context: container.viewContext)    item.id = Int64(model.id)    item.title = model.title    item.price = model.price        saveData()}    func saveData() {    do {        try container.viewContext.save()        fetchRequest() // added    } catch {        print(\"Save failed: \\(error)\")    }}이건 저장하는것도 같이 첨부를 하는데, 이전에도 작성을 해둔적이 있지만, CoreData의 Data가 변할때는 Save를 반드시 해주어야 한다.(11.16 추가) 그리고 이전에 깜빡하고 적지 않았는데 fetch함수를 추가하여 배열이 업데이트 되도록 하였다.4. 삭제기능 구현func deleteData(object: Cart) {    container.viewContext.delete(object)    saveData()}func deleteAllData() {    let request: NSFetchRequest&lt;NSFetchRequestResult&gt; = Cart.fetchRequest()    let deleteRequest = NSBatchDeleteRequest(fetchRequest: request)        do {        try container.viewContext.execute(deleteRequest)        try container.viewContext.save()    } catch {        print(\"Delete failed: \\(error)\")    }}이것도 부분삭제, 전체삭제를 한꺼번에 한다.전체삭제가 기억나지가 않아서, 참고 글을 보고 적용했다.이전에도 이부분을 아마 해외사이트 보고 참고해서 적었던 기억이있다.3. SwiftData 사용 (11.16 수정)SwiftData도 사용하면 좋을듯해서 이미 프로젝트파일 자체는 다 만들어졌기에 새롭게 버튼을 하나 추가해서 Coredata저장, SwiftData저장 이렇게 버튼을 나눠본다.이전에 글을 작성을 해봤기에 그걸 좀 참고하면서 작성하면 더 각인이 되지 않을까 싶다.1. 모델링이전에 만들었던 CartModel을 사용하는것보다, 새롭게 만들어서 비교를 하는게 좋을듯해서 새롭게 만들어본다.우선 SwiftData를 사용할때는 @Model Wrapper를 사용해준다.이때 보통 우리가 모델링을 할때는 struct를 사용했지만 이녀석은 class를 사용해줘야한다.그렇게 바꾸고 나니 이런에러가 난다.첫번째는 init을 해주지 않아서 발생.두번째는 Swift6 부터는 에러가 발생할거라고 경고를 준다.let을 사용하지말라는것이다.import SwiftData@Modelclass SDCartModel {    var id: Int    var title: String    var price: Double        init(id: Int, title: String, price: Double) {        self.id = id        self.title = title        self.price = price    }}이렇게 작성을 해주면 아주 기본적인 모델링이 완성되고, 모든 에러와 경고가 깔끔하게 사라진다.이후에 무결성이 필요하다면#Unique나 @Attribute를 추가로 사용하겠다.@Model을 사용해준 이유는 해당 클래스가 SwiftData의 데이터 모델로 인식되도록 지정한다. 이를 통해 이 클래스의 인스턴스는 SwiftData에서 관리되는 데이터베이스 엔티티가 된다. (이전 글에서도 서술)2. SwiftData용 Button과 View새롭게 추가.1. SDCartViewvar body: some View {        VStack {            List {                ForEach(cartViewModel.cart, id: \\.self) { cart in                    HStack {                        Text(cart.title ?? \"\")                        Spacer()                        Text(cart.price.dollarAdd())                    }                    .swipeActions(edge: .trailing) {                        Button {                            currentCartItem = cart                            isDelete.toggle()                        } label: {                            Image(systemName: \"trash\")                        }                                            }                }            }            .alert(\"항목 삭제\", isPresented: $isDelete) {                Button(\"삭제\", role: .destructive) {                    if let item = currentCartItem {                        cartViewModel.deleteData(object: item)                    }                }                Button(\"취소\", role: .cancel) {}            } message: {                Text(\"이 항목을 삭제하시겠습니까?\")            }        }        .onAppear {            cartViewModel.fetchRequest()        }    }일단은 기존에 만든 CartView의 내용을 그대로 가져왔다.아래 서술할 작업들을 해두고 나서 하나씩 수정을 이에 맞게 할생각이다.2. MainViewButton {        cartViewModel.deleteAllData()    } label: {        Text(\"SD장바구니 비우기\")        Image(systemName: \"cart.badge.minus\")    }Tab(\"SDCart\", systemImage: \"cart.circle\") {                        SDCartView(cartViewModel: cartViewModel)                    }이렇게 메뉴와 탭을 하나 더 추가를 해준다.3. ItemView여기서는 SwiftData에 추가를 해줄 버튼만 하나 만들어 주면 된다.Button {                    } label: {            Text(\"SD추가\")                .fontWeight(.bold)                .font(.headline)                .foregroundStyle(.black)                .frame(width: UIScreen.main.bounds.width * 0.3, height: UIScreen.main.bounds.height * 0.05)                .background(RoundedRectangle(cornerRadius: 10, style: .continuous)                    .foregroundStyle(.red)                    .opacity(0.5))        }//                .alert(isPresented: $isDuplicated) {//                    Alert(title: Text(\"중복 확인\"),//                          message: Text(\"이미 장바구니에 있습니다.\"))//                }우선은 이렇게만 뼈대를 해준다.Frame을 이전에는 버튼이 2개라 90%정도 있으면 좋을듯해서 가로길이의 0.45 였으나, 버튼이 3개므로 0.3을 적용해주었다.적용된사진은 다음과 같다.3. Container 생성 및 함수 구현여기서 부터는 참고글을 바탕으로 좀 만들어 보려고한다.1. Container 만들기보통은 앱과 똑같은 명의 swift파일에 하는듯하다.UIKit에서의 AppDelegate와 같은 위치랄까@mainstruct ApiCartApp: App {    let container: ModelContainer        var body: some Scene {        WindowGroup {            MainView()        }        .modelContainer(container)    }        init() {        do {            container = try ModelContainer(for: SDCartModel.self)        } catch {            fatalError()        }    }}우선은 이렇게 만들었다.Container에 들어가는 for는 우리가 만들어둔 모델을 적용하면된다.이때 원래는 MainView(modelContext: container.mainContext) 이런식으로 context를 전달해야하는데 아직 완성되지않아서 함수를 구현다 하고 다시 세팅할 예정Medium글을 읽어보는데, Coredata처럼 ViewModel에서도 container init이 가능하다.그래서 좀 수정을 해본다.@MainActorclass SDCartViewModel: ObservableObject {        private let modelContainer: ModelContainer    private let modelContext: ModelContext        @Published var cart: [SDCartModel] = []        init() {        self.modelContainer = try! ModelContainer(for: SDCartModel.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))        self.modelContext = modelContainer.mainContext    }        func fetchRequest() -&gt; [SDCartModel] {        do {            return try modelContext.fetch(FetchDescriptor&lt;SDCartModel&gt;())        } catch {            fatalError()        }    }}이렇게 적용하게되면 처음에 App.swift에서는 만들 필요가 없어진다.그래서 지웠다.isStoredInMemoryOnly: true?            속성      설명      true일 때      false일 때                  isStoredInMemoryOnly      메모리에만 데이터를 저장할지 여부 설정      메모리에만 저장하고, 디스크에 저장하지 않음      디스크에 영구적으로 데이터를 저장함              장점      빠른 데이터 접근 속도      테스트 용도 또는 임시 데이터 처리에 적합      영구적인 데이터 저장 가능              단점      데이터 영구성      앱 종료 시 데이터 손실      디스크 I/O로 인해 성능 저하 가능              사용 예시      용도      테스트 및 임시 데이터      실제 사용자 데이터, 영구적 저장 필요      2. Fetch 함수 구현크게 Fetch 함수에 대해선 없는게 그냥 우리가 만든 배열에 저장이되고 그걸 그냥 가져다 쓰면 된다.func fetchRequest() {        do {            cart = try modelContext.fetch(FetchDescriptor&lt;SDCartModel&gt;())        } catch {            fatalError()        }    }특이한 점이라면 request가 아닌 FetchDescriptor를 사용했다는 점.Docs를 보게 되면 애초에 Fetch를 하면서 원하는 조건을 설정하여 가져올 수 있게 되어있다.두개 차이는 아래에서 추후 서술.3. 장바구니 담기 구현func addCart(model: WishModel) {        let item = SDCartModel(id: model.id, title: model.title, price: model.price)        modelContext.insert(item)        saveCart()    }func saveCart() {        do {            try modelContext.save()            fetchRequest()        } catch {            fatalError()        }    }CoreData와 거의 유사 딱히 서술할점은 없어보인다.4. 삭제기능 구현func deleteCart(object: SDCartModel) {        modelContext.delete(object)        saveCart()    }전체삭제는 참고글을 보고 작성한다.func deleteAllCart() {        do {            try modelContext.delete(model: SDCartModel.self)            saveCart()        } catch {            fatalError()        }    }6. 담기 기능 적용하기.1. CoreData생각을 해보니 ViewModel을 가져다 적용을하는데Navigation Toolbar는 DisplayView에 담기버튼은 ItemView에 있다.일단은 진행을 해보자, 어차피 CoreData에 있는걸 배열로 가져오는것이기에 크게 문제는 없어보인다. (1차생각)우선은 직관적으로 보이기 쉬운 ItemView에서 먼저 기능을 구현해보기로 한다.@StateObject var cartViewModel = CartViewModel()Button {        cartViewModel.addCart(model: wishViewModel.wishList.first!)    }이렇게 해주었다.1. 저장경로 확인하기이전에는 print(FileManager.default.urls(for: .documentDirectory, in: .userDomainMask))이걸통해서 확인했는데, 그대로 한번 적용해서 되는지 확인해보자.경로 바로 이동하는건 Command + Shift + GsqlViewer에서는 안보여서 그냥 바로 다음스텝으로 간다.2. 두번째 화면에서 List를 통해 가져오기struct CartView: View {    @StateObject var cartViewModel = CartViewModel()        var body: some View {        VStack {            List(cartViewModel.cart) { cart in                HStack {                    Text(cart.title ?? \"\")                    Spacer()                    Text(cart.price.dollarAdd())                }            }        }    }}기존 두번째 화면에서 viewModel 쪽만 추가.추가했던게 잘 나오고 있었다.안되는줄알고 무지성으로 눌렀더니 중복 문제가 발생.ForEach&lt;Array&lt;Cart&gt;, Int64, HStack&lt;TupleView&lt;(Text, Spacer, Text)&gt;&gt;&gt;: the ID 116 occurs multiple times within the collection, this will give undefined results!예외처리는 추후에 다시 하는걸로.(11.16 사진 추가)2. SwiftData(11.16 추가)이제 추가를 해보는 단계이다.1. ItemView에 Viewmodel 추가@StateObject var sdCartViewModel: SDCartViewModelButton {        sdCartViewModel.addCart(model: wishViewModel.wishList.first!)    } label: {        Text(\"SD추가\")            .fontWeight(.bold)            .font(.headline)            .foregroundStyle(.black)            .frame(width: UIScreen.main.bounds.width * 0.3, height: UIScreen.main.bounds.height * 0.05)            .background(RoundedRectangle(cornerRadius: 10, style: .continuous)                .foregroundStyle(.red)                .opacity(0.5))    }이렇게 해주었다. 당연히 의존성 주입을 위해 MainView에는@StateObject var sdCartViewModel = SDCartViewModel()Button {        sdCartViewModel.deleteAllCart()    } label: {        Text(\"SD장바구니 비우기\")        Image(systemName: \"cart.badge.minus\")    }Tab(\"Display\", systemImage: \"eye\") {                        ItemView(wishViewModel: wishViewModel,                                 cartViewModel: cartViewModel,                                 sdCartViewModel: sdCartViewModel)                    }이렇게 적용을 해주었다.2. SDCartView 적용@StateObject var sdCartViewModel: SDCartViewModelviewmodel을 전달해주니 바로 적용이된다.움짤 귀찮아서 패스이제 기능을 적용해보자.struct SDCartView: View {    @StateObject var sdCartViewModel: SDCartViewModel        @State private var isDelete = false    @State private var currentCartItem: SDCartModel?        var body: some View {        VStack {            List {                ForEach(sdCartViewModel.cart, id: \\.self) { cart in                    HStack {                        Text(cart.title)                        Spacer()                        Text(cart.price.dollarAdd())                    }                    .swipeActions(edge: .trailing) {                        Button {                            currentCartItem = cart                            isDelete.toggle()                        } label: {                            Image(systemName: \"trash\")                        }                                            }                }            }            .alert(\"항목 삭제\", isPresented: $isDelete) {                Button(\"삭제\", role: .destructive) {                    if let currentCartItem {                        sdCartViewModel.deleteCart(object: currentCartItem)                    }                }                Button(\"취소\", role: .cancel) {}            } message: {                Text(\"이 항목을 삭제하시겠습니까?\")            }        }        .onAppear {            sdCartViewModel.fetchRequest()        }    }}완료.이전에 Coredata할때 처럼 중복추가에 대해서도 적용을 해본다. f let checkTitle = wishViewModel.wishList.first?.title {                        isDuplicated = sdCartViewModel.checkDuplicate(title: checkTitle)                        if isDuplicated == false {                            sdCartViewModel.addCart(model: wishViewModel.wishList.first!)                        }                    } else {                        print(\"Title does not exist\")                    }코드는 동일작동 확인 완료.이렇게 확인도 된다.7. SwipeAction을 통한 삭제기능 구현로드되는것도 확인이 되었으니 이제 swipeaction을 통해 삭제를 해보자.var body: some View {        VStack {            List {                ForEach(cartViewModel.cart, id: \\.self) { cart in                    HStack {                        Text(cart.title ?? \"\")                        Spacer()                        Text(cart.price.dollarAdd())                    }                    .swipeActions(edge: .trailing) {                        Button {                            cartViewModel.deleteData(object: cart)                        } label: {                            Image(systemName: \"trash\")                        }                    }                }            }        }    }이렇게 swipeaction을 추가해주었다.삭제는 되는데 문제는 바로 업데이트가 되지않고, 재실행을 해야 지워진게 확인됨을 알았다.그리고 추가를하고 탭뷰를 눌러서 카트를 가보면 UIUpdate가 되지않기에 onappear를 사용했다.struct CartView: View {    @StateObject var cartViewModel = CartViewModel()        var body: some View {        VStack {            List {                ForEach(cartViewModel.cart, id: \\.self) { cart in                    HStack {                        Text(cart.title ?? \"\")                        Spacer()                        Text(cart.price.dollarAdd())                    }                    .swipeActions(edge: .trailing) {                        Button {                            cartViewModel.deleteData(object: cart)                            cartViewModel.fetchRequest()                        } label: {                            Image(systemName: \"trash\")                        }                    }                }            }        }        .onAppear {            cartViewModel.fetchRequest()        }    }}우선 작동은 완료.사진을 다시보니 CartView 쪽에선 navigation tab bar가 보이지 않아서 지우고 MainView에 통합시킨다.struct MainView: View {    var body: some View {        NavigationStack {            Text(\"\")                .toolbar {                    ToolbarItem(placement: .navigationBarTrailing) {                        Menu {                            Button {                                print(\"added\")                            } label: {                                Text(\"추가하기\")                                Image(systemName: \"cart.badge.plus\")                            }                            Button {                                print(\"deleted\")                            } label: {                                Text(\"장바구니 비우기\")                                Image(systemName: \"cart.badge.minus\")                            }                        } label: {                            Image(systemName: \"cart\")                        }                    }            }            NavigationView {                TabView {                    Tab(\"Display\", systemImage: \"eye\") {                        ItemView()                    }                    Tab(\"cart\", systemImage: \"cart\") {                        CartView()                    }                }            }        }            }}사진은 패스.NavigationView가 의미없이 사용이되어 개선을 한다 (11.16)struct MainView: View {    @StateObject var wishViewModel = WishViewModel()    @StateObject var cartViewModel = CartViewModel()    @StateObject var sdCartViewModel = SDCartViewModel()    var body: some View {        NavigationStack {            TabView {                Tab(\"Display\", systemImage: \"eye\") {                    ItemView(wishViewModel: wishViewModel,                             cartViewModel: cartViewModel,                             sdCartViewModel: sdCartViewModel)                }                Tab(\"CoreCart\", systemImage: \"cart\") {                    CoreCartView(cartViewModel: cartViewModel)                }                Tab(\"SDCart\", systemImage: \"cart.circle\") {                    SDCartView(sdCartViewModel: sdCartViewModel)                }                Tab(\"Test\", systemImage: \"star\") {                    TestView()                }            }            .toolbar {                ToolbarItem(placement: .navigationBarTrailing) {                    Menu {                        Button {                            cartViewModel.deleteAllData()                        } label: {                            Text(\"Core 장바구니 비우기\")                            Image(systemName: \"cart.badge.minus\")                        }                        Button {                            sdCartViewModel.deleteAllCart()                        } label: {                            Text(\"SD 장바구니 비우기\")                            Image(systemName: \"cart.badge.minus\")                        }                    } label: {                        Image(systemName: \"cart\")                    }                }            }        }    }}개선 이유중 하나는 TestView에는 필요가 없는것도 있다.8. 전체 삭제 적용toolbar {        ToolbarItem(placement: .navigationBarTrailing) {            Menu {                Button {                    print(\"added\")                } label: {                    Text(\"추가하기\")                    Image(systemName: \"cart.badge.plus\")                }                Button {                    cartViewModel.deleteAllData()                } label: {                    Text(\"장바구니 비우기\")                    Image(systemName: \"cart.badge.minus\")                }            } label: {                Image(systemName: \"cart\")            }        }}우선 전체 삭제는 되지만, View가 서로 달라서 CartView가 활성화 된상태에서 비우면 바로 적용이 안되는 문제가 있다.9. CoreData vs SwiftData비교는 내가 작성한 코드와 간단하게 정리한것을 바탕으로 GPT를 통해 정리해달라고 했다.CoreData와 SwiftData 비교 표            항목      CoreData (NSPersistentContainer)      SwiftData (ModelContainer)                  데이터 컨테이너      NSPersistentContainer 사용      ModelContainer 사용              데이터 컨텍스트      viewContext 사용      mainContext 사용              컨테이너 초기화      loadPersistentStores()로 로드      try! ModelContainer()로 간단히 초기화              메모리 저장 옵션      메모리 전용 옵션 없음      isStoredInMemoryOnly 옵션 지원              Fetch 요청      NSFetchRequest 사용      FetchDescriptor 사용              데이터 삽입      NSManagedObject 인스턴스 생성 후 삽입      Swift 구조체 인스턴스를 생성 후 삽입              데이터 삭제      NSBatchDeleteRequest 등을 사용하여 삭제      modelContext.delete() 메서드 사용              저장 방식      SQLite 데이터베이스 (.sqlite) 파일로 저장      SQLite 데이터베이스 (.store) 파일로 저장              모델 정의 방식      .xcdatamodeld 파일에서 엔티티 정의      Swift 구조체 및 @Model 어노테이션 사용              SwiftUI 통합      ObservableObject로 사용 가능하지만 별도 설정 필요      SwiftData는 SwiftUI와 원활하게 통합됨      위의 표는 GPT에게 viewmodel로 만든 코드를 비교하여 정리를 해달라고 한것이다.1. 모델링CoreData는 CoreData를 사용하기위한 별도의 .xcdatamodeld파일 생성이 필요하다.그리고 그에따른 Model를 만들어줘야한다.struct CartModel: Identifiable {    let id: Int    let title: String    let price: Double}하지만 SwiftData는 파일을 만들 필요가 없고,import SwiftData@Modelclass SDCartModel {    var id: Int    var title: String    var price: Double        init(id: Int, title: String, price: Double) {        self.id = id        self.title = title        self.price = price    }}이렇게 모델링을 해주는것만으로도 해결이 된다.정리CoreData와 SwiftData의 모델 정의 방식의 차이를 아래 표로 정리함. CoreData는 .xcdatamodeld 파일이 필요하지만, SwiftData는 Swift 코드 내에서 직접 모델을 정의할 수 있다.            항목      CoreData      SwiftData                  모델 파일 필요 여부      별도의 .xcdatamodeld 파일 필요      Swift 코드에서 직접 정의, 추가 파일 필요 없음              모델 정의 방식      .xcdatamodeld에서 엔티티와 속성 정의      Swift 클래스/구조체에 @Model 어노테이션 사용              초기화 방식      NSManagedObject 클래스 상속, context 필요      일반 Swift 클래스, Swift 초기화 방식 사용              코드 간결성      .xcdatamodeld 파일과 코드로 분리됨      Swift 코드만으로 정의 가능, 간결하고 직관적임              Swift 언어 특징 사용      Swift의 타입 안전성 및 구조체 사용 어려움      Swift의 기본 타입과 초기화 메서드 사용 가능      부연 설명  모델 파일 생성 필요 여부:          CoreData는 .xcdatamodeld 파일을 통해 모델 구조를 시각적으로 정의함. 이 파일에서 모든 엔티티와 속성을 정의하고, 자동 생성된 NSManagedObject 서브클래스를 사용해야 함.      SwiftData는 별도의 모델 파일 없이, Swift 코드에서 직접 모델 정의가 가능함. 이를 통해 Swift 언어의 타입 안전성과 구조체 사용이 가능함.        코드의 간결성:          CoreData는 모델 정의가 .xcdatamodeld 파일과 코드로 분리되어 있어, 코드 간결성이 떨어지고, 변경 시 파일과 코드 모두 수정해야 함.      SwiftData는 코드 내에서 모든 모델 정의가 가능해, 코드가 더 직관적이고 간결함.        초기화 방식:          CoreData는 context를 필요로 하는 NSManagedObject 초기화 방식을 사용함.      SwiftData는 일반 Swift 클래스의 초기화 방식을 따르며, context를 명시할 필요가 없음.      결론  CoreData는 전통적인 방식으로, 시각적인 모델링과 복잡한 설정이 필요할 때 유리함.  SwiftData는 최신 Swift 언어의 특징을 잘 반영하고 있으며, 더 간단하고 간결한 코드로 정의 가능함.이건 GPT를 통해 정리를 해준내용.2. Container우선 Container 생성을 할때 CoreData는 xcdatamodeld 파일을 만들고 거기 안에 있는 Entity의 명을 제대로 적어 줘야한다.하지만 SwiftData는 우리가 만든 데이터 모델을이 들어간다.그리고 메모리 저장을 할지 말지(isStoredInMemoryOnly)에 대한 차이가 가장 크다.저장되는 파일이 조금 다르다.CoreData는 .sqlite이고 SwiftData는 .store파일이다.물론 두개다 Viewer 프로그램을 통해 확인이 가능하다.정리            항목      CoreData      SwiftData                  모델 정의 방식      .xcdatamodeld 파일 필요, 엔티티 이름을 지정      Swift 클래스/구조체를 직접 지정 (@Model)              초기화 방식      NSPersistentContainer와 loadPersistentStores() 사용      try! ModelContainer()로 간단하게 초기화              메모리 저장 옵션      메모리 전용 저장 옵션 없음      isStoredInMemoryOnly 옵션 지원              저장 파일 확장자      .sqlite (Model.sqlite)      .store (default.store)              파일 뷰어 프로그램      .sqlite 파일은 SQLite Viewer로 확인 가능      .store 파일도 SQLite Viewer로 확인 가능      부연 설명  모델 정의 방식:          CoreData는 .xcdatamodeld 파일을 생성하고, 그 안에 엔티티(Entity)와 속성을 정의함. 컨테이너 초기화 시 .xcdatamodeld 파일 이름을 정확히 지정해야 함.      SwiftData는 Swift 코드 내에서 직접 데이터 모델을 정의하며, @Model 어노테이션을 사용해 Swift 구조체나 클래스를 모델로 지정함.        메모리 저장 옵션:          CoreData는 메모리 전용 저장소 옵션이 없고, 기본적으로 디스크에 데이터를 저장함.      SwiftData는 isStoredInMemoryOnly: true 옵션을 통해 데이터를 메모리에만 저장할 수 있음. 이는 테스트나 임시 데이터 처리 시 유리함.        저장 파일 확장자:          CoreData는 SQLite 형식의 데이터베이스를 사용하며, 저장 파일의 확장자는 .sqlite임 (Model.sqlite).      SwiftData는 .store 확장자를 사용하며 (default.store), 더 간단한 파일 형식을 사용함.        파일 뷰어 프로그램:          두 파일 모두 SQLite 형식이기 때문에, DB Browser for SQLite나 SQLiteStudio 같은 뷰어 프로그램에서 확인 가능함.      결론  CoreData는 전통적인 방식으로, .xcdatamodeld 파일과 SQLite 데이터베이스(.sqlite)를 사용함. 더 많은 설정이 필요하지만, 복잡한 데이터 모델링에 유리함.  SwiftData는 간단하고 현대적인 방식으로, Swift 코드에서 직접 모델을 정의하며, 메모리 전용 옵션과 간단한 초기화 방식이 특징임. 더 간결하고 Swift 언어의 특성을 잘 살리고 있음.위에 Total로 정리한것이랑 중복은 있을것이다. GPT를 통해 정리를 해달라고 했기때문3. ContextCoreData나 SwiftData 모두 Context를 통해 CRUD를 적용하게된다.CoreData는 NSManagedObjectContext이다.SwiftData는 ModelContext이다.정리CoreData와 SwiftData 모두 Context를 사용해 CRUD (Create, Read, Update, Delete) 작업을 수행함. CoreData는 NSManagedObjectContext를 사용하고, SwiftData는 ModelContext를 사용함. 전체 데이터를 삭제할 때 CoreData는 NSBatchDeleteRequest와 execute() 메서드를 사용하며, SwiftData는 delete(model:) 메서드를 사용함.            항목      CoreData (NSManagedObjectContext)      SwiftData (ModelContext)                  Context 타입      NSManagedObjectContext      ModelContext              데이터 삽입 방식      insert(_:) 메서드로 NSManagedObject 삽입      insert(_:) 메서드로 Swift 구조체 삽입              데이터 저장 방식      save() 메서드 호출      save() 메서드 호출              데이터 삭제 방식      delete(_:) 메서드 호출      delete(_:) 메서드 호출              Fetch 요청      NSFetchRequest 사용      FetchDescriptor 사용              전체 삭제 방식      NSBatchDeleteRequest와 execute() 메서드 사용      delete(model:) 메서드 사용      부연 설명  Context 역할:          Context는 데이터의 일시적인 작업 공간으로, 메모리에 로드된 데이터를 관리하고, 변경 사항을 추적함. 변경된 데이터를 저장(save())하면 영구 저장소에 반영됨.        CRUD 작업의 일관성:          CoreData와 SwiftData 모두 Context를 통해 데이터 삽입(insert), 삭제(delete), 저장(save) 작업을 수행함.      CoreData의 NSManagedObjectContext는 NSManagedObject를 사용해 데이터를 관리함.      SwiftData의 ModelContext는 Swift 구조체나 클래스를 직접 관리하므로, 타입 안전성이 높고 더 간결함.        전체 데이터 삭제 방식:          CoreData는 NSBatchDeleteRequest를 사용해 전체 데이터를 삭제함. NSFetchRequest로 엔티티를 지정하고, 이를 기반으로 NSBatchDeleteRequest 객체를 생성함. 이후 execute() 메서드를 호출해 요청을 실행함.      SwiftData는 delete(model:) 메서드를 사용해 간단하게 전체 데이터를 삭제할 수 있음. 모델(SDCartModel.self)만 지정하면 되므로 코드가 더 간결함.        SwiftUI와의 통합:          SwiftData의 ModelContext는 SwiftUI의 @Environment에서 직접 접근할 수 있어, SwiftUI와의 통합이 더 쉬움 (@Environment(\\.modelContext)).      CoreData의 NSManagedObjectContext도 SwiftUI와 통합할 수 있지만, @Environment(\\.managedObjectContext)를 통해 접근해야 하며, 추가적인 설정이 필요할 수 있음.      결론  CoreData는 전통적인 데이터 관리 프레임워크로, NSManagedObjectContext를 사용하여 다양한 고급 기능을 제공함. 특히, NSBatchDeleteRequest와 같은 기능을 통해 대규모 데이터 삭제 시 성능 최적화를 할 수 있음. 그러나 초기 설정이 복잡하고, .xcdatamodeld 파일 관리 및 복잡한 API 사용으로 인해 코드가 길어질 수 있음.  SwiftData는 현대적인 Swift 기반의 데이터 관리 프레임워크로, ModelContext를 사용하여 더 간결하고 타입 안전한 코드 작성을 가능하게 함. 간단한 delete(model:) 메서드를 통해 전체 데이터를 삭제할 수 있으며, SwiftUI와의 자연스러운 통합으로 인해 최신 SwiftUI 프로젝트에서 사용하기 적합함.  SwiftData는 Swift의 기본 타입과 구조체를 직접 사용할 수 있어, 코드의 간결성 및 유지보수성이 높음. 특히, 메모리 전용 옵션(isStoredInMemoryOnly)은 테스트 환경에서 유리하며, SwiftUI 환경에서의 개발 생산성을 크게 향상시킴.따라서:  복잡한 데이터 모델과 고급 기능이 필요한 경우에는 CoreData가 적합함.  간결한 코드, SwiftUI와의 높은 호환성, 그리고 타입 안전성을 중시하는 경우에는 SwiftData가 더 적합함.10. 문제 해결크게 3가지 문제가 파악이 되었다.1. 중복 문제func checkDuplicate(title: String) -&gt; Bool {        if cart.contains(where: { $0.title == title }) {            return true        } else {            return false        }    }다음과 같이 중복확인을 하는 함수를 만들어 주었다.이걸 통해 true / false 체크하여 Alert를 띄우도록 한다.그리고 Alert를 띄우기 위해 Button을 약간 수정한다.@State var isDuplicated = falseButton {        isDuplicated = cartViewModel.checkDuplicate(title: wishViewModel.wishList.first?.title ?? \"\")        print(wishViewModel.wishList.first?.title)        print(isDuplicated)        if !isDuplicated {            cartViewModel.addCart(model: wishViewModel.wishList.first!)        }            } label: {        Text(\"추가\")            .fontWeight(.bold)            .font(.headline)            .foregroundStyle(.black)            .frame(width: UIScreen.main.bounds.width * 0.45, height: UIScreen.main.bounds.height * 0.05)            .background(RoundedRectangle(cornerRadius: 10, style: .continuous)                .foregroundStyle(.green)                .opacity(0.5))    }    .alert(isPresented: $isDuplicated) {        Alert(title: Text(\"중복 확인\"),                message: Text(\"이미 장바구니에 있습니다.\"))    }하지만 계속 false가 뜨는 문제가 발생.print를 해보니Optional(\"Knoll Saarinen Executive Conference Chair\") 옵셔널이어서 타입이 달라서 그런건가? 라는 생각이 들어서 옵셔널 바인딩을 해보았으나 실패.if let checkTitle = wishViewModel.wishList.first?.title {                        isDuplicated = cartViewModel.checkDuplicate(title: checkTitle)                        print(isDuplicated)                        if !isDuplicated {                            cartViewModel.addCart(model: wishViewModel.wishList.first!)                        }                    } else {                        print(\"Title does not exist\")                    }일단 이건 그대로 두는걸로.print(cart.map { $0.title ?? \"\" })를 해본결과담기를 했지만 CartViewModel의 cart가 업데이트가 되지 않아서 생긴 문제였다.func addCart(model: WishModel) {        let item = Cart(context: container.viewContext)        item.id = Int64(model.id)        item.title = model.title        item.price = model.price                saveData()}func saveData() {        do {            try container.viewContext.save()            fetchRequest()        } catch {            print(\"Save failed: \\(error)\")        }    }추가할때마다 fetchRequest()를 실행하게 해주었다.아무래도 데이터가 변화가 있을때마다 save와 fetch를 둘다 해야하는듯 하다.생각해보니 이전에는 배열에 직접 넣어줬기에 관리가 되었는데 지금은 그렇지 않다.계속 fetchRequest를 하는건 그렇게 좋아보이지는 않는듯하다.근본적인 방법을 좀 바꿔야할 필요가 있어보인다.일단은 fetchRequest()를 호출하는 식으로 변경2. CoreData WarningCoreData: error: +[Cart entity] Failed to find a unique match for an NSEntityDescription to a managed object subclass아마 이것도 init과 연관이 좀 있어보이는듯 하다.ViewModel이 메모리가 다른데 CoreData를 공유하기에 발생했던 문제, 즉 init이 여러번 이루어 졌다.3-2의 문제를 해결하면서 해소. (역시 맞았다.)3. 전체 삭제 문제 (CartView)현재 2가지 문제가 있다.1. 전체 삭제 후 UI Update 안됨CartView에서 전체 삭제를 하게되면 view가 업데이트 되지 않는 문제가 있다.2번 문제를 해결 하면서 자연스럽게 해결.2. 카트에 담고 전체삭제후 다시 담을경우 중복 에러 발생장바구니를 비웠으나 아무래도 배열에 대해 초기화가 되지않아서 생기는 문제로 보인다.삭제하는 함수에 print(cart.map { $0.title ?? \"\" })이걸 다시 넣어서 배열을 확인해봐야할듯하다.배열은 [] 이렇게 빈걸로 나온다.아무래도 한번 추가를 하고나면 true로 바뀌어서 그런걸로 보인다.if let checkTitle = wishViewModel.wishList.first?.title {                        isDuplicated = cartViewModel.checkDuplicate(title: checkTitle)                        if !isDuplicated {                            cartViewModel.addCart(model: wishViewModel.wishList.first!)                            isDuplicated = false                        }                    } else {                        print(\"Title does not exist\")                    }추가하고 난뒤 false로 바꿔주기로 결정.그래도 안된다.onAppear에 print로 찍어봤지만 false가 뜬다.문득 각 View 마다 cartViewModel을 인스턴스화 하는데, 그것도 혹시 영향이 있지 않을까라는 생각이 들어서 바꿔본다.해결이 되었다.원래는 모든 문제를 해결하고 이후에 하나로 바꿔줄 생각이었는데 이게 문제였다….그러면서 자연스럽게 전체삭제후 UI가 바뀌지않던 부분도 해결ViewModel에 대해 각각 CoreData를 공유하더라도 ViewModel이 서로 달랐기에 충돌이 일어나지 않았을까 싶다.// MainView@StateObject var cartViewModel = CartViewModel() @ObservedObject var wishViewModel = WishViewModel()Tab(\"Display\", systemImage: \"eye\") {                        ItemView(wishViewModel: wishViewModel,                                cartViewModel: cartViewModel)                    }                    Tab(\"cart\", systemImage: \"cart\") {                        CartView(cartViewModel: cartViewModel)                    }// ItemView@StateObject var cartViewModel: CartViewModel@ObservedObject var wishViewModel: WishViewModel// CartView@StateObject var cartViewModel: CartViewModel지금은 MainView에서 ViewModel을 인스턴스화 해서 필요한 Item, CartView에 전달하는 식으로 바꾸었다.4. SwipeAction시 발생하는 WarningAttempted to invalidate swipe actions layout for invalid decoration index path: &lt;NSIndexPath: 0x8a8d70bf3cd24cb2&gt; {length = 2, path = 0 - 0}이런 경고가 뜬다.확인해보니 List의 마지막을 지울때 발생하게 된다.유효하지 않은 indexpath 에서 유효하지않은 swipeaction이 시도가 되었다는데,뭔가 삭제하고나서도 swipeaction이 활성화가 되어있는지는 모르겠다.그래서 삭제할때 Alert를 띄우면 어떨까 싶어서 해보려고한다.@State private var isDelete = false@State private var currentCartItem: Cart?    var body: some View {    VStack {        List {            ForEach(cartViewModel.cart, id: \\.self) { cart in                HStack {                    Text(cart.title ?? \"\")                    Spacer()                    Text(cart.price.dollarAdd())                }                .swipeActions(edge: .trailing) {                    Button {                        currentCartItem = cart                        isDelete.toggle()                    } label: {                        Image(systemName: \"trash\")                    }                                    }            }        }        .alert(\"항목 삭제\", isPresented: $isDelete) {            Button(\"삭제\", role: .destructive) {                if let item = currentCartItem {                    cartViewModel.deleteData(object: item)                }            }            Button(\"취소\", role: .cancel) {}        } message: {            Text(\"이 항목을 삭제하시겠습니까?\")        }    }    .onAppear {        cartViewModel.fetchRequest()    }}Warning이 더이상 뜨지 않는다.끝.검색해도 내용이 없어서 GPT에게 물어봤다.Alert를 사용했을 때 문제가 해결되는 이유SwiftUI에서 Alert를 사용하면 스와이프 액션 관련 문제가 해결되는 이유는 상태 관리와 이벤트 흐름에 있다. Alert는 SwiftUI에서 비동기적인 UI 업데이트 문제를 해결하고, 스와이프 액션이 남아 있는 상태를 정상적으로 종료시킨다.문제의 원인  스와이프 액션이 활성화된 상태에서 데이터 삭제          사용자가 셀을 스와이프한 후, 삭제 버튼을 누르기 전까지 스와이프 액션이 활성화된 상태로 남아 있다.      이 상태에서 데이터를 삭제하면, SwiftUI는 스와이프 액션이 완료되지 않은 상태에서 셀을 제거하려고 시도하게 된다.      결과적으로 비정상적인 인덱스 참조 문제가 발생할 수 있다.        SwiftUI의 비동기 UI 업데이트 문제          Core Data에서 데이터를 삭제하면, 데이터 소스는 즉시 업데이트된다.      그러나 SwiftUI의 List 뷰는 UI 업데이트와 스와이프 액션 종료 사이에 시간 차이가 있을 수 있다.      특히 마지막 셀을 삭제할 때 문제가 더 자주 발생한다.      Alert가 문제를 해결하는 이유  스와이프 액션 종료          Alert가 표시되면 SwiftUI는 현재 활성화된 스와이프 액션을 종료한다.      SwiftUI는 Alert가 표시되는 동안 사용자 인터랙션을 차단하고, 스와이프 액션이 비활성화된다.      이를 통해, 스와이프 액션이 남아 있는 문제가 방지된다.        UI 업데이트 타이밍 안정화          Alert가 표시되면서 SwiftUI는 UI 업데이트 흐름을 차단하고, 데이터가 안전하게 변경될 시간을 제공한다.      사용자가 Alert에서 “삭제”를 선택하면, 이 시점에서 SwiftUI는 안정된 상태에서 데이터를 업데이트할 수 있다.      이로 인해 List 뷰와 데이터 소스 간의 불일치 문제가 해결된다.      결론  Alert는 스와이프 액션을 종료하고, SwiftUI가 안정적인 상태에서 UI 업데이트를 수행할 수 있도록 돕는다.  Alert가 표시되면서 사용자 인터랙션이 차단되고, 스와이프 액션도 정상적으로 종료된다.  이를 통해 비동기 UI 업데이트 문제와 데이터 간 불일치 문제가 해결된다.11. 테스트여기서 말하는 테스트는 글을 작성하면서 제일 처음에 적었던@ObservableObject, @StateObject 이것에 대해서 해보려고한다.이 앱을 하려고한건처음 생각은 이랬다.  화면하나에 api를 호출하는게 있고 위에 장바구니 초기화 버튼이 있다.      api조회를 한 결과가 화면에 있고 장바구니 초기화를 눌렀을때 api결과가 그대로인상태에서 장바구니가 초기화되면 stateobjectapi조회를 한 결과가 화면에 있고 장바구니 초기화를 눌렀을때 api결과가 초기화되고 장바구니가 초기화되면 observedobject  이런 개념으로 좀 테스트를 해보려고 한것이었다.근데 만들다보니 장바구니 초기화를 하면서 view의 변화가 없다.원래 의도는 장바구니를 초기화하게되었을때 api도 초기화 되면서 새롭게 리로드를 하는걸 상상했는데구현하다보니 의도와 다르게 코드가 작성이 되어버렸다.새롭게 뷰를 만들어서 진행한다.그동안 긴글 작성하느라 지쳐서 GPT한테 기본적인 틀을 만들어 달라고 한뒤, 세부적인 것을 계속 손봤다.struct TestView: View {    @ObservedObject var cartViewModel = CartViewModel()    var body: some View {        VStack(spacing: 20) {            Text(\"TestView - API 조회 및 장바구니 테스트\")                .font(.headline)            // 독립적인 API 조회 뷰            ApiDataSubview(cartViewModel: cartViewModel)            // 독립적인 장바구니 조작 뷰            Text(\"장바구니 내용\")                .font(.headline)            List(cartViewModel.cart, id: \\.self) { item in                Text(item.title ?? \"No Title\")            }            Button(\"장바구니 초기화\") {                cartViewModel.deleteAllData()            }            .padding()        }    }}struct ApiDataSubview: View {    //@ObservedObject var testWishViewModel = TestWishViewModel()    @StateObject var testWishViewModel = TestWishViewModel()    @ObservedObject var cartViewModel: CartViewModel    var body: some View {        VStack {            Text(\"API 조회 결과\")                .font(.headline)            // API 데이터 리스트            List(testWishViewModel.wishList, id: \\.id) { item in                HStack {                    Text(item.title)                    Spacer()                    Button(\"담기\") {                        cartViewModel.addCart(model: item)                    }                    .buttonStyle(.borderedProminent)                }            }            // API 조회 버튼            Button(\"API 조회\") {                Task {                    await testWishViewModel.fetchWishList()                }            }            .padding()        }        .border(Color.blue, width: 2)    }}이게 최종적으로 만들어진 코드.여러 시행착오가 있었다.시행착오1. MainView → TestView 로 ViewModel 전달// MainViewTab(\"Test\", systemImage: \"star\") {                    TestView(wishViewModel: wishViewModel,                             cartViewModel: cartViewModel)                }struct TestView: View {    @ObservedObject var wishViewModel: WishViewModel    @ObservedObject var cartViewModel: CartViewModel    var body: some View {        VStack(spacing: 20) {            Text(\"TestView - API 조회 및 장바구니 테스트\")                .font(.headline)            // API 데이터 표시 및 추가 버튼            List(wishViewModel.wishList, id: \\.id) { item in                HStack {                    Text(item.title)                    Spacer()                    Button(\"담기\") {                        cartViewModel.addCart(model: item)                    }                    .buttonStyle(.borderedProminent)                }            }            // API 조회 버튼            Button(\"API 조회\") {                Task {                    await wishViewModel.fetchWishList()                }            }            .padding()            // 장바구니 초기화 버튼            Button(\"장바구니 초기화\") {                cartViewModel.deleteAllData()            }            .padding()            // 장바구니 데이터 표시            Text(\"장바구니 내용\")                .font(.headline)            List(cartViewModel.cart, id: \\.self) { item in                Text(item.title ?? \"No Title\")            }        }        .onAppear {            Task {                await wishViewModel.fetchWishList()            }        }    }}실패.변화가 없음.2. TestView에서 자체 Instance 생성struct TestView: View {    @StateObject var wishViewModel = WishViewModel() // 독립적인 인스턴스 생성    @StateObject var cartViewModel = CartViewModel() // 독립적인 인스턴스 생성    var body: some View {        VStack(spacing: 20) {            Text(\"TestView - 독립적인 뷰 모델 사용\")                .font(.headline)            // API 데이터 표시 및 장바구니 담기 버튼            List(wishViewModel.wishList, id: \\.id) { item in                HStack {                    Text(item.title)                    Spacer()                    Button(\"담기\") {                        cartViewModel.addCart(model: item)                    }                }            }            // API 조회 버튼            Button(\"API 조회\") {                Task {                    await wishViewModel.fetchWishList()                }            }            .padding()            // 장바구니 초기화 버튼            Button(\"장바구니 초기화\") {                cartViewModel.deleteAllData()            }            .padding()            // 장바구니 데이터 표시            Text(\"장바구니 내용\")                .font(.headline)            List(cartViewModel.cart, id: \\.self) { item in                Text(item.title ?? \"No Title\")            }        }        .onAppear {            Task {                await wishViewModel.fetchWishList()            }        }    }}결과는 상동.3. TestView 강제 렌더링@State private var forceRefreshId = UUID() // 뷰의 강제 재생성을 위한 IDvar body: some View {    VStack {        Button(\"TestView 강제 초기화\") {            forceRefreshId = UUID() // 새로운 UUID로 업데이트하여 뷰를 강제 초기화        }        TestView()            .id(forceRefreshId) // ID가 변경되면 뷰가 강제로 재생성됨    }}이건 뷰를 새롭게 렌더링하면서 인스턴스를 새로 생성하는것.이건 새롭게 렌더링 하면서 onAppear를 통해 새롭게 렌더링을 하므로wrapper와 상관없이 API결과가 계속 달라진다.그래서 onAppear를 빼보았다.조회 결과가 사라진다.왜냐 새롭게 뷰가 렌더링 되었지만 fetch를 하지 않았기 때문.4. 이전에 참고했던 글과 유사한 방식으로 재시도RandomNumberView의 자식뷰로 CounterView가 있었던걸 생각해서 그렇게 구현을 해보았다.struct TestView: View {    //@StateObject var wishViewModel = WishViewModel() // 테스트 1: 유지되는 경우    @ObservedObject var wishViewModel = WishViewModel() // 테스트 2: 초기화되는 경우    @ObservedObject var cartViewModel = CartViewModel()    var body: some View {        VStack(spacing: 20) {            Text(\"TestView - API 조회 및 장바구니 테스트\")                .font(.headline)            // 독립적인 API 조회 뷰            ApiDataSubview(wishViewModel: wishViewModel)            // 독립적인 장바구니 조작 뷰            CartDataSubview(cartViewModel: cartViewModel)        }    }}struct ApiDataSubview: View {    @ObservedObject var wishViewModel: WishViewModel    @ObservedObject var cartViewModel: CartViewModel    var body: some View {        VStack {            Text(\"API 조회 결과\")                .font(.headline)            // API 데이터 리스트            List(wishViewModel.wishList, id: \\.id) { item in                HStack {                    Text(item.title)                    Spacer()                    Button(\"담기\") {                        cartViewModel.addCart(model: item)                    }                    .buttonStyle(.borderedProminent)                }            }            // API 조회 버튼            Button(\"API 조회\") {                Task {                    await wishViewModel.fetchWishList()                }            }            .padding()        }        .border(Color.blue, width: 2)    }}struct CartDataSubview: View {    @ObservedObject var cartViewModel: CartViewModel    var body: some View {        VStack {            Text(\"장바구니 내용\")                .font(.headline)            List(cartViewModel.cart, id: \\.self) { item in                Text(item.title ?? \"No Title\")            }            Button(\"장바구니 초기화\") {                cartViewModel.deleteAllData()            }            .padding()        }        .border(Color.green, width: 2)    }}영향이 없다.5. CartDataSubView를 제거 (최종)1. TestView  @ObservedObject var cartViewModel = CartViewModel()으로 선언하여 CartViewModel 인스턴스는 TestView에서 직접 생성.  ApiDataSubview와 독립적인 장바구니 데이터를 표시하는 UI로 구성.  “장바구니 초기화” 버튼을 통해 장바구니 데이터를 삭제.struct TestView: View {    @ObservedObject var cartViewModel = CartViewModel()    var body: some View {        VStack(spacing: 20) {            Text(\"TestView - API 조회 및 장바구니 테스트\")                .font(.headline)            // 독립적인 API 조회 뷰            ApiDataSubview(cartViewModel: cartViewModel)            // 독립적인 장바구니 조작 뷰            Text(\"장바구니 내용\")                .font(.headline)            List(cartViewModel.cart, id: \\.self) { item in                Text(item.title ?? \"No Title\")            }            Button(\"장바구니 초기화\") {                cartViewModel.deleteAllData()            }            .padding()        }    }}2. ApiDataSubview  @StateObject var testWishViewModel = TestWishViewModel()으로 선언하여 TestWishViewModel 인스턴스는 ApiDataSubview에서 직접 생성.  API 조회 결과를 표시하고, “담기” 버튼을 통해 장바구니에 아이템을 추가.  @StateObject를 사용함으로써, testWishViewModel 인스턴스가 유지됨.struct ApiDataSubview: View {    //@ObservedObject var testWishViewModel = TestWishViewModel()    @StateObject var testWishViewModel = TestWishViewModel()    @ObservedObject var cartViewModel: CartViewModel    var body: some View {        VStack {            Text(\"API 조회 결과\")                .font(.headline)            // API 데이터 리스트            List(testWishViewModel.wishList, id: \\.id) { item in                HStack {                    Text(item.title)                    Spacer()                    Button(\"담기\") {                        cartViewModel.addCart(model: item)                    }                    .buttonStyle(.borderedProminent)                }            }            // API 조회 버튼            Button(\"API 조회\") {                Task {                    await testWishViewModel.fetchWishList()                }            }            .padding()        }        .border(Color.blue, width: 2)    }}🏆 성공 요인            요인      설명                  1. @StateObject 사용      ApiDataSubview에서 @StateObject로 선언한 testWishViewModel은 인스턴스가 유지됨.              2. 독립적인 서브 뷰 구조      ApiDataSubview와 장바구니 표시 뷰를 독립적인 서브 뷰로 분리하여 각각의 상태를 독립적으로 관리.              3. @ObservedObject로 전달된 인스턴스      CartViewModel은 TestView에서 생성되어 재렌더링 시 초기화되지 않음.              4. 뷰의 생명주기 차이 확인 가능      @StateObject는 뷰의 처음 생성 시 한 번만 초기화, @ObservedObject는 뷰가 재렌더링 시마다 초기화됨.      🎯 테스트 결과 비교            선언 방식      testWishViewModel 초기화 여부      API 조회 결과 유지 여부      장바구니 데이터 유지 여부                  @StateObject      ❌ (한 번만 초기화됨)      ✅ (유지됨)      ✅ (유지됨)              @ObservedObject      ✅ (재렌더링 시 초기화됨)      ❌ (초기화됨)      ✅ (유지됨)      결론  @StateObject는 뷰의 생명주기 동안 인스턴스를 유지하므로, API 조회 결과가 유지.  @ObservedObject는 뷰가 재렌더링될 때마다 인스턴스를 새로 생성하므로, API 조회 결과가 초기화.11. 결과1. ObservedObjectstruct ApiDataSubview: View {    @ObservedObject var testWishViewModel = TestWishViewModel()장바구니 UI가 변하면서 api를 재호출함.재호출 하는 이유는 새롭게 만든 ViewModel에@MainActorclass TestWishViewModel: ObservableObject {    @Published var wishList = [WishModel]()    init() {        Task {            await fetchWishList()        }    }    func fetchWishList() async {        let randomNumber: Int = Int.random(in: 1...194)        let url: String = \"https://dummyjson.com/products/\\(randomNumber)\"        guard let list: WishModel = await WishService().downLoadData(url: url) else { return }        wishList = [list]    }}이렇게 init을 해주었기 때문.init을 하지않고 기존에 만들어둔 WishViewModel을 사용하면 wishList가 빈배열이므로 아무 결과도 나오지 않는다.2. @StateObjectstruct ApiDataSubview: View {    @StateObject var testWishViewModel = TestWishViewModel()장바구니 UI가 변해도 API 조회 결과가 그대로 유지된다.3. 한화면에 보여지게 수정struct TestView: View {    @ObservedObject var cartViewModel = CartViewModel()    var body: some View {        ScrollView {            VStack(spacing: 5) {                // ObservedObject 섹션                VStack {                    Text(\"ObservedObject - API 조회\")                        .font(.headline)                    ApiDataSubview(cartViewModel: cartViewModel)                        .frame(height: 180)                }                .padding()                .background(Color.blue.opacity(0.1))                .cornerRadius(10)                // StateObject 섹션                VStack {                    Text(\"StateObject - API 조회\")                        .font(.headline)                    ApiStateSubview(cartViewModel: cartViewModel)                        .frame(height: 180)                }                .padding()                .background(Color.red.opacity(0.1))                .cornerRadius(10)                // 장바구니 내용 섹션                VStack {                    Text(\"장바구니 내용\")                        .font(.headline)                    List(cartViewModel.cart, id: \\.self) { item in                        Text(item.title ?? \"No Title\")                    }                    .frame(height: 80)                    Button(\"장바구니 초기화\") {                        cartViewModel.deleteAllData()                    }                    .padding(.vertical, 5)                    .buttonStyle(.borderedProminent)                }                .padding()                .background(Color.green.opacity(0.1))                .cornerRadius(10)            }            .padding()        }        .navigationBarHidden(true) // NavigationBar 완전히 숨기기    }}그리고 view하나더 만들었다.struct ApiStateSubview: View {    @StateObject var testWishViewModel = TestWishViewModel()    @ObservedObject var cartViewModel: CartViewModel    var body: some View {        VStack {            Text(\"API 조회 결과 - StateObject\")                .font(.headline)            if let item = testWishViewModel.wishList.first {                HStack {                    Text(item.title)                    Spacer()                    Button(\"담기\") {                        cartViewModel.addCart(model: item)                    }                    .buttonStyle(.borderedProminent)                }                .padding()                .background(Color.white.opacity(0.9))                .cornerRadius(10)            }             Button(\"API 조회\") {                Task {                    await testWishViewModel.fetchWishList()                }            }            .padding()        }    }}ApiDataSubview, ApiStateSubview 이렇게 만들었고 ApiDataSubview의 코드도 위의 코드와 동일하게 하되 @observedobject 이걸로만 바꿨다.그러면 이렇게 한화면에서 비교가 가능해진다.내가 생각한대로 결과가 나온다. 하지만 이걸하면서 느낀건 부모뷰와 자식관계에 따라 @StateObject, @ObservableObject의 결과가 같을수도 다를수도 있다는것.@StateObject vs @ObservedObject 가설과 결과 분석이건 GPT를 통해 정리를 해달라고했다.초기 가설처음에 내가 생각한 가설은 위에도 언급했었던  화면하나에 api를 호출하는게 있고 위에 장바구니 초기화 버튼이 있다.      api조회를 한 결과가 화면에 있고 장바구니 초기화를 눌렀을때 api결과가 그대로인상태에서 장바구니가 초기화되면 stateobjectapi조회를 한 결과가 화면에 있고 장바구니 초기화를 눌렀을때 api결과가 초기화되고 장바구니가 초기화되면 observedobject  이것이다.  화면 구성:          API 호출 결과를 표시하는 뷰와, 장바구니 초기화 버튼이 있는 화면을 가정.        가설:          API 조회 결과가 화면에 표시된 상태에서, 장바구니 초기화 버튼을 눌렀을 때의 동작을 통해 차이를 확인할 수 있음:                  @StateObject 사용 시: API 조회 결과는 초기화되지 않고 그대로 유지되며, 장바구니 데이터만 초기화됨.          @ObservedObject 사용 시: API 조회 결과가 뷰모델의 초기 값으로 리셋되며, 장바구니 데이터와 함께 초기화됨.                    시행착오 과정1. 초기 테스트 실패  문제:          처음에는 부모-자식 관계 없이 하나의 뷰에서 @ObservedObject와 @StateObject를 비교 테스트함.      이 경우, @ObservedObject와 @StateObject 모두 동일한 결과가 나타남.      API 조회 결과는 유지되고, 장바구니 초기화 시 API 결과는 초기화되지 않음.        원인 분석:          단일 뷰에서 테스트했을 때는, @ObservedObject와 @StateObject의 차이가 드러나지 않음.      @ObservedObject는 부모 뷰에서 객체를 주입받을 때 차이가 나타나지만, 단일 뷰에서는 객체를 직접 생성하므로 사실상 @StateObject와 같은 동작을 함.      2. 부모-자식 관계를 통한 재테스트  변경 사항:          TestView를 부모 뷰로 만들고, ApiDataSubview와 ApiStateSubview를 자식 뷰로 분리함.      ApiDataSubview는 @ObservedObject를 사용하고, ApiStateSubview는 @StateObject를 사용하도록 수정함.        결과:          @StateObject는 API 조회 결과를 유지하며, 장바구니 초기화 후에도 데이터가 그대로 유지됨.      @ObservedObject는 부모 뷰의 재생성에 따라 뷰모델이 초기화되어, API 조회 결과가 초기 값으로 리셋됨.      3. 상황별 결과 확인  부모 뷰의 생명 주기와 객체 관리 방식에 따라, @ObservedObject와 @StateObject의 결과가 다를 수 있음을 확인함.  이 실험을 통해, 부모 뷰에서 객체를 생성하고 전달할 때(@ObservedObject)와 자식 뷰에서 객체를 직접 생성할 때(@StateObject)의 차이를 명확하게 이해할 수 있었음.시행착오 요약  단일 뷰에서 테스트할 때, @ObservedObject와 @StateObject의 차이가 드러나지 않아 잘못된 결론에 도달할 뻔함.  부모-자식 뷰 관계를 고려한 재테스트를 통해, 객체의 생명 주기와 상태 관리 차이를 명확하게 이해할 수 있었음.  부모-자식 관계에서만 @ObservedObject와 @StateObject의 차이가 제대로 나타나므로, 상태 관리 시 이 관계를 고려해야 함.시행착오 후 수정된 결론  부모 뷰와 자식 뷰의 관계에 따라 @StateObject와 @ObservedObject의 결과가 같을 수도 있고, 다를 수도 있음을 발견함.  결과 차이의 원인:          @StateObject는 자식 뷰에서 직접 객체를 생성하고 관리하므로, 독립적인 생명 주기를 가짐. 이 경우, 부모 뷰의 상태 변화와 무관하게 API 조회 결과가 유지됨.      @ObservedObject는 부모 뷰에서 객체를 전달받아 사용하므로, 부모 뷰의 생명 주기에 따라 객체가 재생성될 수 있음. 이 경우, 부모 뷰의 상태 변화가 있을 때 API 조회 결과가 초기화될 가능성이 있음.      결론            항목      @StateObject 사용 시      @ObservedObject 사용 시                  API 결과 유지 여부      API 결과는 그대로 유지됨      API 결과가 초기 값으로 리셋될 수 있음              객체의 생명 주기      자식 뷰에서 독립적으로 관리됨      부모 뷰의 생명 주기에 따라 변경될 수 있음              장바구니 초기화 후 동작      API 결과는 유지되고, 장바구니만 초기화됨      API 결과와 장바구니 모두 초기화됨              상황 설명      부모 뷰의 상태 변화에 영향을 받지 않음      부모 뷰의 상태 변화에 영향을 받음      결론 요약  @StateObject와 @ObservedObject의 차이는 객체의 생성과 생명 주기 관리에서 비롯되며, 부모 뷰와 자식 뷰 간의 관계에 따라 결과가 달라질 수 있음.  독립적인 상태 유지가 필요하면 @StateObject를 사용하고, 부모 뷰의 상태와 동기화가 필요하면 @ObservedObject를 사용하는 것이 적합함.  이 차이를 이해하면 SwiftUI에서 더 예측 가능하고 안정적인 상태 관리를 할 수 있음.진짜 끝."
  },
  
  {
    "title": "(Deep Dive) @ObservedObject vs @StateObject",
    "url": "/posts/(Deep-Dive)-Object/",
    "categories": "Udemy, Deep Dive",
    "tags": "Myself",
    "date": "2024-11-13 13:00:00 +0900",
    





    
    "snippet": "@ObservedObject vs @StateObject 이부분은 좀 더 자세히 알아봐야할것같아서 이렇게 새롭게 글을 작성한다코드 예시는 여기를 참고하여 작성을 한다.@ObservedObject vs @StateObject우선 둘의 공통점은 ObservableObject 프로토콜을 따른다는 것이다.그리고 지금 아래 코드를 보면 viewModel에 대해...",
    "content": "@ObservedObject vs @StateObject 이부분은 좀 더 자세히 알아봐야할것같아서 이렇게 새롭게 글을 작성한다코드 예시는 여기를 참고하여 작성을 한다.@ObservedObject vs @StateObject우선 둘의 공통점은 ObservableObject 프로토콜을 따른다는 것이다.그리고 지금 아래 코드를 보면 viewModel에 대해 Wrapper를 다르게 했는데 이렇게 해도 실행 결과는 같다.final class CounterViewModel: ObservableObject {    @Published var count = 0    func incrementCounter() {        count += 1    }}struct CounterView: View {    @ObservedObject var viewModel = CounterViewModel()    @StateObject var viewModel = CounterViewModel()    var body: some View {        VStack {            Text(\"Count is: \\(viewModel.count)\")            Button(\"Increment Counter\") {                viewModel.incrementCounter()            }        }    }}그러면 차이를 줘보도록 하자struct RandomNumberView: View {    @State var randomNumber = 0    var body: some View {        VStack {            Text(\"Random number is: \\(randomNumber)\")            Button(\"Randomize number\") {                randomNumber = (0..&lt;1000).randomElement()!            }        }.padding(.bottom)        CounterView()    }}RandomNumberView를 만들어 준다.1. @ObservedObjectstruct CounterView: View {    @ObservedObject var viewModel = CounterViewModel()    var body: some View {        VStack {            Text(\"Count is: \\(viewModel.count)\")            Button(\"Increment Counter\") {                viewModel.incrementCounter()            }        }    }}카운트만 눌렀을때는 숫자가 증가하지만랜덤을 누르는순간 카운트가 초기화가 되어버린다.&lt;SwiftUI.CGDrawingView: 0x101390ed0; frame = (160.333 462.333; 81.6667 20.3333); anchorPoint = (0, 0); opaque = NO; autoresizesSubviews = NO; layer = &lt;_TtC7SwiftUIP33_65A81BD07F0108B0485D2E15DE104A7514CGDrawingLayer: 0x600002635b60&gt;&gt;이제 랜덤을 누르면 어떻게 되는지 확인하자&lt;SwiftUI.CGDrawingView: 0x101390ed0; frame = (160 462.333; 82 20.3333); anchorPoint = (0, 0); opaque = NO; autoresizesSubviews = NO; layer = &lt;_TtC7SwiftUIP33_65A81BD07F0108B0485D2E15DE104A7514CGDrawingLayer: 0x600002635b60&gt;&gt;CounterViewModel의 메모리가 달라진걸 확인할 수 있다.즉 랜덤을 누름과 동시에 ViewModel객체가 초기화가 되기에 count도 초기값인 0으로 돌아가는것.2. @StateObjectstruct CounterView: View {    @StateObject var viewModel = CounterViewModel()        var body: some View {        VStack {            Text(\"Count is: \\(viewModel.count)\")            Button(\"Increment Counter\") {                viewModel.incrementCounter()            }        }    }}위와 달리 카운트가 증가한상태에서 랜덤을 눌러도 카운트가 유지가 된다.&lt;SwiftUI.CGDrawingView: 0x10130f7d0; frame = (160 462.333; 82 20.3333); anchorPoint = (0, 0); opaque = NO; autoresizesSubviews = NO; layer = &lt;_TtC7SwiftUIP33_65A81BD07F0108B0485D2E15DE104A7514CGDrawingLayer: 0x60000262e100&gt;&gt;이건 count is와 관련된 View의 정보숫자를 늘려도 그대로이다. 즉 ViewModel의 메모리가 그대로 유지된채로 값이 바뀐다는것이다.차이점랜덤을 누르는 순간 ViewModel의 객체가 초기화가 되었다.ObservedObject는 초기화가 된 사례StateObject는 초기화가 되지 않은 사례 이다.struct RandomNumberView: View {    @State var randomNumber = 0    var body: some View {        VStack {            Text(\"Random number is: \\(randomNumber)\")            Button(\"Randomize number\") {                randomNumber = (0..&lt;1000).randomElement()!            }        }.padding(.bottom)        CounterView()    }}여기서 랜덤 버튼을 클릭하게되면 숫자가 바뀐다. 즉 View가 업데이트 된다.CounterView()는 현재 RandomNumberView의 자식뷰 이므로, 같이 업데이트가 된다.이때 @ObservedObject를 사용하게 되면 CounterView 자체도 새롭게 렌더링이 되면서 ViewModel을 새롭게 생성하게 된다. 그러면서 메모리가 바뀌게 된것.하지만 @StateObject를 사용하게 되면 CounterView는 새롭게 렌더링이 될지라도 ViewModel 자체는 그대로 유지를 하기에 값이 변하지 않은것."
  },
  
  {
    "title": "TourApp (6)",
    "url": "/posts/TourApp_6/",
    "categories": "Study, TourApp",
    "tags": "",
    "date": "2024-11-12 08:33:00 +0900",
    





    
    "snippet": "Api 적용하기우선 json으로 만든 파일을 웹사이트에 올려 api처럼 가져오게 했다.이후, Medium 글을 통해서 코드를 작성했다.이글을 통해서 작성한것은 바로 Generic을 사용했다는 점이다. 이전에 Generic을 사용해본적이 없기에 이번에는 좀 사용하면서 내걸로 조금씩 만들고 싶었다.ApiModel 만들기struct ApiModel: Cod...",
    "content": "Api 적용하기우선 json으로 만든 파일을 웹사이트에 올려 api처럼 가져오게 했다.이후, Medium 글을 통해서 코드를 작성했다.이글을 통해서 작성한것은 바로 Generic을 사용했다는 점이다. 이전에 Generic을 사용해본적이 없기에 이번에는 좀 사용하면서 내걸로 조금씩 만들고 싶었다.ApiModel 만들기struct ApiModel: Codable {    let tours: [Tour]}enum NetworkError: Error {    case badUrl    case invalidRequest    case badResponse    case badStatus    case failedToDecodeResponse}class ApiService {    func downloadData&lt;T: Codable&gt;(fromURL: String) async -&gt; T? {        do {            guard let url = URL(string: fromURL) else { throw NetworkError.badUrl }            let (data, response) = try await URLSession.shared.data(from: url)            guard let response = response as? HTTPURLResponse else { throw NetworkError.badResponse }            guard response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300 else { throw NetworkError.badStatus }            guard let decodedData = try? JSONDecoder().decode(ApiModel.self, from: data) else {                throw NetworkError.failedToDecodeResponse            }                        return decodedData.tours as? T        } catch NetworkError.badUrl {            print(\"There was an error creating the URL\")        } catch NetworkError.badResponse {            print(\"Did not get a valid response\")        } catch NetworkError.badStatus {            print(\"Did not get a 2xx status code from the response\")        } catch NetworkError.failedToDecodeResponse {            print(\"Failed to decode response into the given type\")        } catch {            print(\"An error occured downloading the data\")        }                return nil    }}여기서 하나 다른점이라면guard let decodedData = try? JSONDecoder().decode(ApiModel.self, from: data) else {                throw NetworkError.failedToDecodeResponse            }이 부분이다 참고글에서는 여기도 역시 T.self를 통해 Generic을 사용했지만, 내가만든 json의 구조에서는\"tours\": [        {            \"title\": \"해운대\",            \"imageUrl\": \"https://www.visitbusan.net/uploadImgs/files/cntnts/20191229153531987_oen\",            \"description\": \"해운대해수욕장은 대한민국 부산광역시 해운대구 중동과 우동에 걸쳐서 위치한 대한민국 최대규모의 해수욕장이다.\\n모래사장의 총면적은 120,000m², 길이는 1.5 km,\\n폭은 70m ~ 90m이다\",            \"address\": \"부산광역시 해운대구 해운대해변로 280\",            \"latitude\": 35.1594965,            \"longitude\": 129.162576,            \"resList\": [이런식으로 tours라는 녀석으로 시작해서 담고있기에 Generic을 사용하려면 애초에 json을 구성할때 tours를 뺐어야했다.하지만 이미 업로드 하기도 해서 저기만 ApiModel.self를 사용했다.ApiViewModel 만들기@MainActor 항상 Main Queue에서 실행이 된다. 즉 Uikit에서 사용했던 DispatchQueue.main이라고 생각하면 된다.import Foundation@MainActor class ApiViewModel: ObservableObject {    @Published var apiData = [Tour]()        init() {        Task {            await fetchData()        }    }        func fetchData() async {        let url = \"https://run.mocky.io/v3/42391865-6e96-4db3-9f68-1e2970796cad\"        guard let downloadedData: [Tour] = await ApiService().downloadData(fromURL: url) else { return }        apiData = downloadedData    }}            특징      DispatchQueue.main      @MainActor                  메인 스레드에서의 실행 요청      명시적으로 DispatchQueue.main.async 사용      자동으로 메인 스레드에서 실행              적용 범위      특정 코드 블록      메서드, 프로퍼티, 클래스 전체              코드 가독성      복잡할 수 있음      가독성이 높아짐              비동기 메서드와의 호환성      추가로 async 블록 필요      async 메서드에서도 안전하게 실행      즉,  @MainActor를 사용하면, 명시적으로 DispatchQueue.main.async를 사용할 필요가 없다.  @MainActor는 메서드나 클래스 전체에서 메인 스레드 실행을 보장하기 때문에, 코드가 더 간결하고 안전해진다.  Swift의 최신 비동기 API(async/await)와 잘 어울리며, UI 업데이트 코드에서 더 많이 사용된다.init을 사용한건, 여기서 내가 만든 json은 이미 내용이 정해져있고, 양이 방대하지도 않고 페이징이필요없기에 한번 로드하면 끝이라 init으로 한번 로드했을때 가져오게 했다.그게아니라 View가 다시 로드될때마다 사용하고 싶다면@ObservedObject var json = loadJsonModel()@StateObject var vm = ApiViewModel()NavigationStack {            Text(\"관광 고고\")                List {                    ForEach(vm.apiData, id: \\.self) { tour in                        NavigationLink(value: tour) {                            CellView(title: tour.title, imageUrl: tour.imageURL)                        }                    }                }            .navigationDestination(for: Tour.self) { model in                DetailView(title: model.title, imageUrl: model.imageURL, description: model.description, address: model.address, coordinate: CLLocationCoordinate2D(latitude: model.latitude, longitude: model.longitude), shopList: model.resList, cameraPosition: .camera(MapCamera(centerCoordinate: CLLocationCoordinate2D(latitude: model.latitude, longitude: model.longitude), distance: 500, heading: 90, pitch: 80)))            }        }        .onAppear {            if vm.apiData.isEmpty {                Task {                    await vm.fetchData()                }            }        }onAppear를 통해서 함수를 호출하면 된다.@ObservedObject vs @StateObject 비교는 새롭게 글을 작성해야 할듯하다."
  },
  
  {
    "title": "TourApp (5)",
    "url": "/posts/TourApp_5/",
    "categories": "Study, TourApp",
    "tags": "",
    "date": "2024-11-11 08:33:00 +0900",
    





    
    "snippet": "회고중 있었던일 정리오늘은 크게 한게 없어서 같이 공부하던분의 문제점을 좀 같이 해결하면서 있었던 일을 정리해보려한다.문제점우선 문제는 이전에 scrollview를 사용하려할때 Frame을 설정하지않으면 사이즈가 바뀌게되는데 이때 나는 귀찮아서 frame을 수동으로 설정을 주고 하다가 귀찮아서Scrollview를 해제하고 그냥 Vstack을 사용하고 ...",
    "content": "회고중 있었던일 정리오늘은 크게 한게 없어서 같이 공부하던분의 문제점을 좀 같이 해결하면서 있었던 일을 정리해보려한다.문제점우선 문제는 이전에 scrollview를 사용하려할때 Frame을 설정하지않으면 사이즈가 바뀌게되는데 이때 나는 귀찮아서 frame을 수동으로 설정을 주고 하다가 귀찮아서Scrollview를 해제하고 그냥 Vstack을 사용하고 넘어갔다.근데 팀원분은 사이즈를 나처럼 고정값이 아닌 Device에 따라서 이미지를 유동적으로 설정하고 싶다고 했다.Text는 괜찮았으나 Tabview에서 이미지가 제대로 사이즈 조절이 안되는게 문제였다.여러시도코드는 팀원분것이 아닌 내걸로 일단 적용하여 이야기를 해본다.ScrollView {    VStack(spacing: 20) {                TabView(selection: $currentPage.animation()) {                    ForEach(lists.indices, id: \\.self) { index in                            VStack {                                AsyncImage(url: URL(string: lists[index].imageURL)) { image in                                    image                                        .resizable()                                        .aspectRatio(4/3, contentMode: .fit)                                        .scaledToFit()                                        .frame(width: self.view.frame.width)                                } placeholder: {                                    Image(systemName: \"photo\")                                }                                Link(destination: URL(string: lists[index].shopURL)!) { Text(lists[index].shopTitle)                                        .fontWeight(.bold)                                        .foregroundStyle(.blue)                            }                        }                    }                }                .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))당시 modifier는 이런식으로 되어있었다.하지만 UIkit과는 달리 SwiftUI에서는 위와같이 self.view.frame.width를 사용하게되면Value of type 'PageView' has no member 'view'이렇게 에러가난다.  width를 재설정우선 uikit에서는 되었지만 지금은 안되기에 저부분을 지우고 디바이스의 크기를 통해 가로길이를 설정하는UIScreen.main.bounds.width로 바꾸고 시도를 해보았다.결과는 실패  GeometryReader를 사용하여 시도GeometryReader { geometry in                Image(\"exampleImage\")                    .resizable()                    .scaledToFill()                    .frame(width: geometry.size.width, height: geometry.size.width * 0.6)            }            .frame(height: UIScreen.main.bounds.width * 0.6) // 기본 높이 설정위의 코드는 예시.frame을 설정하고 해보았으나 역시나 되지 않았다.오히려 이미지 사이즈가 더 작아지는 문제가 발생GeometryReader는 뭔가 좌표값을 통해서 위치를 지정해주는 느낌이 강했다.이건 나중에 다시 정리를 해보는게 좋을듯근본적인 문제 파악GPT에 scrollview를 사용했을때 이미지 사이즈가 작아지는 근본적인 문제에 대해 물어본 결과  ScrollView 내부에 TabView를 배치하고, 그 안에 ImageView를 넣었을 때, 이미지가 작아지는 현상이 발생하는 이유는 SwiftUI의 레이아웃 계산 방식과 관련이 있다.SwiftUI에서 ScrollView는 자식 뷰의 크기를 제한하지 않지만, TabView는 기본적으로 자식 뷰의 크기를 자동으로 축소한다. 이로 인해 Image가 작아질 수 있다.이렇게 답을 했었다.하지만 이부분을 간과하고 위와같은 시도를 하다가 문득 TabView에서 내부의 image에 frame을 통해 사이즈를 정해주는것이 아닌TabView 자체의 Frame을 정해주면 어떨까 라는 생각이 들었다.이유는 팀원분의 화면을 보면서 Hierarchy도 같이 봤었는데, 이미지의 사이즈가 TabView의 사이즈에 영향을 받는다는것을 알았기 때문이다.그래서 이런 생각을 하게 되었고 시도를 다시 해보았다.해결TabView {            ForEach(0..&lt;5) { index in                Image(\"exampleImage\")                    .resizable()                    .scaledToFit()            }        }        .tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))        .frame(width: UIScreen.main.bounds.width, height: UIScreen.main.bounds.height * 0.5)이렇게 TabView에 frame을 통해 사이즈를 설정해주니 해결이 되었다.정리ScrollView 사용시 TabView 내의 이미지가 제대로 사이즈 조절이 안되는 문제가 발생.ScrollView는 Children View의 크기를 제한하지 않지만, TabView는 Children View의 크기를 자동으로 축소하려고한다.그래서 TabView내 ImageView의 Frame을 조정하는게 아닌, TabView 자체 Frame을 조정을 해줘야한다. (Image는 TabView의 크기에 영향을 받기때문)영양가 높은 회고였다."
  },
  
  {
    "title": "TourApp (4)",
    "url": "/posts/TourApp_4/",
    "categories": "Study, TourApp",
    "tags": "",
    "date": "2024-11-08 08:33:00 +0900",
    





    
    "snippet": "json 적용하기우선 json 양식으로 파일을 바꿔준다.이때 이전과 특이점이라면 json 로드가 from server가 아닌 from local이라는것.모델링모델링을 해준다.struct JsonModel: Codable {    let tours: [Tour]}// MARK: - Tourstruct Tour: Codable {    let title:...",
    "content": "json 적용하기우선 json 양식으로 파일을 바꿔준다.이때 이전과 특이점이라면 json 로드가 from server가 아닌 from local이라는것.모델링모델링을 해준다.struct JsonModel: Codable {    let tours: [Tour]}// MARK: - Tourstruct Tour: Codable {    let title: String    let imageURL: String    let description, address: String    let latitude, longitude: Double    let resList: [ResList]    enum CodingKeys: String, CodingKey {        case title        case imageURL = \"imageUrl\"        case description, address, latitude, longitude, resList    }}// MARK: - ResListstruct ResList: Codable {    let imageURL: String    let shopTitle: String    let shopURL: String    enum CodingKeys: String, CodingKey {        case imageURL = \"imageUrl\"        case shopTitle        case shopURL = \"shopUrl\"    }}사실 모델링은 사이트를 통해서 하는게 제일 빠르긴 하다.json load 함수 만들기.여러 자료를 찾아보았는데 UrlSession을 사용하는 경우와 그렇지 않은 경우 두가지가 있었는데urlsession을 사용한 자료는 4년 전이고 근래 자료들은 그냥 로드를 하는듯 하다.기본뼈대는 다음과 같다.class loadJsonModel: ObservableObject {    @Published var json = [JsonModel]()        init() {        load()    }        func load() {            }}Without UrlsessionYoutube 를 참고하였다.class loadJsonModel: ObservableObject {    @Published var tours = [JsonModel]()        init() {        load()    }        func load() {        guard let url = Bundle.main.url(forResource: \"data\", withExtension: \"json\")        else {            print(\"Json file not found\")            return        }              let data = (try? Data(contentsOf: url))!        let tours = try? JSONDecoder().decode([JsonModel].self, from: data)                self.tours = tours!    }}이후 listview를 수정struct ListView: View {        @ObservedObject var json = loadJsonModel()        var body: some View {        NavigationStack {            Text(\"관광 고고\")                List {                    ForEach(json.tours, id: \\.self) { tour in                        NavigationLink(value: tour) {                            CellView(title: tour.title, imageUrl: tour.imageUrl)                        }                    }                }            .navigationDestination(for: TourModel.self) { model in                DetailView(title: model.title, imageUrl: model.imageUrl, description: model.description, address: model.address, coordinate: CLLocationCoordinate2D(latitude: model.latitude, longitude: model.longitude), shopList: model.resList, cameraPosition: .camera(MapCamera(centerCoordinate: CLLocationCoordinate2D(latitude: model.latitude, longitude: model.longitude), distance: 1000, heading: 90, pitch: 80)))            }        }            }}하지만 에러가 발생Cannot convert value of type '[JsonModel]' to expected argument type 'Binding&lt;C&gt;'json에서 잘못된걸 발견@Published var tours = [Tour]() // 수정let decodedData = try? JSONDecoder().decode(JsonModel.self, from: data) // 수정        self.tours = decodedData!.tours // 수정그랬더니Generic struct 'ForEach' requires that 'loadJsonModel' conform to 'RandomAccessCollection'에러발생수정을 하던 도중 hashable 프로토콜이 필요하다고 에러가 발생.현재는 id가 없다.그래서 UUID를 사용하여 id를 부여한다struct Tour: Codable, Hashable {    let id = UUID()    let title: String    let imageURL: String    let description, address: String    let latitude, longitude: Double    let resList: [ResList]        enum CodingKeys: String, CodingKey {        case title        case imageURL = \"imageUrl\"        case description, address, latitude, longitude, resList    }}Generic 관련 에러가 난다.struct PageView: View {        var lists = [ResList]()        @State private var currentPage: Int = 0        var body: some View {        VStack(spacing: 20) {            TabView(selection: $currentPage.animation()) {                ForEach(0..&lt;lists.count, id: \\.self) { index in                        VStack {                            AsyncImage(url: URL(string: lists[index].imageURL)) { image in                                image                                    .resizable()                                    .frame(maxWidth: 150, maxHeight: 150)                            } placeholder: {                                Image(systemName: \"photo\")                            }                            Link(destination: URL(string: lists[index].shopUrl)!) { Text(lists[index].shopTitle)                                    .fontWeight(.bold)                                    .foregroundStyle(.blue)                        }                    }                }            }바로 ForEach 부분에서 Error가 발생미완인채로 같이 공부를 하던 분과 회고를 하던 도중 비슷한 에러를 겪으셨다고 하여, @State var lists = [ResList]() 로 바인딩을 가능하게 하여 적용을 해보려 한다.그렇게 하니 이번엔AsyncImage(url: URL(string: list.imageURL)) { image in 여기서 에러가 발생Cannot convert value of type 'Binding&lt;String&gt;' to expected argument type 'String'bindingString이라 생기는 문제인듯하다.AsyncImage(url: URL(string: list.wrappedValue.imageURL))bindingString을 string을 사용할때는 wrappedValue를 사용한다.📘 Swift의 wrappedValue 이해하기📝 정의  wrappedValue는 Swift의 프로퍼티 래퍼(Property Wrapper)에서 원래 값을 접근할 때 사용하는 속성이다.  @State, @Binding, @Published 등의 프로퍼티 래퍼는 내부 값을 감싸고 있으며, 이 값을 읽거나 수정할 때 wrappedValue를 사용한다.🔍 주요 특징  프로퍼티 래퍼의 실제 값을 반환하거나 수정할 수 있다.  SwiftUI에서는 $를 사용하여 wrappedValue에 간단하게 접근할 수 있다. 예를 들어, $count는 count.wrappedValue와 동일하다.  주로 SwiftUI에서 자동으로 처리되지만, 명시적으로 값을 가져오고 싶을 때 wrappedValue를 사용할 수 있다.💡 사용 예시1️⃣ 기본 사용 예시import SwiftUIstruct ContentView: View {    @State private var count: Int = 0    var body: some View {        VStack {            Text(\"Count: \\(count)\") // 원래 값 사용            Text(\"Wrapped Count: \\($count.wrappedValue)\") // wrappedValue로 접근            Button(\"Increment\") {                $count.wrappedValue += 1 // wrappedValue를 사용하여 값 수정            }        }    }}설명:  @State는 SwiftUI에서 값의 변화를 추적하고 뷰를 업데이트하는 데 사용된다.  $count는 count의 Binding을 나타내며, .wrappedValue를 통해 원래 값에 접근할 수 있다.2️⃣ @Binding과 wrappedValue 예시import SwiftUIstruct ParentView: View {    @State private var name: String = \"Swift\"    var body: some View {        ChildView(text: $name)    }}struct ChildView: View {    @Binding var text: String    var body: some View {        VStack {            Text(\"Wrapped Value: \\(text.wrappedValue)\") // Binding의 wrappedValue 사용            TextField(\"Enter Name\", text: $text)        }    }}설명:  ParentView에서 $name을 전달하면 ChildView에서 @Binding을 통해 값을 받는다.  text.wrappedValue는 @Binding의 원래 값을 가져온다.✅ 결론  wrappedValue는 프로퍼티 래퍼가 감싸고 있는 원래 값을 반환하거나 수정하는 데 사용된다.  SwiftUI에서는 $를 통해 wrappedValue에 쉽게 접근할 수 있다.  주로 SwiftUI에서 자동으로 처리되지만, 명시적으로 접근할 때 wrappedValue를 사용할 수 있다.하지만 문제가 발생그래서 혹시나해서ForEach(lists.indices, id: \\.self) { index in                        VStack {                            AsyncImage(url: URL(string: lists[index].imageURL)) { image in                                image                                    .resizable()                                    .frame(maxWidth: 150, maxHeight: 150)                            } placeholder: {                                Image(systemName: \"photo\")                            }                            Link(destination: URL(string: lists[index].shopURL)!) { Text(lists[index].shopTitle)                                    .fontWeight(.bold)                                    .foregroundStyle(.blue)                        }                    }여기를 다시 돌려봤는데 갑자기 된다.안되었던 이유를 모르겠다."
  },
  
  {
    "title": "TourApp (3)",
    "url": "/posts/TourApp_3/",
    "categories": "Study, TourApp",
    "tags": "",
    "date": "2024-11-07 08:33:00 +0900",
    





    
    "snippet": "DetailView 꾸미기 &amp; PageView 꾸미기Page view 꾸미기이전에 회고를 하던도중 Tabview를 통해 UIKit의 TabBarViewController로 쓸수있고 이미지를 페이징하면서 넘기는 방식으로도 사용이 가능하다고 하여 그걸 적용해보기로했다.@State private var currentPage: Int = 0TabVie...",
    "content": "DetailView 꾸미기 &amp; PageView 꾸미기Page view 꾸미기이전에 회고를 하던도중 Tabview를 통해 UIKit의 TabBarViewController로 쓸수있고 이미지를 페이징하면서 넘기는 방식으로도 사용이 가능하다고 하여 그걸 적용해보기로했다.@State private var currentPage: Int = 0TabView(selection: $currentPage.animation()) {                ForEach(lists.indices, id: \\.self) { index in                        VStack {                            AsyncImage(url: URL(string: lists[index].imageURL)) { image in                                image                                    .resizable()                                    .frame(maxWidth: 150, maxHeight: 150)                            } placeholder: {                                Image(systemName: \"photo\")                            }                            Link(destination: URL(string: lists[index].shopURL)!) { Text(lists[index].shopTitle)                                    .fontWeight(.bold)                                    .foregroundStyle(.blue)                        }                    }                }            }            .tabViewStyle(PageTabViewStyle(indexDisplayMode: .always))이렇게 해서 적용을 했는데 아이러니 하게도 indicator가 아래에있거나 뭔가 원하는 위치에 되지않는 문제가 발생했다.그래서 고민을 하다가 medium의 글을 참고하여 만들었다. ScrollView(.horizontal, showsIndicators: false) {                HStack {                    ForEach(0..&lt;lists.count, id: \\.self) { index in                        Circle()                            .frame(width: index == currentPage ? 12 : 8, height: index == currentPage ? 16 : 10)                            .foregroundStyle(.blue.opacity(index == currentPage ? 1 : 0.5))                    }                }                .padding(.horizontal)                .scrollTargetLayout()            }            .background(.clear, in: RoundedRectangle(cornerRadius: 30))            .frame(width: 60)            .scrollTargetBehavior(.viewAligned)            .scrollPosition(id: Binding($currentPage), anchor: .center)            .allowsTightening(false)뭐 크게 설명할 내용은 없어보이지만 modifier 몇개만 좀 짚어보고 넘어간다.📘 SwiftUI의 ScrollView 모디파이어 설명: .scrollTargetBehavior, .scrollPosition, .allowsTighteningSwiftUI에서 ScrollView에 사용할 수 있는 모디파이어들은 스크롤 동작과 위치 조정에 중요한 역할을 합니다. 이 중 .scrollTargetBehavior(), .scrollPosition(), .allowsTightening()에 대해 설명하겠습니다.1️⃣ .scrollTargetBehavior(.viewAligned)  scrollTargetBehavior는 스크롤 동작이 어떻게 처리되는지를 정의하는 모디파이어다.  .viewAligned 옵션은 스크롤이 뷰의 경계에 맞춰 정렬되도록 설정한다.  가로 스크롤(.horizontal)에서 주로 사용되며, 탭 간의 스크롤 정렬을 부드럽게 만들어 준다.  스크롤 시 뷰가 정확하게 화면에 나타나도록 자동으로 조정하여, 부드러운 스크롤 경험을 제공한다.2️⃣ .scrollPosition(id: Binding&lt;Int&gt;, anchor: .center)  scrollPosition은 스크롤 위치를 제어하는 모디파이어다.  id 파라미터는 바인딩된 값으로, 현재 스크롤 위치를 나타낸다.  anchor는 스크롤 위치를 맞출 기준점으로, 주로 .center, .leading, .trailing을 사용한다.  현재 스크롤 위치를 업데이트하고, 선택된 뷰가 특정 위치(예: 화면의 중앙)에 오도록 한다.  페이지 뷰나 탭 뷰와 같이, 현재 페이지가 중앙에 맞추어져야 하는 경우에 주로 사용된다.3️⃣ .allowsTightening(false)  allowsTightening은 텍스트의 줄 간격 압축 여부를 제어하는 모디파이어다.  false로 설정하면, 텍스트가 줄어들지 않고 원래의 간격을 유지한다.  기본값은 true이며, 텍스트가 제한된 공간 내에서 줄어들 수 있도록 허용한다.  긴 텍스트가 잘리는 것을 방지하고, 줄 간격이 일관되도록 보장한다.📝 요약            모디파이어      설명                  .scrollTargetBehavior(.viewAligned)      스크롤이 뷰의 경계에 맞춰 정렬되도록 설정              .scrollPosition(id: Binding, anchor: .center)      스크롤 위치를 특정 기준점(anchor)에 맞춰 제어              .allowsTightening(false)      텍스트의 줄 간격이 줄어들지 않도록 설정      이 모디파이어들은 ScrollView의 스크롤 동작과 레이아웃을 세밀하게 조정하는 데 유용하다.Detail view 꾸미기Scrollview 적용시 frame 을 설정해줘야한다. 그래서 귀찮아서 scrollview를 사용하려다 포기했지만, frame으로 각 사이즈를 주긴했다."
  },
  
  {
    "title": "TourApp (2)",
    "url": "/posts/TourApp_2/",
    "categories": "Study, TourApp",
    "tags": "",
    "date": "2024-11-06 08:33:00 +0900",
    





    
    "snippet": "DetailView 꾸미기MapKit 사용하기먼저 import를 해준다.내용은 사이트Map(position: $cameraPosition) {                Annotation(title, coordinate: coordinate) {                    ZStack {                        Image(s...",
    "content": "DetailView 꾸미기MapKit 사용하기먼저 import를 해준다.내용은 사이트Map(position: $cameraPosition) {                Annotation(title, coordinate: coordinate) {                    ZStack {                        Image(systemName: \"flag.checkered\")                    }                }                            }기본적인건 Map()이고 Annotation pin도 UIKit과는 달리 심플하게 사용이 가능.오늘은 이게 다라서 이전글에 파라미터에 관한 설명이 있으니 참고.크게 한게없어서 내용이 적다."
  },
  
  {
    "title": "TourApp (1)",
    "url": "/posts/TourApp_1/",
    "categories": "Study, TourApp",
    "tags": "",
    "date": "2024-11-04 08:33:00 +0900",
    





    
    "snippet": "이번엔 그냥 간단하게 관광지 소개 앱을 만들어 보려고 한다.지금은 간단하게 하려고 하고 나중에 조금 더 발전 시킨다면 그때는Grid를 사용해서 꾸미지 않을까나List를 사용했고 기본적인것은 패스이번엔 SwiftModel을 사용하지 않고 만들어 보려고 한다.struct TourModel: Hashable {        var title: String ...",
    "content": "이번엔 그냥 간단하게 관광지 소개 앱을 만들어 보려고 한다.지금은 간단하게 하려고 하고 나중에 조금 더 발전 시킨다면 그때는Grid를 사용해서 꾸미지 않을까나List를 사용했고 기본적인것은 패스이번엔 SwiftModel을 사용하지 않고 만들어 보려고 한다.struct TourModel: Hashable {        var title: String    var image: String        func hash(into hasher: inout Hasher) {        hasher.combine(title)    }    }SwiftModel을 사용할때는 class를 사용했어야해서 나도모르게 class로 만들었는데Hashable 프로토콜이 NavigationDestination에서 필요하다는걸 알았다.이렇게 에러가 떠버린다.그래서 프로토콜을 적용했으나 model에서 에러가 발생.생각을 해보다가 swiftmodel을 쓰지 않을것 같아 class에서 struct로 바꾸니 해결이 되었다.NavigationLink 해결NavigationDestination을 활용하여 클릭시 화면전환이 가능하게 하려고 했는데 되지 않았다.NavigaionLink를 먼저 깔고 후에 List를 하니 안되는 것 같다.이전에 만들었던 코드를 참고하니 List 안에 NavigaionLink가 있었다.그래서 위치를 바꾸니 해결이 되었다.var body: some View {        NavigationStack {            Text(\"관광 고고\")                List {                    ForEach(tours, id: \\.self) { tour in                        NavigationLink(value: tour) {                            CellView(title: tour.title, imageUrl: tour.imageUrl)                        }                    }                }            .navigationDestination(for: TourModel.self) { model in                DetailView(title: model.title)            }        }            }"
  },
  
  {
    "title": "To Do List (5)",
    "url": "/posts/ToDoList_5/",
    "categories": "Study, ToDoList",
    "tags": "",
    "date": "2024-10-24 08:33:00 +0900",
    





    
    "snippet": "수정기능 마무리func modifyList(title: String) {        let i = todoLists.firstIndex { list in            list.title == title        }        todoLists[i!].title = title    }함수를 이렇게 적용하였으나바뀌지 않았다.생각해보니 파라미...",
    "content": "수정기능 마무리func modifyList(title: String) {        let i = todoLists.firstIndex { list in            list.title == title        }        todoLists[i!].title = title    }함수를 이렇게 적용하였으나바뀌지 않았다.생각해보니 파라미터를 잘못했다.func modifyList(currentTitle: String, modifiedTitle: String) {        let i = todoLists.firstIndex { list in            list.title == currentTitle        }        todoLists[i!].title = modifiedTitle    }이렇게 해주니 성공.찾아보니 SwiftData는 Update를 해줄 필요가 없다고한다. 데이터가 바뀌면 자동으로 Save가 된다고한다.완료.Cell클릭시 화면 전환하기NavigationLink를 사용한다.이때 주의점은 NavigationLink를 사용하기전에 NavigationView가 있어야 한다는것.var body: some View {        NavigationStack {            NavigationView {            VStack {                List(todoLists, id: \\.self) { list in                        NavigationLink(value: list) {                            CellView(isOn: list.isCompleted,                                     title: \"\\(list.title)\")                            .swipeActions(edge: .trailing) {                                Button(action: {                                    modelContext.delete(list)                                }) {                                    Image(systemName: \"trash\")                                }                            }                            .tint(.red)                            .swipeActions(edge: .leading) {                                Button(\"edit\",                                       systemImage: \"pencil\") {                                    isEditing.toggle()                                    tempoList = list                                }                            }                            .tint(.blue)                            .alert(\"TodoList 수정\",                                   isPresented: $isEditing) {                                TextField(\"수정\", text: $title)                                Button(\"OK\",                                       role: .cancel) {                                    if let currentTitle = tempoList?.title {                                        modifyList(currentTitle: currentTitle, modifiedTitle: title)                                    }                                    title = \"\"                                }                                Button(\"Cancel\", role: .destructive){                                                                    }                            }                        }                    }                    .navigationTitle(\"ToDoList\")                    .navigationDestination(for: TodoModel.self) { list in                        DetailView(title: list.title)                    }                }            }            .toolbar {                ToolbarItem(id: \"add\",                            placement: .navigationBarTrailing) {                    Button(\"add\",                           systemImage: \"plus.app\") {                        isShowing.toggle()                    }                           .alert(\"TodoList 추가\",                                  isPresented: $isShowing) {                                                              TextField(\"TodoList 추가\", text: $title)                               Button(\"OK\",                                      role: .cancel) {                                   addList()                               }                               Button(\"Cancel\", role: .destructive){                                   title = \"\"                               }                           }                }                ToolbarItem(id: \"DeleteAll\",                            placement: .navigationBarLeading) {                    Button(\"DeleteAll\",                           systemImage: \"folder.badge.minus\") {                        do {                            try modelContext.delete(model: TodoModel.self)                        } catch {                            print(\"Error: \\(error.localizedDescription)\")                        }                    }                }            }        }    }코드가 꽤나 길어졌다.Navigation Area 조절빨간색 박스 부분이 Hierarchy로 확인해보니NavigationBarLargeTitleView(하단), NavigationBarContentView(상단)로 나온다.Vstack을 지우고NavigationView {                List(todoLists, id: \\.self) { list in                    NavigationLink(value: list) {                        CellView(isOn: list.isCompleted,                                 title: \"\\(list.title)\")                        .swipeActions(edge: .trailing) {                            Button(action: {                                modelContext.delete(list)                            }) {                                Image(systemName: \"trash\")                            }                        }                        .tint(.red)                        .swipeActions(edge: .leading) {                            Button(\"edit\",                                   systemImage: \"pencil\") {                                isEditing.toggle()                                tempoList = list                            }                        }                        .tint(.blue)                        .alert(\"TodoList 수정\",                               isPresented: $isEditing) {                            TextField(\"수정\", text: $title)                            Button(\"OK\",                                   role: .cancel) {                                if let currentTitle = tempoList?.title {                                    modifyList(currentTitle: currentTitle, modifiedTitle: title)                                }                                title = \"\"                            }                            Button(\"Cancel\", role: .destructive){                                                            }                        }                    }                }            }            .navigationTitle(\"ToDoList\")            .navigationDestination(for: TodoModel.self) { list in                DetailView(title: list.title)            }NavigationView에 modifier를 적용하니 해결이 되었다.SearchBar 만들기YouTube를 참고하여 만들었다..searchable(text: $searchText, placement: .navigationBarDrawer, prompt: \"Todo Search\")이걸 나는 NavigationStack쪽에 Modifier를 달아주었다.하지만 적용은 되지 않는데, 이제 필터링 되는 리스트를 만들어 준다.var filteredList: [TodoModel] {        guard !searchText.isEmpty else { return todoLists }        return todoLists.filter { $0.title.localizedCaseInsensitiveContains(searchText)}    }    여기서 포인트는  입력을 아무것도 안 했을 때: searchText가 비어 있으면 todoLists 전체를 그대로 반환한다.  입력을 했을 경우:          searchText가 비어 있지 않으면 todoLists를 필터링하여, 각 항목의 title이 searchText를 대소문자 구분 없이 포함하는지 확인한다.      일치하는 항목들만 담은 배열을 반환한다.      localizedCaseInsensitiveContains?  역할: localizedCaseInsensitiveContains는 문자열이 특정 텍스트를 포함하고 있는지 확인하는 메서드다.  특징:          대소문자를 구분하지 않고(caseInsensitive) 비교한다.      로케일에 맞게 비교하여, 언어별 특수 문자를 인식한다.        예시:          title.localizedCaseInsensitiveContains(\"todo\")는 title이 “todo”를 포함하는지 확인하며, “Todo”, “TODO” 등 대소문자 차이를 무시하고 비교한다.      "
  },
  
  {
    "title": "To Do List (4)",
    "url": "/posts/ToDoList_4/",
    "categories": "Study, ToDoList",
    "tags": "",
    "date": "2024-10-23 08:33:00 +0900",
    





    
    "snippet": "수정 기능 추가하기Leading edge부에도 SwipeAction을 추가하여 수정을 하게 만들어보려고한다.VStack {                List(todoLists, id: \\.self) { list in                    CellView(isOn: list.isCompleted,                        ...",
    "content": "수정 기능 추가하기Leading edge부에도 SwipeAction을 추가하여 수정을 하게 만들어보려고한다.VStack {                List(todoLists, id: \\.self) { list in                    CellView(isOn: list.isCompleted,                             title: \"\\(list.title) id: \\(list.id)\")                    .swipeActions(edge: .trailing) {                        Button(action: {                            modelContext.delete(list)                        }) {                            Image(systemName: \"trash\")                        }                    }                    .tint(.red)                    .swipeActions(edge: .leading) {                        Button(\"edit\",                               systemImage: \"pencil\") {                            isEditing.toggle()                        }                               .alert(\"TodoList 수정\",                                      isPresented: $isEditing) {                                                                      TextField(\"TodoList 수정\", text: $title)                                   Button(\"OK\",                                          role: .cancel) {                                        print(\"work\")                                   }                                   Button(\"Cancel\", role: .destructive){                                                                          }                               }                    }                    .tint(.blue)                }            }VStack {                List(todoLists, id: \\.self) { list in                    CellView(isOn: list.isCompleted,                             title: \"\\(list.title)\")                    .swipeActions(edge: .trailing) {                        Button(action: {                            modelContext.delete(list)                        }) {                            Image(systemName: \"trash\")                        }                    }                    .tint(.red)                    .swipeActions(edge: .leading) {                        Button(\"edit\",                               systemImage: \"pencil\") {                            print(isEditing)                            isEditing.toggle()                            print(isEditing)                        }                    }                    .tint(.blue)                    .alert(\"TodoList 수정\",                           isPresented: $isEditing) {                                                TextField(\"TodoList 수정\", text: $title)                        Button(\"OK\",                               role: .cancel) {                            print(\"work\")                        }                        Button(\"Cancel\", role: .destructive){                                                    }                    }                }                            }현재 Delete와 유사하게 코드를 작성했다.하지만 작동하지 않았다.그래서 isEditing 변수에 관해 어떻게 작동을 하는지 확인을 하기위해 print을 해보았는데truefalsetruefalse이런식으로 계속 바뀌는걸 확인했다.그러다 StackOverflow 에 비슷한 글을 보았고 List 쪽에 modifier를 써야한다는걸 알았다.VStack {                List(todoLists, id: \\.self) { list in                    CellView(isOn: list.isCompleted,                             title: \"\\(list.title) id: \\(list.id)\")                    .swipeActions(edge: .trailing) {                        Button(action: {                            modelContext.delete(list)                        }) {                            Image(systemName: \"trash\")                        }                    }                    .tint(.red)                    .swipeActions(edge: .leading) {                        Button(\"edit\",                               systemImage: \"pencil\") {                            isEditing.toggle()                        }                    }                    .tint(.blue)                }                .alert(\"TodoList 수정\",                       isPresented: $isEditing) {                                        TextField(\"TodoList 수정\", text: $title)                    Button(\"OK\",                           role: .cancel) {                        print(\"work\")                    }                    Button(\"Cancel\", role: .destructive){                                            }                }            }작동이 된다.            구분      첫 번째 코드 (CellView에서 alert 적용)      두 번째 코드 (List에서 alert 적용)                  alert 적용 위치      CellView에 개별적으로 적용      List 전체에 적용              동작 결과      작동 안됨: alert가 표시되지 않음      정상 작동: alert가 정상적으로 표시됨      작동하지 않는 이유  List에서의 뷰 재사용 문제:          SwiftUI의 List는 내부적으로 뷰를 재사용한다. 즉, 셀(Cell)이 다시 그려질 때 뷰가 재사용될 수 있기 때문에, 개별 CellView에 대한 상태(State) 관리가 예상대로 동작하지 않을 수 있다.      CellView에 직접 alert를 적용하면 SwiftUI가 이 상태를 적절히 처리하지 못해, alert가 표시되지 않는 문제가 발생한다.        뷰의 계층 구조:          alert는 보통 상위 뷰에서 상태를 관리하며, 하위 뷰가 그 상태 변화를 인식할 수 있도록 한다. 첫 번째 코드에서는 CellView에 적용된 alert가 상위 List에 의한 상태 변화를 반영하지 못해, isEditing 상태가 바뀌더라도 alert가 나타나지 않는다.      두 번째 코드에서는 List의 상위 계층에 alert가 적용되었기 때문에, 전체 리스트 상태와 연동되어 정상적으로 동작한다.      해결 방법  alert 같은 상태 기반의 모디파이어는 상위 뷰에서 적용해야 한다. 이를 통해 SwiftUI의 상태 관리와 뷰 재사용 메커니즘이 정상적으로 작동하게 된다.  즉, 상태(State)와 뷰 재사용이 일어나는 리스트 구조에서 안정적으로 작동하려면, 리스트 자체 또는 리스트의 상위 뷰에 alert 같은 모디파이어를 적용하는 것이 좋다.첫 번째 코드가 작동하지 않는 이유는 SwiftUI의 뷰 재사용과 상태 관리 문제 때문이다. alert를 리스트 수준에서 관리하면 이런 문제를 피할 수 있고, 상태 변경이 제대로 반영되어 alert가 정상적으로 표시된다.문제해결            구분      첫 번째 코드      두 번째 코드                  alert 위치      CellView 내부에 있는 각 항목에서 alert가 개별적으로 정의됨      List 수준에서 한 번 정의되어 전체 리스트에서 상태를 공유함              isEditing 상태 관리      isEditing 상태가 개별 항목에서 변경될 때마다 alert가 그 항목에만 영향을 미침      isEditing 상태가 리스트 전체에서 전역적으로 적용되어, 모든 항목에서 동일하게 반응함              상태 변경 시점      개별 항목의 상태가 변경될 때마다 그 항목에서 alert가 뜨도록 유도함      isEditing 상태가 변경될 때 리스트 전체에서 반응하며, 모든 항목이 동일하게 상태 변화를 겪음              가독성 및 유지보수      항목별로 alert가 존재하므로 복잡도가 올라가고 유지보수 시 관리해야 할 항목이 많아짐      List 수준에서 한 번만 정의되므로 코드가 더 간결하고 유지보수가 쉬움      첫 번째 코드:  CellView 내부에 alert가 정의되어 있어, 각 항목마다 개별적으로 isEditing 상태를 변경하고, 해당 항목에서만 alert를 띄울 수 있다.  그러나 여전히 isEditing 상태는 전역적으로 관리되고 있어, 모든 항목에서 동일한 isEditing 상태를 공유한다는 점에서, 실질적인 개별 항목별 관리가 되지 않는다.두 번째 코드:  alert가 List 레벨에서 한 번만 정의되어 있어, isEditing 상태가 변경되면 모든 항목에서 반응하게 된다.  리스트 전체에서 하나의 상태로 관리되고 있어, 상태 관리가 더 일관성 있게 동작하지만, 개별 항목의 상태를 별도로 관리하고자 할 때는 유연성이 떨어진다.결론:  첫 번째 코드는 각 항목에서 개별적으로 alert를 정의해 유연성을 제공하지만, 상태 관리 측면에서는 불완전하다.  두 번째 코드는 alert를 한 곳에 모아두어 관리하기 쉽고 일관되지만, 개별 항목의 편집 상태를 세밀하게 관리하는 데는 부적합하다.또 다른 문제 해결회고를 하던 도중VStack {                List(todoLists, id: \\.self) { list in                    CellView(isOn: list.isCompleted,                             title: \"\\(list.title)\")                    .swipeActions(edge: .trailing) {                        Button(action: {                            modelContext.delete(list)                        }) {                            Image(systemName: \"trash\")                        }                    }                    .tint(.red)                    .swipeActions(edge: .leading) {                        Button(\"edit\",                               systemImage: \"pencil\") {                            isEditing.toggle()                            print(list.title)                        }                    }                    .tint(.blue)                    .alert(\"TodoList 수정\",                           isPresented: $isEditing) {                        TextField(list.title, text: $title)                        Button(\"OK\",                               role: .cancel) {                            print(list.title)                        }                        Button(\"Cancel\", role: .destructive){                                                    }                    }                }                            }text를 수정할때 가져오는 list.title이 다르다는것을 발견하였다.즉 나는 첫번째 row에 대해서 내용을 수정하고 싶은데, 정작 수정을 하고보면 두번째 row가 수정이 되는 문제가 발생하였따.첫번째 row를 버튼 클릭하고 수정 하고 확인 버튼을 눌렀을때 우선 console에 출력을 해보면WhewWer4334545이렇게 되어버린다.즉 같은 list.title이지만 내용은 다르다는것.print(list.title)가 swipeActions와 alert에서 다르게 출력되는 이유는 SwiftUI의 List에서 셀 재사용 방식 때문이다.SwiftUI의 셀 재사용 관련 원인:      뷰의 재사용:SwiftUI의 List는 셀을 재사용한다. 즉, 셀이 화면에 다시 나타나거나 스크롤될 때 기존의 셀을 새 데이터로 업데이트한다. 이로 인해 swipeActions에서 사용한 list는 그 시점의 데이터를 참조하지만, alert가 호출될 때는 다른 셀이 재사용될 수 있다.        상태의 비동기 처리:isEditing.toggle()가 호출되면 상태가 변하지만, SwiftUI는 내부적으로 필요한 부분만 다시 렌더링한다. 이로 인해 alert가 표시될 때의 list와 swipeActions에서의 list가 다르게 출력될 수 있다.        뷰의 동작 흐름 차이:          swipeActions에서는 print(list.title)이 즉시 해당 셀의 데이터를 출력한다.      그러나 alert가 표시될 때는 셀이 재사용되거나 다른 list 객체가 참조될 수 있어, print(list.title)가 다른 결과를 출력할 수 있다.      해결 방법현재 편집 중인 항목의 데이터를 선택된 항목의 상태로 관리하여 동일한 데이터를 참조하게 하는 방법을 사용한다.수정된 코드 예시@State private var selectedList: TodoModel? = nilVStack {    List(todoLists, id: \\.self) { list in        CellView(isOn: list.isCompleted,                 title: \"\\(list.title)\")        .swipeActions(edge: .trailing) {            Button(action: {                modelContext.delete(list)            }) {                Image(systemName: \"trash\")            }        }        .tint(.red)        .swipeActions(edge: .leading) {            Button(\"edit\",                   systemImage: \"pencil\") {                selectedList = list // 현재 선택된 리스트 저장                isEditing.toggle()                print(list.title)            }        }        .tint(.blue)        .alert(\"TodoList 수정\",               isPresented: $isEditing) {            if let selectedList = selectedList {                TextField(selectedList.title, text: $title)                Button(\"OK\", role: .cancel) {                    print(selectedList.title) // 선택된 리스트의 title 출력                }                Button(\"Cancel\", role: .destructive) {}            }        }    }}정리  뷰 재사용 문제로 인해 List에서 list가 다르게 출력될 수 있다.  선택된 항목을 상태로 관리하여, alert와 swipeActions에서 같은 데이터를 참조하게 함으로써 문제를 해결할 수 있다."
  },
  
  {
    "title": "To Do List (3)",
    "url": "/posts/ToDoList_3/",
    "categories": "Study, ToDoList",
    "tags": "",
    "date": "2024-10-22 08:33:00 +0900",
    





    
    "snippet": "CellView 적용하기List(todoLists, id: \\.self) { list in                    CellView(isOn: list.isCompleted,                             title: list.title)                }MainView에서 List에 다음과 같이 CellVie...",
    "content": "CellView 적용하기List(todoLists, id: \\.self) { list in                    CellView(isOn: list.isCompleted,                             title: list.title)                }MainView에서 List에 다음과 같이 CellView를 적용시켜준다.Toggle 버튼 클릭시 적용하기.On/Off에 따라 AttributedText가 적용되게 해보자.SwiftUI에서는 Text에 바로 stirkethrough Modifier가 있다.isOn이 toggle에 따라 true/ false가 바뀌므로HStack {            Text(title)                .strikethrough(isOn, color: .black)                .padding(.leading, 30)            Toggle(\"\", isOn: $isOn)                .padding(.trailing, 30)        }이렇게 해주면 작동이 된다.LV 2 까지 완료.Swipe를 이용한 삭제기능 구현여기는 LV3이다.VStack {                List(todoLists, id: \\.self) { list in                    CellView(isOn: list.isCompleted,                             title: list.title)                    .swipeActions(edge: .trailing) {                        Button(action: {                            modelContext.delete(list)                        }) {                            Image(systemName: \"trash\")                        }                    }                }            }그리고 Button에 빨간색 배경을 주고 싶었는데 거기에 하는게 아니라,SwipeAction의 마무리에 tint를 사용해서 적용해야한다.VStack {                List(todoLists, id: \\.self) { list in                    CellView(isOn: list.isCompleted,                             title: list.title)                    .swipeActions(edge: .trailing) {                        Button(action: {                            modelContext.delete(list)                        }) {                            Image(systemName: \"trash\")                        }                    }                    .tint(.red)                }            }LV 3 완료.이떄 tint red로 인해이렇게 toggle까지 변하게 된다.그래서 이부분은 초록색으로 유지하기 위해서HStack {            Text(title)                .strikethrough(isOn, color: .black)                .padding(.leading, 30)                .lineLimit(0)            Toggle(\"\", isOn: $isOn)                .padding(.trailing, 10)                .tint(.green)        }CellView에도 tint를 적용시켜준다.적용 완료.List를 id순으로 정렬하기현재는 등록시 규칙없이 추가가 되는듯 하다.@Query(sort: \\TodoModel.id) private var todoLists: [TodoModel]sort를 붙여주면 해결된다.id 중복 수정하기.현재 id 가이렇게 순서대로 정렬이 되지만func addList() {        let id: Int = todoLists.count        let todoModel = TodoModel(id: id + 1, title: title, isCompleted: false)        modelContext.insert(todoModel)        title = \"\"    }이렇게 현재 갯수에서 1씩 증가를 하는 매커니즘으로 되어있다.중복을 방지하기위해 현재 리스트에 있는 값에서 최대값을 구한뒤 거기서 1을 더하게 한다.func chkId(_ currentId: Int) -&gt; Int {        var id = currentId        if let maxId = todoLists.map({ $0.id }).max() {               id = maxId + 1           }        return id    }전부 지우기사이트 를 참고한다.ToolbarItem(id: \"DeleteAll\",                            placement: .navigationBarLeading) {                    Button(\"DeleteAll\",                           systemImage: \"folder.badge.minus\") {                        // action                        do {                            try modelContext.delete(model: TodoModel.self)                        } catch {                            print(\"Error: \\(error.localizedDescription)\")                        }                    }                }이때 하나의 row를 삭제할때는 try - catch 구문이 없었는데전체삭제는 해줘야한다.Coredata와 유사하다.회고.1. Comparable vs Equatable  Comparable  역할          Comparable은 객체 간에 순서를 비교할 수 있게 한다. 이를 통해 두 객체가 크거나 작은지(&lt;, &lt;=, &gt;, &gt;=)를 비교하여 정렬이 가능해진다.        필요성          정렬이 필요한 경우, 예를 들어 배열을 오름차순 또는 내림차순으로 정렬할 때 Comparable이 사용된다. 이 프로토콜은 객체 간의 대소 비교를 위한 연산자를 제공한다.        구현 방법          Comparable을 구현하려면 &lt; 연산자를 구현해야 한다. 그 외의 연산자(&gt;, &lt;=, &gt;=)는 기본적으로 제공된다. Comparable을 준수하려면 Equatable도 함께 구현해야 하므로, 객체 간의 동등성과 순서를 모두 정의할 수 있다.      ex)struct Person: Comparable {    let name: String    let age: Int    static func &lt; (lhs: Person, rhs: Person) -&gt; Bool {        return lhs.age &lt; rhs.age    }    // Equatable의 구현도 필요함    static func == (lhs: Person, rhs: Person) -&gt; Bool {        return lhs.age == rhs.age &amp;&amp; lhs.name == rhs.name    }}let person1 = Person(name: \"Alice\", age: 30)let person2 = Person(name: \"Bob\", age: 25)print(person1 &lt; person2)   // falseprint(person1 &gt; person2)   // truelet sortedPeople = [person1, person2].sorted()print(sortedPeople)  // [Person(name: \"Bob\", age: 25), Person(name: \"Alice\", age: 30)]  Equatable  역할          Equatable은 객체가 서로 같은지 여부를 비교하는 데 사용된다. 이를 통해 두 객체가 동등한지(==) 또는 동등하지 않은지(!=)를 알 수 있다.        필요성          Equatable은 데이터가 같은지 비교할 수 있어야 하는 여러 곳에서 필수적이다. 예를 들어, 배열에서 특정 객체를 찾거나, 두 객체가 같은지 비교할 때 사용된다.        구현 방법          Equatable을 준수하려면 == 연산자를 구현해야 한다. 두 객체가 같은지 확인하기 위해, 각 객체의 속성을 비교한다.      ex)struct Person: Equatable {    let name: String    let age: Int    static func == (lhs: Person, rhs: Person) -&gt; Bool {        return lhs.name == rhs.name &amp;&amp; lhs.age == rhs.age    }}let person1 = Person(name: \"Alice\", age: 30)let person2 = Person(name: \"Alice\", age: 30)let person3 = Person(name: \"Bob\", age: 25)print(person1 == person2)  // trueprint(person1 == person3)  // false  결론      Equatable은 두 객체가 동일한지 확인하는 데 사용되고, Comparable은 객체들 간의 순서 비교와 정렬을 할 때 사용된다.Comparable을 구현하려면 반드시 Equatable을 함께 구현해야 하므로, Comparable을 준수하는 객체는 동등성(==)과 순서 비교(&lt;) 모두 가능하다.  이 두 프로토콜을 잘 활용하면 데이터 비교와 정렬 작업을 효율적으로 처리할 수 있다.            프로토콜      주요 연산자      목적      필수 메서드      사용 예시                  Equatable      ==, !=      두 객체가 동일한지 비교      static func ==(lhs:rhs:) -&gt; Bool      객체가 같은지 비교할 때 (Array.contains())              Comparable      &lt;, &lt;=, &gt;, &gt;=      두 객체 간 순서를 비교      static func &lt;(lhs:rhs:) -&gt; Bool      배열 정렬, 대소 비교 (Array.sorted())      "
  },
  
  {
    "title": "To Do List (2)",
    "url": "/posts/ToDoList_2/",
    "categories": "Study, ToDoList",
    "tags": "",
    "date": "2024-10-16 08:33:00 +0900",
    





    
    "snippet": "1. Lv 2. Todo 추가 및 완료기능 구현하기추가기능 구현우선 추가기능을 구현하려면 Alert를 만들어야 한다.블로그를 참고하여 만들었다.struct MainView: View {    @State private var showing = false    @State private var title = \"\"        var body: some ...",
    "content": "1. Lv 2. Todo 추가 및 완료기능 구현하기추가기능 구현우선 추가기능을 구현하려면 Alert를 만들어야 한다.블로그를 참고하여 만들었다.struct MainView: View {    @State private var showing = false    @State private var title = \"\"        var body: some View {        NavigationStack{            VStack {                List {                    Text(\"test\")                    Text(\"test1\")                    Text(\"test2\")                }            }            .toolbar {                ToolbarItem(id: \"add\",                            placement: .navigationBarTrailing) {                    Button(\"add\",                           systemImage: \"plus.app\") {                        showing.toggle()                    }                           .alert(\"TodoList 추가\",                                  isPresented: $showing) {                               TextField(\"TodoList 추가\", text: $title)                               Button(\"OK\",                                      role: .cancel) {                                   addList()                               }                               Button(\"Cancel\", role: .destructive){                                                                  }                           }                }            }        }    }        func addList() {        print(title)    }    }여기서 포인트는 alert역시도 modifier의 형태로 구현을 한다는 것이다.이때 한가지 눈여겨 볼 점은 isPresented 일반 변수가 들어가는게 아닌 바인딩으로 해줘야한다.  바인딩      SwiftUI에서 바인딩(Binding)은 뷰와 상태 간의 양방향 연결을 의미한다. 상태(State)가 변하면 뷰가 자동으로 업데이트되고, 뷰에서의 사용자 인터랙션에 따라 상태도 업데이트된다. 즉, 바인딩을 통해 상태와 UI 요소가 동기화되는 것이다.@State로 선언한 showing 변수를 $showing으로 바인딩하여 alert의 표시 여부를 제어하고 있다. 이처럼 alert이 표시될 때, showing 값이 true가 되고, 그에 따라 뷰가 반응하여 경고창을 나타내는 방식이다.  그리고 alert안에 다가 TextField, Button을 넣어주어 Alert를 구성해주었다.현재는 테스트용으로 ok를 눌렀을때 Console에 해당 값을 print하게 해두었다.Cell View 디자인struct CellView: View {    @State var isOn: Bool = false        var body: some View {        HStack {            Text(\"Hello, World!\")                .padding(.leading, 30)            Toggle(\"\", isOn: $isOn)                .padding(.trailing, 30)                        if isOn {                            } else {                            }                    }    }}일단은 대충 이렇게 해두었다.SwiftData 사용하여 추가 구현@Environment(\\.modelContext) private var modelContext modelContext를 만들어 준다.이녀석은 CoreData를 사용했을때 Context와 비슷한 역할을 수행한다고 생각하면 된다. CRUD를 담당한다.그리고 함수를 수정한다.func addList() {        let todoModel = TodoModel(id: id + 1, title: title, isCompleted: false)        modelContext.insert(todoModel)    }List 수정@Query private var todoLists: [TodoModel]VStack {                List(todoLists, id: \\.self) { list in                    Text(list.title)                }            }배열에 있는걸 가져와서 사용하게 된다.id: \\.self는 SwiftUI에서 각 항목의 고유성을 결정할 때 사용된다.\\.self는 Swift의 키 경로 문법으로, 해당 항목 자체를 고유 식별자로 사용하겠다는 의미이다. 즉, todoLists 배열의 각 항목이 고유해야 하며, SwiftUI가 항목을 구분할 때 그 자체를 고유 ID로 삼아 내부적으로 비교하고 관리하게 된다.이를 사용하면 목록에서 항목을 삽입, 삭제 또는 업데이트할 때 SwiftUI가 정확하게 각 항목을 추적할 수 있다. 다만, 배열의 각 요소가 고유해야 하며, 그렇지 않으면 문제가 발생할 수 있다."
  },
  
  {
    "title": "To Do List (1)",
    "url": "/posts/ToDoList_1/",
    "categories": "Study, ToDoList",
    "tags": "",
    "date": "2024-10-15 08:33:00 +0900",
    





    
    "snippet": "이전에 사용하던 UIKit이 아닌 SwiftUI를 사용하여 ToDoList를 만들어 본다.이전에 내배캠에서 하던 양식을 그대로 해서 만들어보려고 한다.LV 1. ToDoList 화면 만들기1. 디자인NavigationBar 추가우선 추가하기 버튼이 있는곳은 NavigationBar를 사용하여 만들 예정이다.우선 NavigationBar를 먼저 만들어 ...",
    "content": "이전에 사용하던 UIKit이 아닌 SwiftUI를 사용하여 ToDoList를 만들어 본다.이전에 내배캠에서 하던 양식을 그대로 해서 만들어보려고 한다.LV 1. ToDoList 화면 만들기1. 디자인NavigationBar 추가우선 추가하기 버튼이 있는곳은 NavigationBar를 사용하여 만들 예정이다.우선 NavigationBar를 먼저 만들어 본다.struct ContentView: View {    var body: some View {        NavigationStack{            VStack {                Text(\"Test\")            }            .toolbar {                ToolbarItem(id: \"add\", placement: .navigationBarTrailing) {                    Button(\"add\", systemImage: \"plus.app\") {                        print(\"Add\")                    }                }            }        }    }}아무 생각없이 Toolbar를 먼저 추가했다.하지만 NavigationBar가 보이지 않았다.NavigationStack이 빠졌기 때문이다.그래서 추가를 해주고 나니 보인다.List(TableView) 추가UIKit에서는 TableView라고 불렀지만 SwiftUI에서는 List로 사용된다.struct ContentView: View {    var body: some View {        NavigationStack{            VStack {                List {                    Text(\"test\")                    Text(\"test1\")                    Text(\"test2\")                }            }            .toolbar {                ToolbarItem(id: \"add\",                            placement: .navigationBarTrailing) {                    Button(\"add\",                           systemImage: \"plus.app\") {                        print(\"Add\")                    }                }            }        }    }}Vstack 안에 List를 넣어주었다.테스트로 3개의 행을 넣어줬다.2. 데이터 모델링struct TodoModel {    let id: Int    let title: String    let isCompleted: Bool}우선 심플하게 이렇게 구성을 해주었다.하지만 SwiftData를 사용하기 위해선 class로 사용해야해서 바꿔준다.import SwiftData@Modelclass TodoModel {    var id: Int    var title: String    var isCompleted: Bool        init(id: Int, title: String, isCompleted: Bool) {        self.id = id        self.title = title        self.isCompleted = isCompleted    }}그리고 앱으로 가서@mainstruct ToDoListApp: App {    var body: some Scene {        WindowGroup {            ContentView()                .modelContainer(for: TodoModel.self)        }    }}이렇게 Container를 추가해준다."
  },
  
  {
    "title": "Build the unofficial Udemy Home Screen (9)",
    "url": "/posts/Build-the-unofficial-Udemy-Home-Screen-(9)/",
    "categories": "Udemy",
    "tags": "",
    "date": "2024-10-13 01:13:00 +0900",
    





    
    "snippet": "APIResponse를 UIModel에 파싱하기이전에는 Json으로 데이터를 가져오지 않았기에let uiModel = HomeUIModel(sectionModels: [            .init(section:.mainBanner(id: \"123\"), body: [이렇게 ViewDidLoad에 값을 넣어 주었는데, 이젠 JSON에 값이 있기에 J...",
    "content": "APIResponse를 UIModel에 파싱하기이전에는 Json으로 데이터를 가져오지 않았기에let uiModel = HomeUIModel(sectionModels: [            .init(section:.mainBanner(id: \"123\"), body: [이렇게 ViewDidLoad에 값을 넣어 주었는데, 이젠 JSON에 값이 있기에 JSON을 사용하여 바로 로드를 해보기로 한다.ViewDidLoad에 있던 uiModel에 관한 내용은 모두 날리자.Helper 설정struct HomeUIModelHelper {    typealias SectionModel = HomeUIModel.SectionModel        static func makeUIModel(response: APIResponse) -&gt; HomeUIModel {        var sectionModels = [SectionModel]()        for layout in response.layouts {            switch layout {            case let .mainBanner(id, mainBanner):                let sectionModel = SectionModel(                    section: .mainBanner(id: id),                    body: [.mainBanner(                        id: mainBanner.id,                        imageLink: mainBanner.imageLink,                        title: mainBanner.title,                        caption: mainBanner.caption)                    ])                sectionModels.append(sectionModel)            case let .textHeader(id, textHeader):                let sectionModel = SectionModel(                    section: .textHeader(id: id),                    body: [.textHeader(                        id: textHeader.id,                        text: textHeader.text,                        highlightedText: textHeader.highlightedText)                    ])                sectionModels.append(sectionModel)            case let .courseSwimlane(id, courses):                let items: [HomeUIModel.Item] = courses.map { course in                    return .course(id: course.id, imageLink: course.imageLink, title: course.title, author: course.author, rating: course.rating, reviewCount: course.reviewCount, price: course.price, tag: course.tag)                }일부만 적는다.문제해결갑자기guard let sectionModel = self?.uiModel?.sectionModels[index] else { return nil } 여기부분에서 에러가 발생했다.에러내용은 다음과 같다.'nil' is not compatible with closure result type 'NSCollectionLayoutSection'HomeUIModelHelper를 적으면서 생긴문제이니 거기서부터 확인을 해봐야겠다.그부분은 문제가 없었다.init에서 차이가있음을 발견실행했을때는 차이가 없어서 이부분은 GPT를 통해 내용을 좀 더 적는다.//wronginit() {        super.init(frame: .zero, collectionViewLayout: UICollectionViewLayout())        collectionViewLayout = makeCompositionalLayout()        registerCells()        setupDataSource()    }//correctinit() {    super.init(frame: .zero, collectionViewLayout: UICollectionViewFlowLayout()) // different    collectionViewLayout = makeCompositionalLayout()    registerCells()    setupDataSource()  }  UICollectionViewLayout          추상 클래스로, UICollectionView의 모든 레이아웃의 기본 클래스.      직접 사용하지 않고, 레이아웃을 커스터마이징하려면 이 클래스를 서브클래싱하여 구현함.      개발자가 컬렉션 뷰의 레이아웃을 완전히 제어하고 싶을 때 사용하는 클래스.      class CustomLayout: UICollectionViewLayout {        override func prepare() {        super.prepare()        // 커스텀 레이아웃 준비 작업    }        override var collectionViewContentSize: CGSize {        // 컬렉션 뷰의 전체 콘텐츠 크기 정의        return CGSize(width: 1000, height: 1000)    }        override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? {        var attributes = [UICollectionViewLayoutAttributes]()        // 주어진 rect에 표시할 아이템의 레이아웃 속성 계산        return attributes    }        override func layoutAttributesForItem(at indexPath: IndexPath) -&gt; UICollectionViewLayoutAttributes? {        let attributes = UICollectionViewLayoutAttributes(forCellWith: indexPath)        // 특정 아이템의 레이아웃 속성 정의        attributes.frame = CGRect(x: indexPath.row * 50, y: 0, width: 50, height: 50)        return attributes    }}  UICollectionViewFlowLayout          UICollectionViewLayout의 서브클래스.      미리 정의된 표준 레이아웃을 제공함.      아이템을 그리드 형식으로 행(row)이나 열(column)에 자동으로 배치하는 레이아웃을 제공.      일반적인 수평 및 수직 스크롤을 처리하는 레이아웃으로 많이 사용됨.      간단한 설정으로 섹션 간 간격, 아이템 크기, 스크롤 방향 등을 제어 가능.      let flowLayout = UICollectionViewFlowLayout()flowLayout.itemSize = CGSize(width: 100, height: 100)flowLayout.minimumLineSpacing = 10flowLayout.minimumInteritemSpacing = 10flowLayout.scrollDirection = .verticallet collectionView = UICollectionView(frame: .zero, collectionViewLayout: flowLayout)차이점  UICollectionViewLayout은 추상적인 기본 클래스로, 완전한 커스텀 레이아웃을 만들 때 사용.  UICollectionViewFlowLayout은 그리드 레이아웃을 제공하는 구현된 클래스로, 커스텀이 필요 없는 경우 쉽게 사용할 수 있음.  실행해도 문제가 없는 이유.  초기 기본 레이아웃 설정:          UICollectionViewFlowLayout은 컬렉션 뷰의 기본적인 그리드형 레이아웃(아이템 크기, 간격, 스크롤 방향 등)을 자동으로 처리해 줍니다. 만약 초기화 시 UICollectionViewFlowLayout을 사용하면 기본적인 레이아웃이 설정됨.      반면에, UICollectionViewLayout은 추상적인 기본 클래스이므로, 레이아웃 관련 동작을 모두 직접 구현해야 힌디. 만약 이후에 makeCompositionalLayout()으로 레이아웃을 변경할 예정이라면, 초기화 시 UICollectionViewLayout을 사용해도 문제가 발생하지 않을 수 있다.        의미적인 차이:          UICollectionViewFlowLayout은 명시적으로 기본 그리드 레이아웃을 사용할 의도를 나타낸다. 즉, 기본적으로 표준적인 흐름(flow) 레이아웃을 사용하고 있음을 명확히 알 수 있다.      UICollectionViewLayout은 그 자체로 아무런 레이아웃을 설정하지 않으므로, 이후에 별도로 레이아웃을 설정할 의도임을 나타낸다.        왜 문제가 없을까?현재 코드에서 collectionViewLayout = makeCompositionalLayout()으로 나중에 레이아웃을 덮어씌우기 때문에 초기화 시 사용한 UICollectionViewFlowLayout이나 UICollectionViewLayout이 최종적으로 반영되지 않는다.makeCompositionalLayout()에서 설정한 레이아웃이 최종적으로 사용되기 때문에 문제가 발생하지 않는 것.하지만 명확하게 의도를 표현하고 싶다면 UICollectionViewFlowLayout을 사용하는 것이 더 좋다.그리고 makeCompositionalLayout 힘수에서도 발견//wrongcase .textheader:                guard case let .textHeader(_, text, _) = sectionModel.body.first                else { return nil }                return self?.makeTextHeaderSection(text: text)//correctcase .textHeader:                guard case let .textHeader(_, text, _) = sectionModel.body.first                else { return nil }                return self?.makeTextHeaderSection(text: text)해당에러는 이런 대소문자나 기타 에러에 의해서 파생된 에러로 확인되었다.이후 HomeVC로가서private func loadJSON() {        let apiResponse: APIResponse? = FileManager.modelFromJSON(fileName: \"payload\")                if let response = apiResponse {            let uiModel = HomeUIModelHelper.makeUIModel(response: response)            collectionView.setDataSource(uiModel: uiModel)        }                }uiModel을 적용시켜준다.서버를 통한 JSON 로드하기Mocky 를 사용하여, JSON의 내용을 모두 복사한뒤 업로드한다.New Mock을 클릭하면 위와같이 나오는데 Response에 내용을 복사하자.이후 Generate를 하면이렇게 링크가 생성이 된다.링크를 타고들어가면 우리가 복사한 내용이 그대로 보인다.struct APIClient {        private let urlString =    \"https://run.mocky.io/v3/7efcd0a5-21fd-4f12-9e73-7aaa6701d722\"        func fetchLayout() -&gt; AnyPublisher&lt;APIResponse, Error&gt; {        return URLSession.shared.dataTaskPublisher(for: URL(string: urlString)!)            .map({$0.data})            .decode(type: APIResponse.self, decoder: JSONDecoder())            .eraseToAnyPublisher()    }}API호출 관련 Struct를 만들어 주었다.private let apiClient = APIClient()private func fetchLayout() {        apiClient.fetchLayout()            .receive(on: DispatchQueue.main)            .sink { completion in            if case let .failure(error) = completion {                print(\"Error: \\(error)\")            }        } receiveValue: { [weak self] apiResponse in            let uiModel = HomeUIModelHelper.makeUIModel(response: apiResponse)            self?.collectionView.setupDataSource(uiModel: uiModel)        }.store(in: &amp;cancellables)                        //        let apiResponse: APIResponse? = FileManager.modelFromJSON(fileName: \"payload\")        //        //        if let response = apiResponse {        //            let uiModel = HomeUIModelHelper.makeUIModel(response: response)        //            collectionView.setupDataSource(uiModel: uiModel)        //        }            }loadJSON에서 fetchLayout으로 함수명을 바꿔주었다.이젠 JSON에 아무런 내용이 없어도 서버에서 가져오기에 로드가 된다.작동화면은 달라진게 없어서 패스"
  },
  
  {
    "title": "Build the unofficial Udemy Home Screen (8)",
    "url": "/posts/Build-the-unofficial-Udemy-Home-Screen-(8)/",
    "categories": "Udemy",
    "tags": "",
    "date": "2024-10-12 06:13:00 +0900",
    





    
    "snippet": "FileManager Extension 구성하기extension FileManager {    static func modelFromJSON&lt;T: Decodable&gt;(fileName: String) -&gt; T? {                guard let path = Bundle.main.path(forResource: fileNam...",
    "content": "FileManager Extension 구성하기extension FileManager {    static func modelFromJSON&lt;T: Decodable&gt;(fileName: String) -&gt; T? {                guard let path = Bundle.main.path(forResource: fileName, ofType: \"json\") else {            print(\"&gt;&gt;&gt; Path not found\")            return nil        }                do {            let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .mappedIfSafe)            let stringValue = String(data: data, encoding: .utf8)            print(\"&gt;&gt;&gt; StringValue: \\(stringValue)\")            return try JSONDecoder().decode(T.self, from: data)        } catch {            print(\"&gt;&gt;&gt; Error reading JSON File: \\(error.localizedDescription)\")            return nil        }    }}  &lt;T: Decodable&gt;:          T는 제네릭 타입 매개변수로, 이 함수가 반환할 타입을 의미한다.      T: Decodable은 제약 조건으로, T는 반드시 Decodable 프로토콜을 준수해야 한다는 것을 의미한다. 즉, T는 JSON 데이터를 디코딩할 수 있는 타입이어야 한다. Decodable 프로토콜은 구조체, 클래스, 열거형이 JSON 등의 외부 데이터 포맷에서 변환 가능한 모델이어야 함을 의미한다.      이 제네릭을 통해, JSON 파일에서 특정 타입의 데이터 모델을 동적으로 디코딩할 수 있다. 즉, T는 실행 시점에 결정되며 다양한 타입으로 사용할 수 있다.        파일 경로 찾기          주어진 fileName과 확장자가 .json인 파일을 앱 번들 내에서 찾는다. 파일 경로가 없을 경우 nil을 반환한다.        파일 데이터를 Data로 변환          찾은 파일의 경로를 사용해 파일을 읽어들여 Data 객체로 변환한다. 이 데이터는 JSON 형식의 파일 내용을 바이트로 읽어들인 것이다.      options: .mappedIfSafe는 파일 내용을 메모리 맵 방식으로 로드하는 옵션으로, 파일을 안전하게 메모리에 로드하도록 한다.        JSON 디코딩          JSONDecoder()를 사용하여 JSON 데이터를 제네릭 타입 T로 디코딩한다. 여기서 T.self는 타입을 나타내며, 해당 타입으로 JSON 데이터를 변환한다.      option의 mappedIfSafe              .mappedIfSafe는 파일을 메모리에 매핑할 때 안전한 방식으로 매핑하겠다는 의미이다. 이 옵션은 큰 파일을 다룰 때 메모리를 효율적으로 관리하기 위해 사용된다.      파일을 메모리에 매핑하는 방식인데, 이 방식은 시스템이 해당 파일을 안전하다고 판단하는 경우에만 매핑을 사용한다. 시스템에 의해 안전하지 않다고 판단되면 일반적인 방식으로 파일을 읽어온다.    - 이 과정에서 JSON 데이터가 제네릭 타입 T로 변환되며, 성공하면 변환된 객체를 반환하고, 실패하면 에러를 발생시킨다.      HomeVC에 JSON Load 함수 구성private func loadJSON() {        let response: APIResponse? = FileManager.modelFromJSON(fileName: \"payload\")    }    그리고 ViewDidLoad에서 해당 함수를 호출한다.이렇게 실행하니 json파일이 잘 콘솔에 출력이됨을 알 수 있다.API Response 구성하기Response를 구성할때는 Top to Bottom으로 진행하는데JSON의 제일 상위부터 시작한다.즉 status, layouts부터 구성.struct APIResponse: Decodable {        let status: Int    let layouts: [Layout]    }1. Layout 구성Layout은 type에 따라 다르므로.enum을 사용해서 구성한다.enum Layout {        case mainBanner(String, MainBanner)    }        struct MainBanner {        let id: String        let imageLink: String        let title: String        let caption: String    }이렇게 앞에 String, MainBanner로 나눈 이유는id는 String이고 Value는 MainBanner Struct를 사용해서 구성을 하기 때문에 이렇게 했다.이렇게 JSON의 값을 확인해서 구성을 해주자.Course의 경우case swimLane(String, [Course])이렇게 배열로 감싼건사진을 전부 표현하기엔 길어서 상단만 했는데 이렇게 배열로 값이 감싸지기 때문.배열로 감싸지 않은건이렇게 [로 시작하지 않는다.이렇게 에러가 나기에 에러를 수정하기위해 initializing을 해줘야한다.init(from decoder: any Decoder) throws {            let container = try decoder.container(keyedBy: CodingKeys.self)            let type = try container.decode(String.self, forKey: .type)            let id = try container.decode(String.self, forKey: .id)            switch type {            case \"mainBanner\":                let model = try container.decode(MainBanner.self, forKey: .value)                self = .mainBanner(id, model)            case \"textHeader\":                let model = try container.decode(TextHeader.self, forKey: .value)                self = .textHeader(id, model)            case \"courseSwimlane\":                let models = try container.decode([Course].self, forKey: .value)                self = .courseSwimlane(id, models)            case \"categories\":                let model = try container.decode(Categories.self, forKey: .value)                self = .categories(id, model)            case \"featuredCourse\":                let model = try container.decode(Course.self, forKey: .value)                self = .featuredCourse(id, model)            case \"udemyBusinessBanner\":                let model = try container.decode(UdemyBusinessBanner.self, forKey: .value)                self = .udemyBusinessBanner(id, model)            default:                self = .unknown(type)            }        }  APIResponse.Layout 구조체의 init(from decoder: any Decoder) 부분은 디코딩 로직을 정의하는 커스텀 초기화 메서드이다.이 부분은 JSON 데이터를 파싱하여 해당 Layout 케이스로 변환하는 역할을 한다.이 초기화 메서드에서는 특정 키(type, id, value)에 따라 적절한 케이스를 선택하고 그에 맞는 데이터를 디코딩하여 해당 케이스로 초기화한다.  Decoder 객체로부터 데이터를 읽어오는 과정          let container = try decoder.container(keyedBy: CodingKeys.self)      decoder로부터 컨테이너를 가져옴. 이 컨테이너는 JSON의 키-값 쌍을 읽는 역할을 함.      CodingKeys는 JSON의 키를 정의한 열거형이고, 이를 통해 데이터를 읽음.        type과 id 필드 읽기          JSON의 type과 id 필드를 읽음.      type은 JSON에서 어떤 레이아웃인지 나타내고, id는 그 레이아웃의 고유 식별자임.        switch문으로 type에 따른 분기 처리          type 값에 따라 어떤 케이스로 디코딩할지 결정함.      type에 따라 mainBanner, textHeader, courseSwimlane 등 여러 케이스로 분기함.        케이스별 디코딩 처리          각 케이스에 맞는 데이터를 디코딩하고, self에 해당 케이스로 할당함.              a. mainBanner 케이스                  type이 “mainBanner”인 경우, JSON에서 MainBanner 타입으로 데이터를 디코딩함.          self는 .mainBanner(id, model)로 할당됨.                    b. 다른 케이스 (textHeader, courseSwimlane 등)                  각 케이스마다 비슷한 방식으로 해당 모델을 디코딩하고, self에 적절한 케이스로 할당함.          예를 들어, textHeader는 TextHeader 타입으로, courseSwimlane은 Course 배열로 디코딩됨.                      기본 케이스          type이 정의되지 않은 값인 경우, unknown 케이스로 처리함.      그래도 에러가 발생하는걸 보니 struct로 한것들도 모두 Decodable 뿐만 아니라 Hashable을 적용시켜줘야 한다는걸 알았다.    struct MainBanner: Decodable, Hashable {        let id: String        let imageLink: String        let title: String        let caption: String    }        struct TextHeader: Decodable, Hashable {        let id: String        let title: String        let highlightedText: String?    }        struct Course: Decodable, Hashable {        let id: String        let imageLink: String        let title: String        let author: String        let rating: Double        let reviewCount: Int        let price: Decimal        let tags: String    }        struct Categories: Decodable, Hashable {        let id: String        let title: [String]    }        struct UdemyBusinessBanner: Decodable, Hashable {        let id: String        let link: String    }여기서type, id, value만 key로 사용하므로나머지는 지우자.private enum CodingKeys: String, CodingKey {            case type, value, id        }그리고 Hashable도 필요없으므로, 해당 프로토콜을 모두 지워준다.혹시나 실행을 했는데&gt;&gt;&gt; Error reading JSON File: keyNotFound(CodingKeys(stringValue: \"title\", intValue: nil), Swift.DecodingError.Context(codingPath: [CodingKeys(stringValue: \"layouts\", intValue: nil), _CodingKey(stringValue: \"Index 4\", intValue: 4), CodingKeys(stringValue: \"value\", intValue: nil)], debugDescription: \"No value associated with key CodingKeys(stringValue: \\\"title\\\", intValue: nil) (\\\"title\\\").\", underlyingError: nil))&gt;&gt;&gt; response: nil이런 에러가 발생한다면4번째 레이아웃에서 발생한 에러인데 title이 없다라는것이므로그부분에 오타가 있는지 봐야한다.struct Categories: Decodable {        let id: String        let title: [String]    }title로 해두었는데 json을 가서 확인하면title이 아닌 titles이다.이렇게 json과 다르면 에러가 나므로 오타를 잘 확인하자.Json의 변수를 그대로 잘 맞춰주었다면 실행했을때&gt;&gt;&gt; response: Optional(ios_udemy_home.APIResponse(status: 200, layouts: [ios_udemy_home.APIResponse.Layout.mainBanner(\"79c7e84a-d29b-11ee-8a80-325096b39f47\",이런 결과를 얻게된다."
  },
  
  {
    "title": "Build the unofficial Udemy Home Screen (7)",
    "url": "/posts/Build-the-unofficial-Udemy-Home-Screen-(7)/",
    "categories": "Udemy",
    "tags": "",
    "date": "2024-10-12 06:13:00 +0900",
    





    
    "snippet": "Tap 이벤트를 VC로 전달하기Combine의 EventPublisher를 사용하여 할것이다.HomeCollectionView에서 진행한다.enum Event {        case itemTapped(HomeUIModel.Item)    }private let eventSubject = PassthroughSubject&lt;Event, Never...",
    "content": "Tap 이벤트를 VC로 전달하기Combine의 EventPublisher를 사용하여 할것이다.HomeCollectionView에서 진행한다.enum Event {        case itemTapped(HomeUIModel.Item)    }private let eventSubject = PassthroughSubject&lt;Event, Never&gt;()var eventPublisher: AnyPublisher&lt;Event, Never&gt; {    return eventSubject.eraseToAnyPublisher()}그리고 cell에도 내용을 바꿔준다.private func setupDataSource() {        diffableDataSource = UICollectionViewDiffableDataSource(collectionView: self, cellProvider: { collectionView, indexPath, item in            switch item {            case let .mainBanner(_, imageLink, title, caption):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: MainBannerCollectionViewCell.namedIdentifier, for: indexPath) as! MainBannerCollectionViewCell                cell.configure(imageLink: imageLink, title: title, caption: caption)                return cell            case let .textHeader(id, title, highlightedText):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: TextHeaderCollectionViewCell.namedIdentifier, for: indexPath) as! TextHeaderCollectionViewCell                cell.configure(text: title, highlightedText: highlightedText)                cell.onTap = { [weak self] in                    self?.eventSubject.send(.itemTapped(item))                    print(\"&gt;&gt;&gt; TextHeader link tapped: \\(id) - \\(highlightedText)\")                }                return cell            case let .course(id, imageLink, title, author, rating, reviewCount, price, tag):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CourseCollectionViewCell.namedIdentifier, for: indexPath) as! CourseCollectionViewCell                cell.configure(imageLink: imageLink, title: title, author: author, rating: rating, reviewCount: reviewCount, price: price, tag: tag)                cell.onTap = {[weak self] in                    self?.eventSubject.send(.itemTapped(item))                }                return cell            case let .categoriesScroller(_, titles):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CategoriesCollectionViewCell.namedIdentifier, for: indexPath) as! CategoriesCollectionViewCell                cell.configure(titles: titles)                cell.onTap = { [weak self] title in                    // self?.eventSubject.send(.itemTapped(item))                    print(\"&gt;&gt;&gt; category tapped is \\(title)\")                }                return cell            case let .featuredCourse(_, imageLink, title, author, rating, reviewCount, price):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: FeaturedCourseCollectionViewCell.namedIdentifier, for: indexPath) as! FeaturedCourseCollectionViewCell                cell.configure(imageLink: imageLink, title: title, author: author, rating: rating, reviewCount: reviewCount, price: price)                cell.onTap = { [weak self] in                    self?.eventSubject.send(.itemTapped(item))                }                return cell            case let .udemyBusinessBanner(_, link):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: UdemyBusinessCollectionViewCell.namedIdentifier, for: indexPath) as! UdemyBusinessCollectionViewCell                cell.onTap = { [weak self] in                    self?.eventSubject.send(.itemTapped(item))                }                return cell            }        })    }categoriesScroller경우만 프린트를 해둔 이유는title에 바로 접근을 지금 할수가 없기에 잠시 보류를 해둔상태라고 보면된다.지금 할 수 없다는 것은enum Item: Hashable {        case mainBanner(id: String, imageLink: String, title: String, caption: String)        case course(id: String, imageLink: String, title: String, author: String, rating: Double, reviewCount: Int, price: Decimal, tag: String)        case textHeader(id: String, text: String, highlightedText: String?)        case udemyBusinessBanner(id: String, link: String)        case categoriesScroller(id: String, titles: [String])        case featuredCourse(id: String, imageLink: String, title: String, author: String, rating: Double, reviewCount: Int, price: Decimal)    }여기 아이템에서 categoriesScroller로 들어가서 title을 가져올수없기때문.HomeVC에서 Event 정의하기우선 loadView를 override 해준다.loadView의 경우엔 이전에 간략하게 적어둔게 있어서 생략override func loadView() {        super.loadView()        observe()    }private func observe() {        collectionView.eventPublisher.sink { [weak self] event in            switch event {            case let .itemTapped(item):                self?.handleItemTapped(item: item)            }        }.store(in: &amp;cancellables)    }    private func handleItemTapped(item: HomeUIModel.Item) {        switch item {        case .mainBanner(let id, let imageLink, let title, let caption):            print(\"&gt;&gt;&gt; mainBanner tapped\")        case .course(let id, let imageLink, let title, let author, let rating, let reviewCount, let price, let tag):            print(\"&gt;&gt;&gt; course tapped\")        case .textHeader(let id, let text, let highlightedText):            print(\"&gt;&gt;&gt; textHeader tapped\")        case .udemyBusinessBanner(let id, let link):            print(\"&gt;&gt;&gt; udemyBusinessBanner tapped\")        case .categoriesScroller(let id, let titles):            print(\"&gt;&gt;&gt; categoriesScroller tapped\")        case .featuredCourse(let id, let imageLink, let title, let author, let rating, let reviewCount, let price):            print(\"&gt;&gt;&gt; featuredCourse tapped\")        }    }observe() 함수:  컬렉션 뷰에서 발생하는 이벤트를 감지하는 역할을 한다.  collectionView.eventPublisher를 통해 이벤트 스트림을 구독하고, 아이템이 탭 되었을 때 itemTapped 이벤트가 발생하면 handleItemTapped 함수로 해당 아이템을 전달하여 처리한다.  메모리 누수를 방지하기 위해 [weak self]로 약한 참조를 사용하며, 구독은 cancellables에 저장된다.handleItemTapped(item:) 함수:  사용자가 탭한 항목에 대한 세부 처리를 담당한다.  HomeUIModel.Item 타입의 아이템에 대해 switch를 사용하여 어떤 타입의 아이템이 탭되었는지 확인하고, 그에 맞는 동작(여기서는 print)을 수행한다.  탭된 아이템의 타입에 따라 (예: mainBanner, course, textHeader 등) 적절한 로그를 출력한다.Category Tap 수정cell.onTap = { [weak self] title in                    // self?.eventSubject.send(.itemTapped(item))                    print(\"&gt;&gt;&gt; category tapped is \\(title)\")                }여기만 프린트로 별도로 해둔부분을 수정하려고 한다.프린트를 지우고 주석단부분을 활성화 했을때 어떻게 나오는지 먼저 확인해보자.[before][after]아이템을 지칭하는 전체적인것이 탭이 되었다고 뜬다.  그러면 HomeVC에서 titles를 가져오면?case .categoriesScroller(let id, let titles):            print(\"&gt;&gt;&gt; categoriesScroller tapped \\(titles)\")이렇게 했을때 어떻게 출력이 되는지 확인해보자.하나를 클릭하더라도 전체 category안에 있는 전체 Item들이 다 보이는걸 알 수 있다.그래서 잠시 홀딩을 해두었던것.HomeCollectionView로 가서선택된 항목에 대한 변수를 하나 만들어 준다.cell.onTap = { [weak self] title in                    let selected = HomeUIModel.Item.categoriesScroller(id: id, titles: [title])                    self?.eventSubject.send(.itemTapped(selected))                }그리고 item대신 selected로 파라미터를 바꿔주자.selected는 사용자가 카테고리를 탭했을 때, 선택된 카테고리 정보를 담은 객체이다.이 객체는 HomeUIModel.Item.categoriesScroller 타입의 새로운 인스턴스로 생성되며, 탭된 title 정보를 가지고 있다.  selected는 탭된 카테고리 정보를 바탕으로 새로운 categoriesScroller 아이템을 만든다.  id: 기존의 categoriesScroller 아이템의 고유 ID를 유지한다.  titles: [title]: 사용자가 선택한 하나의 title만을 포함하는 배열로 생성된다.  기존의 titles 배열이 아니라, 탭된 특정 카테고리(title)만을 포함하는 배열로 만들어진다.case .categoriesScroller(let id, let titles):            guard let title = titles.first else { return }            print(\"&gt;&gt;&gt; categoriesScroller tapped \\(title)\")그리고 선택된 항목의 값만 출력하기위해 first를 한다.first를 하지않으면&gt;&gt;&gt; categoriesScroller tapped [\"Development\"]이런식으로 배열로 값이 보일것이다.이제 탭을 해보면잘 된다.Course 상세 설명 보여주기.우선 새로운 디렉토리(CourseDetail)를 만들어 준다.상세페이지를 담당할 CourseDetailViewController파일을 만들어 준다.class CourseDetailViewController: UIViewController {        private let titleLabel: UILabel = {        let label = UILabel()        label.numberOfLines = 0        label.textAlignment = .center        label.font = .systemFont(ofSize: 18, weight: .bold)        return label    }()        override func viewDidLoad() {        super.viewDidLoad()                view.backgroundColor = .white        view.addSubview(titleLabel)        titleLabel.snp.makeConstraints { make in            make.centerX.centerY.equalToSuperview()            make.leading.equalToSuperview().offset(32)            make.trailing.equalToSuperview().offset(-32)        }            }        func setText(title: String) {        titleLabel.text = title            }}아직까진 크게 서술할만한건 없다.HomeVC에서 CourseDetailVC를 호출하도록 만든다.case .course(let id, let imageLink, let title, let author, let rating, let reviewCount, let price, let tag):            showCourseDetailsViewcontroller(title: title)            print(\"&gt;&gt;&gt; course tapped \\(id) - \\(title)\")private func showCourseDetailsViewcontroller(title: String) {        let viewController = CourseDetailViewController()        viewController.setText(title: title)        navigationController?.pushViewController(viewController, animated: true)    }    하지만 이렇게해도 실행했을때 화면이 나오지 않는다.왜냐면 showCourseDetailsViewcontroller에서 NavigationController를 사용하는데, 현재 NavigationController는 없기 때문이다.StoryBoard로 가서 NavigationController를 Embeded 해주자.여기서 해도되고편한걸로 하자.상단에 NavigationBar Area가 생긴걸 알 수 있다.이걸 숨기기 위해서override func viewWillAppear(_ animated: Bool) {        super.viewWillAppear(animated)        navigationController?.setNavigationBarHidden(true, animated: false)            }    override func viewWillDisappear(_ animated: Bool) {        super.viewWillDisappear(animated)        navigationController?.setNavigationBarHidden(false, animated: false)    }이렇게 해주었다.HomeVC가 보일때는 NavigationBar를 숨기고, 사라질때 NavigationBar를 보이게 한다.그래야 CourseDetailVC에서 NavigationBar 가 보여서 back을 할 수 있기 때문UdemyBusiness 탭 이벤트 적용하기여기는 html링크가 있으므로 해당부분을 탭했을때 safari를 통해 홈페이지가 보여지게 하면 된다.먼저 함수를 하나 만들어준다.그리고 사파리를 사용하기 위해서import SafariServices 임포트 해주자.private func showSafariWebView(link: String) {        guard let url = URL(string: link) else { return }        navigationController?.pushViewController(SFSafariViewController(url: url), animated: true)    }case .udemyBusinessBanner(let id, let link):            showSafariWebView(link: link)print 대신 바꿔준다.현재 링크를 Udemy로 해두었는데 이렇게 바로 사이트로 연결되는걸 확인할 수 있다.Tab Event 정리현재 이렇게 Warning이 많기에 사용하지 않는 파라미터, 그리고 item들을 좀 정리한다.private func handleItemTapped(item: HomeUIModel.Item) {        switch item {        case .mainBanner:            break        case let .course(_, _, title, _, _, _, _, _):            showCourseDetailsViewcontroller(title: title)        case .textHeader:            break        case let .udemyBusinessBanner(_, link):            showSafariWebView(link: link)        case let .categoriesScroller(_, titles):            guard let title = titles.first else { return }            print(\"&gt;&gt;&gt; categoriesScroller tapped \\(title)\")        case .featuredCourse:            break        }    }warning들이 전부 사라졌다.case 바로 뒤에 let을 사용함으로써 파라미터안애서 변수를 만들지 않게 했다.case 뒤에 let을 붙이는 것과 파라미터에서 let을 붙이는 것은 패턴 매칭을 통해 값을 바인딩하는 위치와 방식에서 차이를 나타낸다.  case let을 사용하는 경우:          case 뒤에 let을 붙이면 한 번에 모든 값을 바인딩한다      각 변수에 let을 따로 붙이지 않고 더 간결하게 작성할 수 있다      패턴 매칭을 통해 케이스의 모든 값을 한꺼번에 처리한다      case let .udemyBusinessBanner(id, link): // 한 번에 모든 값을 바인딩        각 변수에 let을 붙이는 경우:          각 변수마다 let을 붙여서 개별적으로 바인딩한다      명시적으로 값을 바인딩하므로 어떤 값을 바인딩하는지 더 명확하게 표현한다      case let .udemyBusinessBanner(id, link): // 한 번에 모든 값을 바인딩      "
  },
  
  {
    "title": "Build the unofficial Udemy Home Screen (6)",
    "url": "/posts/Build-the-unofficial-Udemy-Home-Screen-(6)/",
    "categories": "Udemy",
    "tags": "",
    "date": "2024-10-12 06:13:00 +0900",
    





    
    "snippet": "다른 Course Swimlane을 추가코드는 생략이미지로 대체한다.HomeVC에서 내용을 추가, 수정했다.FeaturedCourseView 추가CourseView의 내용을 가져오되, tag만 지워준다.그리고 높이만 바꿔주었다.struct FeaturedCourseView: View {    let imageLink: String    let titl...",
    "content": "다른 Course Swimlane을 추가코드는 생략이미지로 대체한다.HomeVC에서 내용을 추가, 수정했다.FeaturedCourseView 추가CourseView의 내용을 가져오되, tag만 지워준다.그리고 높이만 바꿔주었다.struct FeaturedCourseView: View {    let imageLink: String    let title: String    let author: String    let rating: Double    let reviewCount: Int    let price: Decimal        var body: some View {        VStack(alignment: .leading, spacing: 4) {            AsyncImage(url: URL(string: imageLink)) { image in                image                    .resizable()                    .aspectRatio(contentMode: .fill)                    .frame(maxWidth: .infinity)                    .frame(height: 140)                    .border(Color.gray.opacity(0.3))                    .clipped()            } placeholder: {                PlaceholderImageView()                    .frame(height: 140)            }.padding(.bottom, 4)                        Text(title)                .font(.system(size: 12, weight: .bold, design: .default))                .fixedSize(horizontal: false, vertical: true)                .lineLimit(4)            Text(author)                .font(.system(size: 10, weight: .regular, design: .default))                .foregroundStyle(.gray)            ReviewRatingView(rating: rating, reviewCount: reviewCount)            Text(price.priceFormat)                .font(.system(size: 10, weight: .bold))            Spacer()        }    }}FeaturedCollectionViewCell 설정이전글 과 유사하므로 생략…한가지 새롭게 추가된거라면private func makeFeaturedCourseSection() -&gt; NSCollectionLayoutSection {                let itemSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .fractionalHeight(1.0))                let item = NSCollectionLayoutItem(layoutSize: itemSize)                let layoutSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .absolute(230))                let group = NSCollectionLayoutGroup.horizontal(            layoutSize: layoutSize,            subitems: [item])                group.interItemSpacing = NSCollectionLayoutSpacing.fixed(10)                let section = NSCollectionLayoutSection(group: group)        section.contentInsets = NSDirectionalEdgeInsets(top: 0, leading: 20, bottom: 20, trailing: 20)                return section    }group.interItemSpacing = NSCollectionLayoutSpacing.fixed(10)은 NSCollectionLayoutGroup 내의 아이템들 간의 간격을 고정된 간격으로 설정하는 코드이다.  group은 여러 아이템을 포함하는 그룹이며, 이 그룹 내에서 아이템들이 가로 또는 세로로 배치될 수 있다.  interItemSpacing은 이 그룹 안에서 각 아이템 간의 간격을 설정하는 속성이다. 여기서는 그룹 안에서의 아이템 간 간격을 지정하고 있다.  NSCollectionLayoutSpacing.fixed(10)는 고정된 10 포인트(pixels)의 간격을 의미한다. 즉, 그룹 내에서 각 아이템 사이에 10 포인트의 간격이 들어가게 된다.완성사진.UdemyBusinessView 추가struct UdemyBusinessView: View {    var onTap: (() -&gt; Void)?        var body: some View {        VStack(spacing: 20) {            Text(\"Top companies trust Udemy\")                .font(.system(size: 18, weight: .semibold, design: .serif))                .padding(.top, 16)            HStack(spacing: 40) {                UdemyBusinessIconView(systemName: \"apple.logo\")                UdemyBusinessIconView(systemName: \"shazam.logo.fill\")                UdemyBusinessIconView(systemName: \"playstation.logo\")            }                        Button {                self.onTap?()            } label: {                Text(\"Try Udemy Business\")                    .font(.system(size: 12, weight: .bold))            }            .tint(.indigo)            .padding(.bottom, 16)        }        .frame(maxWidth: .infinity)        .border(Color(uiColor: .systemGray), width: 1)    }}struct UdemyBusinessIconView: View {    let systemName: String        var body: some View {        Image(systemName: systemName)            .resizable()            .aspectRatio(contentMode: .fit)            .frame(width: 48, height: 48)            .foregroundStyle(Color(uiColor: .gray))    }    }뭐 크게 언급할 만한 내용은 없어보인다.UdemyBusinessCollectionViewCell 설정 및 추가여기서 하나 언급할만한건final class UdemyBusinessCollectionViewCell: UICollectionViewCell {    private var hostingController: UIHostingController&lt;UdemyBusinessView&gt;!        var onTap: (() -&gt; Void)?        override init(frame: CGRect) {        super.init(frame: frame)        layout()    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        private func layout() {        hostingController = UIHostingController(rootView: UdemyBusinessView())        addSubview(hostingController.view)        hostingController.view.clipsToBounds = true        hostingController.view.snp.makeConstraints { make in            make.edges.equalToSuperview()        }        hostingController.rootView.onTap = { [weak self] in            self?.onTap?()        }    }}case let .udemyBusinessBanner(_, link):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: UdemyBusinessCollectionViewCell.namedIdentifier, for: indexPath) as! UdemyBusinessCollectionViewCell                cell.onTap = {                    print(\"&gt;&gt;&gt;&gt;&gt; tapped on udemy Business \\(link)\")                }                return cell이 코드인데. 셀을 탭했을때의 이벤트를 핸들링 하기위해 클로저를 사용했다.var onTap: (() -&gt; Void)?  onTap은 클로저 타입으로 선언된 프로퍼티다. (() -&gt; Void)?는 매개변수가 없고 반환값도 없는 클로저를 의미하며, 이 클로저는 선택적으로 설정될 수 있기 때문에 Optional(?)로 선언되었다.  이 프로퍼티는 외부에서 해당 셀을 탭했을 때 수행할 동작을 정의하기 위해 사용된다.cell.onTap = {    print(\"&gt;&gt;&gt;&gt;&gt; tapped on udemy Business \\(link)\")}  collectionView에서 셀을 구성할 때, onTap 클로저에 특정 동작을 할당한다. 여기서는 탭을 하면 콘솔에 print문이 실행되도록 설정되었다.  이 코드는 셀을 탭했을 때 실행될 행동을 정의하며, 여기서는 해당 링크 정보(link)를 출력하는 기능을 담당한다.hostingController.rootView.onTap = { [weak self] in    self?.onTap?()}  UdemyBusinessView에서 정의된 onTap이라는 클로저가 실제로 트리거되는 부분이다. 이 클로저가 호출되면, UdemyBusinessCollectionViewCell의 onTap 프로퍼티에 할당된 클로저가 실행된다.  [weak self]는 메모리 누수를 방지하기 위해 사용된 약한 참조다. 이를 통해 클로저가 self를 강하게 참조하는 것을 방지하며, self가 해제되어도 강한 참조 순환이 일어나지 않도록 한다.순서  UICollectionView에서 셀을 설정할 때, UdemyBusinessCollectionViewCell의 onTap 클로저에 원하는 동작을 정의  UdemyBusinessCollectionViewCell 내부에서 UdemyBusinessView를 SwiftUI로 렌더링하고, rootView의 onTap 클로저에 셀의 onTap을 연결  UdemyBusinessView에서 사용자가 셀을 탭하면, SwiftUI 뷰의 onTap이 호출된다. 이 때, UdemyBusinessCollectionViewCell의 onTap 클로저가 트리거된다.  사용자가 탭했을 때, UdemyBusinessCollectionViewCell에서 설정된 onTap 클로저가 실행되고, 외부에서 설정된 동작(여기서는 print)이 수행된다.완성된 화면은 위와 같다.TapGestures 추가하기계속 추가를 하는것이기에 매커니즘은 같아서 하나만 예를 든다struct CategoriesView: View {    let titles: [String]        var midPoint: Int {        return Int(titles.count / 2)    }        var body: some View {        ScrollView(.horizontal, showsIndicators: false) {            LazyVStack(alignment: .leading, spacing: 8) {                HStack {                    ForEach(titles[..&lt;midPoint], id: \\.self) { title in                        CatgoryButton(title: title) {                            print(\"&gt;&gt;&gt;&gt; tapped: \\(title)\")                        }                                            }                }                                HStack {                    ForEach(titles[midPoint...], id: \\.self) { title in                        CatgoryButton(title: title) {                            print(\"&gt;&gt;&gt;&gt; tapped: \\(title)\")                        }                                            }                }            }            .padding(.horizontal, 20)        }    }}이렇게 버튼을 눌렀을때 print를 하던것을 onTap 프로퍼티를 만들어 대체한다.var onTap: ((String) -&gt; Void)?HStack {                    ForEach(titles[..&lt;midPoint], id: \\.self) { title in                        CatgoryButton(title: title) {                            onTap?(title)                        }                                            }                }여기는 Category의 title을 받기에 String을 파라미터로 밭지만, 이걸 제외하고 나머지는var onTap: (() -&gt; Void)? 이렇게 되어있다.final class CategoriesCollectionViewCell: UICollectionViewCell {        private var hostingController: UIHostingController&lt;CategoriesView&gt;!        var onTap: ((String) -&gt; Void)?        override init(frame: CGRect) {        super.init(frame: frame)    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        func configure(titles: [String]) {        guard hostingController == nil else { return }        let categoriesView = CategoriesView(titles: titles)        hostingController = UIHostingController(rootView: categoriesView)        addSubview(hostingController.view)        hostingController.view.clipsToBounds = true        hostingController.view.snp.makeConstraints { make in            make.edges.equalToSuperview()        }        hostingController.rootView.onTap = { [weak self] title in            self?.onTap?(title)        }    }}rootView가 categoriesView이기에 ontap에 대하여 실제로 트리거가 되게 설정을 한다.private func setupDataSource() {        diffableDataSource = UICollectionViewDiffableDataSource(collectionView: self, cellProvider: { collectionView, indexPath, item in            switch item {            case let .mainBanner(_, imageLink, title, caption):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: MainBannerCollectionViewCell.namedIdentifier, for: indexPath) as! MainBannerCollectionViewCell                cell.configure(imageLink: imageLink, title: title, caption: caption)                return cell            case let .textHeader(id, title, highlightedText):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: TextHeaderCollectionViewCell.namedIdentifier, for: indexPath) as! TextHeaderCollectionViewCell                cell.configure(text: title, highlightedText: highlightedText)                cell.onTap = {                    print(\"&gt;&gt;&gt; TextHeader link tapped: \\(id) - \\(highlightedText)\")                }                return cell            case let .course(id, imageLink, title, author, rating, reviewCount, price, tag):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CourseCollectionViewCell.namedIdentifier, for: indexPath) as! CourseCollectionViewCell                cell.configure(imageLink: imageLink, title: title, author: author, rating: rating, reviewCount: reviewCount, price: price, tag: tag)                cell.onTap = {                    print(\"&gt;&gt;&gt; course tapped: \\(id) - \\(title)\")                }                return cell            case let .categoriesScroller(_, titles):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CategoriesCollectionViewCell.namedIdentifier, for: indexPath) as! CategoriesCollectionViewCell                cell.configure(titles: titles)                cell.onTap = { title in                    print(\"&gt;&gt;&gt; category tapped is \\(title)\")                }                return cell            case let .featuredCourse(_, imageLink, title, author, rating, reviewCount, price):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: FeaturedCourseCollectionViewCell.namedIdentifier, for: indexPath) as! FeaturedCourseCollectionViewCell                cell.configure(imageLink: imageLink, title: title, author: author, rating: rating, reviewCount: reviewCount, price: price)                return cell            case let .udemyBusinessBanner(_, link):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: UdemyBusinessCollectionViewCell.namedIdentifier, for: indexPath) as! UdemyBusinessCollectionViewCell                cell.onTap = {                    print(\"&gt;&gt;&gt;&gt;&gt; tapped on udemy Business \\(link)\")                }                return cell            default :                fatalError()            }        })    }그리고 트리거가 되었을때에 대한 액션을 정의한다.지금은 print로 한다.struct FeaturedCourseView: View {    let imageLink: String    let title: String    let author: String    let rating: Double    let reviewCount: Int    let price: Decimal        var onTap: (() -&gt; Void)?        var body: some View {        VStack(alignment: .leading, spacing: 4) {            AsyncImage(url: URL(string: imageLink)) { image in                image                    .resizable()                    .aspectRatio(contentMode: .fill)                    .frame(maxWidth: .infinity)                    .frame(height: 140)                    .border(Color.gray.opacity(0.3))                    .clipped()            } placeholder: {                PlaceholderImageView()                    .frame(height: 140)            }.padding(.bottom, 4)                        Text(title)                .font(.system(size: 12, weight: .bold, design: .default))                .fixedSize(horizontal: false, vertical: true)                .lineLimit(4)            Text(author)                .font(.system(size: 10, weight: .regular, design: .default))                .foregroundStyle(.gray)            ReviewRatingView(rating: rating, reviewCount: reviewCount)            Text(price.priceFormat)                .font(.system(size: 10, weight: .bold))            Spacer()        }        .onTapGesture {            onTap?()        }    }}뷰 자체를 탭하는 경우.onTapGesture Modifier를 사용해준다.var onTap: (() -&gt; Void)?.onTapGesture {            onTap?()        }실행하면 이렇게 print 됨을 알 수 있다."
  },
  
  {
    "title": "Build the unofficial Udemy Home Screen (5)",
    "url": "/posts/Build-the-unofficial-Udemy-Home-Screen-(5)/",
    "categories": "Udemy",
    "tags": "",
    "date": "2024-10-12 05:13:00 +0900",
    





    
    "snippet": "CategoryTextHeader 추가.init(section: .textheader(id: \"1233332\"), body: [                .textHeader(id: \"1234fds\", text: \"Categories\", highlightedText: nil)이렇게 적어주면 Categories가 생긴다.CategoryView 추가모델...",
    "content": "CategoryTextHeader 추가.init(section: .textheader(id: \"1233332\"), body: [                .textHeader(id: \"1234fds\", text: \"Categories\", highlightedText: nil)이렇게 적어주면 Categories가 생긴다.CategoryView 추가모델링그전에 먼저 모델링을 해준다.enum Category: String, CaseIterable {    case development    case business    case officeProductivity    case healthAndFitness    case teachingAndAcademics    case financeAndAccounting    case itAndSoftware    case personalDevelopment    case marketing    case photographyAndVideo    case design    case lifestyle    case Music}이때 처음 보는것이 있다. 바로 CaseIterableCaseIterable은 Swift의 프로토콜로, enum 타입에 적용하여 해당 enum이 가지는 모든 케이스를 컬렉션처럼 순회할 수 있도록 해준다.즉, CaseIterable을 채택한 enum은 자동으로 allCases라는 배열 형태의 속성을 제공하며, 이를 통해 열거형의 모든 케이스에 접근할 수 있다.주요 기능:  자동으로 allCases 배열 제공: CaseIterable을 적용한 enum은 모든 케이스를 포함하는 allCases 배열을 자동으로 생성한다.  케이스 순회 가능: allCases 배열을 통해 for-in 루프를 사용하여 enum의 모든 케이스를 순회할 수 있다enum Category: String, CaseIterable {    case development    case business    case officeProductivity    case healthAndFitness    // 다른 케이스들...}for category in Category.allCases {    print(category.rawValue)}장점:  enum의 모든 케이스를 쉽게 관리하고 접근할 수 있다.  enum의 케이스 목록을 사용해 드롭다운 메뉴, 필터링 기능 등을 쉽게 구현할 수 있다.CategoryButton 만들기struct CatgoryButton: View {    let title: String    let onTap: (() -&gt; Void)?        var body: some View {        Button {            self.onTap?()        } label: {            Text(title)                .padding(.all, 12)                .font(.system(size: 10,weight: .semibold))                .foregroundStyle(.black)                .background(RoundedRectangle(cornerRadius: 20, style: .continuous).stroke(.black, lineWidth: 1.0))        }    }}카테고리 버튼을 만들어준다.CategoryView 만들기struct CategoriesView: View {    let titles: [String]        var midPoint: Int {        return Int(titles.count / 2)    }        var body: some View {        ScrollView(.horizontal, showsIndicators: false) {            LazyVStack(alignment: .leading, spacing: 8) {                HStack {                    ForEach(titles[..&lt;midPoint], id: \\.self) { title in                        CatgoryButton(title: title) {                            print(\"&gt;&gt;&gt;&gt; tapped: \\(title)\")                        }                                            }                }                                HStack {                    ForEach(titles[midPoint...], id: \\.self) { title in                        CatgoryButton(title: title) {                            print(\"&gt;&gt;&gt;&gt; tapped: \\(title)\")                        }                                            }                }            }        }    }}Lazy가 붙었는데 우리가 알고있는 그 Lazy가 맞다.필요로 하기전까지는 메모리에 상주시키지 않는다.이렇게 나온다.\\.self?\\.self는 Swift에서 ForEach와 같은 반복 구조에서 사용되는 키 경로(key path) 구문이다. 이는 Swift의 Identifiable 프로토콜을 따르지 않는 타입에서 고유한 값을 참조하기 위해 사용된다. 여기서는 String 배열의 각 요소가 반복문 내에서 고유하게 식별될 수 있도록, 해당 요소 자체를 식별자로 사용하겠다는 의미이다.  ForEach는 각 항목을 식별할 수 있는 값이 필요하다. titles 배열은 String 타입이므로, 문자열 자체로 각 항목을 고유하게 식별할 수 있다.  .self는 각 String 값 그 자체를 고유 식별자로 사용한다는 의미이다. 즉, 각 String이 해당 반복 항목의 ID로 사용된다.ForEach(titles[..&lt;midPoint], id: \\.self) { title in    CatgoryButton(title: title) {        print(\"&gt;&gt;&gt;&gt; tapped: \\(title)\")    }}여기서 id: .self는 ForEach가 각 title을 고유하게 식별할 수 있도록, title 그 자체를 ID로 사용하겠다는 의미이다. 각 title은 배열 내에서 고유하기 때문에 ForEach는 이를 사용해 아이템을 구분할 수 있다.정리:  .self는 그 값 자체를 고유 식별자로 사용한다는 의미이다.  이 구문은 값 타입이 Identifiable 프로토콜을 따르지 않는 경우에 주로 사용된다.  위 코드에서는 String 타입의 값 자체를 식별자로 사용하고 있다.CategoriesCollectionViewCell 추가이전에 했던것과 같은 방식이다.private var hostingController: UIHostingController&lt;CategoriesView&gt;!        override init(frame: CGRect) {        super.init(frame: frame)    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        func configure(titles: [String]) {        guard hostingController == nil else { return }        let categoriesView = CategoriesView(titles: titles)        hostingController = UIHostingController(rootView: categoriesView)        addSubview(hostingController.view)        hostingController.view.clipsToBounds = true        hostingController.view.snp.makeConstraints { make in            make.edges.equalToSuperview()        }            }패스.HomeCollectionView에 추가하기1. Cell 등록private func setup() {        register(MainBannerCollectionViewCell.self, forCellWithReuseIdentifier: MainBannerCollectionViewCell.namedIdentifier)        register(TextHeaderCollectionViewCell.self, forCellWithReuseIdentifier: TextHeaderCollectionViewCell.namedIdentifier)        register(CourseCollectionViewCell.self, forCellWithReuseIdentifier: CourseCollectionViewCell.namedIdentifier)        register(CategoriesCollectionViewCell.self, forCellWithReuseIdentifier: CategoriesCollectionViewCell.namedIdentifier)    }2. Datasource 추가private func setupDataSource() {        diffableDataSource = UICollectionViewDiffableDataSource(collectionView: self, cellProvider: { collectionView, indexPath, item in            switch item {            case let .mainBanner(_, imageLink, title, caption):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: MainBannerCollectionViewCell.namedIdentifier, for: indexPath) as! MainBannerCollectionViewCell                cell.configure(imageLink: imageLink, title: title, caption: caption)                return cell            case let .textHeader(_, title, highlightedText):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: TextHeaderCollectionViewCell.namedIdentifier, for: indexPath) as! TextHeaderCollectionViewCell                cell.configure(text: title, highlightedText: highlightedText)                return cell            case let .course(_, imageLink, title, author, rating, reviewCount, price, tag):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CourseCollectionViewCell.namedIdentifier, for: indexPath) as! CourseCollectionViewCell                cell.configure(imageLink: imageLink, title: title, author: author, rating: rating, reviewCount: reviewCount, price: price, tag: tag)                return cell            case let .categoriesScroller(_, titles):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CategoriesCollectionViewCell.namedIdentifier, for: indexPath) as! CategoriesCollectionViewCell                cell.configure(titles: titles)                return cell            default :                fatalError()            }        })    }3. Compositional Layout 설정private func makeCompositionalLayout() -&gt; UICollectionViewCompositionalLayout {                let provider: UICollectionViewCompositionalLayoutSectionProvider = { [weak self] index, env in                        guard let sectionModel = self?.uiModel?.sectionModels[index] else { return nil }                        switch sectionModel.section {            case .mainBanner:                return self?.makeMainBannerSection()            case .textheader:                guard case let .textHeader(_, text, _) = sectionModel.body.first else { return nil }                return self?.makeTextHeaderSection(text: text)            case .courseSwimlane:                return self?.makeCourseSwimlaneSection()            case .categories:                return self?.makeCategoriesSection()            default :                fatalError()            }        }        return UICollectionViewCompositionalLayout(sectionProvider: provider)    }4. makeCategoriesSection 함수 설정private func makeCategoriesSection() -&gt; NSCollectionLayoutSection {                let itemSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .fractionalHeight(1.0))                let item = NSCollectionLayoutItem(layoutSize: itemSize)                let layoutSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .absolute(88))                let group = NSCollectionLayoutGroup.horizontal(            layoutSize: layoutSize,            subitems: [item])                let section = NSCollectionLayoutSection(group: group)        section.interGroupSpacing = 10        section.contentInsets = NSDirectionalEdgeInsets(top: 0, leading: 0, bottom: 20, trailing: 0)                return section    }HomeVC에 데이터 추가override func viewDidLoad() {        super.viewDidLoad()        setupView()                let uiModel = HomeUIModel(sectionModels: [            .init(section:.mainBanner(id: \"123\"), body: [                .mainBanner(                    id: \"123\",                    imageLink: \"https://images.unsplash.com/photo-1627634777217-c864268db30c?q=80&amp;w=1740&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\", title: \"Some Title\",                    caption: \"some caption\")            ]),            .init(section: .textheader(id: \"2321\"), body: [                .textHeader(                    id: \"879\",                    text: \"Newest courses in Mobile Development\",                    highlightedText: \"Mobile Development\")            ]),            .init(section: .courseSwimlane(id: \"4432\"), body: [                .course(                    id: \"313123\",                    imageLink: \"https://picsum.photos/300/200\",                    title: \"iOs &amp; Swift: Server Driven UI Compositional Layout &amp; SwiftUI\",                    author: \"Kelvin Fok\",                    rating: 4.5,                    reviewCount: 224,                    price: 19.99,                    tag: \"BestSeller\"),                .course(                    id: \"313124\",                    imageLink: \"https://picsum.photos/300/200\",                    title: \"iOs &amp;z Swift: SwiftUI Mastery\",                    author: \"Kelvin Fok\",                    rating: 4.2,                    reviewCount: 224,                    price: 19.99,                    tag: \"BestSeller\"),                .course(                    id: \"313125\",                    imageLink: \"https://picsum.photos/300/200\",                    title: \"iOs &amp; Swift: AutoLayout\",                    author: \"Kelvin Fok\",                    rating: 3.5,                    reviewCount: 224,                    price: 19.99,                    tag: \"BestSeller\")            ]),            .init(section: .textheader(id: \"1233332\"), body: [                .textHeader(id: \"1234fds\", text: \"Categories\", highlightedText: nil)            ]),            .init(section: .categories(id: \"sdf1\"), body: [                .categoriesScroller(id: \"123444\", titles: Category.allCases.map({                    $0.rawValue.camelCaseToEnglish.useShortAndFormat.capitalized }))            ])        ])        collectionView.setupDataSource(uiModel: uiModel)    }카테고리 뷰가 너무 붙어있어서 패딩을 준다.struct CategoriesView: View {    let titles: [String]        var midPoint: Int {        return Int(titles.count / 2)    }        var body: some View {        ScrollView(.horizontal, showsIndicators: false) {            LazyVStack(alignment: .leading, spacing: 8) {                HStack {                    ForEach(titles[..&lt;midPoint], id: \\.self) { title in                        CatgoryButton(title: title) {                            print(\"&gt;&gt;&gt;&gt; tapped: \\(title)\")                        }                                            }                }                                HStack {                    ForEach(titles[midPoint...], id: \\.self) { title in                        CatgoryButton(title: title) {                            print(\"&gt;&gt;&gt;&gt; tapped: \\(title)\")                        }                                            }                }            }            .padding(.horizontal, 20) // added        }    }}완성.대부분 반복이라 크게 서술할건 없다."
  },
  
  {
    "title": "Build the unofficial Udemy Home Screen (4)",
    "url": "/posts/Build-the-unofficial-Udemy-Home-Screen-(4)/",
    "categories": "Udemy",
    "tags": "",
    "date": "2024-10-11 12:13:00 +0900",
    





    
    "snippet": "지금까지 빨간색 테두리로 된 부분을 만들었다.주황색 테두리가 이제 만들 CourseView이다.그전에 조금 수정을 한다.Textheader 간격주기private func makeMainBannerSection() -&gt; NSCollectionLayoutSection {                let itemSize = NSCollectionLa...",
    "content": "지금까지 빨간색 테두리로 된 부분을 만들었다.주황색 테두리가 이제 만들 CourseView이다.그전에 조금 수정을 한다.Textheader 간격주기private func makeMainBannerSection() -&gt; NSCollectionLayoutSection {                let itemSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .fractionalHeight(1.0))        let item = NSCollectionLayoutItem(layoutSize: itemSize)                let layoutSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .absolute(220))                let group = NSCollectionLayoutGroup.horizontal(            layoutSize: layoutSize,            subitems: [item])                let section = NSCollectionLayoutSection(group: group)        section.contentInsets = NSDirectionalEdgeInsets(top: 0, leading: 0, bottom: 20, trailing: 0)                return section    }return 으로 섹션을 바로 하던걸 인스턴스화 하였고, Insets를 주었다.그리고 노란색 배경도 지웠다. (이건 서술할 필요가 없을듯해서 생략)CourseView 추가우선 필요한 변수들을 만들어 준다.struct CourseView: View {    let imageLink: String    let title: String    let author: String    let rating: Double    let reviewCount: Int    let price: Decimal    let tag: String        var body: some View {        VStack(alignment: .leading, spacing: 4) {            AsyncImage(url: URL(string: imageLink)) { image in                image                    .resizable()                    .aspectRatio(contentMode: .fill)                    .frame(maxWidth: .infinity)                    .frame(height: 64)                    .border(Color.gray.opacity(0.3))                    .clipped()            } placeholder: {                PlaceholderImageView()                    .frame(height: 64)            }.padding(.bottom, 4)                        Text(title)                .font(.system(size: 12, weight: .bold, design: .default))                .fixedSize(horizontal: false, vertical: true)            Text(author)                .font(.system(size: 10, weight: .regular, design: .default))                .foregroundStyle(.gray)        }    }}크게 언급할만한건 없는듯 하다.이렇게 나온다.ReviewRaingView 만들기struct ReviewRatingView: View {    let rating: Double    let reviewCount: Int    var body: some View {        HStack(spacing: 4, content: {            Text(rating.description)                .foregroundStyle(.orange)                .font(.system(size: 10, weight: .semibold))            Image(systemName: \"star.fill\")                .resizable()                .aspectRatio(contentMode: .fit)                .frame(height: 10)                .foregroundStyle(.yellow)            Text(reviewCount.formatted())                .foregroundStyle(.gray)                .font(.system(size: 10))        })    }}이때 rating은 Dount, reviewCount는 Int인데 Text는 String을 받는다.그래서 Rating은 Description을 통해 String으로 전환 해주었다.그리고 count의 경우는 formatted를 사용하여 String으로 형변환을 함과 동시에 default 숫자 설정을 따르게 했다.그리고 extension을 사용했는데extension String {    var withBrackets: String {        String(format: \"(%@)\", self)    }}숫자 뒤에 괄호로 감싸주기 위함이다.이렇게 리뷰쪽에 관한 부분도 만들었다.CourseView 마무리VStack(alignment: .leading, spacing: 4) {            AsyncImage(url: URL(string: imageLink)) { image in                image                    .resizable()                    .aspectRatio(contentMode: .fill)                    .frame(maxWidth: .infinity)                    .frame(height: 64)                    .border(Color.gray.opacity(0.3))                    .clipped()            } placeholder: {                PlaceholderImageView()                    .frame(height: 64)            }.padding(.bottom, 4)                        Text(title)                .font(.system(size: 12, weight: .bold, design: .default))                .fixedSize(horizontal: false, vertical: true)            Text(author)                .font(.system(size: 10, weight: .regular, design: .default))                .foregroundStyle(.gray)            ReviewRatingView(rating: rating, reviewCount: reviewCount)            Text(price.priceFormat)                .font(.system(size: 10, weight: .bold))            Text(tag)                .font(.system(size: 10, weight: .semibold))                .padding(EdgeInsets(top: 4, leading: 8, bottom: 4, trailing: 8))                .background(content: {                    RoundedRectangle(cornerRadius: 2)                        .fill(Color.yellow.opacity(0.4))                })            Spacer()이때 Price가 Decimal인데, Decimal에 대한 extension을 또 하나 만들어 준다.extension Decimal {    var priceFormat: String {        let formatter = NumberFormatter()        formatter.numberStyle = .currency        formatter.locale = Locale(identifier: \"en_US\")        return formatter.string(from: self as NSDecimalNumber) ?? String(describing: self)    }}이건 금액앞에 통화 단위를 붙여주게 된다. 현재는 locale을 en_US로 했기에 달러로 나올것이다.이렇게 CourseView가 완성이 되었다.CourseCollectionViewCell 추가하기final class CourseCollectionViewCell: UICollectionViewCell {    private var hostingController: UIHostingController&lt;CourseView&gt;!        override init(frame: CGRect) {        super.init(frame: frame)        backgroundColor = .gray    }    required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        func configure(        imageLink: String,        title: String,        author: String,        rating: Double,        reviewCount: Int,        price: Decimal,        tag: String    ) {        guard hostingController == nil else { return }        let courseView = CourseView(            imageLink: imageLink,            title: title,            author: author,            rating: rating,            reviewCount: reviewCount,            price: price,            tag: tag        )        hostingController = UIHostingController(rootView: courseView)        addSubview(hostingController.view)        hostingController.view.clipsToBounds = true        hostingController.view.snp.makeConstraints { make in            make.edges.equalToSuperview()        }    }    }CourseSwimLane 추가하기우선 HomeCollectionView에 셀을 등록해준다.private func setup() {        register(MainBannerCollectionViewCell.self, forCellWithReuseIdentifier: MainBannerCollectionViewCell.namedIdentifier)        register(TextHeaderCollectionViewCell.self, forCellWithReuseIdentifier: TextHeaderCollectionViewCell.namedIdentifier)        register(CourseCollectionViewCell.self, forCellWithReuseIdentifier: CourseCollectionViewCell.namedIdentifier)    }그리고 셀에 대한 데이터 소스를 추가private func setupDataSource() {        diffableDataSource = UICollectionViewDiffableDataSource(collectionView: self, cellProvider: { collectionView, indexPath, item in            switch item {            case let .mainBanner(_, imageLink, title, caption):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: MainBannerCollectionViewCell.namedIdentifier, for: indexPath) as! MainBannerCollectionViewCell                cell.configure(imageLink: imageLink, title: title, caption: caption)                return cell            case let .textHeader(_, title, highlightedText):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: TextHeaderCollectionViewCell.namedIdentifier, for: indexPath) as! TextHeaderCollectionViewCell                cell.configure(text: title, highlightedText: highlightedText)                return cell            case let .course(_, imageLink, title, author, rating, reviewCount, price, tag):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CourseCollectionViewCell.namedIdentifier, for: indexPath) as! CourseCollectionViewCell                cell.configure(imageLink: imageLink, title: title, author: author, rating: rating, reviewCount: reviewCount, price: price, tag: tag)                return cell            default :                fatalError()            }        })    }이후 컴포지셔널 레이아웃을 관리하는 함수에도 추가를 해준다private func makeCompositionalLayout() -&gt; UICollectionViewCompositionalLayout {                let provider: UICollectionViewCompositionalLayoutSectionProvider = { [weak self] index, env in                        guard let sectionModel = self?.uiModel?.sectionModels[index] else { return nil }                        switch sectionModel.section {            case .mainBanner:                return self?.makeMainBannerSection()            case .textheader:                guard case let .textHeader(_, text, _) = sectionModel.body.first else { return nil }                return self?.makeTextHeaderSection(text: text)            case .courseSwimlane:                return self?.makeCourseSwimlaneSection()            default :                fatalError()            }        }        return UICollectionViewCompositionalLayout(sectionProvider: provider)    }   makeCourseSwimlaneSection 함수 만들기private func makeCourseSwimlaneSection() -&gt; NSCollectionLayoutSection {                let itemSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .fractionalHeight(1.0))        let item = NSCollectionLayoutItem(layoutSize: itemSize)                let layoutSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(160),            heightDimension: .fractionalHeight(200))                let group = NSCollectionLayoutGroup.horizontal(            layoutSize: layoutSize,            subitems: [item])                let section = NSCollectionLayoutSection(group: group)        section.interGroupSpacing = 10        section.contentInsets = NSDirectionalEdgeInsets(top: 0, leading: 20, bottom: 20, trailing: 20)        section.orthogonalScrollingBehavior = .continuous                return section    }HomeVC에 내용 추가override func viewDidLoad() {        super.viewDidLoad()        setupView()                let uiModel = HomeUIModel(sectionModels: [            .init(section:.mainBanner(id: \"123\"), body: [                .mainBanner(                    id: \"123\",                    imageLink: \"https://images.unsplash.com/photo-1627634777217-c864268db30c?q=80&amp;w=1740&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\", title: \"Some Title\",                    caption: \"some caption\")            ]),            .init(section: .textheader(id: \"2321\"), body: [                .textHeader(                    id: \"879\",                    text: \"Newest courses in Mobile Development\",                    highlightedText: \"Mobile Development\")            ]),            .init(section: .courseSwimlane(id: \"321\"), body: [                .course(                    id: \"313123\",                    imageLink: \"https://picsum.photos/300/200\",                        title: \"iOs &amp; Swift: Server Driven UI Compositional Layout &amp; SwiftUI\",                        author: \"Kelvin Fok\",                        rating: 4.5,                        reviewCount: 224,                        price: 19.99,                        tag: \"BestSeller\"),                .course(                    id: \"313124\",                    imageLink: \"https://picsum.photos/300/200\",                        title: \"iOs &amp; Swift: Server Driven UI Compositional Layout &amp; SwiftUI\",                        author: \"Kelvin Fok\",                        rating: 4.5,                        reviewCount: 224,                        price: 19.99,                        tag: \"BestSeller\"),                .course(                    id: \"313125\",                    imageLink: \"https://picsum.photos/300/200\",                        title: \"iOs &amp; Swift: Server Driven UI Compositional Layout &amp; SwiftUI\",                        author: \"Kelvin Fok\",                        rating: 4.5,                        reviewCount: 224,                        price: 19.99,                        tag: \"BestSeller\")        ])            ])        collectionView.setupDataSource(uiModel: uiModel)    }하지만 문제가 발생했다.이미지쪽에서 문제가 발생했다.주소가 틀리지 않았음에도 로드가 안되는 문제가 발생CourseView의 Preview에서는 제대로 나오기에 다른부분이 문제가 생긴듯하다.문제를 찾았다private func makeCourseSwimlaneSection() -&gt; NSCollectionLayoutSection {                let itemSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .fractionalHeight(1.0))        let item = NSCollectionLayoutItem(layoutSize: itemSize)                let layoutSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(160), // cause             heightDimension: .fractionalHeight(200)) // cause                let group = NSCollectionLayoutGroup.horizontal(            layoutSize: layoutSize,            subitems: [item])                let section = NSCollectionLayoutSection(group: group)        section.interGroupSpacing = 10        section.contentInsets = NSDirectionalEdgeInsets(top: 0, leading: 20, bottom: 20, trailing: 20)        section.orthogonalScrollingBehavior = .continuous                return section    }바로 저기가 문제였던것….이전글에 너무 간단하게 적은것 같아 여기에 조금더 설명을 덧붙인다.Fractional Width &amp; HeightfractionalWidth와 fractionalHeight는 UICollectionViewCompositionalLayout에서 레이아웃 아이템의 크기를 설정할 때 사용하는 NSCollectionLayoutDimension 클래스의 메서드이다.이들은 각각 부모 뷰의 크기에 대한 비율로 아이템의 너비와 높이를 설정하는 방식이다.fractionalWidthfractionalWidth는 부모 요소(상위 그룹이나 섹션)의 너비에 대한 비율로 아이템의 너비를 결정한다.fractionalHeightfractionalHeight는 부모 요소의 높이에 대한 비율로 아이템의 높이를 설정한다.let itemSize = NSCollectionLayoutSize(    widthDimension: .fractionalWidth(1.0), // 부모의 100% 너비    heightDimension: .fractionalHeight(0.3) // 부모의 30% 높이)부모 요소가 무엇인지?fractionalWidth와 fractionalHeight에서 말하는 부모 요소는 레이아웃에 따라 다르다.  아이템의 부모 요소는 그룹이다.  그룹의 부모 요소는 섹션이다.  섹션의 부모 요소는 컬렉션 뷰 전체이다.따라서, fractionalWidth(0.5)를 설정하면 해당 아이템이 속한 그룹의 너비에 대해 50% 크기를 가진다는 의미이다.장점이 방식의 장점은 부모의 크기에 상대적인 비율로 아이템 크기를 정의할 수 있어, 다양한 화면 크기에서도 유연하게 레이아웃을 맞출 수 있다는 점이다. 아이폰, 아이패드처럼 화면 크기가 다른 기기에서도 레이아웃이 자동으로 조정된다.let itemSize = NSCollectionLayoutSize(    widthDimension: .fractionalWidth(0.5), // 그룹의 50% 너비    heightDimension: .fractionalHeight(1.0) // 그룹의 100% 높이)let item = NSCollectionLayoutItem(layoutSize: itemSize)let groupSize = NSCollectionLayoutSize(    widthDimension: .fractionalWidth(1.0), // 섹션의 100% 너비    heightDimension: .absolute(200) // 절대 높이 200)let group = NSCollectionLayoutGroup.horizontal(layoutSize: groupSize, subitems: [item])다시 돌아와서 실행을 하면잘 된다.Xcode가 새롭게 업데이트되면서 자동완성을 나도모르게 남발해서 생긴 문제였다."
  },
  
  {
    "title": "Build the unofficial Udemy Home Screen (3)",
    "url": "/posts/Build-the-unofficial-Udemy-Home-Screen-(3)/",
    "categories": "Udemy",
    "tags": "",
    "date": "2024-10-10 12:13:00 +0900",
    





    
    "snippet": "이전에 Background Color를 Green으로 했던걸 지워준다.private func setup() {        register(MainBannerCollectionViewCell.self, forCellWithReuseIdentifier: MainBannerCollectionViewCell.namedIdentifier)    }TextHe...",
    "content": "이전에 Background Color를 Green으로 했던걸 지워준다.private func setup() {        register(MainBannerCollectionViewCell.self, forCellWithReuseIdentifier: MainBannerCollectionViewCell.namedIdentifier)    }TextHeaderCollectionViewCell 세팅final class TextHeaderCollectionViewCell: UICollectionViewCell {        private let label = AttributedTappableLabel()        override init (frame: CGRect) {        super.init(frame: frame)        layout()    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        func configure(text: String, highlightedText: String?) {        label.setAttributedText(text: text,                                highlightedText: highlightedText,                                color: .systemIndigo,                                font: .systemFont(ofSize: 18, weight: .bold)        )    }        private func layout() {        addSubview(label)        label.snp.makeConstraints { make in            make.edges.equalToSuperview()        }                label.onTap = {            print(\"&gt;&gt;&gt;&gt;&gt; tapped\")        }    }    }뭐 딱히 서술할게 없어 보인다.HomeCollectionView에 통합하기private func setup() {        register(MainBannerCollectionViewCell.self, forCellWithReuseIdentifier: MainBannerCollectionViewCell.namedIdentifier)        register(TextHeaderCollectionViewCell.self, forCellWithReuseIdentifier: TextHeaderCollectionViewCell.namedIdentifier) // new    }우선 위에 만들어둔 셀을 등록을 해준다.private func setupDataSource() {        diffableDataSource = UICollectionViewDiffableDataSource(collectionView: self, cellProvider: { collectionView, indexPath, item in            switch item {            case let .mainBanner(_, imageLink, title, caption):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: MainBannerCollectionViewCell.namedIdentifier, for: indexPath) as! MainBannerCollectionViewCell                cell.configure(imageLink: imageLink, title: title, caption: caption)                return cell            case let .textHeader(_, title, highlightedText):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: TextHeaderCollectionViewCell.namedIdentifier, for: indexPath) as! TextHeaderCollectionViewCell                cell.configure(text: title, highlightedText: highlightedText)                return cell                default :                fatalError()            }        })    }TextHeader인 경우를 추가하여 셀을 새로 구성해주자.그리고 HeaderSection을 만들어주는 함수도 만든다.private func makeTextHeaderSection() -&gt; NSCollectionLayoutSection {                let itemSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .fractionalHeight(1.0))                let item = NSCollectionLayoutItem(layoutSize: itemSize)                let layoutSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .absolute(120))                let group = NSCollectionLayoutGroup.horizontal(            layoutSize: layoutSize,            subitems: [item]        )                let section = NSCollectionLayoutSection(group: group)                let section = NSCollectionLayoutSection(group: group)        section.contentInsets = NSDirectionalEdgeInsets(top: 0, leading: 20, bottom: 8, trailing: 20)        return section    }관련 내용은 이전글 에 서술했으니 참고할 것.새롭게 추가된 부분이라면 Insets을 주었다.  Padding이라고 생각하면 될듯.HomeVC 세팅override func viewDidLoad() {        super.viewDidLoad()        setupView()                let uiModel = HomeUIModel(sectionModels: [            .init(section:.mainBanner(id: \"123\"), body: [                .mainBanner(                    id: \"123\",                    imageLink: \"https://images.unsplash.com/photo-1627634777217-c864268db30c?q=80&amp;w=1740&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\", title: \"Some Title\",                    caption: \"some caption\")            ]),            .init(section: .textheader(id: \"2321\"), body: [                .textHeader(                    id: \"879\",                    text: \"Newest courses in Mobile Development\",                    highlightedText: \"Mobile Development\") // added            ])        ])        collectionView.setupUIModel(uiModel: uiModel)    }이렇게 추가가 된걸 알 수 있다.Tap 부분 문제해결원래는 layout 함수에서 레입르을 탭했을때 콘솔에 출력이 되어야하는데 되지 않았다.그부분을 해결하려고 한다.먼저 정확하게 label의 영역이 어디인지를 식별 하기 위해 배경화면을 임의로 정해줄 것이다.func configure(text: String, highlightedText: String?) {        label.setAttributedText(text: text,                                highlightedText: highlightedText,                                color: .systemIndigo,                                font: .systemFont(ofSize: 18, weight: .bold))        label.backgroundColor = .yellow // added    }확인 완료.실제로 영역 안에서 클릭을 해보면 되는부분이 있고 안되는 부분이 있다.AttributedTappableLabel 로 가서 문제를 확인하면 된다.func setAttributedText(text: String, highlightedText: String?, color: UIColor = .black, font: UIFont = .systemFont(ofSize: 18, weight: .bold)) {    let attributedString = NSMutableAttributedString(string: text)        // Check if highlighted string is provided    if let highlighted = highlightedText {      // Find the range of the highlighted part      let range = (text as NSString).range(of: highlighted)            // Apply the color to the range      attributedString.addAttribute(.foregroundColor, value: color, range: range)    }        attributedString.addAttribute(.font, value: font, range: NSRange(location: 0, length: text.count))        self.attributedText = attributedString    self.tapRange = (text as NSString?)?.range(of: highlightedText ?? \"\") // modified    self.labelFont = font  }tapRange에서 highlightedText를 text로 바꿔준다.  highlightedText의 범위 찾기:          (text as NSString).range(of: highlightedText ?? “”) 코드를 통해 text 내에서 highlightedText가 위치한 범위를 찾는다. 이 범위는 NSRange 타입으로 저장된다.      이 범위는 tapRange에 할당되어 나중에 어떤 특정한 텍스트 부분이 터치되었는지 확인할 수 있게 한다.      TextHeader의 높이를 동적으로 조절하게 세팅private func makeTextHeaderSection(        text: String,        highlightedText: String?    ) -&gt; NSCollectionLayoutSection {                let itemSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .fractionalHeight(1.0))                let item = NSCollectionLayoutItem(layoutSize: itemSize)                let label = AttributedTappableLabel()        label.setAttributedText(text: text, highlightedText: highlightedText)        let height = label.heightForWidth(frame.size.width)                let layoutSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .absolute(height))                let group = NSCollectionLayoutGroup.horizontal(            layoutSize: layoutSize,            subitems: [item]        )                let section = NSCollectionLayoutSection(group: group)        section.contentInsets = NSDirectionalEdgeInsets(top: 0, leading: 20, bottom: 8, trailing: 20)                return section    }label을 추가해 주었고, setAttributedText에는 text, highlightedText를 파라미터로 받기에함수에서 그걸 파라미터로 받아서 label에 전달하도록 바꿔주었다.그리고 height를 설정해주는데함수는 다음과 같다func heightForWidth(_ width: CGFloat) -&gt; CGFloat {    guard let font = labelFont, let text = text else { return 0 }        let size = CGSize(width: width, height: .greatestFiniteMagnitude)    let boundingRect = NSString(string: text).boundingRect(      with: size,      options: .usesLineFragmentOrigin,      attributes: [NSAttributedString.Key.font: font],      context: nil    )    let safePadding: CGFloat = 4    return boundingRect.height + safePadding  }  labelFont와 text 확인:          labelFont와 text가 모두 존재하는지 확인한다. 둘 중 하나라도 없으면 0을 반환한다.        CGSize 설정:          계산할 크기를 나타내는 CGSize를 설정한다. 여기서 너비는 함수로 전달된 값이고, 높이는 .greatestFiniteMagnitude를 사용)하여 매우 큰 값으로 설정된다. 이는 텍스트가 높이 제한 없이 얼마만큼의 공간을 차지하는지 계산하기 위함이다.        boundingRect를 사용한 높이 계산:          NSString의 boundingRect(with:options:attributes:context: 메서드를 사용하여 텍스트가 주어진 너비에서 차지하는 실제 크기를 계산한다. 이 메서드는 텍스트가 주어진 CGSize 내에서 어느 정도의 공간을 차지하는지 CGRect로 반환한다.      attributes에는 폰트 정보가 포함되어 있으며, 이를 바탕으로 텍스트의 높이를 정확히 계산한다.        safePadding 추가:          safePadding은 기본적으로 4포인트의 여유 공간을 추가하여, 텍스트가 너무 꽉 차 보이지 않도록 한다.        최종 높이 반환:          계산된 boundingRect.height에 safePadding을 더한 값을 반환하여, 레이블이 주어진 너비에 맞는 높이를 계산한다.      그리고 CompositionalLayout 함수도 바꿔준다.private func makeCompositionalLayout() -&gt; UICollectionViewCompositionalLayout {                let provider: UICollectionViewCompositionalLayoutSectionProvider = { [weak self] index, env in                        guard let sectionModel = self?.uiModel?.sectionModels[index] else { return nil }                        switch sectionModel.section {            case .mainBanner:                return self?.makeBannerSection()            case .textheader:                guard case let .textHeader(_, text, highlightedText) = sectionModel.body.first else { return nil }                return self?.makeTextHeaderSection(text: text, highlightedText: highlightedText)            default :                fatalError()            }        }        return UICollectionViewCompositionalLayout(sectionProvider: provider)    }레이블의 범위가 줄어들었음을 알 수 있다.그리고 case 뒤에 .이 붙는 이유는 case 뒤에 .mainBanner, .textHeader와 같은 구문에서 enum 타입이 생략된 것이다. Swift는 패턴 매칭 시, enum의 타입이 명시적으로 확인 가능한 경우 case .value로 작성할 수 있다. 여기서 생략된 것은 enum 타입의 이름이다.  enum 타입:          HomeUIModel.Item 또는 HomeUIModel.Section과 같은 enum 타입에서 정의된 케이스들(예: .mainBanner, .textHeader)이다. Swift에서는 타입이 명확하게 추론될 수 있는 경우 enum 타입을 생략할 수 있다.        생략된 부분:          생략된 부분은 HomeUIModel.Item이다.      예를 들어, HomeUIModel.Item.mainBanner와 같이 타입 이름을 포함할 수 있지만, Swift의 문맥에서 타입이 명확하기 때문에 case .mainBanner로 작성 가능하다.        Swift의 타입 추론:          diffableDataSource는 UICollectionViewDiffableDataSource&lt;HomeUIModel.Section, HomeUIModel.Item&gt;로 정의되어 있으므로, Swift는 item이 HomeUIModel.Item 타입이라는 것을 알고 있다. 따라서 case 구문에서 enum 타입을 생략하고 .mainBanner, .textHeader와 같이 간결하게 작성할 수 있다.      리팩토링heightForWidth 함수를 좀 더 다른데서도 사용하기 위해 static을 붙여준다.static func heightForWidth(    _ width: CGFloat,    font: UIFont = .systemFont(ofSize: 18, weight: .bold),    text: String) -&gt; CGFloat {        let size = CGSize(width: width, height: .greatestFiniteMagnitude)    let boundingRect = NSString(string: text).boundingRect(      with: size,      options: .usesLineFragmentOrigin,      attributes: [NSAttributedString.Key.font: font],      context: nil    )    let safePadding: CGFloat = 4    return boundingRect.height + safePadding  }그리고 makeTextHeaderSection함수도 바꿔준다.private func makeTextHeaderSection(        text: String    ) -&gt; NSCollectionLayoutSection {                let itemSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .fractionalHeight(1.0))                let item = NSCollectionLayoutItem(layoutSize: itemSize)        let layoutSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .absolute(AttributedTappableLabel.heightForWidth(frame.size.width, text: text)))                let group = NSCollectionLayoutGroup.horizontal(            layoutSize: layoutSize,            subitems: [item]        )                let section = NSCollectionLayoutSection(group: group)        section.contentInsets = NSDirectionalEdgeInsets(top: 0, leading: 20, bottom: 8, trailing: 20)                return section    }height와 label 변수가 사라졌다.그리고 파라미터로 받던 highlightedText도 지워주었다.대신 높이를 조절하는 heightDimension에 absolute안에 있던 파라미터값이 120이었던가 그랬는데 그것을 높이를 동적으로 조절하기위해 바꿔준다.label객체를 만든것도 그런의미 였는데 이젠 static으로 선언했기에 그냥 사용이 가능.작동사진은 어차피 그대로기에 패스!"
  },
  
  {
    "title": "Build the unofficial Udemy Home Screen (2)",
    "url": "/posts/Build-the-unofficial-Udemy-Home-Screen-(2)/",
    "categories": "Udemy",
    "tags": "",
    "date": "2024-10-10 12:13:00 +0900",
    





    
    "snippet": "MainBannerCollectionViewCell 추가하기이 파일은 View에 있지만, SwiftUI를 import 해주었다.  import SwiftUI를 하게되면 UIkit 을 별도로 import를 해야하나?                이렇게 Definition을 보게되면 SwiftUI안에 UIKit을 이미 import한게 내장이 되어있다는걸 알...",
    "content": "MainBannerCollectionViewCell 추가하기이 파일은 View에 있지만, SwiftUI를 import 해주었다.  import SwiftUI를 하게되면 UIkit 을 별도로 import를 해야하나?                이렇게 Definition을 보게되면 SwiftUI안에 UIKit을 이미 import한게 내장이 되어있다는걸 알 수 있다. 즉 import를 할 필요가 없다.      Swift Style Guide에 코드 컨벤션 관련한 내용이 있으니 한번 확인해보자.import SwiftUIfinal class MainBannerCollectionViewCell: UICollectionViewCell {        private var hostingController: UIHostingController&lt;MainBannerView&gt;!        func configure(        imageLink: String,        title: String,        caption: String)    {        guard hostingController == nil else { return }        let mainBannerView = MainBannerView(imageLink: imageLink, title: title, caption: caption)        hostingController = UIHostingController(rootView: mainBannerView)        guard let hostingController = hostingController else { return }        addSubview(hostingController.view)        hostingController.view.clipsToBounds = true        hostingController.view.snp.makeConstraints { make in            make.edges.equalToSuperview()        }    }}여기서 새로운건 바로 Hosting Controller라는 녀석이다.참고글도 읽어보면 좋을듯.간단하게 정의를 하면 UIKit에서 SwiftUI View를 사요하고 싶을때 쓴다고 보면 될듯.이부분은 생소할수 있으니 조금 더 살펴보기로 하면,  configure 함수에서의 guard hostingController == nil else { return }          hostingController가 이미 초기화되었으면(즉, 해당 셀이 재사용될 때) 다시 초기화하지 않도록 guard 문을 통해 보호한다.        hostingController = UIHostingController(rootView: mainBannerView)          MainBannerView(imageLink:title:caption:)를 통해 새로운 SwiftUI 뷰를 생성하고, 이를 UIHostingController의 rootView로 설정한다.        addSubview(hostingController.view)          UIHostingController의 뷰를 UICollectionViewCell의 서브뷰로 추가한다. 이때, SwiftUI 뷰가 UIView 계층 구조에 들어간다.      MainBannerCollectionViewCell을 CollectionView에 추가하기DiffableDataSource 세팅여기선 DiffableDataSource를 사용했다.private var diffableDataSource: UICollectionViewDiffableDataSource&lt;HomeUIModel.Section, HomeUIModel.Item&gt;!func setupUIModel(uiModel: HomeUIModel) {        self.uiModel = uiModel        self.applySnapshot()    }먼저 diffableDataSource 객체를 생성해준다.이때 디퍼블에 들어가는 속성은 반드시 Hashable Protocol을 따라야 한다.그 다음 안에 들어가는건 섹션과, 아이템이다.UICollectionViewDiffableDataSource&lt;HomeUIModel.Section, HomeUIModel.Item&gt;이렇게 객체 생성을 하고난 뒤에는 Datasource를 관리하는 함수를 만든다.CellforRowAt과 유사하다고 생각하면 될듯.private func setupDataSource() {        diffableDataSource = UICollectionViewDiffableDataSource(collectionView: self, cellProvider: { collectionView, indexPath, item in            switch item {            case let .mainBanner(_, imageLink, title, caption):                let cell = collectionView.dequeueReusableCell(withReuseIdentifier: MainBannerCollectionViewCell.namedIdentifier, for: indexPath) as! MainBannerCollectionViewCell                cell.configure(imageLink: imageLink, title: title, caption: caption)                return cell                default :                fatalError()            }        })    }  UICollectionViewDiffableDataSource 생성:          diffableDataSource는 컬렉션 뷰에 데이터를 제공하는 데이터 소스다.      셀을 생성하는 역할을 담당하는 클로저(cellProvider)가 전달된다.        cellProvider 클로저:          collectionView, indexPath, item을 매개변수로 받아, 적절한 셀을 반환하는 역할을 한다.      switch문에서 item의 타입을 검사하고, MainBannerCollectionViewCell이 필요할 때 이를 생성하고 구성한다.        MainBannerCollectionViewCell 설정:          dequeueReusableCell 메서드를 사용해 셀을 재사용 큐에서 가져온 후, configure(imageLink:title:caption:) 메서드를 호출해 셀의 내용을 구성한다.      그다음은 스냅샷을 적용.private func applySnapshot() {        var snapshot = NSDiffableDataSourceSnapshot&lt;HomeUIModel.Section, HomeUIModel.Item&gt;()        uiModel?.sectionModels.forEach({ sectionModel in            snapshot.appendSections([sectionModel.section])            snapshot.appendItems(sectionModel.body, toSection: sectionModel.section)        })        diffableDataSource.apply(snapshot, animatingDifferences: false)    }  스냅샷 생성:          NSDiffableDataSourceSnapshot&lt;HomeUIModel.Section, HomeUIModel.Item&gt;()로 새로운 스냅샷을 생성한다. 스냅샷은 컬렉션 뷰의 섹션과 아이템을 나타내는 데이터 구조이다.        섹션 및 아이템 추가:          sectionModels 배열을 반복하며, 각 섹션을 스냅샷에 추가한다.      snapshot.appendSections([sectionModel.section])로 각 섹션을 추가하고, snapshot.appendItems(sectionModel.body, toSection: sectionModel.section)로 해당 섹션에 속하는 아이템들을 추가한다.        스냅샷 적용:          diffableDataSource.apply(snapshot, animatingDifferences: false)를 통해 스냅샷을 데이터 소스에 적용한다. animatingDifferences: false는 애니메이션 없이 스냅샷이 적용되도록 설정한 것이다.      Compositional Layout 세팅private func makeCompositionalLayout() -&gt; UICollectionViewCompositionalLayout {                let provider: UICollectionViewCompositionalLayoutSectionProvider = { [weak self] index, env in                        guard let sectionModel = self?.uiModel?.sectionModels[index] else { return nil }                        switch sectionModel.section {            case .mainBanner:                return self?.makeBannerSection()                            default :                fatalError()            }        }        return UICollectionViewCompositionalLayout(sectionProvider: provider)    }  UICollectionViewCompositionalLayoutSectionProvider를 사용해 각각의 섹션에 맞는 레이아웃을 동적으로 반환하게 한다.  UICollectionViewCompositionalLayout 생성:          makeCompositionalLayout() 함수는 UICollectionViewCompositionalLayout을 반환한다. 이는 컬렉션 뷰의 레이아웃을 정의하는 역할을 한다.      UICollectionViewCompositionalLayoutSectionProvider는 컬렉션 뷰의 각 섹션에 맞는 레이아웃을 제공하는 클로저 형태의 제공자다.        SectionProvider 클로저:          sectionProvider 클로저는 index와 env (환경 설정)를 매개변수로 받는다.      uiModel의 sectionModels 배열에서 해당 섹션을 가져와, 그 섹션에 맞는 레이아웃을 반환한다.      섹션이 mainBanner일 경우, makeBannerSection() 함수를 호출해 배너 레이아웃을 반환한다.      이외의 섹션이 들어오면 fatalError()를 호출해 프로그램이 중단되도록 한다. 이는 예상치 못한 섹션이 포함될 때 디버깅을 쉽게 하기 위함이다.        Weak Self 사용:          [weak self]는 클로저에서 순환 참조를 방지하기 위해 사용되며, self가 해제될 수 있도록 약한 참조를 사용한다. 이로써 메모리 누수를 방지한다.      private func makeBannerSection() -&gt; NSCollectionLayoutSection {                let itemSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .fractionalHeight(1.0))        let item = NSCollectionLayoutItem(layoutSize: itemSize)                let layoutSize = NSCollectionLayoutSize(            widthDimension: .fractionalWidth(1.0),            heightDimension: .absolute(220))                let group = NSCollectionLayoutGroup.horizontal(            layoutSize: layoutSize,            subitems: [item])                return NSCollectionLayoutSection(group: group)    }  컬렉션 뷰의 섹션을 가로로 스크롤되는 배너 형식으로 레이아웃을 설정한다.  아이템 크기 정의 (itemSize):          NSCollectionLayoutSize를 사용하여 아이템의 크기를 설정한다.      widthDimension: .fractionalWidth(1.0)는 아이템이 그룹 너비의 100%를 차지하게 하고, heightDimension: .fractionalHeight(1.0)는 그룹 높이의 100%를 차지하게 한다.      이 크기를 바탕으로 NSCollectionLayoutItem을 생성한다.        그룹 크기 정의 (layoutSize):          NSCollectionLayoutSize로 그룹의 크기를 설정한다.      widthDimension: .fractionalWidth(1.0)는 그룹이 섹션 너비의 100%를 차지하게 하고, heightDimension: .absolute(220)는 그룹의 높이를 고정된 220 포인트로 설정한다.      NSCollectionLayoutGroup.horizontal을 사용하여 가로 방향으로 아이템을 배치하는 그룹을 생성한다. 여기서는 하나의 아이템이 그룹에 포함된다.        섹션 생성 (NSCollectionLayoutSection):          NSCollectionLayoutSection에 그룹을 추가하여 섹션을 생성하고, 이 섹션을 반환한다.      HomeVC에 CollectionView 추가하기override func viewDidLoad() {        super.viewDidLoad()        setupView()                let uiModel = HomeUIModel(sectionModels: [            .init(section: .mainBanner(id: \"123\"),                  body: [.mainBanner(id: \"123\", imageLink: \"https://images.unsplash.com/photo-1627634777217-c864268db30c?q=80&amp;w=1740&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\", title: \"Some Title\", caption: \"some caption\")])        ])        collectionView.setupUIModel(uiModel: uiModel)    }완성하고 나니 강의와 달랐다.caption에 대한 내용이 없다.역산을 하며 올라가던중 MainBannerView에 caption이 없음을 인지했다.struct MainBannerView: View {    let imageLink: String    let title: String    let caption: String        var body: some View {        VStack(alignment: .leading) {            AsyncImage(url: URL(string: imageLink)) { image in                image                    .resizable()                    .aspectRatio(contentMode: .fill)                    .frame(height: 160)                    .clipped()            } placeholder: {                PlaceholderImageView()                    .frame(height: 160)            }            VStack(alignment: .leading, spacing: 4) {                Text(title)                    .font(.system(size: 24, weight: .bold)) // modified                    .fixedSize(horizontal: false, vertical: true)                    .lineLimit(2)                Text(caption) // 빠져있었다.                    .font(.system(size: 12))                    .fixedSize(horizontal: false, vertical: true)                    .lineLimit(2)            }            .padding(.leading, 20)        }    }}MainBannerView의 Vstack에서 caption에 대한 부분이 아예 없었다. 빼먹었나보다.이전 글 에 해당 내용이 빠져있으니 참고…수정을 하고나니 제대로 나온다.그러면 제일 상단의 메인 배너 쪽이 완성이 된다!"
  },
  
  {
    "title": "Build the unofficial Udemy Home Screen (1)",
    "url": "/posts/Build-the-unofficial-Udemy-Home-Screen-(1)/",
    "categories": "Udemy",
    "tags": "",
    "date": "2024-10-09 12:13:00 +0900",
    





    
    "snippet": "시작전 기본 세팅우선 스냅킷을 설치.Snapkit Dynamic은 여전히 에러가 발생하는듯하니 설치하지 말자.Xcode Project 생성시 생기는 파일에서 Info.plist, VC 빼고 나머지 파일들을 모두 Supporting Files에 넣어주었다.그리고 이번엔 JSON을 사용하여 구성을하기에 JSON 파일을 하나 만들어 준다.{    \"layo...",
    "content": "시작전 기본 세팅우선 스냅킷을 설치.Snapkit Dynamic은 여전히 에러가 발생하는듯하니 설치하지 말자.Xcode Project 생성시 생기는 파일에서 Info.plist, VC 빼고 나머지 파일들을 모두 Supporting Files에 넣어주었다.그리고 이번엔 JSON을 사용하여 구성을하기에 JSON 파일을 하나 만들어 준다.{    \"layout\" : {        \"name\" : \"Hello\"    }}그리고 내용은 간단하게 이렇게만 한다.그리고 SwiftUIView 디렉토리엔 반드시 위와 같이 SwiftUI 에 해당하는 파일로 선택해서 만들자.컬렉션뷰 세팅View 디렉토리에 여러 파일들을 미리 만들어준다.현재는 아무것도 없는 빈 깡통.HomeCollectionView Settingimport UIKitfinal class HomeCollectionView: UICollectionView {        init() {        super.init(frame: .zero, collectionViewLayout: UICollectionViewLayout())        setup()    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        private func setup() {        backgroundColor = .green    }}우선은 기본적인 세팅만 해두었다.VC로 가서 제대로 세팅이 되었는지 확인해보자.import UIKitimport SnapKitclass HomeViewController: UIViewController {    private let collectionView = HomeCollectionView()        override func viewDidLoad() {        super.viewDidLoad()        setupView()    }    private func setupView() {        view.addSubview(collectionView)        collectionView.snp.makeConstraints { make in            make.edges.equalToSuperview()        }    }}우선 collectionView를 만들고 그것을 띄우는데 autolayout을 view전체를 덮어씌우는 느낌으로 간다.즉 실행했을때 녹색화면이 보인다면 제대로 되었다는 것.정상인것을 확인!UIModel 추가import Foundationstruct HomeUIModel: Hashable {        let sectionModels: [SectionModel] // added         struct SectionModel: Hashable {        let section: Section        let body: [Item]    }        enum Section:Hashable {        case mainBanner(id: String)        case textheader(id: String)        case courseSwimlane(id: String)        case udemyBusinessBanner(id: String)        case categories(id: String)        case featuredCourses(id: String)    }        enum Item: Hashable {        case mainBanner(id: String, imageLink: String, title: String, caption: String)        case course(id: String, imageLink: String, title: String, author: String, rating: Double, reviewCount: Int, price: Decimal, tag: String)        case textHeader(id: String, text: String, highlightedText: String?)        case udemyBusinessBanner(id: String, link: String)        case categoriesScroller(id: String, titles: [String])        case featuredCourse(id: String, imageLink: String, title: String, author: String, rating: Double, reviewCount: Int, price: Decimal)    }}강의에 있는 이부분에 대한 모델링을 미리 해두는 것이다.let sectionModels: [SectionModel] 이부분이 빠져서 새로 추가 해준다 - 24.10.10 modifiedMainBannerView 추가struct PlaceholderImageView: View {    var body: some View {        Rectangle()            .foregroundColor(.gray.opacity(0.3))    }}#Preview {    PlaceholderImageView()}struct MainBannerView: View {    let imageLink: String    let title: String    let caption: String        var body: some View {        VStack(alignment: .leading) {            AsyncImage(url: URL(string: imageLink)) { image in                image                    .resizable()                    .aspectRatio(contentMode: .fill)                    .frame(height: 160)                    .clipped()            } placeholder: {                PlaceholderImageView()                    .frame(height: 160)            }            VStack(alignment: .leading, spacing: 4) {                Text(title)                    .font(.system(size: 12))                    .fixedSize(horizontal: false, vertical: true)                    .lineLimit(2)            }            .padding(.leading, 20)        }    }}#Preview {    MainBannerView(imageLink: \"https://plus.unsplash.com/premium_photo-1661373704604-7c4d230c8928?q=80&amp;w=1740&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\", title: \"Learning that fits\", caption: \"Skills for your present and future\")}Preview를 하게 되면 이렇게 나온다.여기서 새로운건 AsyncImage이다.Docs도 읽어보면 좋을듯.간단하게 정의하면 url주소를 통해 이미지를 가져온다고 생각하면 된다.그리고 거기에있는 새로운 Modifier는 바로 .clipped이녀석은 이미지나 뷰의 일부가 부모 뷰의 경계를 벗어날 때, 그 초과 부분을 잘라내는 역할을 한다.예를 들어, 이미지가 frame의 크기를 초과할 경우 clipped()를 사용하면 지정된 크기 바깥으로 나오는 부분을 잘라낸다.이렇게 하면 이미지가 frame의 경계를 벗어나지 않고 깔끔하게 표시된다.  clipped()가 없는 경우: 이미지가 지정된 frame을 넘어갈 경우, 초과된 부분이 화면에 그대로 표시될 수 있다.  clipped() 사용 시: 이미지가 frame 밖으로 나가는 부분이 잘려서 보이지 않게 된다."
  },
  
  {
    "title": "Hike (2)",
    "url": "/posts/HIke_2/",
    "categories": "Udemy, Hike",
    "tags": "",
    "date": "2024-08-01 08:33:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "Hike (1)",
    "url": "/posts/HIke_1/",
    "categories": "Udemy, Hike",
    "tags": "",
    "date": "2024-08-01 08:33:00 +0900",
    





    
    "snippet": "1. 기본 세팅1. Asset에 이미지 파일 추가설명은 생략한다.그냥 드래그 앤 드롭으로 끝.2. 이미지 로드struct ContentView: View {    var body: some View {        Image(\"image-1\")            .resizable()            .scaledToFit()    }}이렇게 파...",
    "content": "1. 기본 세팅1. Asset에 이미지 파일 추가설명은 생략한다.그냥 드래그 앤 드롭으로 끝.2. 이미지 로드struct ContentView: View {    var body: some View {        Image(\"image-1\")            .resizable()            .scaledToFit()    }}이렇게 파일 명만 적어도 로드가 된다.작동 사진은 생략.3. CardView 생성새로운 SwiftUI File을 만들고 image 관련코드를 넣어준다.LinearGradient를 사용하여 그라데이션 효과를 줄 수 있다.Extension으로 오타 방지extension Color {    static let customGreenLight = Color(\"ColorGreenLight\")    static let customGreenMedium = Color(\"ColorGreenMedium\")    static let customGreenDark = Color(\"ColorGreenDark\")    static let customGrayLight = Color(\"ColorGrayLight\")    static let customGrayMedium = Color(\"ColorGrayMedium\")    static let customIndigoMedium = Color(\"ColorIndigoMedium\")    static let customSalmonLight = Color(\"ColorSalmonLight\")}Asset에 추가한 색을 사용하는데 문자열로 이렇게 입력하다보면 오타가 날 수 있다.Extension을 활용하여 오타를 방지한다.struct CustomBackgroundView: View {    var body: some View {        ZStack {            // MARK: - 3. Depth            Color.customGreenDark                .cornerRadius(40)                .offset(y: 12)            // MARK: - 2. Light            Color.customGrayLight                .cornerRadius(40)                .offset(y: 3)                .opacity(0.85)            // MARK: - 1. Surface            LinearGradient(                colors: [                    .customGreenLight,                    .customGreenMedium],                startPoint: .top,                endPoint: .bottom            )            .cornerRadius(40)        }    }}사용 예시3. HeaderView 생성struct CardView: View {    var body: some View {        ZStack {            CustomBackgroundView()            VStack {                // MARK: - Header                VStack(alignment: .leading) {                    HStack {                        Text(\"Hiking\")                            .fontWeight(.black)                            .font(.system(size: 52))                            .foregroundStyle(                                LinearGradient(colors: [                                    .customGrayLight,                                    .customGrayMedium],                                               startPoint: .top,                                               endPoint: .bottom)                            )                        Button {                            // Action: Show a Sheet                            print(\"The button was pressed\")                        } label: {                            Text(\"Button\")                        }                    }                    Text(\"Fun and enjoyable outdoor activity for friends and families\")                        .multilineTextAlignment(.leading)                        .italic()                        .foregroundColor(.customGrayMedium)                } //: Header                .padding(.horizontal, 30)                // MARK: - Main content                ZStack {                    Circle()                        .fill(                            LinearGradient(                                colors: [                                    Color(\"ColorIndigoMedium\"),                                    Color(\"ColorSalmonLight\")                                ],                                startPoint: .topLeading,                                endPoint: .bottomTrailing                            )                        )                        .frame(width: 256, height: 256)                    Image(\"image-1\")                        .resizable()                        .scaledToFit()                }                // MARK: - Footer            } //: Vstack        } //: Card        .frame(width: 320, height: 570)    }}크게 언급할만한 부분은 없어보인다.포인트는 어떤 UIComponent에서 특정 StackView를 상위로 할때는 Embed하면 된다는 것.즉이렇게 우클릭을 해서 Embedded 하여 Stack을 계속 쌓아가면 된다.4. Button Design새로운 ButtonView를 하나 만들어준다.struct CustomButtonView: View {    var body: some View {        ZStack {            Circle()                .fill(                    LinearGradient(                        colors: [                            .white,                            .customGreenLight,                            .customGreenMedium],                        startPoint: .top,                        endPoint: .bottom)                )            Circle()                .stroke(                    LinearGradient(                        colors: [                            .customGrayLight,                            .customGrayMedium],                        startPoint: .top,                        endPoint: .bottom),                    lineWidth: 4                )            Image(systemName: \"figure.hiking\")                .fontWeight(.black)                .font(.system(size: 30))                .foregroundStyle(                    LinearGradient(                        colors: [                            .customGrayLight,                            .customGrayMedium                        ],                        startPoint: .top,                        endPoint: .bottom)                )        } //: Zstack        .frame(width: 58, height: 58)    }}크게 언급할만한 내용은 없다 단지 보통 우리가 icon을 추가하려고할때 SF Symbol을 사용하는데간단하게 할 수 있는 방법이 있다.유용하게 쓰일듯이렇게 디자인한 버튼뷰를 적용할때는 Button의 Label에 하면 된다.Button { // Action: Show a Sheet    print(\"The button was pressed\")    } label: {             CustomButtonView()               }적용완료."
  },
  
  {
    "title": "How to load a remote image from the Internet?",
    "url": "/posts/Asyncimage/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-08-01 08:33:00 +0900",
    





    
    "snippet": "AsyncImageAsyncImage는 비동기로 이미지를 로드할때 사용한다.로드중일때는 보통 Placeholder를 사용한다.1. 뼈대 작성struct ContentView: View {    private let imageURL: String = \"https://credo.academy/credo-academy@3x.png\"        var bo...",
    "content": "AsyncImageAsyncImage는 비동기로 이미지를 로드할때 사용한다.로드중일때는 보통 Placeholder를 사용한다.1. 뼈대 작성struct ContentView: View {    private let imageURL: String = \"https://credo.academy/credo-academy@3x.png\"        var body: some View {        // MARK: - 1. BASIC                AsyncImage(url: URL(string: imageURL))            }}이것이 바로 기본 틀이다.실행하면 다음과 같다.2. Scalevar body: some View {        // MARK: - 2. Scale        AsyncImage(url: URL(string: imageURL), scale: 3.0)    }Scale의 경우는 숫자가 클수록 이미지가 작아지고, 작아질수록 이미지가 커진다.3. PlaceHolderPlaceHolder의 경우 이미지가 로드되기전에 보여주는 이미지 이다.var body: some View {        // MARK: - 3. PlaceHolder        AsyncImage(url: URL(string: imageURL)) {            image in            image                .resizable()                .scaledToFit()        } placeholder: {            Image(systemName: \"photo.circle.fill\")                .resizable()                .scaledToFit()                .frame(maxWidth: 128)                .foregroundColor(.purple)                .opacity(0.5)        }        .padding(40)    }4. Extension 사용으로 코드 줄이기현재.resizable().scaledToFit()위 두개의 Modifier가 반복되고 있다.이걸 Extension을 사용하여 코드를 줄여보자.extension Image {    func imageModifier() -&gt; some View {        self            .resizable()            .scaledToFit()    }        func iconModifier() -&gt; some View {        self            .imageModifier()            .frame(maxWidth: 128)            .foregroundColor(.purple)            .opacity(0.5)    }}여기서 흥미로운건 some View 를 리턴한다는 것이다.some View를 리턴한다는 의미는 이 함수가 어떤 특정한 뷰 타입을 리턴한다는 것이다.SwiftUI에서 some View는 함수가 리턴할 구체적인 뷰 타입을 명시하지 않고, 대신 SwiftUI의 View 프로토콜을 준수하는 하나의 뷰를 반환한다고 선언하는 방식이다.예를 들어, imageModifier() 함수는 View 프로토콜을 따르는 구체적인 뷰인 Image를 리턴하는데, 함수가 직접 리턴하는 타입을 명시하지 않고, 대신 어떤 View 타입이든 리턴할 수 있음을 나타낸다. 하지만 Swift가 컴파일 시점에 이 리턴 타입을 추론하므로, 내부적으로 리턴하는 뷰 타입은 고정되어 있다.이 방식의 장점은 함수가 여러 개의 뷰를 리턴할 수 있게 하는 대신, Swift의 타입 안정성과 최적화 기능을 유지할 수 있다는 점이다.그리고 안애서 self가 나오는데, self는 그 해당하는 뷰 자신을 의미한다.imageModifier함수를 예로 들면거기서 self는 이 메서드가 호출된 뷰 자신을 가리킨다. 즉, 이 메서드를 호출한 뷰(예를 들어, Image)에 대해 resizable()과 scaledToFit() 같은 modifier를 적용하게 된다.5. PhaseAsyncImage(url: URL(string: imageURL)) { phase in            // Success: The image successfully loaded            if let image = phase.image {                image.imageModifier()            } else if phase.error != nil {                // Failure: The image failed to load with an error                Image(systemName: \"ant.circle.fill\").iconModifier()            } else {                // Empty: No image is loaded                Image(systemName: \"photo.circle.fill\").iconModifier()            }                    }        .padding(40)Phase는 이미지가 제대로 로드가 되었는지, 아닌지 이런 예외처리를 하는것으로 이해하면 쉽다.즉 이미지가 제대로 로드가 될경우엔 imageModifier 함수가 적용이 되고여기선 이미지 로드에 문제가 발생했을때 개미 아이콘이 나오게 되어있다.6. AnimationAsyncImage(url: URL(string: imageURL)) { phase in            switch phase {            case .success(let image):                image.imageModifier()            case .failure(_):                Image(systemName: \"ant.circle.fill\").iconModifier()            case .empty:                Image(systemName: \"photo.circle.fill\").iconModifier()            }        }        .padding(40)5번의 케이스를 if 대신 switch-case를 사용하여 다르게 표현을 했다.이때 Warning이 발생했다.warning에대해 Fix를 누르니 @unknown default에 관한 항목이 생긴다.AsyncImage(url: URL(string: imageURL)) { phase in            switch phase {            case .success(let image):                image.imageModifier()            case .failure(_):                Image(systemName: \"ant.circle.fill\").iconModifier()            case .empty:                Image(systemName: \"photo.circle.fill\").iconModifier()            @unknown default:                ProgressView()            }        }        .padding(40)transaction을 추가하여 애니메이션을 넣어보자.AsyncImage(url: URL(string: imageURL),                   transaction: Transaction(                    animation: .spring(response: 0.5,                    dampingFraction: 0.6,                    blendDuration: 0.25))) { phase in            switch phase {            case .success(let image):                image.imageModifier()                    .transition(.move(edge: .bottom))            case .failure(_):                Image(systemName: \"ant.circle.fill\").iconModifier()            case .empty:                Image(systemName: \"photo.circle.fill\").iconModifier()            @unknown default:                ProgressView()            }        }        .padding(40)  Transaction은 상태 변화에 대해 애니메이션을 정의하는 구조체이다.  animation: .spring(…)는 스프링 애니메이션을 지정하고 있다.  response: 0.5: 애니메이션의 지속 시간을 의미한다. 값이 클수록 애니메이션이 느리게 진행된다.  dampingFraction: 0.6: 애니메이션이 끝날 때 진동을 얼마나 억제할지를 나타낸다. 값이 낮을수록 진동이 더 많이 발생한다.  blendDuration: 0.25: 애니메이션이 다른 애니메이션과 섞이는 데 걸리는 시간이다.따라서 이 transaction은 이미지가 성공적으로 로드되었을 때, 스프링 애니메이션을 적용하는 데 사용된다."
  },
  
  {
    "title": "LOTR Converter (5)",
    "url": "/posts/LOTR-Converter-(5)/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-07-27 08:33:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "LOTR Converter (4)",
    "url": "/posts/LOTR-Converter-(4)/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-07-23 08:33:00 +0900",
    





    
    "snippet": "Info Button 기능 추가하기Info Button을 누르면 Exchange Info 화면이 나오게 할 것이다.// Info Button                HStack {                    Spacer()                                        Button {                   ...",
    "content": "Info Button 기능 추가하기Info Button을 누르면 Exchange Info 화면이 나오게 할 것이다.// Info Button                HStack {                    Spacer()                                        Button {                        showExchangeInfo.toggle()                                                                    } label: {                        Image(systemName: \"info.circle.fill\")                            .font(.largeTitle)                            .foregroundStyle(.white)                    }                    .padding(.trailing)                    .sheet(isPresented: $showExchangeInfo) {                        ExchangeInfo()                    }                }이렇게 버튼 뒤에 Modifier를 추가해준다.이때 사용된 Modifier는 Sheet이며, 새로운 페이지를 보여줄때 사용한다.뭐랄까 화면전환의 개념이다.UIKit에서는 present와 비슷하다고 생각하면 될듯하다.이때 isPresented의 parameter로 showExchangeInfo를 받게하고 true / false에 따라 보여지는지 아닌지를 확인하게한다.지금은 modal처럼 화면이 올라온다.Done 버튼을 눌렀을때 화면을 다시 이전으로 돌아가게 하기새로운 Wrapper를 사용한다. 바로 @Environment이다.SwiftUI에서 @Environment는 뷰에 환경 값을 주입하는 데 사용하는 프로퍼티 래퍼이다.SwiftUI는 뷰 간에 데이터를 전달하기 위해 다양한 방법을 제공하며, @Environment는 부모 뷰에서 하위 뷰로 환경 값을 전달하는 중요한 방법 중 하나이다.  @Environment의 주요 개념          @Environment는 SwiftUI 앱의 전역 설정이나 상태를 뷰에 제공하는 데 사용된다.      앱의 여러 뷰가 동일한 데이터를 필요로 할 때, 환경을 통해 해당 데이터를 공유하고 접근할 수 있다.        @Environment의 특징          미리 정의된 환경 값: SwiftUI는 미리 정의된 여러 환경 값을 제공한다. 예를 들어 colorScheme, presentationMode, accessibilityDifferentiateWithoutColor, horizontalSizeClass 등이 있다.      커스텀 환경 값: 사용자가 직접 커스텀 환경 값을 정의하고 공유할 수도 있다. EnvironmentKey 프로토콜을 채택하여 커스텀 키를 만들고, 그 키에 대한 기본 값을 제공하는 식으로 구현한다.      @Environment(\\.dismiss) var dismiss: @Environment를 사용하여 시스템에서 제공하는 dismiss 메서드를 가져와 뷰를 닫는 데 사용한다.struct ExchangeInfo: View {    @Environment(\\.dismiss) var dismiss        var body: some View {        ZStack {            // Background parchment image            Image(.parchment)                .resizable()                .ignoresSafeArea()                .background(.brown)                        VStack {                // Title text                Text(\"Exchange Rates\")                    .font(.largeTitle)                    .tracking(3)                                // Description Text                Text(\"Here at the Prancing Pony, we are happy to offer you a place where you can exchange all the known currencies in the entire world except one. We used to take Brandy Bucks, but after finding out that it was a person instead of a piece of paper, we realized it had no value to us. Below is a simple guide to our currency exchange rates:\")                    .font(.title2)                    .padding()                                // Exchnage rates                ExchangeRate(leftImage: .goldpiece, text: \"1 Gold Piece = 4 Gold Pennies\", rightImage: .goldpenny)                                ExchangeRate(leftImage: .goldpenny, text: \"1 Gold Penny = 4 Silver Pieces\", rightImage: .silverpiece)                                ExchangeRate(leftImage: .silverpiece, text: \"1 Silver Piece = 4 Silver Pennies\", rightImage: .silverpenny)                                ExchangeRate(leftImage: .silverpenny, text: \"1 Silver Penny = 100 Copper Pennies\", rightImage: .copperpenny)                                // Done Button                Button(\"Done\") {                    dismiss()                }                .buttonStyle(.borderedProminent)                .tint(.brown)                .font(.largeTitle)                .padding()                .foregroundStyle(.white)            }            .foregroundStyle(.black)        }    }}작동도 잘된다.이떄 ExchangeInfo에서 하면 작동확인이 안되므로, ContentView에서 확인하도록 하자.그리고 흥미로운게 dismiss를 변수로 만들었지만이녀석 일종의 액션의 형태를 가진다.그래서 dismiss를 하기위해선 ()를 적어주는것이다."
  },
  
  {
    "title": "LOTR Converter (3)",
    "url": "/posts/LOTR-Converter-(3)/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-07-22 08:33:00 +0900",
    





    
    "snippet": "Info View 디자인하기우선 파일을 하나 생성해주고이때 UIkit을 할때는 Swift File을 했지만이제는 아래에 있는 SwiftUI View로 만들어 준다.그리고 다음과 같이 큰 틀을 짜준다.struct ExchangeInfo: View {    var body: some View {        ZStack {            // Bac...",
    "content": "Info View 디자인하기우선 파일을 하나 생성해주고이때 UIkit을 할때는 Swift File을 했지만이제는 아래에 있는 SwiftUI View로 만들어 준다.그리고 다음과 같이 큰 틀을 짜준다.struct ExchangeInfo: View {    var body: some View {        ZStack {            // Background parchment image                        VStack {                // Title text                                // Description Text                                // Exchnage rates                                HStack {                    // Left Currency image                                        // Exchange rate text                                        // Right Currency image                }                                // Done Button            }        }    }}배경화면을 추가해주고Title Text를 추가를 해주었다.이때 자간을 늘리려고 할때 사용되는것이 바로 tracking Modifier이다.Text(\"Exchange Rates\")                    .font(.largeTitle)                    .tracking(3)차이가 명확하다.struct ExchangeInfo: View {    var body: some View {        ZStack {            // Background parchment image            Image(.parchment)                .resizable()                .ignoresSafeArea()                .background(.brown)                        VStack {                // Title text                Text(\"Exchange Rates\")                    .font(.largeTitle)                    .tracking(3)                                // Description Text                Text(\"Here at the Prancing Pony, we are happy to offer you a place where you can exchange all the known currencies in the entire world except one. We used to take Brandy Bucks, but after finding out that it was a person instead of a piece of paper, we realized it had no value to us. Below is a simple guide to our currency exchange rates:\")                    .font(.title2)                    .padding()                                // Exchnage rates                HStack {                    // Left Currency image                    Image(.goldpiece)                        .resizable()                        .scaledToFit()                        .frame(height: 33)                                        // Exchange rate text                    Text(\"1 Gold Piece = 4 Gold Pennies\")                                        // Right Currency image                    Image(.goldpenny)                        .resizable()                        .scaledToFit()                        .frame(height: 33)                }                                // Done Button                Button(\"Done\") {                                    }                .buttonStyle(.borderedProminent)                .tint(.brown)                .font(.largeTitle)                .padding()                .foregroundStyle(.white)            }            .foregroundStyle(.black)        }    }}이렇게 완성이 되었다.SubView 사용해보기HStack을 여러번 사용할것이라 효과적으로 코드를 작성하기위해 SubView를 사용하려고 한다.그래서 HStack을 우클릭하여 Extract 해주자.struct ExtractedView: View {    var body: some View {        HStack {            // Left Currency image            Image(.goldpiece)                .resizable()                .scaledToFit()                .frame(height: 33)                        // Exchange rate text            Text(\"1 Gold Piece = 4 Gold Pennies\")                        // Right Currency image            Image(.goldpenny)                .resizable()                .scaledToFit()                .frame(height: 33)        }    }}그러면 이렇게 별도로 Seperated 된다.또한 SubView만 preview로 보고싶다면#Preview {    ExtractedView()}그냥 아래에 이렇게 적어주면 된다.그럼 이렇게 상단에 preview를 선택해서 볼 수 있다.하지만 폰 전체 말고 딱 그 사이즈만 보고싶다면이전 글을 참조.#Preview(traits: .sizeThatFitsLayout) {    ExtractedView()}여기선 코드로 대체한다.그리고 파일을 새롭게 만들어 주고 코드를 이관해주자.파일명은 ExchangeRate로 해주었다.그리고 다시 Exchange Info로 와서 view를 3개 더 추가해준다.// Exchnage rates                ExtractedView()                                ExtractedView()                                ExtractedView()                                ExtractedView()이렇게 SubView를 사용하면 코드를 좀 더 간결하게 할 수 있고, 유지 보수도 용이해진다.SubView 모듈화 하기현재는 ExchangeRate 뷰 자체가 같은 이미지를 가지고 있다.하지만 4개가 모두 같은 이미지, 내용을 가지고 있기에 커스터마이징이 불가능 하다.struct ExchangeRate: View {    let leftImage: ImageResource    let text: String    let rightImage: ImageResource        var body: some View {        HStack {            // Left Currency image            Image(leftImage)                .resizable()                .scaledToFit()                .frame(height: 33)                        // Exchange rate text            Text(text)                        // Right Currency image            Image(rightImage)                .resizable()                .scaledToFit()                .frame(height: 33)        }    }}#Preview(traits: .sizeThatFitsLayout) {    ExchangeRate(leftImage: .silverpiece, text: \"1 Gold Piece = 4 Gold Pennies\", rightImage: .silverpenny)}이렇게 변수를 만들어 주었다.정확히 말하면 let을 사용하여 상수로 했다.이제 ExchangeInfo 에서 Error가 발생하는데 그전에는 내부에 파라미터가 없었지만 지금은 생겼기에 설정을 해줘야한다.친절한 녀석들.                 // Exchnage rates                ExchangeRate(leftImage: .goldpiece, text: \"1 Gold Piece = 4 Gold Pennies\", rightImage: .goldpenny)                                ExchangeRate(leftImage: .goldpenny, text: \"1 Gold Penny = 4 Silver Pieces\", rightImage: .silverpiece)                                ExchangeRate(leftImage: .silverpiece, text: \"1 Silver Piece = 4 Silver Pennies\", rightImage: .silverpenny)                                ExchangeRate(leftImage: .silverpenny, text: \"1 Silver Penny = 100 Copper Pennies\", rightImage: .copperpenny)코드를 모두 적어주자.이렇게 코드는 간결해지고, 원하는 내용을 바로바로 추가하거나 변경만 하면 되므로 쉽게 커스터마이징이 가능해졌다."
  },
  
  {
    "title": "LOTR Converter (2)",
    "url": "/posts/LOTR-Converter-(2)/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-07-22 08:33:00 +0900",
    





    
    "snippet": "Info Button 추가하기기본적인 틀이 만들어졌으니, 버튼을 추가해보도록한다.우선 버튼 디자인을 할 것인데,Button {                } label: {                    Image(systemName: \"info.circle.fill\")                                    }       ...",
    "content": "Info Button 추가하기기본적인 틀이 만들어졌으니, 버튼을 추가해보도록한다.우선 버튼 디자인을 할 것인데,Button {                } label: {                    Image(systemName: \"info.circle.fill\")                                    }                .font(.largeTitle)                .foregroundStyle(.white)이렇게 해준다.이전의 글에 있었던 마지막 화면과 동일하므로 이미지는 패스label에 이미지를 넣고 버튼의 이미지를 디자인 해주는 것이다.이제 버튼을 작동시키기 위해 변수를 하나 만들어준다.var showExchangeInfo = false하지만 이렇게 에러가 뜬다.이때 이전에 사용했던 @State Wrapper를 적용시켜주면 된다.버튼 작동의 확인을 위해 toggle을 해주었는데,preview에서도 확인이 가능하다.아래에 있는 Preview를 탭해주고 테스트하면 이렇게 콘솔에 출력이 되는것을 확인할 수 있다.그리고 버튼이 현재 중간에 위치하므로, HStack 하나 더 추가 해주고 버튼의 위치를 Spacer()를 통해 옮겨볼 것이다.이전에 컨트롤 클릭으로 추가하는것을 언급했는데, 그냥 우클릭을 해도 된다.참고하자하지만 이렇게 완전 사이드에 붙은것을 알 수 있다.현재 파란선은 이해를 돕기 위해 임시로 BorderLine을 추가해주었다.그래서 버튼에 패딩을 준다.// Info Button                HStack {                    Spacer()                                        Button {                                                showExchangeInfo.toggle()                    } label: {                        Image(systemName: \"info.circle.fill\")                            .font(.largeTitle)                            .foregroundStyle(.white)                    }                    .padding(.trailing)                }이렇게 trailing쪽에 패딩을 줌으로써 약간의 간격이 생겼다.Textfields 추가하기현재는 Text로 해두고 위치만 설정 해두었는데 이제 Textfield로 바꾸어 입력이 가능하게 하자.그전에 변수를 만들어 준다.    @State var leftAmount = \"\"    @State var rightAmount = \"\"왼쪽 오른쪽 값을 받을 변수이다.그리고 이제 Textfield를 추가해주자.이때 여러가지 옵션이 있는데 우린 바로 첫번째것을 선택한다.titleKey는 PlaceHolder이다.text는 값이라고 간단하게 생각하면 되는데, UIKit처럼 바로 변수를 대입하는것은 아니다.이렇게 바인딩 스트링 타입이 필요하다고 한다.이전에 컴바인을 하면서 했던것 처럼 앞에 $를 붙여주면 된다.그러면 값의 변화를 감지할것이다.하지만 입력을 어디에 해야하는지 보이지 않아서 이렇게 Modifier를 추가해준다.TextField(\"Amount\", text: $leftAmount)                            .textFieldStyle(.roundedBorder)우측도 똑같이 해주자.Amount가 둘다 왼쪽에 붙어있어서 뭔가 이쁘지 않아 보인다.우측의 placeholder는 우측에 붙이는게 어떨까?// Textfield                        TextField(\"Amount\", text: $rightAmount)                            .textFieldStyle(.roundedBorder)                            .multilineTextAlignment(.trailing)이렇게 .multilineTextAlignment(.trailing) Modifier를 통해 우측으로 붙여줄 수 있다.뭔가 이쁘게 정돈이 되었다.그리고 패딩을 사용해서 간격을 좀 더 붙여본다.VStack {                        // Currency                        HStack {                            // Currency image                            Image(.silverpiece)                                .resizable()                                .scaledToFit()                                .frame(height: 33)                                                        // Currency text                            Text(\"Silver Piece\")                                .font(.headline)                                .foregroundStyle(.white)                        }                        .padding(.bottom, -5)                                                // Textfield                        TextField(\"Amount\", text: $leftAmount)                            .textFieldStyle(.roundedBorder)                                            }이렇게 before / after로 확인이 가능하다.우측도 똑같이 해주자.그리고 관련된 전체 Hstack부분에HStack {                    // Left conversion section                    VStack {                        // Currency                        HStack {                            // Currency image                            Image(.silverpiece)                                .resizable()                                .scaledToFit()                                .frame(height: 33)                                                        // Currency text                            Text(\"Silver Piece\")                                .font(.headline)                                .foregroundStyle(.white)                        }                        .padding(.bottom, -5)                                                // Textfield                        TextField(\"Amount\", text: $leftAmount)                            .textFieldStyle(.roundedBorder)                                            }                                        // Equal sign                    Image(systemName: \"equal\")                        .font(.largeTitle)                        .foregroundStyle(.white)                        .symbolEffect(.pulse)                                        // Right conversion section                    VStack {                        // Currency                        HStack {                            // Currency text                            Text(\"Gold Piece\")                                .font(.headline)                                .foregroundStyle(.white)                                                        // Currency image                            Image(.goldpiece)                                .resizable()                                .scaledToFit()                                .frame(height: 33)                        }                        .padding(.bottom, -5)                                                // Textfield                        TextField(\"Amount\", text: $rightAmount)                            .textFieldStyle(.roundedBorder)                            .multilineTextAlignment(.trailing)                                            }                }                .padding()                .background(.black.opacity(0.5))                .clipShape(.capsule)투명도 0.5인 검은색을 배경화면으로 주고, 캡슐 모양으로 해서 좀 더 디자인 해보았다. (코드의 마지막 부분)이렇게 메인화면 디자인이 끝났다."
  },
  
  {
    "title": "LOTR Converter (1)",
    "url": "/posts/LOTR-Converter-(1)/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-07-22 08:33:00 +0900",
    





    
    "snippet": "VHZStack이미지로 간단하게 설명이 가능하다.V: VerticalH: HorizontalZ는 그냥 Z Axis인듯하다.우리가 최종적으로 만들 앱의 Structure는 다음과 같이 될것이다.VHZStack도 View 라는것을 꼭 기억해두자.뼈대 구성하기여기 강의에서는 먼저 어떻게 할지 이미지화를 하고 그것에 대해서 크게 뼈대를 잡는 식으로 하였다.구...",
    "content": "VHZStack이미지로 간단하게 설명이 가능하다.V: VerticalH: HorizontalZ는 그냥 Z Axis인듯하다.우리가 최종적으로 만들 앱의 Structure는 다음과 같이 될것이다.VHZStack도 View 라는것을 꼭 기억해두자.뼈대 구성하기여기 강의에서는 먼저 어떻게 할지 이미지화를 하고 그것에 대해서 크게 뼈대를 잡는 식으로 하였다.구성은 위와 같다.struct ContentView: View {    var body: some View {        ZStack {            // Background Image                        VStack {                // Prancing pony image                                // Currency exchange text                                // Currency conversion section                HStack {                    // Left conversion section                    VStack {                        // Currency                        HStack {                            // Currency image                                                        // Currency text                        }                                                // Textfield                    }                                        // Equal sign                                        // Right conversion section                    VStack {                        // Currency                        HStack {                            // Currency text                                                        // Currency image                        }                                                // Textfield                                            }                }                                // Info Button            }        }    }}이렇게 주석을 잡아가면서 뼈대를 잡았다.좋은 방법인듯 하다.UI 추가하기이미지는 Image(.background) 이렇게만 적으면 된다.이전에 UIKit을 사용할때는 Image(\"background\") 이런식으로 문자열을 사용했는데, SwiftUI에서는 간편하게 할 수 있다. 물론 두개 다 여기선 사용가능하다.이미지를 추가하면 그냥 꽉 차버리는데 이때 .resizable() 을 사용하자.그러면이렇게 SafeArea는 유지한채로 이미지가 깔리는데,우리는 전역에 배경화면이 깔리게 할것이므로 Modifier를 하나 더 추가해준다.바로 .ignoresSafeArea()이다.그냥 읽어봐도 직관적으로 어떤 걸 의미하는지 알 수 있다.이렇게 깔끔하게 되었다.VStack {                // Prancing pony image                Image(.prancingpony)                    .resizable()                    .scaledToFit()                    .frame(height: 200)이렇게 Image 추가하듯이 Text도 추가하면 된다.코드를 추가해주면struct ContentView: View {    var body: some View {        ZStack {            // Background Image            Image(.background)                .resizable()                .ignoresSafeArea()                        VStack {                // Prancing pony image                Image(.prancingpony)                    .resizable()                    .scaledToFit()                    .frame(height: 200)                                // Currency exchange text                Text(\"Currency Exchange\")                    .font(.largeTitle)                    .foregroundStyle(.white)                                // Currency conversion section                HStack {                    // Left conversion section                    VStack {                        // Currency                        HStack {                            // Currency image                            Image(.silverpiece)                                .resizable()                                .scaledToFit()                                .frame(height: 33)                                                        // Currency text                            Text(\"Silver Piece\")                                .font(.headline)                                .foregroundStyle(.white)                        }                                                // Textfield                        Text(\"Textfield\")                                            }                                        // Equal sign                    Image(systemName: \"equal\")                        .font(.largeTitle)                        .foregroundStyle(.white)                        .symbolEffect(.pulse)                                        // Right conversion section                    VStack {                        // Currency                        HStack {                            // Currency text                            Text(\"Gold Piece\")                                .font(.headline)                                .foregroundStyle(.white)                                                        // Currency image                            Image(.goldpiece)                                .resizable()                                .scaledToFit()                                .frame(height: 33)                        }                                                // Textfield                        Text(\"Textfield\")                                            }                }                                Spacer()                                // Info Button                Image(systemName: \"info.circle.fill\")                    .font(.largeTitle)                    .foregroundStyle(.white)            }            //.border(.blue)        }    }}equal이 pulse 효과를 주어 은은하게 반짝이지만 gif대신 png이미지로 대체한다.그리고 Textfield는 임시로 Text로 해주었다."
  },
  
  {
    "title": "TabView",
    "url": "/posts/TabView/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-07-21 11:33:00 +0900",
    





    
    "snippet": "TabView를 사용하여 모두 가져오기ContentView를 다듬어서 여태 구현한것을 모두 보여지게 해보자.TabView는 UIKit에서의 TabBarController이다.import SwiftUIimport SwiftDatastruct ContentView: View {    var body: some View {        TabView {  ...",
    "content": "TabView를 사용하여 모두 가져오기ContentView를 다듬어서 여태 구현한것을 모두 보여지게 해보자.TabView는 UIKit에서의 TabBarController이다.import SwiftUIimport SwiftDatastruct ContentView: View {    var body: some View {        TabView {            Tab(\"Places\", systemImage: \"photo\") {                PlaceList()            }                        Tab(\"Trip History\", systemImage: \"chart.line.uptrend.xyaxis\") {                TripsChart()            }        }        .preferredColorScheme(.dark)    }}#Preview {    ContentView()        .modelContainer(Place.preview)}.preferredColorScheme(.dark)를 통해 다크모드에서 보여지게 했다.사실 이부분은 크게 언급할만한게 없다.작동도 잘 되는것을 확인할 수 있다."
  },
  
  {
    "title": "Math Function Charts",
    "url": "/posts/Math-Function-Charts/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-07-21 10:33:00 +0900",
    





    
    "snippet": "차트를 구현해보려한다.TripsChart라는 새로운 파일을 만들어주고import Charts를 해주자.1. 샘플 데이터 모델링struct SampleTripRating {    let trip: Int    let rating: Int        static let ratings: [SampleTripRating] = [        SampleTr...",
    "content": "차트를 구현해보려한다.TripsChart라는 새로운 파일을 만들어주고import Charts를 해주자.1. 샘플 데이터 모델링struct SampleTripRating {    let trip: Int    let rating: Int        static let ratings: [SampleTripRating] = [        SampleTripRating(trip: 1, rating: 55),        SampleTripRating(trip: 2, rating: 27),        SampleTripRating(trip: 3, rating: 67),        SampleTripRating(trip: 4, rating: 72),        SampleTripRating(trip: 5, rating: 81)    ]}2. 구현하기struct TripsChart: View {    var body: some View {        Chart(SampleTripRating.ratings, id: \\.trip) { rating in            LinePlot(x: \"Years\", y: \"Ratings\") { x in                return x * 6 + 50            }            .foregroundStyle(.purple)        }        .chartXScale(domain: 1...5)        .chartYScale(domain: 1...100)        .padding()    }}Graph를 보면SampleTripRating.ratings를 통해 어떤 데이터를 가져올지를 지정하고, id는 각항목의 고유 식별자로 이해하면된다.LinePlot 는 바로 직선이다.x축, y축에 대해 설정을 해주고.  .chartXScale(domain: 1…5)          x축 범위        .chartYScale(domain: 1…100)          y축 범위      그리고 리턴을 해주었다. 즉 저 그래프는y = 6x + 50의 그래프이다.이렇게 그래프가 나온다.3. 그래프를 여러개 구현하기struct TripsChart: View {    var body: some View {        Chart(SampleTripRating.ratings, id: \\.trip) { rating in            PointMark(x: .value(\"Year\", rating.trip), y: .value(\"Rating\", rating.rating))                        LinePlot(x: \"Years\", y: \"Ratings\") { x in                return x * 6 + 50            }            .foregroundStyle(.purple)        }        .chartXScale(domain: 1...5)        .chartYScale(domain: 1...100)        .padding()    }}그래프를 여러개라고 적었지만 실제로는 우리가 샘플로 만든 값을 표시했다.물론 bar type도 가능하다.Point를 Bar로만 바꿔 주면 된다."
  },
  
  {
    "title": "SwiftCharts",
    "url": "/posts/SwiftCharts/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-07-21 09:33:00 +0900",
    





    
    "snippet": "차트를 구현해보려한다.VegasChart라는 새로운 파일을 만들어주고import Charts를 해주자.1. 샘플 데이터 모델링struct SampleRating {    let place: String    let rating: Int        static let ratings: [SampleRating] = [        SampleRating...",
    "content": "차트를 구현해보려한다.VegasChart라는 새로운 파일을 만들어주고import Charts를 해주자.1. 샘플 데이터 모델링struct SampleRating {    let place: String    let rating: Int        static let ratings: [SampleRating] = [        SampleRating(place: \"Bellagio\", rating: 88),        SampleRating(place: \"Paris\", rating: 75),        SampleRating(place: \"Treasure Island\", rating: 33),        SampleRating(place: \"Excalibur\", rating: 99)    ]}2. 구현하기struct VegasChart: View {    var body: some View {        Chart(SampleRating.ratings, id: \\.place) { rating in            SectorMark(angle: .value(\"Ratings\", rating.rating)                       , innerRadius: .ratio(0.25)                       , angularInset: 1)                .cornerRadius(7)                .foregroundStyle(by: .value(\"Place\", rating.place))        }        .padding()        .frame(height: 500)    }}Chart를 보면SampleRating.ratings를 통해 어떤 데이터를 가져올지를 지정하고, id는 각항목의 고유 식별자로 이해하면된다.(Legend)SectorMark는 Pie Chart / Donut Chart이다.  innerRadius: .ratio(0.25)는 섹터의 안쪽 반지름을 설정하여 도넛 형태를 만든다.  angularInset: 1은 각 섹터 사이의 간격을 조절한다.이렇게 차트가 나온다."
  },
  
  {
    "title": "MapKit",
    "url": "/posts/MapKit/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-07-21 08:33:00 +0900",
    





    
    "snippet": "MapView 파일을 하나 만들어준다.그리고 MapKit을 import 해주자.지도를 화면에 보여주는건 아주 간단하다그냥 Map()을 적으면 된다.struct MapView: View {    var body: some View {        Map()    }}이렇게 바로 지도가 보이게 된다.1. 설정한 지역을 보이게 구현하기우리가 이전에 Plac...",
    "content": "MapView 파일을 하나 만들어준다.그리고 MapKit을 import 해주자.지도를 화면에 보여주는건 아주 간단하다그냥 Map()을 적으면 된다.struct MapView: View {    var body: some View {        Map()    }}이렇게 바로 지도가 보이게 된다.1. 설정한 지역을 보이게 구현하기우리가 이전에 Place를 통해 여러 샘플의 좌표를 지정해두었다.그것을 활용해서 지도에 보여지게 해보자.우선 preview에 다음과 같이 적어보자#Preview {    MapView(place: Place.previewPlaces[0], position: .camera(MapCamera(        centerCoordinate: Place.previewPlaces[0].location,        distance: 1000,        heading: 250,        pitch: 80    )))}heading과 pitch는 지도나 카메라 뷰에서 카메라의 방향과 각도를 조절하는 데 사용되는 중요한 속성들이다. 특히 지도 애플리케이션에서 사용자가 지도를 보는 각도와 방향을 제어할 때 유용하다.  Heading (헤딩)          설명: 헤딩은 카메라가 바라보는 방향을 나타내는 값이다. 지도를 위에서 내려다볼 때, 기본 방향은 북쪽(0도)이다. 헤딩 값은 시계 방향으로 증가하며, 360도는 다시 북쪽을 가리킨다.      범위: 0에서 360까지의 값으로, 0도는 북쪽, 90도는 동쪽, 180도는 남쪽, 270도는 서쪽을 가리킨다.      예시:              0도: 북쪽을 바라봄      90도: 동쪽을 바라봄      180도: 남쪽을 바라봄      270도: 서쪽을 바라봄        Pitch (피치)          설명: 피치는 카메라의 기울기를 나타내는 값이다. 피치는 지도 또는 3D 뷰를 수직 방향에서 얼마나 기울여서 볼지를 결정한다.      범위: 0에서 90까지의 값으로, 0도는 수직으로 아래를 내려다보는 것이고, 90도는 지면과 수평하게 보는 것이다.      예시:              0도: 지도를 수직으로 내려다보는 뷰 (탑다운 뷰)      45도: 지도를 약간 기울여서 보는 뷰 (일부 지형이 보이기 시작함)      80도: 거의 수평으로 지형과 건물 등을 볼 수 있는 뷰 (지상에서 보는 것과 유사한 뷰)      하지만 보이지 않는다?왜냐하면 body 부분을 더 보완해야 하기 때문이다.그전에, 현재 프리뷰쪽 코드에서 Place.previewPlaces[0] 이게 두번 반복이 된다.코드를 좀 줄여보자.#Preview {    @Previewable @State var place = Place.previewPlaces[0]        MapView(place: place, position: .camera(MapCamera(        centerCoordinate: place.location,        distance: 1000,        heading: 250,        pitch: 80    )))}참고하자!이제 body부분을 보완하자.간단하다. Map() 괄호 안에 위치를 넣어주면 된다.struct MapView: View {        var place: Place    @State var position: MapCameraPosition        var body: some View {        Map(position: $position)    }}2. Annotation 추가하기struct MapView: View {        var place: Place    @State var position: MapCameraPosition        var body: some View {        Map(position: $position) {            Annotation(place.intersted ? \"Place of Interest\" : \"Not Interested\", coordinate: place.location) {                ZStack {                    RoundedRectangle(cornerRadius: 7)                        .fill(.ultraThickMaterial)                        .stroke(.secondary, lineWidth: 5)                    Image(systemName: place.intersted ? \"face.smiling\" : \"hand.thumbsdown\")                }            }        }    }}어노테이션을 그냥 추가하면 되는데 이때 앞에는 title이 들어간다.그래서 interested가 true / false에 따라 이름이 다르게 나오게 삼항연산자를 사용하였고, 그뒤에는 annotation pin이 들어갈 좌표를 설정해준다.이후 Zstack을 사용하여 핀의 이미지를 구현하는데 true면 웃는 표시, false면 👎 표시가 나온다.3. 핀 클릭시 값 변경하기onTapGesture 를 통해서 토글을 해주면 된다.struct MapView: View {        var place: Place    @State var position: MapCameraPosition        var body: some View {        Map(position: $position) {            Annotation(place.intersted ? \"Place of Interest\" : \"Not Interested\", coordinate: place.location) {                ZStack {                    RoundedRectangle(cornerRadius: 7)                        .fill(.ultraThickMaterial)                        .stroke(.secondary, lineWidth: 5)                    Image(systemName: place.intersted ? \"face.smiling\" : \"hand.thumbsdown\")                        .padding(5)                }                .onTapGesture {                    place.intersted.toggle()                }            }        }    }}이렇게 클릭하면 토글로 인해 값이 바뀌면서 이미지와 title도 같이 바뀌게 된다.3. PlaceList와 연동하기다시 PlaceList로 돌아와서 NavigationLink를 추가해준다.NavigationStack {            List ((try? places.filter(predicate)) ?? places) { place in                NavigationLink(value: place) {                    HStack {                        place.image                            .resizable()                            .scaledToFit()                            .clipShape(.rect(cornerRadius: 7))                            .frame(width: 100, height: 100)                                                Text(place.name)                                                Spacer()                                                if place.intersted {                            Image(systemName: \"star.fill\")                                .foregroundStyle(.yellow)                                .padding(.trailing)                        }                    }                }            }하지만 아직 넘어가지는 않는다.왜냐하면 Destination을 설정하지 않았기 때문animation 밑에 destination을 설정해주자..navigationTitle(\"Places\")            .searchable(text: $searchText, prompt: \"Find a Place\")            .animation(.default, value: searchText)            .navigationDestination(for: Place.self) { place in                MapView(place: place, position: .camera(MapCamera(                    centerCoordinate: place.location,                    distance: 1000,                    heading: 250,                    pitch: 80                )))            }카메라는 아까 preview에 했던 세팅 그대로 값을 가져왔다.이렇게 화면전환이 되는 것을 확인할 수 있다.하지만 화면전환시 Navigation Bar 영역이 남아있어 좋아보이지 않는다.MapView로 가서struct MapView: View {        var place: Place    @State var position: MapCameraPosition        var body: some View {        Map(position: $position) {            Annotation(place.intersted ? \"Place of Interest\" : \"Not Interested\", coordinate: place.location) {                ZStack {                    RoundedRectangle(cornerRadius: 7)                        .fill(.ultraThickMaterial)                        .stroke(.secondary, lineWidth: 5)                    Image(systemName: place.intersted ? \"face.smiling\" : \"hand.thumbsdown\")                        .padding(5)                }                .onTapGesture {                    place.intersted.toggle()                }            }        }        .toolbarBackground(.automatic)    }}toolbarBackground에 대해 automatically로 작동하게 설정을 한다.여기 Preview에서는 변화를 감지하지 못한다.다시 PlaceList에서 확인을 해보면이렇게 작동이 되고, 또한 interested도 반영이 되는걸 확인할 수 있다.Swift data의 장점이 여기서 나온다.Swift 데이터를 사용하고 실제 데이터베이스에 데이터를 저장하면 다음 중 하나를 변경할 수 있다.→ 값이 바뀌면 모든 곳에서 바뀐다!→ 동일한 값이고 동일한 속성이기 때문에 데이터베이스에서 해당 값을 참조한다.4. 부모, 자식뷰를 활용하여 보완하기var body: some View {        NavigationStack {            List ((try? places.filter(predicate)) ?? places) { place in                NavigationLink(value: place) {                    HStack {                        place.image                            .resizable()                            .scaledToFit()                            .clipShape(.rect(cornerRadius: 7))                            .frame(width: 100, height: 100)                                                Text(place.name)                                                Spacer()                                                if place.intersted {                            Image(systemName: \"star.fill\")                                .foregroundStyle(.yellow)                                .padding(.trailing)                        }                    }                }                .matchedTransitionSource(id: 1, in: namespace) // added            }            .navigationTitle(\"Places\")            .searchable(text: $searchText, prompt: \"Find a Place\")            .animation(.default, value: searchText)            .navigationDestination(for: Place.self) { place in                MapView(place: place, position: .camera(MapCamera(                    centerCoordinate: place.location,                    distance: 1000,                    heading: 250,                    pitch: 80                )))                .navigationTransition(.zoom(sourceID: 1, in: namespace)) // added            }            .toolbar {                ToolbarItem(placement: .topBarTrailing) {                    Button(\"Show Images\", systemImage: \"photo\") {                        showImages.toggle()                    }                    .sheet(isPresented: $showImages) {                        Scrolling()                    }                }                                ToolbarItem(placement: .topBarLeading) {                    Button(\"filter\", systemImage: filterByInterested ? \"star.fill\" : \"star\") {                        withAnimation {                            filterByInterested.toggle()                        }                    }                    .tint(filterByInterested ? .yellow : .blue)                }            }        }    }그리고 ` @Namespace var namespace`를 추가해주었다.namespace와 id는 SwiftUI에서 애니메이션 및 뷰 간 전환(transition) 효과를 정의할 때 사용되는 요소들이다. namespace는 뷰 간의 일관된 애니메이션을 관리하기 위해 사용되고, id는 전환 효과가 적용될 대상 뷰를 식별하기 위해 사용된다.@Namespace  설명: @Namespace는 SwiftUI에서 뷰 간의 애니메이션 전환을 일관되게 관리할 수 있도록 도와주는 속성이다. 서로 다른 뷰가 같은 namespace를 공유하게 되면 SwiftUI는 뷰 간의 상태 변화에 대해 자연스러운 전환을 적용할 수 있다.  용도: 뷰 전환 시 matchedGeometryEffect 또는 matchedTransitionSource와 같은 기능을 사용할 때 @Namespace를 사용한다.id  설명: id는 특정 전환 효과나 애니메이션이 적용될 뷰를 식별하는 데 사용되는 고유한 식별자이다. 같은 namespace 내에서 id가 동일한 두 뷰는 전환 중에 서로 연결되어 자연스러운 애니메이션을 제공할 수 있다.  용도: SwiftUI에서 matchedTransitionSource 및 matchedTransitionDestination와 같은 수식어를 사용하여 특정 id를 기반으로 뷰 간의 전환을 설정할 수 있다.이렇게 클릭시 화면전환이 바뀐걸 알 수 있다.5. SwipeAction 추가하기.matchedTransitionSource(id: 1, in: namespace)                .swipeActions(edge: .leading) {                    Button(place.interested ? \"Interested\" : \"Not Interested\", systemImage: \"star\") {                        place.interested.toggle()                    }                }                .tint(place.interested ? .yellow : .gray)이렇게 밑에 swipeAction을 추가하고 버튼을 만들어 준다.작동이 잘 되는것을 확인할 수 있다."
  },
  
  {
    "title": "SwiftData",
    "url": "/posts/SwiftData/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-07-20 08:33:00 +0900",
    





    
    "snippet": "EmptyFile을 하나 만들어주고 이름을 Place.swift로 해주었다.그리고 3가지를 import해준다.import SwiftDataimport SwiftUIimport MapKit1. Data Modeling새로운 파일을 만들어서 모델링을 해도 되지만 여기서는 하나의 파일에 하는것같다.한가지 새로운점이라면 @Model을 사용했다는 점이다.@Mo...",
    "content": "EmptyFile을 하나 만들어주고 이름을 Place.swift로 해주었다.그리고 3가지를 import해준다.import SwiftDataimport SwiftUIimport MapKit1. Data Modeling새로운 파일을 만들어서 모델링을 해도 되지만 여기서는 하나의 파일에 하는것같다.한가지 새로운점이라면 @Model을 사용했다는 점이다.@Modelclass Place {    #Unique&lt;Place&gt;([\\.name, \\.latitude, \\.longitude])        @Attribute(.unique) var name: String    var latitude: Double    var longitude: Double    var intersted: Bool            init(name: String, latitude: Double, longitude: Double, intersted: Bool) {        self.name = name        self.latitude = latitude        self.longitude = longitude        self.intersted = intersted    }}UIKit를 사용하면서 했던 데이터 모델링과는 다른 양상을 보여준다.  @Model          @Model은 SwiftData에서 데이터 모델을 정의하는 데 사용되는 속성 래퍼이다. 이를 사용하면 클래스가 데이터 모델로 인식되도록 지정한다. SwiftData는 이러한 데이터 모델을 기반으로 데이터베이스에서 데이터를 저장하고 관리한다.      주요 특징              @Model이 적용된 클래스는 SwiftData의 데이터 모델로 인식된다.      @Model로 선언된 클래스의 인스턴스는 SwiftData의 데이터베이스에서 관리된다.      @Model은 자동으로 클래스의 속성을 추적하고, 데이터의 변경 사항을 감지하여 SwiftUI와 같은 프레임워크와 통합할 수 있다.        #Unique          #Unique는 SwiftData에서 사용되는 매크로로, 데이터 모델의 고유(유니크) 제약 조건을 설정하는 데 사용된다. 이 매크로는 특정 속성 조합이 데이터베이스에서 고유해야 함을 보장한다.      사용법              #Unique([\\.name, \\.latitude, \\.longitude])는 Place 모델의 name, latitude, longitude 조합이 고유해야 함을 나타낸다.      이는 데이터베이스 수준에서 중복 항목을 방지하고, 특정 조건이 만족될 때만 데이터가 삽입되거나 업데이트되도록 한다.    - 주요 특징      데이터의 무결성을 보장한다.      중복된 데이터 입력을 방지한다.      데이터베이스에서 Unique Index로 사용될 수 있다.        @Attribute          @Attribute는 SwiftData에서 모델 속성의 특성을 정의하는 데 사용되는 속성 래퍼이다. @Attribute(.unique)는 해당 속성이 고유해야 한다는 의미이다. SwiftData는 이를 사용하여 데이터베이스 내에서 속성의 유일성을 보장한다.      사용법              @Attribute(.unique) var name: String는 name 속성이 데이터베이스에서 고유해야 한다는 것을 나타낸다.      이 속성에 같은 값이 존재하는 경우 데이터베이스에 저장할 수 없도록 제약 조건을 설정한다.    - 주요 특징      속성에 제약 조건을 부여하여 데이터베이스 내에서 데이터 무결성을 보장한다.      다양한 제약 조건을 설정할 수 있으며, .unique는 그중 하나이다.      즉 여기서는      @Model: Place 클래스가 SwiftData의 데이터 모델로 인식되도록 지정한다. 이를 통해 이 클래스의 인스턴스는 SwiftData에서 관리되는 데이터베이스 엔티티가 된다.        #Unique&lt;Place&gt;([\\.name, \\.latitude, \\.longitude]): Place 모델의 name, latitude, longitude 속성 조합이 고유해야 함을 정의한다. 이를 통해 동일한 장소(같은 이름과 위치 조합)가 중복으로 저장되지 않도록 보장한다.        @Attribute(.unique) var name: String: name 속성이 데이터베이스에서 고유해야 함을 나타낸다. 이 속성에 중복된 값이 존재할 수 없으며, 데이터베이스에 저장할 때 이를 보장한다.  그리고 변수를 몇개 더 추가해줄 것이다.이때 변수는 Computed Properties로 만든다.var location: CLLocationCoordinate2D {        CLLocationCoordinate2D(latitude: latitude, longitude: longitude)    }    var image: Image {        Image(name.lowercased().replacingOccurrences(of: \" \", with: \"\"))    }첫번째는 좌표에 대한 변수이다. Computed Property로 하였고, 위, 경도 값을 리턴하게 한다.두번째는 이미지이다. 현재 Assets에 이미지들이 있는데 소문자로 되어있고, 띄어쓰기가 없는 상태이다.그래서 유져가 대문자와 띄어쓰기를 포함시켜서 입력을 해도 그것을 소문자로 바꾸면서, 공백을 없애도록 하였다.Image(name.lowercased().replacingOccurrences(of: \" \", with: \"\"))  lowercased(): 문자열을 소문자로 치환  eplacingOccurrences(of: “ “, with: “”): of의 값을 with의 값으로 치환.2. Sample Data 추가하기    static var previewPlaces: [Place] {        [            Place(name: \"Bellagio\", latitude: 36.1129, longitude: -115.1765, intersted: true),            Place(name: \"Paris\", latitude: 36.1125, longitude: -115.1707, intersted: true),            Place(name: \"Treasure Island\", latitude: 36.1247, longitude: -115.1721, intersted: false),            Place(name: \"Stratosphere\", latitude: 36.1475, longitude: -115.1566, intersted: false),            Place(name: \"Luxor\", latitude: 36.0955, longitude: -115.1761, intersted: false),            Place(name: \"Excalibur\", latitude: 36.0988, longitude: -115.1754, intersted: true),        ]    }다음과 같이 Sample Data를 만들어 주었다.3. Preview Container 만들어주기@MainActor    static var preview: ModelContainer {        let container = try! ModelContainer(for: Place.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))                for place in previewPlaces {            container.mainContext.insert(place)        }                return container    }  @MainActor 가 뭘까?                  @MainActor는 코드를 메인 스레드에서 실행하도록 보장하는 속성 래퍼이다. UI 관련 코드는 반드시 메인 스레드에서 실행되어야 한다.                  preview는 ModelContainer의 정적 변수이다. 프리뷰나 테스트를 위해 인메모리(in-memory) 데이터베이스를 생성하는 데 사용된다.          try! ModelContainer(for: Place.self, configurations: ModelConfiguration(isStoredInMemoryOnly: true))는 Place 모델을 관리하는 ModelContainer를 생성한다. isStoredInMemoryOnly: true는 데이터가 메모리에만 저장되고 영구 저장소에는 저장되지 않음을 의미한다.          for place in previewPlaces는 previewPlaces라는 샘플 데이터를 반복하며, container.mainContext.insert(place)로 각 Place 인스턴스를 mainContext에 삽입한다.          최종적으로, 준비된 container를 반환하여 프리뷰나 테스트 환경에서 사용할 수 있게 한다.                    그리고 메인으로 돌아와서@mainstruct VacationInVegasApp: App {    var body: some Scene {        WindowGroup {            ContentView()        }        .modelContainer(for: Place.self)    }}이렇게 modelContainer를 추가해준다.WindowGroup에 modelContainer를 설정하여 데이터 모델의 컨테이너를 지정한다. modelContainer는 SwiftData에서 모델 데이터를 관리하는 역할을 한다.  .modelContainer(for: Place.self)는 Place 모델을 관리하는 ModelContainer를 설정한다. 앱 내에서 Place 모델 데이터를 읽고 쓰는 작업을 수행할 수 있게 한다.  이 컨테이너는 WindowGroup과 연결되어 있어, 해당 뷰 계층 구조 내에서 Place 모델에 대한 데이터 작업을 할 수 있다.확실히 SwiftUI는 Wrapper가 있다보니 생소한게 많다.4. Database 접근을 위한 Query 작성PlaceList라는 파일을 만들어 주었고import SwiftUIimport SwiftDatastruct PlaceList: View {    @Query(sort: \\Place.name) private var places: [Place]        var body: some View {        List (places) { place in            HStack {                            }        }    }}#Preview {    PlaceList()        .modelContainer(Place.preview)}우선 이렇게 작성을 해주었다.이때 또 Wrapper가 나타나는데 Query이며 DB에 접근하여 값을 가져올때 무작위로 가져오므로 sorting을 통해 순서대로 정렬을 하기로 결정.여기서는 장소의 이름순으로 소팅을 해주었다.이렇게만 해줘도 Preview에 바로 row가 6개가 나온다왜냐 이전에 우리가 Sample Data를 6개 만들어 두었기 때문struct PlaceList: View {    @Query(sort: \\Place.name) private var places: [Place]        var body: some View {        List (places) { place in            HStack {                place.image                    .resizable()                    .scaledToFit()                    .clipShape(.rect(cornerRadius: 7))                    .frame(width: 100, height: 100)                                Text(place.name)            }        }    }}이렇게 해주니이렇게 나온다.여기서 우리가 아까 interested도 해주었기에 true/false에 따라 ⭐️가 나오게 해보자.struct PlaceList: View {    @Query(sort: \\Place.name) private var places: [Place]        var body: some View {        List (places) { place in            HStack {                place.image                    .resizable()                    .scaledToFit()                    .clipShape(.rect(cornerRadius: 7))                    .frame(width: 100, height: 100)                                Text(place.name)                                Spacer()                                if place.intersted {                    Image(systemName: \"star.fill\")                        .foregroundStyle(.yellow)                        .padding(.trailing)                }            }        }    }}이렇게 확인이 가능하다.5. NavigationStack 추가 하기navigationBar로 생각하면 될듯하다..toolbar {                ToolbarItem(placement: .topBarTrailing) {                    Button(\"Show Images\", systemImage: \"photo\") {                        showImages.toggle()                    }                }            }이렇게 toolbar를 하나 만들어 줄것이다.그리고 버튼을 하나 만들고 이름은 Show Images로 하고 디자인은 photo로 했다. 버튼이 눌러지면 토글이 되게한다.그렇기에 변수를 하나 만들어 준다.@State private var showImages = false위치는 위에 코드를 보면 topBarTrailing으로 해두어서 우상단에 위치한 걸 알 수 있다.6. 버튼에 기능을 추가하기이제 버튼을 만들었으니 기능을 추가해보자struct PlaceList: View {    @Query(sort: \\Place.name) private var places: [Place]        @State private var showImages = false        var body: some View {        NavigationStack {            List (places) { place in                HStack {                    place.image                        .resizable()                        .scaledToFit()                        .clipShape(.rect(cornerRadius: 7))                        .frame(width: 100, height: 100)                                        Text(place.name)                                        Spacer()                                        if place.intersted {                        Image(systemName: \"star.fill\")                            .foregroundStyle(.yellow)                            .padding(.trailing)                    }                }            }            .toolbar {                ToolbarItem(placement: .topBarTrailing) {                    Button(\"Show Images\", systemImage: \"photo\") {                        showImages.toggle()                    }                    .sheet(isPresented: $showImages) {                        Scrolling()                    }                }            }        }    }}isPresented는 showImages 상태 변수를 바인딩하여 시트(sheet)가 표시될지를 결정한다.showImages가 true일 때 시트가 나타나고, false일 때 시트가 사라진다..sheet(isPresented: $showImages)는 showImages가 변경될 때마다 시트의 표시 상태를 업데이트한다. sheet 내부에는 Scrolling() 뷰가 표시된다.  isPresented?          isPresented는 SwiftUI의 sheet modifier에서 사용되는 매개변수로, 시트(sheet) 뷰가 표시될지 여부를 결정하는 역할을 한다. isPresented는 Binding 타입으로, 이 값이 true일 때 시트가 화면에 나타나고, false일 때 시트가 사라진다. 이를 통해 뷰의 상태에 따라 시트의 표시 여부를 동적으로 제어할 수 있다.      7. predicates 사용하기1. Search Bar 만들기struct PlaceList: View {    @Query(sort: \\Place.name) private var places: [Place]        @State private var showImages = false    @State private var searchText = \"\"        var body: some View {        NavigationStack {            List (places) { place in                HStack {                    place.image                        .resizable()                        .scaledToFit()                        .clipShape(.rect(cornerRadius: 7))                        .frame(width: 100, height: 100)                                        Text(place.name)                                        Spacer()                                        if place.intersted {                        Image(systemName: \"star.fill\")                            .foregroundStyle(.yellow)                            .padding(.trailing)                    }                }            }            .navigationTitle(\"Places\")            .searchable(text: $searchText, prompt: \"Find a Place\")            .toolbar {                ToolbarItem(placement: .topBarTrailing) {                    Button(\"Show Images\", systemImage: \"photo\") {                        showImages.toggle()                    }                    .sheet(isPresented: $showImages) {                        Scrolling()                    }                }            }        }    }}SwiftUI를 공부하면서 느낀점은 UIComponent 추가하는게 너무 쉽게 느껴진다는 것이다.우선 검색어가 필요하므로 변수를 하나 만들어 주었다.@State private var searchText = \"\"그 이후 List의 }뒤에 (끝에) navigation Title과 서치바를 만들어 주어야 한다.일일이 대괄호를 찾기가 힘드니,저부분을 더블 클릭 해주면?좀 더 쉽게 확인이 가능해진다!.이렇게 Search Bar가 만들어졌다.하지만 아직 작동은 하지 않는다.그래서 Predicate를 만들어 줄 것이다.Computed Property를 활용을 해서 만들것이다.private var predicate: Predicate&lt;Place&gt; {        #Predicate&lt;Place&gt; {            if !searchText.isEmpty &amp;&amp; filterByInterested {                $0.name.localizedStandardContains(searchText) &amp;&amp; $0.intersted            } else if !searchText.isEmpty {                $0.name.localizedStandardContains(searchText)            } else if filterByInterested {                $0.intersted            } else {                true // default            }        }    }이렇게 작성을 해주었다.  localizedStandardContains(_:)          문자열이 다른 문자열을 포함하는지 여부를 확인하는 메서드로, 로케일에 따라 사용자의 언어 및 지역 설정에 맞게 비교를 수행한다. 이 메서드는 String 타입에서 사용할 수 있으며, 대소문자 구분 없이 검색어가 포함되어 있는지 검사한다. 특히 사용자에게 친숙한 방식으로 문자열을 비교하므로, 예를 들어 한국어나 다른 언어에서도 효과적으로 사용할 수 있다.      주요 특징  로케일 민감한 비교          로케일(언어 및 지역) 설정에 따라 문자열 비교를 수행한다.      즉, 영어와 같은 언어뿐만 아니라 한국어, 일본어 등 다양한 언어 환경에서도 유사한 문자열을 잘 인식한다.        대소문자 구분 없음          기본적으로 대소문자를 구분하지 않고 검색을 수행한다.      예를 들어, “Vacation”과 “vacation”은 동일하게 취급된다.        사용자가 기대하는 방식으로 비교          문자열 비교는 사용자에게 친숙한 방식으로 수행된다.      이는 특히 사용자가 다양한 언어로 데이터를 검색하는 앱에서 유용하다.      그리고 List ((try? places.filter(predicate)) ?? places) 이렇게 place 부분을 바꿔 주었다.그러면 filter를 통해 걸러지게 된다.2. 애니메이션 추가하기.navigationTitle(\"Places\")            .searchable(text: $searchText, prompt: \"Find a Place\")            .animation(.default, value: searchText)여기에 modifier인 animation을 추가해주자.뭔가 디퍼블 사용하는듯한 느낌이 든다.3. Toolbar Item 추가하기ToolbarItem(placement: .topBarLeading) {                    Button(\"filter\", systemImage: \"star\") {                        withAnimation {                            filterByInterested.toggle()                        }                    }                }trailing했던 부분 바로 밑에 하나를 더 만들어 주었다.이녀석은 interested = true인 것만 보여주는 녀석이다.이것 역시도 withAnimation을 추가하여 애니메이션 효과를 주었다.그리고 지금은 버튼이 클릭이 되었는지 아닌지 결과를 보고 해야하기에 툴바 버튼을 삼항연산자를 통해 색이 바뀌게 해보자. ToolbarItem(placement: .topBarLeading) {                    Button(\"filter\", systemImage: filterByInterested ? \"star.fill\" : \"star\") {                        withAnimation {                            filterByInterested.toggle()                        }                    }                    .tint(filterByInterested ? .yellow : .blue)                }완료."
  },
  
  {
    "title": "ScrollView",
    "url": "/posts/ScrollView/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-07-19 08:33:00 +0900",
    





    
    "snippet": "struct ScrollImage: View {    let image: String        var body: some View {        Image(image)            .resizable()            .scaledToFit()            .clipShape(.rect(cornerRadius: 20))    ...",
    "content": "struct ScrollImage: View {    let image: String        var body: some View {        Image(image)            .resizable()            .scaledToFit()            .clipShape(.rect(cornerRadius: 20))            .scrollTransition { content, phase in                content                    .scaleEffect(phase.isIdentity ? 1 : 0.5)                    .opacity(phase.isIdentity ? 1 : 0.5)            }    }}scrollTransition의 phase:  scrollTransition 클로저 내부에서 phase는 현재 스크롤 상태를 나타내는 객체이다.  phase.isIdentity는 콘텐츠가 스크롤 상태의 기본 위치에 있는지 (true) 또는 전환 중인지 (false)를 나타낸다.  즉 어디에 있는지?isIdentity는 Bool 타입의 값으로, true일 때는 콘텐츠가 기본 상태(identity)에 있으며, false일 때는 애니메이션 또는 전환의 다른 상태에 있음을 나타낸다.예를 들어, 스크롤 애니메이션 중에 콘텐츠가 처음 위치에 있으면 isIdentity는 true가 되며, 스크롤에 의해 변형되거나 이동 중이라면 isIdentity는 false가 된다.위와 같이 Preview에서는 지금 false인 상태로 되는데 이유는 스크롤을 할때 어떤 상태인지를 보여주기 위해서이다!그리고 새롭게 파일을 만들고 다음과 같이 코드를 적어주었다.struct Scrolling: View {    var body: some View {        ScrollView {            VStack {                ScrollImage(image: \"bellagio\")                                ScrollImage(image: \"excalibur\")                                ScrollImage(image: \"luxor\")                                ScrollImage(image: \"paris\")                                ScrollImage(image: \"stratosphere\")                                ScrollImage(image: \"treasureisland\")            }            .padding()        }    }}그리고 ScollImage는 우리가 위에 만들어둔 구조체이다.그렇기에 위로 스크롤할때 opacity와 이미지 스케일이 변화가 되는것이다."
  },
  
  {
    "title": "Symbol Effects",
    "url": "/posts/Symbol-Effects/",
    "categories": "Udemy, SwiftUI",
    "tags": "SwiftUI",
    "date": "2024-07-19 07:33:00 +0900",
    





    
    "snippet": "SwiftUI의 구성파일을 SwiftUI로 설정하여 만들게 되면위와같이 2개의 파일이 생성이 된다.이전과는 다른 양식이다.import SwiftUI@mainstruct VacationInVegasApp: App {    var body: some Scene {        WindowGroup {            ContentView()      ...",
    "content": "SwiftUI의 구성파일을 SwiftUI로 설정하여 만들게 되면위와같이 2개의 파일이 생성이 된다.이전과는 다른 양식이다.import SwiftUI@mainstruct VacationInVegasApp: App {    var body: some Scene {        WindowGroup {            ContentView()        }    }}WindowGroup에 ContentView가 있는데,이것을 통해 화면에 보여준다라고 생각을 하면 된다.ContentView는 바로 ContentView.swift 이다.SwiftUI는 UIKit과는 달리 Preview가 제공이 되는데. 이것을 통해 내가 현재 어떤 작업을 하는지 가시적으로 확인이 가능해지는 장점이 있다.import SwiftUIstruct Symbols: View {    @State private var shouldIBounce = false    @State private var shouldIRotate = false        var body: some View {        VStack {            Image(systemName: \"globe\")                .font(.largeTitle)                .imageScale(.large)                .foregroundStyle(.tint)                .symbolEffect(.pulse)                        Image(systemName: \"airplane\")                .font(.largeTitle)                .imageScale(.large)                .foregroundStyle(.teal)                .symbolEffect(.wiggle)                        Image(systemName: \"wifi\")                .font(.largeTitle)                .imageScale(.large)                .foregroundStyle(.purple)                .symbolEffect(.variableColor.reversing)                        Image(systemName: \"person.crop.circle.badge.plus\")                .font(.largeTitle)                .imageScale(.large)                .foregroundStyle(.tint)                .symbolRenderingMode(.multicolor)                .symbolEffect(.bounce, value: shouldIBounce)                .onTapGesture {                    shouldIBounce.toggle()                }                        Image(systemName: \"cloud.sun.rain.fill\")                .font(.largeTitle)                .imageScale(.large)                .foregroundStyle(.gray, .yellow, .mint)                .symbolEffect(.bounce, value: shouldIBounce)                .onTapGesture {                    shouldIBounce.toggle()                }                        Image(systemName: \"arrow.clockwise.square\")                .font(.largeTitle)                .imageScale(.large)                .foregroundStyle(.blue.mix(with: .red, by: 0.75))                .symbolEffect(.rotate, value: shouldIRotate)                .onTapGesture {                    shouldIRotate.toggle()                }                        Image(systemName: \"sun.max.fill\")                .font(.largeTitle)                .imageScale(.large)                .foregroundStyle(.yellow)                .symbolEffect(.breathe)        }        .padding()    }}#Preview {    Symbols()}foregroundStyle은 색을 지정하는데 사용.symbolEffect는 말그대로 효과를 줄때 사용한다.이때 wiggle은 ios18이후에서 사용 가능하니 주의.ontapGesture도 역시 말그대로 탭을 했을때의 이벤트가 어떻게 될지를 정한다.결과는 다음과 같다.@state 란?상태 프로퍼티이며, 상태에 관한 가장 기본적인 형태이다.@state로 선언하며, 해당 뷰의 값이 변경될 때마다, 뷰를 다시 렌더링 하도록 한다.단, 뷰 내부에서만 사용가능하며, 외부에서는 직접적으로 접근을 할 수 없다.혹시나 해서 true로 바꾸고 하면 평상시에 계속 작동하지 않을까 했지만 작동하지 않았다.애니메이션 효과의 경우 동일한 값이 유지된 상태 즉 false, true로 유지된 상태에서는 작동하지 않고, 값이 변할때 작동을 하기에 ,toggle을 통해 값이 변경 됨에 따라 애니메이션이 작동하는 것이다."
  },
  
  {
    "title": "SwiftUI (4)",
    "url": "/posts/SwiftUI-(4)/",
    "categories": "Udemy, SwiftUI",
    "tags": "",
    "date": "2024-07-18 12:13:00 +0900",
    





    
    "snippet": "HackerNews API를 사용하여 앱 만들기.1. ListView(TableView)를 사용하여 만들기.예전에는 Text를 여러개 사용하면 에러가 났던 것 같은데, 현재는 가능하다.struct ContentView: View {    var body: some View {        List{            Text(\"Hello, world...",
    "content": "HackerNews API를 사용하여 앱 만들기.1. ListView(TableView)를 사용하여 만들기.예전에는 Text를 여러개 사용하면 에러가 났던 것 같은데, 현재는 가능하다.struct ContentView: View {    var body: some View {        List{            Text(\"Hello, world!\")            Text(\"Hi!\")        }    }}이렇게 리스트를 추가하니테이블뷰와 같은 녀석이 나왔다.2. Navigation View 추가하기Navigation Bar를 추가함으로써 뒤로돌아가기 용이하게 한다.struct ContentView: View {    var body: some View {        NavigationView {            List{                Text(\"Hello, world!\")                Text(\"Hi!\")            }                    }    }}지금은 보이지 않는다.1. Navigation Tilte 설정하기struct ContentView: View {    var body: some View {        NavigationView {            List{                Text(\"Hello, world!\")                Text(\"Hi!\")            }            .navigationBarTitle(\"H4X0R News\")        }    }}이때 Title의 위치가 중요한데뷰안에 해줘야 된다. 뷰 밖에 해주면 보이지 않는다.  잘못된 예시struct ContentView: View {    var body: some View {        NavigationView {            List{                Text(\"Hello, world!\")                Text(\"Hi!\")            }        }        .navigationBarTitle(\"H4X0R News\")    }}3. 게시글에 관한 struct 구성하기struct Post: Identifiable {    let id: String    let title: String}이렇게 Post 라는 Struct를 만들어 주었는데 여기서 눈여겨 봐야할 것은 바로 Identifiable 프로토콜이다.자세한건 Docs 를 참고하자.간단하게 정리를 하면 ID값이 필요할때 사용한다.그리고 ID를 가진다는것은 중복값이 없다는 것을 의미한다.그래서 id라는 변수나 상수가 없을때는 아래와 같이 에러가 뜬다.4. posts라는 배열의 변수를 만들어 ListView에 출력하기let posts = [    Post(id: \"1\", title: \"Hello\"),    Post(id: \"2\", title: \"Bonjour\"),    Post(id: \"3\", title: \"안녕\")]이렇게 posts라는 배열을 만들어 주었다.이제 ListView에 배열의 값을 출력하게 해보자.List를 입력하면 이렇게 여러가지를 선택할 수 있다.그러면 다음과 같이 되는데,data에는 우리가 새롭게 만든 배열을 넣어준다.rowContent는 Closure 형태를 사용하여 만들어준다.struct ContentView: View {    var body: some View {        NavigationView {            List(posts, rowContent: { post in                Text(post.title)            })            .navigationBarTitle(\"H4X0R News\")        }    }}struct ContentView: View {    var body: some View {        NavigationView {            List(posts) { post in                Text(post.title)            }            .navigationBarTitle(\"H4X0R News\")        }    }}두개의 코드는 같은 걸 의미한다. 취향차이즉 각 줄에 title을 넣어준다 라는 것!다음과 같이 보여지게 된다.5. API를 사용하여 값을 가져오기api는 사이트에서 확인.1. 가져올 값에 대한 데이터 모델링PostData라는 파일을 만들고 다음과 같이 해준다.struct Results: Decodable {    let hits: [Post]}struct Post: Decodable, Identifiable {    var id: String {        return objectID    }    let objectID: String    let points: Int    let title: String    let url: String}Post는 이전에 했던것과 중복되므로 이전것을 지워주도록 하자.Identifiable이 있어야 하므로, Computed Property를 사용하여 objectID를 리턴하도록 한다.2. Network Manager를 사용하여 API를 이용해 값을 가져오기class NetworkManageL: ObservableObject {        func fetchData() {        if let url = URL(string: \"http://hn.algolia.com/api/v1/search?tags=front_page\") {            let session = URLSession(configuration: .default)            let task = session.dataTask(with: url) { (data, response, error) in                if error == nil {                    let decoder = JSONDecoder()                    if let safeData = data {                        do {                            let results = try decoder.decode(Results.self, from: safeData)                        } catch {                            print(error)                        }                    }                }            }            task.resume()        }    }    }이건 이전에 많이 해봤던 것이라 설명은 패스하나 다른점이라면 바로 ObservableObject를 사용했다는 점!그렇다면 ObservableObject란 무엇일까?1. ObservableObjectObservableObject는 클래스가 상태 변화를 외부에 알릴 수 있도록 하는 프로토콜이다.ObservableObject를 준수하는 클래스는 상태가 변경되었음을 알리기 위해 SwiftUI에서 제공하는 objectWillChange 프로퍼티를 사용한다.ObservableObject를 채택한 클래스는 뷰와 함께 사용되어, 데이터가 변경될 때마다 해당 뷰를 자동으로 업데이트할 수 있다.  주요 특징          클래스에서만 사용할 수 있다. 구조체에는 사용할 수 없다.      ObservableObject 프로토콜을 준수하는 클래스는 상태가 변경되었음을 알리기 위해 SwiftUI 뷰에 바인딩된다.      SwiftUI는 ObservableObject 클래스 인스턴스의 변경을 감지하고, 이로 인해 뷰를 다시 렌더링한다.      여기까지 했다면 값을 출력하도록 할 것이다.class안에 var posts = [Post]() 로 배열을 하나 만들어 주자.이때 그냥 만드는 것이 아닌 @Published를 붙여주자!2. Published사실 이건 Combine을 사용할때 해봤지만 정리를 해본다.@Published는 ObservableObject 클래스 내에서 상태를 저장하고, 상태가 변경될 때마다 이를 알릴 수 있는 프로퍼티 래퍼이다.@Published 속성이 변경되면 SwiftUI는 이를 감지하고, 해당 속성을 사용하는 뷰를 자동으로 업데이트한다.  주요 특징          @Published는 ObservableObject에서만 사용 가능      @Published 프로퍼티의 값이 변경될 때마다 objectWillChange를 자동으로 호출하여 구독자에게 알린다.      SwiftUI의 데이터 바인딩과 밀접하게 연결되어 있어, 데이터를 쉽게 공유하고 업데이트할 수 있다.      그리고 networkManager 객체를 하나 만들어 준다.struct ContentView: View {        @ObservedObject var networkManaer = NetworkManager()        var body: some View {        NavigationView {            List(posts) { post in                Text(post.title)            }            .navigationBarTitle(\"H4X0R News\")        }    }}3. ObservedObject@ObservedObject는 뷰가 특정 ObservableObject를 관찰하도록 할 때 사용되는 프로퍼티 래퍼이다.@ObservedObject는 부모 뷰가 소유하고 있는 ObservableObject를 자식 뷰에서 사용할 때 주로 사용된다.  주요 특징          @ObservedObject를 사용하면 뷰가 해당 객체의 변경 사항을 관찰하고, 객체의 값이 변경될 때마다 뷰가 자동으로 다시 렌더링된다.      @ObservedObject는 뷰 내에서 다른 뷰 모델을 공유할 수 있게 해준다.      @StateObject와 달리 @ObservedObject는 객체의 생명 주기를 관리하지 않는다.                  즉, 뷰가 업데이트될 때마다 객체가 새로 생성되지 않는다.                    다시 돌아와서 정리를 해보면.  ContentView가 생성되고 NetworkManager 인스턴스를 @ObservedObject로 초기화.  ContentView가 화면에 나타나면 onAppear를 통해 fetchData() 메서드가 호출됨.  NetworkManager의 fetchData()가 네트워크 요청을 비동기적으로 수행.  데이터가 성공적으로 수신되면, 메인 스레드에서 @Published var posts를 업데이트.  posts가 변경되면 SwiftUI는 이를 감지하고 ContentView를 다시 렌더링.  업데이트된 데이터로 List가 다시 렌더링되어 사용자에게 표시됨.3. NetworkManager의 fetchData를 실행하도록 구현이렇게 networkManager를 구현했지만, 정작 중요한 fetchData를 실행할 부분은 어디에도 없다.이제 이부분을 실행하도록 하면 되는데 UIKit에서는 ViewDidLoad 같은 생명주기를 이용해서 앱이 실행될때마다 호출을 하는 방식이 있는데 SwiftUI에서는 앱의 생명주기를 어떻게 표현을 할까?→ 모든 ContentView에는 onAppear가 있다!struct ContentView: View {        @ObservedObject var networkManaer = NetworkManager()        var body: some View {        NavigationView {            List(networkManaer.posts) { post in                Text(post.title)            }            .navigationBarTitle(\"H4X0R News\")        }        .onAppear {            self.networkManaer.fetchData()        }    }}4. DispatchQueue를 사용하여 결과를 Main Thread에서 작업하기class NetworkManager: ObservableObject {        @Published var posts = [Post]()        func fetchData() {        if let url = URL(string: \"http://hn.algolia.com/api/v1/search?tags=front_page\") {            let session = URLSession(configuration: .default)            let task = session.dataTask(with: url) { (data, response, error) in                if error == nil {                    let decoder = JSONDecoder()                    if let safeData = data {                        do {                            let results = try decoder.decode(Results.self, from: safeData)                            DispatchQueue.main.async {                                self.posts = results.hits                            }                        } catch {                            print(error)                        }                    }                }            }            task.resume()        }    }    }이렇게 값만 해주면 끄읏.단 url이 없는 경우도 있으므로 옵셔널로 바꿔주자.let url: String?6. Hstack을 사용하여 숫자도 표현하기HStack {                    Text(String(post.points))                    Text(post.title)                }뭐 이건 설명할게 없어서 패스7. 새로운 뷰를 만들고 list의 row를 클릭시 화면이 전환되게 구현하기우선 DetailView라는 SwiftUI파일을 하나 만들어 준다.그리고 url이라는 상수를 하나 만들어 준다.struct DetailView: View {        let url: String?        var body: some View {        Text(\"Hello, World!\")    }}1. Navigation Link를 사용하여 연결하기이것도 역시 여러 선택지가 있는데, 해당부분을 선택 하도록 하자.뭐랄까 UIKit의 TableView에서의 didSelectRowAt 같은 느낌으로 보면 될 것 같다.여기서 destination은 말 그대로 클릭시 전환될 부분이다.마치 우리가 예전에 TableView를 만들고서, 다음 화면으로 전환을 할때, 새로운 VC를 만들어서 그곳에 데이터를 넘기면서 전환을 하던것으로 생각하면 이해하기가 쉽다.이전 글을 보며 회상하면 좋을 듯 하다.거기선 스토리 보드를 사용 하였기에 instantiateViewController를 통해서 VC를 인스턴스화 해주었다.label은 그 destination에서 보여줄 내용에 관한것을 담아준다.먼저 label은 엔터를 쳐서 Closure 형태로 만들어 준다.그리고 그 내용는 이전에 있던 Hstack의 내용을 그냥 이동해주자.struct ContentView: View {        @ObservedObject var networkManaer = NetworkManager()        var body: some View {        NavigationView {            List(networkManaer.posts) { post in                NavigationLink(destination: DetailView(url: post.url)) {                    HStack {                        Text(String(post.points))                        Text(post.title)                    }                }            }            .navigationBarTitle(\"H4X0R News\")        }        .onAppear {            self.networkManaer.fetchData()        }    }}현재 클릭시에는 내용의 변화는 없다.단지 화면의 변화만 생긴다.8. DetailView에서 내용을 출력하기화면의 변화만 생기는 이유는struct DetailView: View {        let url: String?        var body: some View {        Text(\"Hello, World!\")    }}이렇게 우리가 text를 Hello World라고 했기 때문이다1. uikit의 webView를 사용하여 url을 보여주기우선 WebKit을 import 해주자.그리고 WebView라는 새로운 구조체를 만들고 UIViewRepresentable 프로토콜을 따르게 만들자UIViewRepresentable이란?SwiftUI에서 UIView 사용 가능하게 해주는 프로토콜이다.struct WebView: UIViewRepresentable {    }그랬더니 다음과 같은 에러가 발생!현재 우리가 만들어둔 구조체가 UIViewRepresentable를 수행할 수 없다는 것이다.이런 에러는 TableView에서 프로토콜을 사용했을때 이러한 에러가 나서 numberOfRowsInSection, cellForRowAt 을 무조건 구현해야하는 것과 같은 맥락으로 이해하자.struct WebView: UIViewRepresentable {        let urlString: String?        func makeUIView(context: Context) -&gt; WebView.UIViewType {                return WKWebView()    }        func updateUIView(_ uiView: WKWebView, context: UIViewRepresentableContext&lt;WebView&gt;) {                if let safeString = urlString {            if let url = URL(string: safeString) {                let request = URLRequest(url: url)                uiView.load(request)            }        }    }    }이렇게 코드를 작성한다.Context는 다음과 같다.Flow는 다음과 같다.  DetailView가 로드된다.  DetailView에 url이 전달된다.  makeUIView 함수를 통해 WebKit의 WKWebView를 만들게 된다.  옵셔널 바인딩을 통해 url값이 있으면 view에 url의 내용을 출력한다.이렇게 로드가 되는것을 볼 수 있다.9. 코드 리팩토링WebView가 현재 DetailView.swift 파일에 같이 있기에 코드 관리를 좀 더 편하게 하고자 새롭게 파일을 만들어 준다.내용만 옮겨주면 끝.import SwiftUIimport WebKitstruct WebView: UIViewRepresentable {        let urlString: String?        func makeUIView(context: Context) -&gt; WebView.UIViewType {                return WKWebView()    }        func updateUIView(_ uiView: WKWebView, context: UIViewRepresentableContext&lt;WebView&gt;) {                if let safeString = urlString {            if let url = URL(string: safeString) {                let request = URLRequest(url: url)                uiView.load(request)            }        }    }    }#Preview {    WebView(urlString: \"https://www.google.com\")}"
  },
  
  {
    "title": "SwiftUI (3)",
    "url": "/posts/SwiftUI-(3)/",
    "categories": "Udemy, SwiftUI",
    "tags": "",
    "date": "2024-07-18 12:13:00 +0900",
    





    
    "snippet": "Dicee App 만들기1. ZStack을 사용하여 배경화면 설정하기.struct ContentView: View {    var body: some View {        ZStack {            Image(\"background\")                .resizable()                .ignoresSafeArea...",
    "content": "Dicee App 만들기1. ZStack을 사용하여 배경화면 설정하기.struct ContentView: View {    var body: some View {        ZStack {            Image(\"background\")                .resizable()                .ignoresSafeArea(.all)        }    }}이렇게 해서 assets에 있는 이미지를 가져오고 설정을 해준다.2. VStack을 사용하여 이미지 쌓기struct ContentView: View {    var body: some View {        ZStack {            Image(\"background\")                .resizable()                .ignoresSafeArea(.all)            VStack {                Image(\"diceeLogo\")                Image(\"dice1\")                    .resizable()                    .aspectRatio(contentMode: .fit)            }        }    }}이렇게 VStack을 사용하여 이미지를 쌓아주었다.3. 모듈화하여 관리하기주사위 이미지를 담당하는 부분을 따로 서브뷰로 추출하여 좀 더 관리하기 쉽게 만들어 본다.struct ContentView: View {    var body: some View {        ZStack {            Image(\"background\")                .resizable()                .ignoresSafeArea(.all)            VStack {                Image(\"diceeLogo\")                HStack {                    DiceView(n: 1)                }            }        }    }}struct DiceView: View {        let n: Int        var body: some View {        Image(\"dice\\(n)\")            .resizable()            .aspectRatio(contentMode: .fit)    }}그리고 주사위 이미지를 좀 더 유기적으로 관리하기위해서 n이라는 상수를 하나 만들어 주었다. 그리고 현재 n에는 1의 값을 부여 해줌으로써 주사위 이미지는 점이 1인 주사위가 나온다.4. HStack을 사용하여 주사위를 하나 더 추가struct ContentView: View {    var body: some View {        ZStack {            Image(\"background\")                .resizable()                .ignoresSafeArea(.all)            VStack {                Image(\"diceeLogo\")                HStack {                    DiceView(n: 1)                    DiceView(n: 1)                }            }        }    }}이렇게 해주니 이제 좀 느낌이 나기 시작한다5. Padding을 주어 이미지간의 간극 조절VStack {                Image(\"diceeLogo\")                HStack {                    DiceView(n: 1)                    DiceView(n: 1)                }                .padding(.horizontal)            }이때 안에 어떠한 값도 주지 않으면 4변이 다 패딩이 들어가므로 이를 원하지 않는다면 특정 값을 주도록 하자.여기선 가로만 패딩을 주기위해 horizontal을 사용.6. Button을 추가하고 디자인struct ContentView: View {    var body: some View {        ZStack {            Image(\"background\")                .resizable()                .ignoresSafeArea(.all)            VStack {                Image(\"diceeLogo\")                HStack {                    DiceView(n: 1)                    DiceView(n: 1)                }                .padding(.horizontal)                Button(\"Roll\")                {                                    }                .font(.system(size: 50))                .fontWeight(.heavy)                .foregroundStyle(.white)                .background(.red)                .padding()            }        }    }}struct DiceView: View {        let n: Int        var body: some View {        Image(\"dice\\(n)\")            .resizable()            .aspectRatio(contentMode: .fit)            .padding()    }}버튼 바로 다음에 .을 붙여서 해보았으나 되지 않았다.강의 버전과는 달리 버튼의 text는 바로 적을 수 있고, 버튼의 폰트나 이런 외적인 요소는 액선 뒤에다가 해줘야 적용이 된다.그리고 주사위 이미지간의 간격을 주기위해Diceview에도 똑같이 패딩을 준다.7. Spacer를 사용하여 이미지간 간격을 더 주기.struct ContentView: View {    var body: some View {        ZStack {            Image(\"background\")                .resizable()                .ignoresSafeArea(.all)            VStack {                Image(\"diceeLogo\")                Spacer()                HStack {                    DiceView(n: 1)                    DiceView(n: 1)                }                .padding(.horizontal)                Button(\"Roll\")                {                                    }                .font(.system(size: 50))                .fontWeight(.heavy)                .foregroundStyle(.white)                .background(.red)                .padding()            }        }    }}이렇게 스페이서를 넣어주니둘다 양끝으로 붙어 버린다.그래서 버튼과 hstack 사이에도 스페이서를 주어 간격을 준다.struct ContentView: View {    var body: some View {        ZStack {            Image(\"background\")                .resizable()                .ignoresSafeArea(.all)            VStack {                Image(\"diceeLogo\")                Spacer()                HStack {                    DiceView(n: 1)                    DiceView(n: 1)                }                .padding(.horizontal)                Spacer() // new                Button(\"Roll\")                {                                    }                .font(.system(size: 50))                .fontWeight(.heavy)                .foregroundStyle(.white)                .background(.red)                .padding()            }        }    }}이렇게 균등하게 분포가 되었음을 알 수 있다.8. button을 활용하여 주사위의 숫자를 바꾸기먼저 해야할것이 좌,우측 주사위의 숫자를 정해줘야한다.그래서 변수를 하나 ContentView안에서 만들어 준다.struct ContentView: View {        var leftDiceNumber = 1    var rightDiceNumber = 1        var body: some View {        ZStack {            Image(\"background\")                .resizable()                .ignoresSafeArea(.all)            VStack {                Image(\"diceeLogo\")                Spacer()                HStack {                    DiceView(n: leftDiceNumber)                    DiceView(n: rightDiceNumber)                }                .padding(.horizontal)                Spacer()                Button(\"Roll\")                {                                    }                .font(.system(size: 50))                .fontWeight(.heavy)                .foregroundStyle(.white)                .background(.red)                .padding()            }        }    }}이때 바뀐점은 HStack에서 DiceView의 n이 1이었지만 이제는 left,rightDiceNumber가 되었다는 것이다.이것을 활용하여 버튼의 Action Section에 랜덤함수를 이용하여 숫자를 1~6 사이의 숫자로 바뀌게 할것이다.아래는 Action에 관한 CodeButton(\"Roll\")                {                    leftDiceNumber = Int.random(in: 1...6)                    rightDiceNumber = Int.random(in: 1...6)                }하지만 에러가 발생한다.바꿀 수 없다는 것이다.  Struct안에 있는 변수는 Immutable이 라는 것이다.          값타입이기 때문이다.      그래서 이전에 작성한 글에서도 우리는 mutating을 사용하여 값을 바꿀 수 있게 하였다.  그러면 변수에도 똑같이 하면 되지않을까?          답은 No      애석하게도 mutating이라는 녀석은 함수를 선언할때만 가능하다.그렇다면 해결책은?바로 @state 이다.간단하게 정의를 하면 변수를 업데이트하고 contentview를 다시 생성하게 한다.더 자세한 내용은 Docs  확인."
  },
  
  {
    "title": "SwiftUI (2)",
    "url": "/posts/SwiftUI-(2)/",
    "categories": "Udemy, SwiftUI",
    "tags": "",
    "date": "2024-07-17 12:13:00 +0900",
    





    
    "snippet": "Personal Business Card App 만들기1. 배경색을 추가하자struct ContentView: View {    var body: some View {        ZStack {            Color(.green)                .ignoresSafeArea(.all)            Text(\"Hello, ...",
    "content": "Personal Business Card App 만들기1. 배경색을 추가하자struct ContentView: View {    var body: some View {        ZStack {            Color(.green)                .ignoresSafeArea(.all)            Text(\"Hello, world!\")        }    }}강의에서는 edgesIgnoringSafeArea를 사용하지만 현재는 Deprecated 되어있으므로 ignoreSafeArea를 사용하자.2. Text를 변경 하자struct ContentView: View {    var body: some View {        ZStack {            Color(red: 0.09, green: 0.63, blue: 0.52)                .ignoresSafeArea(.all)            Text(\"Harold Song\")                .font(Font.custom(\"Pacifico-Regular\", size: 40))                .bold()                .foregroundStyle(.white)        }    }}여기서 폰트를 드래그 앤 드롭하여 추가를 했지만 변화가 없다.이때는 Info.plist 파일을 수정 해줘야 한다.그런데 보이지 않는다?참고 하자그냥 target에서 수정을 하도록 하자.이렇게 추가를 해주면 된다.추가한 폰트가 적용이 되었음을 알 수 있다.3. VStack 추가하기이건 생략!추가로 Text를 더 추가하고 싶을때는 엔터치고 바로 적어도 되지만이렇게 드래그를 해서 추가도 가능하니 알아두자4. 이미지 추가하고 변경하기struct ContentView: View {    var body: some View {        ZStack {            Color(red: 0.09, green: 0.63, blue: 0.52)                .ignoresSafeArea(.all)            VStack {                Image(\"turtle\")                    .resizable()                    .aspectRatio(contentMode: .fit)                    .frame(width: 200.0, height: 150.0)                    .clipShape(Circle())                    .overlay(                        Circle().stroke(.white, lineWidth: 5)                    )                                Text(\"Harold Song\")                    .font(Font.custom(\"Pacifico-Regular\", size: 40))                    .bold()                    .foregroundStyle(.white)                Text(\"iOS Developer\")                    .foregroundStyle(.white)                    .font(.system(size: 25))            }        }    }}여기서 clipShape를 하게되면 원이 생긴다.그리고 stroke property를 통해 테두리 색과, 테두리의 굵기를 설정이 가능하다.clipShape(Circle())                    .overlay(                        Circle().stroke(.white, lineWidth: 5)                    )5. 구분선 추가하기Divider()를 사용하여 구분선을 추가해줄것이다.Challenge 1다음과 같이 번호를 입력하는 부분을 만들어 보자.Divider()  ZStack {    RoundedRectangle(cornerRadius: 25)    .frame(height: 50)    .foregroundStyle(.white)    Text(\"010-1234-5678\")                }처음해보는거라 조금 시간이 걸렸다.나는 위와같이 하였고 강의는 다음과 같이 했다.Divider()RoundedRectangle(cornerRadius: 25)    .fill(.white)    .frame(height: 50)    .overlay(        Text(\"010-1234-5678\")    )Challenge 2다음과 같이 전화 이미지와 텍스트를 같이 두기너무 1차원 적인 생각을 했다.Divider()                RoundedRectangle(cornerRadius: 25)                    .fill(.white)                    .frame(height: 50)                    .overlay(                        HStack {                            Image(systemName: \"phone.fill\")                                .foregroundStyle(.green)                            Text(\"010-1234-5678\")                        }                                            )HStack을 사용하면 되는것이었다.6. 별도의 View로 코드를 추출하기RoundedRectangle의 부분을 별도로 추출을 하고 싶을때는VHZStack을 추가하듯이 컨트롤 클릭을 하여 추출하면 된다.7. 모듈화 하기추출한 뷰를 모듈화를 하여 좀 더 관리하기 쉽게 만들어 보자.struct ContentView: View {    var body: some View {        ZStack {            Color(red: 0.09, green: 0.63, blue: 0.52)                .ignoresSafeArea(.all)            VStack {                Image(\"turtle\")                    .resizable()                    .aspectRatio(contentMode: .fit)                    .frame(width: 200.0, height: 150.0)                    .clipShape(Circle())                    .overlay(                        Circle().stroke(.white, lineWidth: 5)                    )                                Text(\"Harold Song\")                    .font(Font.custom(\"Pacifico-Regular\", size: 40))                    .bold()                    .foregroundStyle(.white)                Text(\"iOS Developer\")                    .foregroundStyle(.white)                    .font(.system(size: 25))                                Divider()                InfoView(                    text: \"010-1234-5678\", imageName: \"phone.fill\"                )                            }        }    }}#Preview {    ContentView()}InfoView.swift 파일을 새로 만들어 주었다.struct InfoView: View {        let text: String    let imageName: String        var body: some View {        RoundedRectangle(cornerRadius: 25)            .fill(.white)            .frame(height: 50)            .overlay(                HStack {                    Image(systemName: imageName)                        .foregroundStyle(.green)                    Text(text)                }                            )            .padding(.all)    }}#Preview(traits: .sizeThatFitsLayout) {    InfoView(text: \"hi\", imageName: \"phone.fill\")}그리고 sizeThatFitsLayout를 사용하게 되면 폰 베젤에서 렌더링 되지 않고 보이는데 적용이 안된다고 하면이걸 클릭하자.8. 모듈화한것을 사용하기다시 ContentView로 돌아가서InfoView(                    text: \"dongik369@naver.com\", imageName: \"envelope.fill\"                )이걸 추가해주자.그럼 이렇게 이젠 모듈화가 되어있기에 property만 변경해주면 된다."
  },
  
  {
    "title": "SwiftUI (1)",
    "url": "/posts/SwiftUI-(1)/",
    "categories": "Udemy, SwiftUI",
    "tags": "",
    "date": "2024-07-16 12:13:00 +0900",
    





    
    "snippet": "SwiftUI란?SwiftUI는 WWDC2019에 발표 된 새로운 UI Framework이다.특징  Declarative Syntax          선언형 프로그래밍이다.              코드의 가독성을 높이고, 유지 보수를 용이하게 한다.      개발과정을 단순화 하고, 더 직관적인 코드 작성을 가능하게 한다.        라이브 프리뷰를...",
    "content": "SwiftUI란?SwiftUI는 WWDC2019에 발표 된 새로운 UI Framework이다.특징  Declarative Syntax          선언형 프로그래밍이다.              코드의 가독성을 높이고, 유지 보수를 용이하게 한다.      개발과정을 단순화 하고, 더 직관적인 코드 작성을 가능하게 한다.        라이브 프리뷰를 제공          실시간 미리보기를 통해 코드를 작성하면서 동시에 UI의 변경사항을 확인 가능        반응형 UI          데이터와 UI의 바인딩을 통해 데이터가 변경될 때 자동으로 UI를 업데이트 한다.              @state, @Binding 과 같은 속성을 사용하여 상태 관리를 할 수 있다.        간결한 레이아웃 시스템          HStack, VStack, ZStack과 같은 간단한 레이아웃 도구를 사용하여 UI 요소들을 보다 수비게 배치를 할 수 있다.        다양한 애니메이션  다중 플랫폼 지원          SwiftUI는 iOS, macOS, watchOS, tvOS를 모두 지원하는 통합 프레임워크이다.              하나의 코드베이스로 여러 애플 플랫폼에서 동작하는 앱을 만들 수 있다.      I Am Rich 만들기이전에 UIKit으로 했다면 이번엔 SwiftUI로 해본다.여기서는 크게 적을건 없어보인다.우선 강의의 내용과 버전 차이가 심해서 알아두면 좋을 부분만 정리를 해본다.우선 어떤 property에 VHZStack을 쌓고 싶을때는 컨트롤 클릭을 하면 추가할 수 있다.폰트나 이것저것 추가를 하고싶은데 어떻게 해야할지 모른다면우리가 UIKit에서 UIcomponents를 추가힐때 처럼 단축키를 사용하여 더블 클릭해서 추가도 가능하다.단축키는 command + shift + lstruct ContentView: View {    var body: some View {        ZStack {            Color(.systemTeal)                .edgesIgnoringSafeArea(.all)            VStack {                Text(\"I Am Rich\")                    .font(.system(size: 40))                    .fontWeight(.bold)                    .foregroundStyle(Color.white)                Image(\"diamond\")                    .resizable()                    .aspectRatio(contentMode: .fit).frame(width: 200, height: 200)            }        }        .padding()    }}"
  },
  
  {
    "title": "231. 윤년",
    "url": "/posts/231.-%EC%9C%A4%EB%85%84/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-15 03:19:00 +0900",
    





    
    "snippet": "문제연도가 주어졌을 때, 윤년이면 1, 아니면 0을 출력하는 프로그램을 작성하시오.윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다.예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 ...",
    "content": "문제연도가 주어졌을 때, 윤년이면 1, 아니면 0을 출력하는 프로그램을 작성하시오.윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다.예를 들어, 2012년은 4의 배수이면서 100의 배수가 아니라서 윤년이다. 1900년은 100의 배수이고 400의 배수는 아니기 때문에 윤년이 아니다. 하지만, 2000년은 400의 배수이기 때문에 윤년이다.입력첫째 줄에 연도가 주어진다. 연도는 1보다 크거나 같고, 4000보다 작거나 같은 자연수이다.출력첫째 줄에 윤년이면 1, 아니면 0을 출력한다.예제 입력 1 2000예제 출력 1 1예제 입력 2 1999예제 출력 2 0"
  },
  
  {
    "title": "230. 시험 성적",
    "url": "/posts/230.-%EC%8B%9C%ED%97%98-%EC%84%B1%EC%A0%81/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-15 03:19:00 +0900",
    





    
    "snippet": "문제시험 점수를 입력받아 90 ~ 100점은 A, 80 ~ 89점은 B, 70 ~ 79점은 C, 60 ~ 69점은 D, 나머지 점수는 F를 출력하는 프로그램을 작성하시오.입력첫째 줄에 시험 점수가 주어진다. 시험 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.출력시험 성적을 출력한다.예제 입력 1 100예제 출력 1 Alet input ...",
    "content": "문제시험 점수를 입력받아 90 ~ 100점은 A, 80 ~ 89점은 B, 70 ~ 79점은 C, 60 ~ 69점은 D, 나머지 점수는 F를 출력하는 프로그램을 작성하시오.입력첫째 줄에 시험 점수가 주어진다. 시험 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.출력시험 성적을 출력한다.예제 입력 1 100예제 출력 1 Alet input = Int(readLine()!)!        switch input {    case 90...100 :        print(\"A\")    case 80...89 :        print(\"B\")    case 70...79 :        print(\"C\")    case 60...69 :        print(\"D\")    default:        print(\"F\")    }이부분은 switch-case로 하는게 더 깔끔할것 같아서 이렇게 해결하였다.물론 이전과 같이 삼항연산자도 가능하지만, 식별이 어려워지는 단점이 존재.그래서 if를 하게되면 괜시리 코드가 길어지므로 심플하게 할 수 있는 switch-case로 해결."
  },
  
  {
    "title": "229. 두 수 비교하기",
    "url": "/posts/229.-%EB%91%90-%EC%88%98-%EB%B9%84%EA%B5%90%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-15 03:19:00 +0900",
    





    
    "snippet": "문제두 정수 A와 B가 주어졌을 때, A와 B를 비교하는 프로그램을 작성하시오.입력첫째 줄에 A와 B가 주어진다. A와 B는 공백 한 칸으로 구분되어져 있다.출력첫째 줄에 다음 세 가지 중 하나를 출력한다.A가 B보다 큰 경우에는 ‘&gt;’를 출력한다.A가 B보다 작은 경우에는 ‘&lt;’를 출력한다.A와 B가 같은 경우에는 ‘==’를 출력한다.제한...",
    "content": "문제두 정수 A와 B가 주어졌을 때, A와 B를 비교하는 프로그램을 작성하시오.입력첫째 줄에 A와 B가 주어진다. A와 B는 공백 한 칸으로 구분되어져 있다.출력첫째 줄에 다음 세 가지 중 하나를 출력한다.A가 B보다 큰 경우에는 ‘&gt;’를 출력한다.A가 B보다 작은 경우에는 ‘&lt;’를 출력한다.A와 B가 같은 경우에는 ‘==’를 출력한다.제한-10,000 ≤ A, B ≤ 10,000예제 입력 1 1 2예제 출력 1 &lt;예제 입력 2 10 2예제 출력 2  예제 입력 3 5 5예제 출력 3 ==—```swift    let input = readLine()?.split(separator: “ “)    let A = Int(input![0])    let B = Int(input![1])let answer = A! &gt; B! ? \"&gt;\" : A! &lt; B! ? \"&lt;\" : \"==\"print(answer) ``` ---if문으로 할 수 있지만 삼항연산자로 하고싶어서 삼항연산자를 통해 풀었다.특이점이라면 삼항연산자를 중첩을 해서 해결 하였다는 것.보통의 삼항연산자의 경우아래처럼 if문을 심플하게 표현했다고 볼 수 있다.if a &gt; 0 {    print(\"1\")} else {    print(\"2\")}a &gt; 0 ? print(\"1\") : print(\"2\")? 뒤에 붙는게 참일경우, : 뒤에 붙는게 거짓일 경우이다.  삼항연산자를 중첩할때는      뒤에 거짓 조건일때에 또 다른 조건을 붙여서 중첩을 시키면 된다.  "
  },
  
  {
    "title": "228. 개",
    "url": "/posts/228.-%EA%B0%9C/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-10 03:19:00 +0900",
    





    
    "snippet": "문제아래 예제와 같이 개를 출력하시오.입력없음.출력개를 출력한다.예제 입력 1 예제 출력 1 |\\_/||q p|   /}( 0 )\"\"\"\\|\"^\"'    |||_/=\\\\__|—이 문제의 포인트는 \\을 어떻게 문자열로 인식하게 하여서 사용하느냐이다.다른언어에서는 ‘’ 이걸 사용했던것 같은데 그게 되지 않았다.그냥 \\두번 사용했더니 하나가 인식이 되었다.p...",
    "content": "문제아래 예제와 같이 개를 출력하시오.입력없음.출력개를 출력한다.예제 입력 1 예제 출력 1 |\\_/||q p|   /}( 0 )\"\"\"\\|\"^\"'    |||_/=\\\\__|—이 문제의 포인트는 \\을 어떻게 문자열로 인식하게 하여서 사용하느냐이다.다른언어에서는 ‘’ 이걸 사용했던것 같은데 그게 되지 않았다.그냥 \\두번 사용했더니 하나가 인식이 되었다.print를 통해 좌우 간격을 조절하여 성공."
  },
  
  {
    "title": "227. 고양이",
    "url": "/posts/227.-%EA%B3%A0%EC%96%91%EC%9D%B4/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-10 03:19:00 +0900",
    





    
    "snippet": "문제아래 예제와 같이 고양이를 출력하시오.입력없음.출력고양이를 출력한다.예제 입력 1 예제 출력 1 \\    /\\ )  ( ')(  /  ) \\(__)|—    print(\"\\\\    /\\\\\")    print(\" )  ( ')\")    print(\"(  /  )\")    print(\" \\\\(__)|\")이 문제의 포인트는 \\을 어떻게 문자열로 인식하게...",
    "content": "문제아래 예제와 같이 고양이를 출력하시오.입력없음.출력고양이를 출력한다.예제 입력 1 예제 출력 1 \\    /\\ )  ( ')(  /  ) \\(__)|—    print(\"\\\\    /\\\\\")    print(\" )  ( ')\")    print(\"(  /  )\")    print(\" \\\\(__)|\")이 문제의 포인트는 \\을 어떻게 문자열로 인식하게 하여서 사용하느냐이다.다른언어에서는 ‘’ 이걸 사용했던것 같은데 그게 되지 않았다.그냥 \\두번 사용했더니 하나가 인식이 되었다.print를 통해 좌우 간격을 조절하여 성공."
  },
  
  {
    "title": "226. 꼬마 정민",
    "url": "/posts/226.-%EA%BC%AC%EB%A7%88-%EC%A0%95%EB%AF%BC/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-10 03:19:00 +0900",
    





    
    "snippet": "문제꼬마 정민이는 이제 A + B 정도는 쉽게 계산할 수 있다. 이제 A + B + C를 계산할 차례이다!입력첫 번째 줄에 A, B, C (1 ≤ A, B, C ≤ 1012)이 공백을 사이에 두고 주어진다.출력A+B+C의 값을 출력한다.예제 입력 1 77 77 7777예제 출력 1 7931—    let input = readLine()!.split(...",
    "content": "문제꼬마 정민이는 이제 A + B 정도는 쉽게 계산할 수 있다. 이제 A + B + C를 계산할 차례이다!입력첫 번째 줄에 A, B, C (1 ≤ A, B, C ≤ 1012)이 공백을 사이에 두고 주어진다.출력A+B+C의 값을 출력한다.예제 입력 1 77 77 7777예제 출력 1 7931—    let input = readLine()!.split(separator: \" \")    let A = Int(input[0])!    let B = Int(input[1])!    let C = Int(input[2])!        print(A + B + C)크게 문제되는 부분이 없다."
  },
  
  {
    "title": "225. 곱셈",
    "url": "/posts/225.-%EA%B3%B1%EC%85%88/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-09 03:19:00 +0900",
    





    
    "snippet": "문제(세 자리 수) × (세 자리 수)는 다음과 같은 과정을 통하여 이루어진다.(1)과 (2)위치에 들어갈 세 자리 자연수가 주어질 때 (3), (4), (5), (6)위치에 들어갈 값을 구하는 프로그램을 작성하시오.입력첫째 줄에 (1)의 위치에 들어갈 세 자리 자연수가, 둘째 줄에 (2)의 위치에 들어갈 세자리 자연수가 주어진다.출력첫째 줄부터 넷째...",
    "content": "문제(세 자리 수) × (세 자리 수)는 다음과 같은 과정을 통하여 이루어진다.(1)과 (2)위치에 들어갈 세 자리 자연수가 주어질 때 (3), (4), (5), (6)위치에 들어갈 값을 구하는 프로그램을 작성하시오.입력첫째 줄에 (1)의 위치에 들어갈 세 자리 자연수가, 둘째 줄에 (2)의 위치에 들어갈 세자리 자연수가 주어진다.출력첫째 줄부터 넷째 줄까지 차례대로 (3), (4), (5), (6)에 들어갈 값을 출력한다.예제 입력 1 472385예제 출력 1 236037761416181720    var first = Int(readLine()!)!    var second = Int(readLine()!)!        print(first*(second%10))    print(first*((second/10)%10))    print(first*(second/100))    print(first*second)몫과 나머지를 이용해서 계산"
  },
  
  {
    "title": "224. 나머지",
    "url": "/posts/224.-%EB%82%98%EB%A8%B8%EC%A7%80/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-09 03:19:00 +0900",
    





    
    "snippet": "문제(A+B)%C는 ((A%C) + (B%C))%C 와 같을까?(A×B)%C는 ((A%C) × (B%C))%C 와 같을까?세 수 A, B, C가 주어졌을 때, 위의 네 가지 값을 구하는 프로그램을 작성하시오.입력첫째 줄에 A, B, C가 순서대로 주어진다. (2 ≤ A, B, C ≤ 10000)출력첫째 줄에 (A+B)%C, 둘째 줄에 ((A%C) + ...",
    "content": "문제(A+B)%C는 ((A%C) + (B%C))%C 와 같을까?(A×B)%C는 ((A%C) × (B%C))%C 와 같을까?세 수 A, B, C가 주어졌을 때, 위의 네 가지 값을 구하는 프로그램을 작성하시오.입력첫째 줄에 A, B, C가 순서대로 주어진다. (2 ≤ A, B, C ≤ 10000)출력첫째 줄에 (A+B)%C, 둘째 줄에 ((A%C) + (B%C))%C, 셋째 줄에 (A×B)%C, 넷째 줄에 ((A%C) × (B%C))%C를 출력한다.예제 입력 1 5 8 4예제 출력 1 1100—    let input = readLine()!.split(separator: \" \")    let A = Int(input[0])!    let B = Int(input[1])!    let C = Int(input[2])!    print((A+B)%C)    print(((A%C) + (B%C))%C)    print((A*B)%C)    print(((A%C)*(B%C))%C)이것도 크게 서술할게 없어서 패스"
  },
  
  {
    "title": "223. 1998년생인 내가 태국에서는 2541년생?!",
    "url": "/posts/223.-1998%EB%85%84%EC%83%9D%EC%9D%B8-%EB%82%B4%EA%B0%80-%ED%83%9C%EA%B5%AD%EC%97%90%EC%84%9C%EB%8A%94-2541%EB%85%84%EC%83%9D-!/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-09 03:19:00 +0900",
    





    
    "snippet": "문제ICPC Bangkok Regional에 참가하기 위해 수완나품 국제공항에 막 도착한 팀 레드시프트 일행은 눈을 믿을 수 없었다. 공항의 대형 스크린에 올해가 2562년이라고 적혀 있던 것이었다.불교 국가인 태국은 불멸기원(佛滅紀元), 즉 석가모니가 열반한 해를 기준으로 연도를 세는 불기를 사용한다. 반면, 우리나라는 서기 연도를 사용하고 있다. ...",
    "content": "문제ICPC Bangkok Regional에 참가하기 위해 수완나품 국제공항에 막 도착한 팀 레드시프트 일행은 눈을 믿을 수 없었다. 공항의 대형 스크린에 올해가 2562년이라고 적혀 있던 것이었다.불교 국가인 태국은 불멸기원(佛滅紀元), 즉 석가모니가 열반한 해를 기준으로 연도를 세는 불기를 사용한다. 반면, 우리나라는 서기 연도를 사용하고 있다. 불기 연도가 주어질 때 이를 서기 연도로 바꿔 주는 프로그램을 작성하시오.입력서기 연도를 알아보고 싶은 불기 연도 y가 주어진다. (1000 ≤ y ≤ 3000)출력불기 연도를 서기 연도로 변환한 결과를 출력한다.예제 입력 1 2541예제 출력 1 1998—let input = Int(readLine()!)!let answer = input - 543    print(answer)예제를 통해 차이가 543이란것을 알기에 input에서 빼주면 된다."
  },
  
  {
    "title": "222. ??!",
    "url": "/posts/222.-!/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-09 03:18:00 +0900",
    





    
    "snippet": "문제준하는 사이트에 회원가입을 하다가 joonas라는 아이디가 이미 존재하는 것을 보고 놀랐다. 준하는 놀람을 ??!로 표현한다. 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어졌을 때, 놀람을 표현하는 프로그램을 작성하시오.입력첫째 줄에 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어진다. 아이디는 알파벳 소문자로만 이루어져...",
    "content": "문제준하는 사이트에 회원가입을 하다가 joonas라는 아이디가 이미 존재하는 것을 보고 놀랐다. 준하는 놀람을 ??!로 표현한다. 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어졌을 때, 놀람을 표현하는 프로그램을 작성하시오.입력첫째 줄에 준하가 가입하려고 하는 사이트에 이미 존재하는 아이디가 주어진다. 아이디는 알파벳 소문자로만 이루어져 있으며, 길이는 50자를 넘지 않는다.출력첫째 줄에 준하의 놀람을 출력한다. 놀람은 아이디 뒤에 ??!를 붙여서 나타낸다.예제 입력 1 joonas예제 출력 1 joonas??!예제 입력 2 baekjoon예제 출력 2 baekjoon??!—let input = readLine()!    print(input+\"??!\")이것도 그냥 받아온 값에다가 ??!를 붙여주면 되기에 크게 문제가 없다."
  },
  
  {
    "title": "220. 사칙연산",
    "url": "/posts/221.-%EC%82%AC%EC%B9%99%EC%97%B0%EC%82%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-09 03:15:00 +0900",
    





    
    "snippet": "문제두 자연수 A와 B가 주어진다. 이때, A+B, A-B, A*B, A/B(몫), A%B(나머지)를 출력하는 프로그램을 작성하시오.입력두 자연수 A와 B가 주어진다. (1 ≤ A, B ≤ 10,000)출력첫째 줄에 A+B, 둘째 줄에 A-B, 셋째 줄에 A*B, 넷째 줄에 A/B, 다섯째 줄에 A%B를 출력한다.예제 입력 1 7 3예제 출력 1 10...",
    "content": "문제두 자연수 A와 B가 주어진다. 이때, A+B, A-B, A*B, A/B(몫), A%B(나머지)를 출력하는 프로그램을 작성하시오.입력두 자연수 A와 B가 주어진다. (1 ≤ A, B ≤ 10,000)출력첫째 줄에 A+B, 둘째 줄에 A-B, 셋째 줄에 A*B, 넷째 줄에 A/B, 다섯째 줄에 A%B를 출력한다.예제 입력 1 7 3예제 출력 1 1042121—let input = readLine()!.split(separator: \" \")    let A = Int(input[0])!    let B = Int(input[1])!    print(A+B)    print(A-B)    print(A*B)    print(A/B)    print(A%B)이건 뭐 그냥 위의 출력에 적혀있는대로 적어주면 답이기에 생략"
  },
  
  {
    "title": "220. A/B",
    "url": "/posts/220.-A%EB%82%98%EB%88%84%EA%B8%B0B/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-09 03:14:00 +0900",
    





    
    "snippet": "문제두 자연수 A와 B가 주어진다. 이때, A+B, A-B, A*B, A/B(몫), A%B(나머지)를 출력하는 프로그램을 작성하시오.입력두 자연수 A와 B가 주어진다. (1 ≤ A, B ≤ 10,000)출력첫째 줄에 A+B, 둘째 줄에 A-B, 셋째 줄에 A*B, 넷째 줄에 A/B, 다섯째 줄에 A%B를 출력한다.예제 입력 1 7 3예제 출력 1 10...",
    "content": "문제두 자연수 A와 B가 주어진다. 이때, A+B, A-B, A*B, A/B(몫), A%B(나머지)를 출력하는 프로그램을 작성하시오.입력두 자연수 A와 B가 주어진다. (1 ≤ A, B ≤ 10,000)출력첫째 줄에 A+B, 둘째 줄에 A-B, 셋째 줄에 A*B, 넷째 줄에 A/B, 다섯째 줄에 A%B를 출력한다.예제 입력 1 7 3예제 출력 1 1042121—import Foundationvar input = readLine()!.split(separator: \" \")var A = Double(input[0])!var B = Double(input[1])!print(A / B)처음에 아무 생각없이 Float를 하였지만 문제가 틀렸다.아마도 예제 입력 1에서의 조건이 틀렸기 때문으로 판단이 된다.Float 보다는 Double이 더 범위가 크다.그래서 Double로 변환하면서 해결Float  정밀도: 32비트 부동소수점 수를 저장  메모리 사용량: 4바이트를 사용.  유효 숫자 자릿수: 약 6~7자리의 유효 자릿수를 가진다.  사용 사례: 메모리 사용량이 중요한 경우나, 높은 정밀도가 필요하지 않은 경우에 사용Double  정밀도: 64비트 부동소수점 수를 저장  메모리 사용량: 8바이트를 사용.  유효 숫자 자릿수: 약 15자리의 유효 자릿수를 가진다.  사용 사례: 높은 정밀도가 요구되는 계산이나, 부동소수점 연산의 정확도가 중요한 경우에 사용"
  },
  
  {
    "title": "219. AxB",
    "url": "/posts/219.-AxB/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-09 03:13:00 +0900",
    





    
    "snippet": "문제두 정수 A와 B를 입력받은 다음, A-B를 출력하는 프로그램을 작성하시오.입력첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)출력첫째 줄에 A-B를 출력한다.예제 입력 1 3 2예제 출력 1 1—import Foundationvar input = readLine()!.split(separator: \" \")var A = Int...",
    "content": "문제두 정수 A와 B를 입력받은 다음, A-B를 출력하는 프로그램을 작성하시오.입력첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)출력첫째 줄에 A-B를 출력한다.예제 입력 1 3 2예제 출력 1 1—import Foundationvar input = readLine()!.split(separator: \" \")var A = Int(input[0])!var B = Int(input[1])!print(A * B)* 로만 바꾸면 되는 문제이기에 쉽게 해결"
  },
  
  {
    "title": "218. A-B",
    "url": "/posts/218.-A-B/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-09 03:12:00 +0900",
    





    
    "snippet": "문제두 정수 A와 B를 입력받은 다음, A-B를 출력하는 프로그램을 작성하시오.입력첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)출력첫째 줄에 A-B를 출력한다.예제 입력 1 3 2예제 출력 1 1—import Foundationvar input = readLine()!.split(separator: \" \")var A = Int...",
    "content": "문제두 정수 A와 B를 입력받은 다음, A-B를 출력하는 프로그램을 작성하시오.입력첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)출력첫째 줄에 A-B를 출력한다.예제 입력 1 3 2예제 출력 1 1—import Foundationvar input = readLine()!.split(separator: \" \")var A = Int(input[0])!var B = Int(input[1])!print(A - B)- 로만 바꾸면 되는 문제이기에 쉽게 해결"
  },
  
  {
    "title": "217. A+B",
    "url": "/posts/217.-A+B/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-07-09 03:11:00 +0900",
    





    
    "snippet": "[문제]두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.[입력]첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)[출력]첫째 줄에 A+B를 출력한다.[예제 입력 1] 1 2[예제 출력 1] 3import Foundationvar input = readLine()!.split(separator: \" \")va...",
    "content": "[문제]두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.[입력]첫째 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10)[출력]첫째 줄에 A+B를 출력한다.[예제 입력 1] 1 2[예제 출력 1] 3import Foundationvar input = readLine()!.split(separator: \" \")var A = Int(input[0])!var B = Int(input[1])!print(A + B)처음에는 문제를 왜 틀렸는지 이해가 안갔다.import Foundationvar A = Int(readLine()!)!var B = Int(readLine()!)!print(A + B)이렇게 2개를 받아서 처리를 하면 되는걸로 판단했는데보니까 첫째줄에 받는다가 포인트였던 것 같다.즉 이렇게 하면 2개씩 받기에 2줄이 되어버리는 것.split을 사용하여 해결한다오래간만에 복기  readLine          입력값을 받을 때 쓰이며 Return Type은 Optional 이다. 따라서 ! 를 통해서 강제unwrapping을 해야한다.        split          입력값이 하나의 줄에 여러개의 값이 특정한 구분자를 가지고 들어올때, 구분자를 기준으로 값을 나눌때 사용.      이때 리턴타압은 배열이 된다.      "
  },
  
  {
    "title": "Final (19)",
    "url": "/posts/Final-(19)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-18 01:00:00 +0900",
    





    
    "snippet": "애플 토큰 생성배포전 여러 자료를 찾아보다가, 애플 계정 관련해서는 토큰이 있어야 한다는것을 보고 구현을 해보려 한다.",
    "content": "애플 토큰 생성배포전 여러 자료를 찾아보다가, 애플 계정 관련해서는 토큰이 있어야 한다는것을 보고 구현을 해보려 한다."
  },
  
  {
    "title": "Final (18)",
    "url": "/posts/Final-(18)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-17 01:00:00 +0900",
    





    
    "snippet": "신고기능이전에는 textfield로 간단하게 했다면 이번에는 만들어둔 VC에 전달하게 한다.VM만 만들어 둔다.class ReportViewModel {        private let manageManager = ManageManager()        var managePublisher = PassthroughSubject&lt;Void, Err...",
    "content": "신고기능이전에는 textfield로 간단하게 했다면 이번에는 만들어둔 VC에 전달하게 한다.VM만 만들어 둔다.class ReportViewModel {        private let manageManager = ManageManager()        var managePublisher = PassthroughSubject&lt;Void, Error&gt;()        func addReportCount(uid: String, storeAddress: String, title: String, completion: @escaping () -&gt; Void) {        manageManager.getSpecificReview(uid: uid, storeAddress: storeAddress, title: title) { [weak self] querySnapshot, error in                        if let error = error {                self?.managePublisher.send(completion: .failure(error))            }                        if let documents = querySnapshot?.documents {                for doc in documents {                    let id = doc.documentID                    let data = doc.data()                    guard let reportCount = data[db_reportCount] as? Int else { return }                    let count = [db_reportCount: reportCount + 1]                    reviewCollection.document(id).setData(count, merge: true)                    self?.managePublisher.send(())                    completion()                }            }        }    }    }애플계정 로그아웃 문제 관리현재 로그아웃을 눌렀을때 로그아웃이 되어 메인페이지로 가는것이 아니라, 첫화면으로 돌아가는 이슈가 발생한다.이제 로그아웃이 제대로 되었을때 넘기기로 결정func signOut(completion: @escaping () -&gt; Void) {        signManager.signOutCurrentUser { [weak self] result in            switch result {            case .success:                self?.logoutPublisher.send(.success(()))                completion()            case .failure(let error):                self?.logoutPublisher.send(.failure(error))                completion()            }        }    }기존에는 completion이 없었는데, completion Handler를 추가함으로써 로그아웃이 되었을때 처리하는것으로 변경하였다."
  },
  
  {
    "title": "Final (17)",
    "url": "/posts/Final-(17)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-16 01:00:00 +0900",
    





    
    "snippet": "Custom TextField 설정class CustomTextField: UITextField {        init(placeholder: String, keyboardType: UIKeyboardType = .default, target: Any?, action: Selector) {        super.init(frame: .zero)  ...",
    "content": "Custom TextField 설정class CustomTextField: UITextField {        init(placeholder: String, keyboardType: UIKeyboardType = .default, target: Any?, action: Selector) {        super.init(frame: .zero)        self.placeholder = placeholder        leftViewMode = .always        borderStyle = .none        textColor = .black        keyboardAppearance = .light        clearButtonMode = .whileEditing        autocorrectionType = .no        spellCheckingType = .no                self.keyboardType = keyboardType                let toolBar = UIToolbar(frame: CGRect(x: 0, y: 0, width: UIView().frame.size.width, height: 36))        toolBar.barStyle = .default        toolBar.sizeToFit()        let doneButton = UIBarButtonItem(            title: \"Done\",            style: .plain,            target: target,            action: action)        toolBar.items = [            UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil),            doneButton        ]                toolBar.isUserInteractionEnabled = true        inputAccessoryView = toolBar    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }}이렇게 해서 이전에는 func로 했다면 이번엔 애초에 클래스를 하나 만들었다.완료.처음에 유져 인증시 검은 화면 나오는 부분 수정SceneDelegate에서func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {            guard let windowScene = (scene as? UIWindowScene) else { return }                        let window = UIWindow(windowScene: windowScene)            self.window = window                        let loadingVC = UIViewController()            loadingVC.view.backgroundColor = .white             let activityIndicator = UIActivityIndicatorView(style: .large)            activityIndicator.center = loadingVC.view.center            activityIndicator.startAnimating()            loadingVC.view.addSubview(activityIndicator)                        window.rootViewController = loadingVC            window.makeKeyAndVisible()                        configureInitialViewController()        }configureInitialViewController() 이 실행이 될때 그 찰나의 순간에 검은 화면으로 보이는 경우가 있다.이부분을 조금 더 바꿔주기 위해서 위와같이 VC를 하나 만들고 indicator를 띄우는 방식으로 했다.Completion 문제 해결현재가 문제가 되는 부분private func bind() {        viewModel.loginPublisher.sink { [weak self] completion in            switch completion {            case .finished:                return            case .failure(let error):                self?.showMessage(title: \"에러 발생\", message: \"\\(error.localizedDescription)발생했습니다.\")            }        } receiveValue: { _ in            let scene = UIApplication.shared.connectedScenes.first            if let sd: SceneDelegate = (scene?.delegate as? SceneDelegate) {                sd.switchToMainTabBarController()            }        }.store(in: &amp;cancellables)    }completion 부분에서 finished or failure가 한번 발생하게 되면 이후에 다시 재작동을 안하게 된다.우선 publisher를 변경한다.// beforevar loginPublisher = PassthroughSubject&lt;Void, Error&gt;()// aftervar loginPublisher = PassthroughSubject&lt;Result&lt;Void, Error&gt;, Never&gt;()우선 PassthroughSubject의 속성을 알아야 한다.output과 failure로 전달을 하게 되는데나는 여기서 Failure에 Error를 전달을 했던 것.그러다보니 sinke에 자연스럽게 completion이 생겼던 것이고, 한번 completion이 발생하고나선 이후에 해당 부분이 skip이 되는 상황이 발생 했던 것.그래서 Failure에 Never를 전달하고, output에 result를 사용하여 void, Error로 기존처럼 전달을하게 했다.그래서 자연스럽게 bind 부분도 달라졌다.이렇게 같은 sink라도 completion이 있고 없고 다르다.이렇게 바꿔 줌으로써 문제 해결.private func bind() {        viewModel.loginPublisher.sink { [weak self] result in            switch result {            case .success():                let scene = UIApplication.shared.connectedScenes.first                if let sd: SceneDelegate = (scene?.delegate as? SceneDelegate) {                    sd.switchToMainTabBarController()                }            case .failure(let error):                self?.showMessage(title: \"에러 발생\", message: \"\\(error.localizedDescription)발생했습니다.\")            }        }.store(in: &amp;cancellables)    }위와 차이점은 성공 결과에 따라 전달은 되나 completion이 아니기에 subscription이 유지 된다라는 가장 큰 차이점이 존재.계정 생성시 realtimeDatabase에 추가 안되던 문제 수정팀원분의 제보로 계정을 새로 만들면 무한로딩이 발생한다는것을 알게 되었다.func googleLoginDidTapped(presentViewController: UIViewController) {    // 중략                                        if let snapshot = snapshot {                        let userData = snapshot.value as! [String: Any]                        let isBlockInt = userData[db_isBlock] as? Int ?? 0                        let isBlock = isBlockInt != 0                        if isBlock {                            let error = NSError(domain: \"\", code: 403, userInfo: [NSLocalizedDescriptionKey: \"현재 계정은 계정차단 관련 문제가 \"])                            self?.loginPublisher.send(completion: .failure(error))                            self?.signOut()                        } else {                            self?.loginPublisher.send(())                        }                    } else {                        let model = UserModel(uid: user.uid, email: email!, isBlock: false, nickName: \"\", profileImageUrl: \"https://firebasestorage.googleapis.com/v0/b/tteoppokki4u.appspot.com/o/dummyProfile%2FdefaultImage.png?alt=media&amp;token=b4aab21e-e19a-42b7-9d17-d92a3801a327\")                        self?.signManager.saveUserData(user: model)                        self?.loginPublisher.send(())                    }                }            }        }    }여기서 옵셔널 바인딩하면서 당연히 예외로 새로 생성을 한다고 생각했던게 잘못 되었다.그래서 snapshot의 존재유무로 확인하려 했으나 바로 exception 발생func googleLoginDidTapped(presentViewController: UIViewController) {    // 중략                                        if let snapshot = snapshot {                        if snapshot.exists() {                            let userData = snapshot.value as! [String: Any]                            let isBlockInt = userData[db_isBlock] as? Int ?? 0                            let isBlock = isBlockInt != 0                            if isBlock {                                let error = NSError(domain: \"\", code: 403, userInfo: [NSLocalizedDescriptionKey: \"현재 계정은 계정차단 관련 문제가 \"])                                self?.loginPublisher.send( .failure(error))                                self?.signOut()                            } else {                                self?.loginPublisher.send(.success(()))                            }                        } else {                            let model = UserModel(uid: user.uid, email: email!, isBlock: false, nickName: \"\", profileImageUrl: \"https://firebasestorage.googleapis.com/v0/b/tteoppokki4u.appspot.com/o/dummyProfile%2FdefaultImage.png?alt=media&amp;token=b4aab21e-e19a-42b7-9d17-d92a3801a327\")                            self?.signManager.saveUserData(user: model)                            self?.loginPublisher.send(.success(()))                        }                                            }                }            }        }}func googleLoginDidTapped(presentViewController: UIViewController) {                                        if let snapshot = snapshot {                        if let userData = snapshot.value as? [String: Any] {                            let isBlockInt = userData[db_isBlock] as? Int ?? 0                            let isBlock = isBlockInt != 0                            if isBlock {                                let error = NSError(domain: \"\", code: 403, userInfo: [NSLocalizedDescriptionKey: \"현재 계정은 계정차단 관련 문제가 \"])                                self?.loginPublisher.send(.failure(error))                                self?.signOut()                            } else {                                self?.loginPublisher.send(.success(()))                            }                        } else {                            let model = UserModel(uid: user.uid, email: email!, isBlock: false, nickName: \"\", profileImageUrl: \"https://firebasestorage.googleapis.com/v0/b/tteoppokki4u.appspot.com/o/dummyProfile%2FdefaultImage.png?alt=media&amp;token=b4aab21e-e19a-42b7-9d17-d92a3801a327\")                            self?.signManager.saveUserData(user: model)                            self?.loginPublisher.send(.success(()))                        }                    }                }            }        }    }userdata가 존재한다면 즉 document안에 값이 있다면으로 if문을 조금더 구체화 시켜주었다.문제 해결 완료."
  },
  
  {
    "title": "Final (16)",
    "url": "/posts/Final-(16)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-15 01:00:00 +0900",
    





    
    "snippet": "신고 기능 구현커뮤니티, 리뷰같은 특성상 이미지와 내용이 중요한데, 이때 폭력적, 선정적인 내용이 담겼을때 신고를 할 수 있게 하여 사후처리를 할 수있게 해야한다.해당 기능이 없을 경우 앱 배포 심사시 Reject사유가 충분히 될 수 있으므로, 해당기능을 구현해보려 한다.우선 리뷰를 보는 VC(DetailedReviewVC)에 button을 하나 추가...",
    "content": "신고 기능 구현커뮤니티, 리뷰같은 특성상 이미지와 내용이 중요한데, 이때 폭력적, 선정적인 내용이 담겼을때 신고를 할 수 있게 하여 사후처리를 할 수있게 해야한다.해당 기능이 없을 경우 앱 배포 심사시 Reject사유가 충분히 될 수 있으므로, 해당기능을 구현해보려 한다.우선 리뷰를 보는 VC(DetailedReviewVC)에 button을 하나 추가한다.우선은 Temporary로 textfield에 신고내용을 입력하게 했다.해당기능은 발표이후 수정 예정…@objc private func reportButtonTapped() {        let alert = UIAlertController(title: \"신고\", message: \"이 리뷰를 신고하시겠습니까?\", preferredStyle: .alert)                // 텍스트 필드 추가        alert.addTextField { textField in            textField.placeholder = \"신고 사유를 입력해 주세요\"        }                alert.addAction(UIAlertAction(title: \"예\", style: .default, handler: { _ in            if let reason = alert.textFields?.first?.text {                print(\"신고 사유: \\(reason)\")            }            self.showMessage(title: \"신고\", message: \"리뷰가 신고되었습니다.\")            //let reportVC = ReportViewController()            //self.present(reportVC, animated: true)        }))        alert.addAction(UIAlertAction(title: \"아니오\", style: .cancel, handler: nil))                present(alert, animated: true, completion: nil)    }완료.오늘은 다른 잔잔바리 처리를 했지만 생략…"
  },
  
  {
    "title": "Final (15)",
    "url": "/posts/Final-(15)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-14 01:00:00 +0900",
    





    
    "snippet": "코드 리팩토링기존에 있던 걸 viewmodel로 넘겨서 좀더 단순하게 바꾼다.func checkUserisBlock(uid: String, completion: @escaping (Bool) -&gt; Void) {        signManager.fetchUserData(uid: uid) { error, dataSnapshot in         ...",
    "content": "코드 리팩토링기존에 있던 걸 viewmodel로 넘겨서 좀더 단순하게 바꾼다.func checkUserisBlock(uid: String, completion: @escaping (Bool) -&gt; Void) {        signManager.fetchUserData(uid: uid) { error, dataSnapshot in            if let dataSnapshot = dataSnapshot {                if let userData = dataSnapshot.value as? [String: Any] {                    let isBlockInt = userData[db_isBlock] as? Int ?? 0                    let isBlock = isBlockInt != 0                    if isBlock {                        completion(isBlock)                    } else {                        completion(isBlock)                    }                }            }        }    }이렇게 바꿔준다.이렇게하면 completion handler의 결과인 true / false에 따라서 처리만 해주면 된다.func configureInitialViewController() {        let auth = Auth.auth().currentUser        if auth != nil {            signViewModel.checkUserisBlock(uid: auth!.uid) { [weak self] isBlock in                if isBlock {                    self?.switchToGreetingViewController()                    self?.greetingVC.showMessage(title: \"차단 알림\", message: \"현재 계정은 차단되었습니다.\\n관리자에게 문의하세요\")                } else {                    self?.switchToMainTabBarController()                }            }        } else {            switchToGreetingViewController()        }    }수정 완료.ReportVC 디자인코드는 생략..오늘은 두통이 좀 심해서 여기까지…"
  },
  
  {
    "title": "Final (14)",
    "url": "/posts/Final-(14)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-13 01:00:00 +0900",
    





    
    "snippet": "Cell 의존성 주입    private lazy var setButton: UIButton = {        let button = UIButton(type: .system)        button.setTitle(\"차단\", for: .normal)        button.setTitleColor(.systemBlue, for: .normal)...",
    "content": "Cell 의존성 주입    private lazy var setButton: UIButton = {        let button = UIButton(type: .system)        button.setTitle(\"차단\", for: .normal)        button.setTitleColor(.systemBlue, for: .normal)        button.addTarget(self, action: #selector(deactivate), for: .touchUpInside)        return button    }()        private lazy var unsetButton: UIButton = {        let button = UIButton(type: .system)        button.setTitle(\"해제\", for: .normal)        button.setTitleColor(.systemRed, for: .normal)        button.addTarget(self, action: #selector(activate), for: .touchUpInside)        return button    }()        var activateTapped: (() -&gt; Void)?    var deactivateTapped: (() -&gt; Void)?    @objc func deactivate() {        deactivateTapped?()        print(\"deactivate tapped\")    }        @objc func activate() {        activateTapped?()        print(\"activate tapped\")    }다른부분을 날리고 이렇게 했다.하지만 현재 작동을 하지 않는다 문제를 찾아봐야할거같다.뭔가 Layout에서 생기는 문제같다.문제 발견…몇시간 동안 고민했는데 결국 지피티한테 여러번 물어보면서 알게되었다.contentView.addSubview(titleLabel)contentView.addSubview(setButton)contentView.addSubview(unsetButton)지피티는 문제점을 처음에 내가 추가한 방식이 잘못되었다고 했다차이점  self.addSubview(view):          여기서 self는 UITableViewCell을 의미      이 경우, 서브뷰가 셀 자체에 추가        contentView.addSubview(view):          contentView는 UITableViewCell의 기본 제공 속성으로, 셀의 콘텐츠를 담는 뷰.      서브뷰를 contentView에 추가하면, 테이블 뷰 셀의 레이아웃과 스타일이 올바르게 적용된다.      애플은 모든 서브뷰를 contentView에 추가할 것을 권장. Docs      따라서, 서브뷰를 셀에 추가할 때는 항상 contentView를 사용해야 함.Manager 추가func editSpecificUser(uid: String, values: [String: Any], completion: @escaping ((any Error)?, DatabaseReference) -&gt; Void) {        ref.child(db_user_users).child(uid).updateChildValues(values, withCompletionBlock: completion)    }    func getSpecificReview(uid: String, storeAddress: String, title: String, completion: @escaping(QuerySnapshot?, (Error)?) -&gt; Void) {        reviewCollection.whereField(db_uid, isEqualTo: uid).whereField(db_storeAddress, isEqualTo: storeAddress).whereField(db_title , isEqualTo: title).getDocuments(completion: completion)    }이렇게 수정용으로 만들어 주었다.ViewModel 수정.func activateUser(uid: String, completion: @escaping ()-&gt; Void) {        let values = [db_isBlock: false]        manageManager.editSpecificUser(uid: uid, values: values) { [weak self] error, reference in            if let error = error {                self?.managePublisher.send(completion: .failure(error))            }            self?.managePublisher.send(())            completion()        }    }    func deactivateUser(uid: String, completion: @escaping ()-&gt; Void) {        let values = [db_isBlock: true]        manageManager.editSpecificUser(uid: uid, values: values) { [weak self] error, reference in            if let error = error {                self?.managePublisher.send(completion: .failure(error))            }            self?.managePublisher.send(())            completion()        }    }        func activateReview(uid: String, storeAddress: String, title: String, completion: @escaping () -&gt; Void) {                let data = [db_isActive: true]                manageManager.getSpecificReview(uid: uid, storeAddress: storeAddress, title: title) { [weak self] querySnapshot, error in                        if let error = error {                self?.managePublisher.send(completion: .failure(error))            }                        if let documents = querySnapshot?.documents {                for doc in documents {                    let id = doc.documentID                    reviewCollection.document(id).setData(data, merge: true)                    self?.managePublisher.send(())                    completion()                }            }        }    }    func deactivateReview(uid: String, storeAddress: String, title: String, completion: @escaping () -&gt; Void) {               let data = [db_isActive: false]                manageManager.getSpecificReview(uid: uid, storeAddress: storeAddress, title: title) { [weak self] querySnapshot, error in                        if let error = error {                self?.managePublisher.send(completion: .failure(error))            }                        if let documents = querySnapshot?.documents {                for doc in documents {                    let id = doc.documentID                    reviewCollection.document(id).setData(data, merge: true)                    self?.managePublisher.send(())                    completion()                }            }        }            }작동 확인 완료.이제 제대로 된 값을 입력했을때 넘어가게 구현VM에는 할수없는것이라 VC에서 작성extension GreetingViewController {        func generate(completion: @escaping (Bool) -&gt; Void) {        let key = Secret().key        let alert = UIAlertController(title: \"관리자 전용\", message: \"관리자 인증용 Key를 입력하세요.\", preferredStyle: .alert)             alert.addTextField { textField in            textField.placeholder = \"Key\"        }        let confirmAction = UIAlertAction(title: \"확인\", style: .default) { _ in            let text = alert.textFields?.first?.text                        if text == key {                completion(true)            } else {                completion(false)            }        }        alert.addAction(confirmAction)                let cancelAction = UIAlertAction(title: \"Cancel\", style: .cancel) { _ in            completion(false)        }        alert.addAction(cancelAction)                present(alert, animated: true)    }    }그리고 SceneDelegate를 수정한다.hiddenTapped: {                self.greetingVC.generate(completion: { bool in                   if bool {                       self.greetingVC.present(self.manageVC, animated: true)                   }                })            },완료.이제 key값을 입력하면 유져, 게시글을 관리할수있는 vc가 나온다.프로필 수정 페이지 예외 처리문제는 아래와 같이 2가지가 존재한다.  프로필 사진을 변경하지 않고 닉네임만 변경하는 경우 무한로딩이 생기는 문제  프로필 이미지만 변경할 때는 닉네임이 들어가지 않아 “” 로 변경 되는 문제이부분에 대한 예외 처리를 하려고한다.우선 화면 이동시 현재 프로필 정보도 같이 넘긴다.case [0, 0]:            let personalInfoVC = PersonalInfoViewController()            personalInfoVC.gotProfileImage = currentImageUrl            personalInfoVC.profileName = currentName // added            navigationController?.pushViewController(personalInfoVC, animated: true)그리고 해당 VC에서 이미지를 저장할때 nil이거나 ““일때의 예외 처리를 하도록 구현.if userName == \"\" {            userName = profileName        }        if selectedImage == nil {            KingfisherManager.shared.retrieveImage(with: URL(string: gotProfileImage!)!) { [weak self] result in                switch result {                case .success(let image):                    selectedImage = image.image                case .failure(let error):                    self?.showMessage(title: \"에러 발생\", message: \"\\(error)가 발생했습니다\")                }            }        }해결 완료.로그인시 block인지 아닌지 확인func configureInitialViewController() {        let auth = Auth.auth().currentUser        if auth != nil {            signManager.fetchUserData(uid: auth!.uid) { [weak self] error, dataSnapshot in                if let dataSnapshot = dataSnapshot {                    if let userData = dataSnapshot.value as? [String: Any] {                        let isBlockInt = userData[db_isBlock] as? Int ?? 0                        let isBlock = isBlockInt != 0                        if isBlock {                            self?.switchToGreetingViewController()                            self?.greetingVC.showMessage(title: \"차단 알림\", message: \"현재 계정은 차단되었습니다.\\n관리자에게 문의하세요\")                        } else {                            self?.switchToMainTabBarController()                        }                                            }                }            }                    } else {            switchToGreetingViewController()        }    }SceneDelegate에 다음과 같이 코드를 구현리팩토링은 내일 하는걸로…하지만 로그인을 할때는 이게 반영이 되어있지않아서 로그인쪽도 코드를 다듬어본다.if let snapshot = snapshot {    if snapshot.exists() {        let userData = snapshot.value as! [String: Any]        let isBlockInt = userData[db_isBlock] as? Int ?? 0        let isBlock = isBlockInt != 0            if isBlock {                        let error = NSError(domain: \"\", code: 403, userInfo: [NSLocalizedDescriptionKey: \"현재 계정은 계정차단 관련 문제가 \"])                        self?.loginPublisher.send(completion: .failure(error))                        self?.signOut()                        } else {                                self?.loginPublisher.send(())                                }                            } else {                                let model = UserModel(uid: user.uid, email: email, isBlock: false, nickName: \"\", profileImageUrl: \"https://firebasestorage.googleapis.com/v0/b/tteoppokki4u.appspot.com/o/dummyProfile%2FdefaultImage.png?alt=media&amp;token=b4aab21e-e19a-42b7-9d17-d92a3801a327\")                                self?.signManager.saveUserData(user: model)                                self?.loginPublisher.send(())                            }                                                    }이런식으로 집어 넣어 줬다.완료.하지만 alert가 두번째부터는 안뜨는데 그건 내일 해야겠다."
  },
  
  {
    "title": "Final (13)",
    "url": "/posts/Final-(13)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-12 01:00:00 +0900",
    





    
    "snippet": "ManageVC 만들기유져나, 게시글 관리를 위한 VC를 만드려고한다.의존성 주입을 나름대로 해서 SceneDelegate에서 VC를 호출하게 했다.func switchToGreetingViewController() {        greetingVC = GreetingViewController(            appleTapped: { [wea...",
    "content": "ManageVC 만들기유져나, 게시글 관리를 위한 VC를 만드려고한다.의존성 주입을 나름대로 해서 SceneDelegate에서 VC를 호출하게 했다.func switchToGreetingViewController() {        greetingVC = GreetingViewController(            appleTapped: { [weak signViewModel] in                signViewModel?.appleLoginDidTapped()            },            googleTapped: { [weak signViewModel] in                signViewModel?.googleLoginDidTapped(presentViewController: self.greetingVC)},            hiddenTapped: {                 self.greetingVC.present(self.manageVC, animated: true)            },            viewModel: signViewModel)                window?.rootViewController = greetingVC    } ManageManager 만들기func fetchUsers(completion: @escaping ((any Error)?, DataSnapshot?) -&gt; Void) {        let ref = Database.database().reference()        ref.child(db_user_users).getData(completion: completion)    }    func fetchUserReviews(completion: @escaping (QuerySnapshot?, (any Error)?) -&gt; Void) {        reviewCollection.getDocuments(completion: completion)    }ViewModel 만들기private let manageManager: ManageManager        init(manageManager: ManageManager) {        self.manageManager = manageManager    }        var managePublisher = PassthroughSubject&lt;Void, Error&gt;()    @Published var userReview = [ReviewModel]()    @Published var userArray = [UserModel]()        func getUsers() {        manageManager.fetchUsers { [weak self] error, dataSnapshot in            self?.userArray.removeAll()            if let error = error {                self?.managePublisher.send(completion: .failure(error))            }            guard let dictionary = dataSnapshot?.value as? [String: [String: Any]] else { return }                        for (uid, userDict) in dictionary {                let email = userDict[db_email] as? String ?? \"\"                let nickName = userDict[db_nickName] as? String ?? \"\"                let profileImageUrl = userDict[db_profileImageUrl] as? String ?? \"\"                let isBlockInt = userDict[db_isBlock] as? Int ?? 0                let isBlock = isBlockInt != 0                                let model = UserModel(uid: uid, email: email, isBlock: isBlock, nickName: nickName, profileImageUrl: profileImageUrl)                self?.userArray.append(model)            }            self?.managePublisher.send(())        }    }        func getRevies() {        manageManager.fetchUserReviews { [weak self] querySnapshot, error in            self?.userReview.removeAll()            if let error = error {                self?.managePublisher.send(completion: .failure(error))            }                        if let snapshotDocuments = querySnapshot?.documents {                if !snapshotDocuments.isEmpty {                    for doc in snapshotDocuments {                        let data = doc.data()                        guard                            let uid = data[db_uid] as? String,                            let title = data[db_title] as? String,                            let storeName = data[db_storeName] as? String,                            let storeAddress = data[db_storeAddress] as? String,                            let content = data[db_content] as? String,                            let rating = data[db_rating] as? Float,                            let imageURL = data[db_imageURL] as? [String],                            let isActive = data[db_isActive] as? Bool,                            let createdAt = data[db_createdAt] as? Timestamp,                            let updatedAt = data[db_updatedAt] as? Timestamp                        else {                            print(\"error\")                            return                        }                        let reviewData = ReviewModel(uid: uid, title: title, storeAddress: storeAddress, storeName: storeName, content: content, rating: rating, imageURL: imageURL, isActive: isActive, createdAt: createdAt, updatedAt: updatedAt)                        self?.userReview.append(reviewData)                        self?.managePublisher.send(())                    }                }            }        }    }여기서 이상하게 안되었던부분이 바로 여기.let email = userDict[db_email] as? String ?? \"\"let nickName = userDict[db_nickName] as? String ?? \"\"let profileImageUrl = userDict[db_profileImageUrl] as? String ?? \"\"let isBlockInt = userDict[db_isBlock] as? Int ?? 0let isBlock = isBlockInt != 0guard let으로 처음에 했는데 자꾸 else로 빠져나가면서 원하는 데이터를 가져오지 못하는 경우가 생겼다.그래서 옵셔널 바인딩을 하기로 결정.VC 디퍼블 데이터 소스 적용// MARK: - Diffable DataSourceextension ManageViewController {    func configureDiffableDataSource() {        tableDatasource = UITableViewDiffableDataSource(tableView: manageView.tableView, cellProvider: { tableView, indexPath, itemIdentifier in                        let cell = tableView.dequeueReusableCell(withIdentifier: \"ManageTableViewCell\", for: indexPath) as! ManageTableViewCell                        switch itemIdentifier {            case .user(let users):                                cell.titleLabel.text = users.uid                                return cell            case .review(let review):                print(review)                cell.titleLabel.text = review.title                return cell            }                    })    }        func configureUserSnapshot() {        var userSnapshot = NSDiffableDataSourceSnapshot&lt;DiffableSectionModel, DiffableSectionItemModel&gt;()                userSnapshot.appendSections([.user])        let userItems = viewModel.userArray.map { DiffableSectionItemModel.user($0) }        userSnapshot.appendItems(userItems, toSection: .user)                tableDatasource?.apply(userSnapshot, animatingDifferences: true)    }        func configureReviewSnapshot() {        var reviewSnapshot = NSDiffableDataSourceSnapshot&lt;DiffableSectionModel, DiffableSectionItemModel&gt;()        reviewSnapshot.appendSections([.review])        let reviewItems = viewModel.userReview.map { DiffableSectionItemModel.review($0) }        reviewSnapshot.appendItems(reviewItems, toSection: .review)                tableDatasource?.apply(reviewSnapshot, animatingDifferences: true)    }    }완료.내일은 실제로 block을 해보는걸로…."
  },
  
  {
    "title": "Final (12)",
    "url": "/posts/Final-(12)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-11 01:00:00 +0900",
    





    
    "snippet": "이미지 업로드 TS1. 문제점현재 문제점은 이미지를 수정하게 되면 새롭게 이미지를 업로드 하는 방식으로 이루어 진다.그러다보니 Storage에 불필요한 데이터가 계속 쌓이게 되고, 이는 서버 용량에도 부담이 된다.그래서 이를 개선하기 위해 이미지를 수정하게 될 경우 파일 값을 일정하게하여 덮어씌우는 방식으로 하려고한다.2. 이미지 업로드func upl...",
    "content": "이미지 업로드 TS1. 문제점현재 문제점은 이미지를 수정하게 되면 새롭게 이미지를 업로드 하는 방식으로 이루어 진다.그러다보니 Storage에 불필요한 데이터가 계속 쌓이게 되고, 이는 서버 용량에도 부담이 된다.그래서 이를 개선하기 위해 이미지를 수정하게 될 경우 파일 값을 일정하게하여 덮어씌우는 방식으로 하려고한다.2. 이미지 업로드func uploadImage(image: UIImage) -&gt; AnyPublisher&lt;String, Error&gt; {        Future&lt;String, Error&gt; { promise in            let storageRef = Storage.storage().reference()            guard let imageData = image.jpegData(compressionQuality: 0.5) else {                return            }                        let imageRef = storageRef.child(\"images/\\(UUID().uuidString).jpg\")            imageRef.putData(imageData, metadata: nil) { metadata, error in                if let error = error {                    promise(.failure(error))                    return                }                                imageRef.downloadURL { url, error in                    if let error = error {                        promise(.failure(error))                    } else if let downloadURL = url {                        promise(.success(downloadURL.absoluteString))                    }                }            }        }        .eraseToAnyPublisher()    }UUID로 되어있던걸 uid+index를 붙여서 진행func uploadImage(image: UIImage, index: Int) -&gt; AnyPublisher&lt;String, Error&gt; {        Future&lt;String, Error&gt; { promise in            guard let uid = Auth.auth().currentUser?.uid else { return }            let storageRef = Storage.storage().reference()            guard let imageData = image.jpegData(compressionQuality: 0.3) else {                return            }                        let imageRef = storageRef.child(\"images/\\(uid)\\(index).jpg\")            imageRef.putData(imageData, metadata: nil) { metadata, error in                if let error = error {                    promise(.failure(error))                    return                }                                imageRef.downloadURL { url, error in                    if let error = error {                        promise(.failure(error))                    } else if let downloadURL = url {                        promise(.success(downloadURL.absoluteString))                    }                }            }        }        .eraseToAnyPublisher()    }        func uploadImages(images: [UIImage]) -&gt; AnyPublisher&lt;[String], Error&gt; {        let publishers = images.enumerated().map { (index, image) in            uploadImage(image: image, index: index + 1) // 인덱스를 1부터 시작        }        return Publishers.MergeMany(publishers)            .collect()            .eraseToAnyPublisher()    }이렇게되면 현재 유져의 최대 이미지 저장갯수는 5개 이다.Storage 관리도 완료."
  },
  
  {
    "title": "Final (11)",
    "url": "/posts/Final-(11)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-10 01:00:00 +0900",
    





    
    "snippet": "Extension을 사용한 Alert 구현extension UIViewController {        func showMessage(title: String, message: String, completion: (() -&gt; Void)? = nil) {        let alert = UIAlertController(title: title, ...",
    "content": "Extension을 사용한 Alert 구현extension UIViewController {        func showMessage(title: String, message: String, completion: (() -&gt; Void)? = nil) {        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"확인\", style: .default, handler: { _ in            completion?()        }))        alert.addAction(UIAlertAction(title: \"취소\", style: .default))        present(alert, animated: true)    }    func showMessageWithCancel(title: String, message: String, completion: (() -&gt; Void)? = nil) {        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"확인\", style: .default, handler: { _ in            completion?()        }))        alert.addAction(UIAlertAction(title: \"취소\", style: .default))        present(alert, animated: true)    }    }목적은 아래에서 서술WriteVC에서 등록, 수정이 완료되었을때 alert 구현기존에 했던 방식사실 두뇌회전이 잘 되지않아, 미봉책으로 약 4초의 텀을 주고 dismiss를 하게 했다.하지만 해당 문제는 서버상태에따라 달라지므로 허점투성이 이다.문제를 파악하고 있었지만 completion Handler를 통해서 하면 되지않을까? 라고 생각을 했는데,어제는 무슨 생각이 들었는지 안될것같다고 머리속으로 판단을 내서 시도조차 하지 않았다.그래서 튜터님께 여쭤봤는데 completion Hanler를 사용해보는게 어떻겠냐고 하셨다.생각만 하고 이게 맞나 싶다가 아니라고 못박고 하지않다가, 오늘 다시 튜터님께 말씀을 듣고 생각해보니 아이디어가 명확해져서 구현해본다.우선 alert를 삼항연산자로 구분했던것을 위에 하나의 extension을 사용함으로써 코드를 간소화해준다.두개는 같은 기능이지만 한줄로 간소화를 할 수있기에 효율적이다.private func reviewTapped() {        guard            let uid = Auth.auth().currentUser?.uid,            let title = titleTextField.text,            let content = contentTextView.text        else {            return        }        ProgressHUD.animate()        uploadImages(images: selectedImages)                    .sink(receiveCompletion: { [weak self] completion in                switch completion {                case .finished:                    break                case .failure(let error):                    self?.showMessage(title: \"에러 발생\", message: \"\\(error.localizedDescription)이 발생 했습니다.\")                }            }, receiveValue: { [weak self] imageURLs in                guard let self = self else { return }                                let dictionary: [String: Any] = [                    db_uid: uid,                    db_title: title,                    db_storeAddress: self.addressText!,                    db_storeName: self.storeTitleText!,                    db_content: content,                    db_rating: self.selectedRating,                    db_imageURL: imageURLs,                    db_isActive: false,                    db_createdAt: self.isEditMode ? self.review!.createdAt : Timestamp(date: Date()),                    db_updatedAt: Timestamp(date: Date())                ]                                                if isEditMode {                    viewModel.editUserReview(uid: uid, storeAddress: self.addressText!, title: review!.title, userDict: dictionary) {                        ProgressHUD.remove()                        self.showMessage(title: \"리뷰 수정\", message: \"리뷰가 수정 되었습니다.\") {                            self.navigationController?.popViewController(animated: true)                        }                    }                } else {                    viewModel.createReview(userDict: dictionary) {                        ProgressHUD.remove()                        self.showMessage(title: \"리뷰 등록\", message: \"리뷰가 등록 되었습니다\") {                            self.dismiss(animated: true, completion: nil)                        }                    }                }            })            .store(in: &amp;cancellables)    }수정 완료.프로필 저장 완료시 dismiss 처리func updateProfile(uid: String, nickName: String, profile: UIImage, completion: @escaping ((Result&lt;(),Error&gt;) -&gt; Void)) {                        let storageRef = Storage.storage().reference(forURL: \"gs://tteoppokki4u.appspot.com\")        let storageProfileRef = storageRef.child(db_user_profile).child(uid)        guard let imageData = profile.jpegData(compressionQuality: 0.8) else { return }                let metaData = StorageMetadata()        metaData.contentType = \"image/jpg\"                storageProfileRef.putData(imageData, metadata: metaData) { (metadata, error) in            if let error = error {                completion(.failure(error))                return            }                        storageProfileRef.downloadURL { (url, error) in                if let error = error {                    completion(.failure(error))                    return                }                                guard let downloadURL = url else { return }                let values = [db_nickName: nickName, db_profileImageUrl: downloadURL.absoluteString]                self.ref.child(db_user_users).child(uid).updateChildValues(values) { error, reference in                    if let error = error {                        completion(.failure(error))                        return                    }                    completion(.success(()))                }            }        }            }기존에는 Error만 전달 했다면, 지금은 Result를 사용하여 Success, Failure의 상태에 따라 void, error로 다르게 전달하게 했다.성공시에 void를 치는 이유는 성공했을때 데이터 전달을 할필요가 없기 때문이다.@objc func saveChanges() {        ProgressHUD.animate()        guard let uid = Auth.auth().currentUser?.uid else { return }        guard let image = profileImage else { return }        let userName = userNameTextField.text ?? \"\"                userManager.updateProfile(uid: uid, nickName: userName, profile: image) { [weak self] result in            switch result {            case .success(()):                ProgressHUD.dismiss()                self?.showMessage(title: \"수정 완료\", message: \"프로필 정보가 수정 되었습니다.\") {                    self?.navigationController?.popViewController(animated: true)                }            case .failure(let error) :                ProgressHUD.dismiss()                self?.showMessage(title: \"에러 발생\", message: \"\\(error.localizedDescription)가 발생했습니다.\")            }        }    }switch~case 문을 사용하여 이벤트 핸들링.완료.로그인 예외 상황처리현재 로그아웃 하고 다시 로그인을 하게 되는경우 SignManager의func saveUserData(user: UserModel) {        let ref = Database.database().reference()        let userData: [String: Any] = [            db_uid: user.uid,            db_nickName: \"\",            db_email: user.email,            db_profileImageUrl: \"https://firebasestorage.googleapis.com/v0/b/tteoppokki4u.appspot.com/o/dummyProfile%2FdefaultImage.png?alt=media&amp;token=b4aab21e-e19a-42b7-9d17-d92a3801a327\"        ]        ref.child(\"users\").child(user.uid).setValue(userData)    }이 메서드가 실행이 되면서 닉네임과 프로필 이미지 주소가 위의 내용으로 바뀌는 문제가 생긴다.이부분을 해결하려고 한다.지금 생각한건 realtimedatabase를 조회해서 해다 내용이 있으면 그대로 사용하는 함수를 구현하면 될듯하다.func fetchUserData(uid: String, completion: @escaping ((any Error)?, DataSnapshot?) -&gt; Void) {        let ref = Database.database().reference()        ref.child(\"users\").child(uid).getData(completion: completion)    }값을 조회하는 함수를 만들어준다.func googleLoginDidTapped(presentViewController: UIViewController) {                GIDSignIn.sharedInstance.signIn(withPresenting: presentViewController) { [weak self] signInResult, error in            if let error = error {                self?.loginPublisher.send(completion: .failure(error))            }                                    guard let result = signInResult else { return }                        let user = result.user            let idToken = user.idToken?.tokenString                        let credential = GoogleAuthProvider.credential(withIDToken: idToken!, accessToken: user.accessToken.tokenString)                        Auth.auth().signIn(with: credential) { result, error in                if let error = error {                    self?.loginPublisher.send(completion: .failure(error))                }                                guard let user = result?.user else { return }                                let uid = user.uid                let email = user.email                                self?.signManager.fetchUserData(uid: uid) { error, snapshot in                    if let error = error {                        self?.loginPublisher.send(completion: .failure(error))                    }                                        if let snapshot = snapshot {                        if snapshot.exists() {                            self?.loginPublisher.send(())                        } else {                            let model = UserModel(uid: uid, email: email!, isBlock: false, nickName: \"\", profileImageUrl: \"https://firebasestorage.googleapis.com/v0/b/tteoppokki4u.appspot.com/o/dummyProfile%2FdefaultImage.png?alt=media&amp;token=b4aab21e-e19a-42b7-9d17-d92a3801a327\")                            self?.signManager.saveUserData(user: model)                        }                    }                }                            }                        self?.loginPublisher.send()        }    }func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {                guard let credential = authorization.credential as? ASAuthorizationAppleIDCredential else { return }                let nonce = currentNonce                signManager.saveApple(appleCredential: credential, nonce: nonce!) { [weak self] result in            switch result {            case .success(let result):                if let user = result?.user {                    let email = credential.email ?? \"\"                    self?.signManager.fetchUserData(uid: user.uid) { error, snapshot in                        if let error = error {                            self?.loginPublisher.send(completion: .failure(error))                        }                        if let snapshot = snapshot {                            if snapshot.exists() {                                self?.loginPublisher.send(())                            } else {                                let model = UserModel(uid: user.uid, email: email, isBlock: false, nickName: \"\", profileImageUrl: \"https://firebasestorage.googleapis.com/v0/b/tteoppokki4u.appspot.com/o/dummyProfile%2FdefaultImage.png?alt=media&amp;token=b4aab21e-e19a-42b7-9d17-d92a3801a327\")                                self?.signManager.saveUserData(user: model)                            }                        }                    }                }            case .failure(let error):                self?.loginPublisher.send(completion: .failure(error))            }        }            }    snapshot이 존재한다면 그냥 넘어가고없으면 새롭게 생성하게 만들었다.작동 확인 완료."
  },
  
  {
    "title": "Final (10)",
    "url": "/posts/Final-(10)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-09 01:00:00 +0900",
    





    
    "snippet": "로그인 상태에따라 다른 페이지 보여주기.SceneDelegate에서 함수를 하나 만들어서 실행하면 문제가 해결될걸로 보인다.     if Auth.auth().currentUser != nil {               window.rootViewController = tabbarController           } else {          ...",
    "content": "로그인 상태에따라 다른 페이지 보여주기.SceneDelegate에서 함수를 하나 만들어서 실행하면 문제가 해결될걸로 보인다.     if Auth.auth().currentUser != nil {               window.rootViewController = tabbarController           } else {               window.rootViewController = greetingVC           }SceneDelegate 전면 수정func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {        configureInitialViewController()                guard let windowScene = (scene as? UIWindowScene) else { return }                let window = UIWindow(windowScene: windowScene)        self.window = window        window.makeKeyAndVisible()                configureInitialViewController()    }        func configureInitialViewController() {        if Auth.auth().currentUser != nil {            switchToMainTabBarController()        } else {            switchToGreetingViewController()        }    }        func switchToMainTabBarController() {        let tabbarController = UITabBarController()                greetingVC = GreetingViewController(            appleTapped: { [weak signViewModel] in                signViewModel?.appleLoginDidTapped()            },            kakaoTapped: { [weak signViewModel] in                signViewModel?.kakaoLoginDidTapped()            },            googleTapped: { [weak signViewModel] in                signViewModel?.googleLoginDidTapped(presentViewController: self.greetingVC)},            viewModel: signViewModel)                let mapVC = MapViewController()        let recommendVC = UINavigationController(rootViewController: RecommendViewController())        let communityVC = UINavigationController(rootViewController: CommunityViewController())        let mypageVC = UINavigationController(rootViewController: MyPageViewController(signOutTapped: { [weak signViewModel, weak self] in            signViewModel?.signOut()            self?.configureInitialViewController()        }, viewModel: signViewModel))                greetingVC.tabBarItem = UITabBarItem(            title: \"로그인테스트\",            image: UIImage(systemName: \"magnifyingglass.circle\"),            selectedImage: UIImage(systemName: \"magnifyingglass.circle.fill\"))        mapVC.tabBarItem = UITabBarItem(            title: \"지도\",            image: UIImage(systemName: \"map.circle\"),            selectedImage: UIImage(systemName: \"map.circle.fill\"))        recommendVC.tabBarItem = UITabBarItem(            title: \"추천\",            image: UIImage(systemName: \"hand.thumbsup\"),            selectedImage: UIImage(systemName: \"hand.thumbsup.fill\"))        communityVC.tabBarItem = UITabBarItem(            title: \"커뮤니티\",            image: UIImage(systemName: \"person.3\"),            selectedImage: UIImage(systemName: \"person.3.fill\"))        mypageVC.tabBarItem = UITabBarItem(            title: \"마이페이지\",            image: UIImage(systemName: \"person.crop.circle\"),            selectedImage: UIImage(systemName: \"person.crop.circle.fill\"))                tabbarController.viewControllers = [recommendVC, mapVC, communityVC, mypageVC]                window?.rootViewController = tabbarController    }        func switchToGreetingViewController() {        greetingVC = GreetingViewController(            appleTapped: { [weak signViewModel] in                signViewModel?.appleLoginDidTapped()            },            kakaoTapped: { [weak signViewModel] in                signViewModel?.kakaoLoginDidTapped()            },            googleTapped: { [weak signViewModel] in                signViewModel?.googleLoginDidTapped(presentViewController: self.greetingVC)},            viewModel: signViewModel)                window?.rootViewController = greetingVC    }        func scene(_ scene: UIScene, openURLContexts URLContexts: Set&lt;UIOpenURLContext&gt;) {        if let url = URLContexts.first?.url {            if (AuthApi.isKakaoTalkLoginUrl(url)) {                _ = AuthController.handleOpenUrl(url: url)            }        }    }아예 로그인 이후에 나오는 탭바 호출 함수, 로그인화면 호출 함수를 나누었고configureInitialViewController 메서드를 통해서 현재 로그인되어있는지 아닌지로 판단한다.그리고 로그아웃을 눌렀을때도 다시 첫화면으로 돌아가게 하기 위해서let mypageVC = UINavigationController(rootViewController: MyPageViewController(signOutTapped: { [weak signViewModel, weak self] in            signViewModel?.signOut()            self?.configureInitialViewController() // added        }, viewModel: signViewModel))여기를 추가하여 메인페이지로 돌아가게끔 했다.이후 GreetingVC 바인드 함수를 조금 수정private func bind() {        viewModel.loginPublisher.sink { [weak self] completion in            switch completion {            case .finished:                return            case .failure(let error):                let alert = UIAlertController(title: \"에러 발생\", message: \"\\(error.localizedDescription)이 발생했습니다.\", preferredStyle: .alert)                alert.addAction(UIAlertAction(title: \"확인\", style: .default))                self?.present(alert, animated: true)            }        } receiveValue: { _ in            let scene = UIApplication.shared.connectedScenes.first            if let sd: SceneDelegate = (scene?.delegate as? SceneDelegate) {                sd.switchToMainTabBarController()            }        }.store(in: &amp;cancellables)    }receiveValue쪽에 print(\"로그인\")만 되어있었는데sceneDelegate를 호출하면서 tabbarVC를 호출하는 함수를 불러왔다.로그아웃하고 로그인하면 유져 정보가 새롭게 씌워져서 프로필 이미지url이 날아가는 문제가 생기는데 이부분은 이따 고민해보는걸로가게에 대한 리뷰 표시StoreVC에 보여줄 Cell에 대해서 작성을 해보려한다.우선 StoreManager를 하나 만들어 주었다.class StoreManager {        func reqeustStore(storeAddress: String, completion: @escaping(QuerySnapshot?, (Error)?) -&gt; Void) {        reviewCollection.whereField(db_storeAddress, isEqualTo: storeAddress).getDocuments(completion: completion)    }    }Viewmodel 생성func getStoreReview(storeAddress: String) {        storeManager.reqeustStore(storeAddress: storeAddress) { [weak self] querySnapshot, error in            self?.userReview.removeAll()            if let error = error {                self?.reviewPublisher.send(completion: .failure(error))            }                        if let snapshotDocuments = querySnapshot?.documents {                if !snapshotDocuments.isEmpty {                    for doc in snapshotDocuments {                        let data = doc.data()                        guard                            let uid = data[\"uid\"] as? String,                            let title = data[\"title\"] as? String,                            let storeName = data[\"storeName\"] as? String,                            let storeAddress = data[\"storeAddress\"] as? String,                            let content = data[\"content\"] as? String,                            let rating = data[\"rating\"] as? Float,                            let imageURL = data[\"imageURL\"] as? [String],                            let isActive = data[\"isActive\"] as? Bool,                            let createdAt = data[\"createdAt\"] as? Timestamp,                            let updatedAt = data[\"updatedAt\"] as? Timestamp                        else {                            print(\"error\")                            return                        }                        let reviewData = ReviewModel(uid: uid, title: title, storeAddress: storeAddress, storeName: storeName, content: content, rating: rating, imageURL: imageURL, isActive: isActive, createdAt: createdAt, updatedAt: updatedAt)                        self?.userReview.append(reviewData)                        self?.reviewPublisher.send(())                    }                }            }        }    }VC에 함수 생성private func fetchRequest() {        viewModel.getStoreReview(storeAddress: addressText!)    }private func bind() {        viewModel.$userReview            .receive(on: DispatchQueue.main)            .sink { _ in                self.tableView.reloadData()            }.store(in: &amp;cancellables)                viewModel.reviewPublisher.sink { completion in            switch completion {            case .finished:                return            case .failure(let error):                print(error)            }        } receiveValue: { _ in        }.store(in: &amp;cancellables)       }로드가 안되어서 생각해보니 .receive(on: DispatchQueue.main) 이게 없어서 안되었다.애플 로그아웃이 뭔가 제대로 안되어서 수정여기는 솔직히 지피티의 의존도가 있다 ㅠfunc signOutApple(completion: @escaping (Error?) -&gt; Void) {        guard let userID = UserDefaults.standard.string(forKey: \"appleAuthorizedUserIdKey\") else {            let error = NSError(domain: \"AppleSignOut\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"No Apple ID user ID found.\"])            completion(error)            return        }                let appleIDProvider = ASAuthorizationAppleIDProvider()        appleIDProvider.getCredentialState(forUserID: userID) { (credentialState, error) in            if let error = error {                completion(error)                return            }                        switch credentialState {            case .authorized:                completion(nil)            case .revoked, .notFound:                // Consider the user logged out if the credential is revoked or not found                completion(nil)            default:                let unknownError = NSError(domain: \"AppleSignOut\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"Unknown Apple credential state.\"])                completion(unknownError)            }        }    }func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {        guard let credential = authorization.credential as? ASAuthorizationAppleIDCredential else { return }                let userID = credential.user                if UserDefaults.standard.string(forKey: \"appleAuthorizedUserIdKey\") == nil {                UserDefaults.standard.set(userID, forKey: \"appleAuthorizedUserIdKey\")            }                let nonce = currentNonce                signManager.saveApple(appleCredential: credential, nonce: nonce!) { [weak self] result in            switch result {            case .success(let result):                if let user = result?.user {                    let email = credential.email ?? \"\"                    self?.signManager.fetchUserData(uid: user.uid) { error, snapshot in                        if let error = error {                            self?.loginPublisher.send(completion: .failure(error))                        }                        if let snapshot = snapshot {                            if snapshot.exists() {                                self?.loginPublisher.send(())                            } else {                                let model = UserModel(uid: user.uid, email: email, isBlock: false, nickName: \"\", profileImageUrl: \"https://firebasestorage.googleapis.com/v0/b/tteoppokki4u.appspot.com/o/dummyProfile%2FdefaultImage.png?alt=media&amp;token=b4aab21e-e19a-42b7-9d17-d92a3801a327\")                                self?.signManager.saveUserData(user: model)                            }                        }                    }                }            case .failure(let error):                self?.loginPublisher.send(completion: .failure(error))            }        }            }이젠 로그아웃도 잘된다."
  },
  
  {
    "title": "Final (9)",
    "url": "/posts/Final-(9)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-08 01:00:00 +0900",
    





    
    "snippet": "내가쓴 리뷰를 확인 할 수 있는 기능 구현이건 그냥 uid에 해당하는 documents만 가져오면 된다.UserReview의 컬렉션에서 field가 uid에서 유져의 값과 일치하는 녀석만 가져오게 하면된다.1. userManager 작성func getMyReview(uid: String, completion: @escaping(QuerySnapshot...",
    "content": "내가쓴 리뷰를 확인 할 수 있는 기능 구현이건 그냥 uid에 해당하는 documents만 가져오면 된다.UserReview의 컬렉션에서 field가 uid에서 유져의 값과 일치하는 녀석만 가져오게 하면된다.1. userManager 작성func getMyReview(uid: String, completion: @escaping(QuerySnapshot?, (Error)?) -&gt; Void) {        reviewCollection.whereField(\"uid\", isEqualTo: uid).order(by: \"createdAt\").getDocuments(completion: completion)    }함수는 다음과 같이 구현.2. VM 작성func getUserReview(uid: String) {        userManager.getMyReview(uid: uid) { [weak self] querySnapshot, error in            if let error = error {                self?.reviewPublisher.send(completion: .failure(error))            }                        if let snapshotDocuments = querySnapshot?.documents {                if !snapshotDocuments.isEmpty {                    for doc in snapshotDocuments {                        let data = doc.data()                        guard                            let uid = data[\"uid\"] as? String,                            let title = data[\"title\"] as? String,                            let storeAddress = data[\"storeAddress\"] as? String,                            let content = data[\"content\"] as? String,                            let rating = data[\"rating\"] as? Float,                            let imageURL = data[\"imageURL\"] as? [String],                            let isActivate = data[\"isActivate\"] as? Bool,                            let createdAt = data[\"createdAt\"] as? Timestamp,                            let updatedAt = data[\"updatedAt\"] as? Timestamp                        else {                            return                        }                        let reviewData = ReviewModel(uid: uid, title: title, storeAddress: storeAddress, content: content, rating: rating, imageURL: imageURL, isActivate: isActivate, createdAt: createdAt, updatedAt: updatedAt)                        self?.userReview.append(reviewData)                        self?.reviewPublisher.send(())                    }                }            }        }    }3. VC 작성private func getData() {        viewModel.getUserReview()    }        private func bind() {        viewModel.$userReview            .print()            .sink { _ in            self.collectionView.reloadData()        }.store(in: &amp;cancellables)                viewModel.reviewPublisher.sink { completion in            switch completion {            case .finished:                return            case .failure(let error):                print(error)            }        } receiveValue: { _ in            print(\"received\")        }.store(in: &amp;cancellables)    }하지만 에러가 발생뭐가 문제일까 해서 보니 updatedAt을 이전에 사용하지 않아서 생긴 문제즉 guard문에서 return되면서 종료되었던것그래서 필드를 추가해주고 글을 작성할때도 updatedAt을 넣게 해주었다.성공.리뷰 수정 페이지 구현.작성과 수정을 같이 하기위해서, 굳이 또 VC를 만들어야하나에 대한 의구심이 생겼다.var isEditMode: Bool = false 이녀석을 만들어서새로작성할때는 false 유지,수정할때만 true로 값을 넘겨서 하려고한다.@objc func submitButtonTapped() {                if isEditMode == false {            writeReview()        } else {            editReview()        }                   }1. 데이터를 전달하기 위한 코드 수정아무래도 indexPath가 필요하여 프로토콜부분과 관련된 모든 부분이 고쳐져야할 필요성을 느꼈다.우선 프로토콜에 indexpath를 추가한다.protocol ReviewCellDelegate: AnyObject {    func editReview(_ review: ReviewModel, indexPath: IndexPath)    func deleteReview(_ review: ReviewModel, indexPath: IndexPath)}관련 함수 수정extension MyReviewViewController: ReviewCellDelegate {    func editReview(_ review: ReviewModel, indexPath: IndexPath) {        let writeVC = WriteViewController()        let item = viewModel.userReview[indexPath.row]        writeVC.isEditMode = true        writeVC.isNavagtion = true        writeVC.review = item                navigationController?.pushViewController(writeVC, animated: true)    }        func deleteReview(_ review: ReviewModel, indexPath: IndexPath) {        let item = viewModel.userReview[indexPath.row]        print(item)    }}데이터를 ui로 전달하는 함수도 만들고, Kingfisher를 사용하여 이미지를 가져오는것도 했다.Kingfisher가 이미지를 uiimage로 바꿀수 있는건 첨알았다.보통은 이미지 뷰에서 url을 가져와서 바로 적용을 했지 해당 메서드 사용은 처음이다.출처private func setDataForEdit() {        if review != nil {            titleTextField.text = review?.title            contentTextView.text = review?.content            selectedRating = Int(review!.rating)            updateStarButtons()            getImages()        }    }    private func getImages() {        review?.imageURL.forEach { url in            guard let imageURL = URL(string: url) else { return }            KingfisherManager.shared.retrieveImage(with: imageURL) { result in                switch result {                case .success(let image):                    DispatchQueue.main.async {                        self.addImageToStackView(image: image.image)                        self.selectedImages.append(image.image)                    }                case .failure(let error):                    print(\"Error: \\(error)\")                }            }        }    }완료.Document 수정 기능 구현이제 메인기능이 남았다.UserManager에는 다음과 같이 구현했다.func editReview(uid: String, storeAddress: String, title: String, completion: @escaping(QuerySnapshot?, (Error)?) -&gt; Void) {        reviewCollection.whereField(\"uid\", isEqualTo: uid).whereField(\"storeAddress\", arrayContains: storeAddress).whereField(\"title\", arrayContains: title).getDocuments(completion: completion)    }유져의 uid, 가게주소, 작성한 제목을 바탕으로 수정하는 작업을 하게 된다.우선 VM은 다음과 같이 했다.func editUserReview(uid: String, storeAddress: String, title: String, userDict: [String: Any]) {        userManager.editReview(uid: uid, storeAddress: storeAddress, title: title) { [weak self ] querySnapshot, error in            if let error = error {                self?.reviewPublisher.send(completion: .failure(error))            }                        if let documents = querySnapshot?.documents {                for doc in documents {                    let id = doc.documentID                    reviewCollection.document(id).setData(userDict, merge: true)                }            }        }    }VC 수정isEditMode를 기준으로 삼항연산자를 사용하여 다음과 같이 구현private func reviewTapped() {        guard            let uid = Auth.auth().currentUser?.uid,            let title = titleTextField.text,            let content = contentTextView.text        else {            return        }                uploadImages(images: selectedImages)            .sink(receiveCompletion: { completion in                switch completion {                case .finished:                    break                case .failure(let error):                    let alert = UIAlertController(title: \"에러 발생\", message: \"\\(error.localizedDescription)이 발생했습니다.\", preferredStyle: .alert)                    alert.addAction(UIAlertAction(title: \"확인\", style: .default))                    self.present(alert, animated: true)                }            }, receiveValue: { [weak self] imageURLs in                guard let self = self else { return }                                let dictionary: [String: Any] = [                    \"uid\": uid,                    \"title\": title,                    \"storeAddress\": self.addressText!,                    \"storeName\": self.storeTitleText!,                    \"content\": content,                    \"rating\": self.selectedRating,                    \"imageURL\": imageURLs,                    \"isActive\": false,                    \"createdAt\": self.isEditMode ? self.review!.createdAt : Timestamp(date: Date()),                    \"updatedAt\": Timestamp(date: Date())                ]                                if self.isEditMode {                    self.viewModel.editUserReview(uid: uid, storeAddress: self.addressText!, title: self.storeTitleText!, userDict: dictionary)                } else {                    self.viewModel.createReview(userDict: dictionary)                }            })            .store(in: &amp;cancellables)                let alertTitle = isEditMode ? \"리뷰 수정\" : \"리뷰 저장\"        let alertMessage = isEditMode ? \"리뷰가 수정 되었습니다.\" : \"리뷰가 등록 되었습니다.\"        let alert = UIAlertController(title: alertTitle, message: alertMessage, preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"확인\", style: .default, handler: { [unowned self] _ in            if self.isNavagtion {                self.navigationController?.popViewController(animated: true)            } else {                self.dismiss(animated: true, completion: nil)            }        }))        present(alert, animated: true)    }문제점 확인.옵셔널 문제가 발생해서 생각해보니, addressText, storeTitleText를 넘기지 않은게 원인이다.private func setDataForEdit() {        if review != nil {            titleTextField.text = review?.title            contentTextView.text = review?.content            selectedRating = Int(review!.rating)            addressText = review?.storeAddress            storeTitleText = review?.storeName            updateStarButtons()            getImages()        }    }하지만 에러가 발생Error Domain=FIRFirestoreErrorDomain Code=3 \"A maximum of 1 'ARRAY_CONTAINS' filter is allowed per disjunction.\" UserInfo={NSLocalizedDescription=A maximum of 1 'ARRAY_CONTAINS' filter is allowed per disjunction.}어디가 문제있나 봤더니 자동완성으로 생긴 문제로 보인다.func editReview(uid: String, storeAddress: String, title: String, completion: @escaping(QuerySnapshot?, (Error)?) -&gt; Void) {        reviewCollection.whereField(\"uid\", isEqualTo: uid).whereField(\"storeAddress\", isEqualTo: storeAddress).whereField(\"title\", isEqualTo: title).getDocuments(completion: completion)    }isEqualTo가 arrayContains이걸로 되어있었다.수정이 되지않아 뭐가 문제일까 봤더니self.viewModel.editUserReview(uid: uid, storeAddress: self.addressText!, title: title, userDict: dictionary)여기 title이 가게명으로 되어있었다.또한 documents를 못찾는 문제가 발생했다.생각해보니 title을 바꾸면서 쿼리를 못찾는것같다.viewModel.editUserReview(uid: uid, storeAddress: self.addressText!, title: review!.title, userDict: dictionary)title을 변경된 값이 아닌 기존에 들고온 리뷰 제목을 해야 그에 맞는게 수정이 된다.너무 안일하게 생각해서 생긴 문제.수정은 되었으나 너무 빨리 dismiss가 되어 서버에 변경되기전 VC가 이미 호출되어 리뷰가 이전께 보여지는 문제가 발생.ProgressHUD.animate()        let alertTitle = isEditMode ? \"리뷰 수정\" : \"리뷰 저장\"        let alertMessage = isEditMode ? \"리뷰가 수정 되었습니다.\" : \"리뷰가 등록 되었습니다.\"        let alert = UIAlertController(title: alertTitle, message: alertMessage, preferredStyle: .alert)        DispatchQueue.main.asyncAfter(deadline: .now() + 4) { [unowned self] in            alert.addAction(UIAlertAction(title: \"확인\", style: .default, handler: { [unowned self] _ in                if isNavagtion {                    navigationController?.popViewController(animated: true)                } else {                    dismiss(animated: true, completion: nil)                }            }))            ProgressHUD.remove()            present(alert, animated: true)        }임시방편으로 약간의 로딩시간을 주었다.그리고 vc재 호출시 수정이 안되는거같아서 확인했보니 append로 계속 누적이 되는걸 확인func getUserReview() {        guard let uid = Auth.auth().currentUser?.uid else { return }                userManager.getMyReview(uid: uid) { [weak self] querySnapshot, error in            self?.userReview.removeAll() // added            if let error = error {                self?.reviewPublisher.send(completion: .failure(error))            }                        if let snapshotDocuments = querySnapshot?.documents {                if !snapshotDocuments.isEmpty {                    for doc in snapshotDocuments {                        let data = doc.data()                        guard                            let uid = data[\"uid\"] as? String,                            let title = data[\"title\"] as? String,                            let storeName = data[\"storeName\"] as? String,                            let storeAddress = data[\"storeAddress\"] as? String,                            let content = data[\"content\"] as? String,                            let rating = data[\"rating\"] as? Float,                            let imageURL = data[\"imageURL\"] as? [String],                            let isActive = data[\"isActive\"] as? Bool,                            let createdAt = data[\"createdAt\"] as? Timestamp,                            let updatedAt = data[\"updatedAt\"] as? Timestamp                        else {                            print(\"error\")                            return                        }                        let reviewData = ReviewModel(uid: uid, title: title, storeAddress: storeAddress, storeName: storeName, content: content, rating: rating, imageURL: imageURL, isActive: isActive, createdAt: createdAt, updatedAt: updatedAt)                        self?.userReview.append(reviewData)                        self?.reviewPublisher.send(())                    }                }            }        }    }이렇게 로드하기전 배열을 비우기로했다.Document 삭제 기능 구현이건 크게 어려운 문제가 아니다.1. UserManager작성func getSpecificReview(uid: String, storeAddress: String, title: String, completion: @escaping(QuerySnapshot?, (Error)?) -&gt; Void) {        reviewCollection.whereField(\"uid\", isEqualTo: uid).whereField(\"storeAddress\", isEqualTo: storeAddress).whereField(\"title\", isEqualTo: title).getDocuments(completion: completion)    }생각해보니 특정 필드에 대한 값을 가져와서 삭제하므로 이름을 변경해주었다.2. VM 작성func removeUserReview(uid: String, storeAddress: String, title: String) {        userManager.getSpecificReview(uid: uid, storeAddress: storeAddress, title: title) { [weak self ] querySnapshot, error in            if let error = error {                self?.reviewPublisher.send(completion: .failure(error))            }                        if let documents = querySnapshot?.documents {                              for doc in documents {                    let id = doc.documentID                    reviewCollection.document(id).delete()                }            }        }    }그냥 delete만 쳐주면 된다.3. VC 작성func deleteReview(_ review: ReviewModel, indexPath: IndexPath) {        let item = viewModel.userReview[indexPath.row]        let alert = UIAlertController(title: \"삭제 확인\", message: \"삭제하시면 복원 할 수 없습니다.\", preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"확인\", style: .destructive, handler: { [unowned self] _ in            viewModel.removeUserReview(uid: item.uid, storeAddress: item.storeAddress, title: item.title)                        getData()            bind()        }))        alert.addAction(UIAlertAction(title: \"취소\", style: .default))        present(alert, animated: true)    }우선 삭제는 되나 collectionview에 바로 보이지는 않는다.아무래도 DiffableDatasource를 사용해야할듯싶다.그건 내일 하는걸로…"
  },
  
  {
    "title": "Final (8)",
    "url": "/posts/Final-(8)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-07 01:00:00 +0900",
    





    
    "snippet": "리뷰 작성글을 보여지게 구현1. 모델링이젠 Firebase의 모델링이 중요해진다.부리더인 미림님이 구현한 VC에서 유져가 작성한 글을 올리는 걸 해보려한다.물론 모델링의 회의도 같이 해보았다.Collection은 UserReview로 하기로했다.우선 모델링은 둘이서 회의를 하면서 진행했고 다음과 같다struct ReviewModel {        v...",
    "content": "리뷰 작성글을 보여지게 구현1. 모델링이젠 Firebase의 모델링이 중요해진다.부리더인 미림님이 구현한 VC에서 유져가 작성한 글을 올리는 걸 해보려한다.물론 모델링의 회의도 같이 해보았다.Collection은 UserReview로 하기로했다.우선 모델링은 둘이서 회의를 하면서 진행했고 다음과 같다struct ReviewModel {        var uid: String    var title: String    var storeAddress: String    var content: String    var rating: Float    var imageURL: [String]    var isActivate: Bool    var createdAt: Timestamp    var updatedAt: Timestamp    }2. UserManager에 구현func writeReview(userDict: [String: Any], completion: (((Error)?) -&gt; Void)?) {        reviewCollection.addDocument(data: userDict, completion: completion)    }이렇게 적었다.3. ViewModelclass ReviewViewModel {        private let userManager: UserManager        var reviewPublisher = PassthroughSubject&lt;Void, Error&gt;()        func createReview(userDict: [String: Any]) {        userManager.writeReview(userDict: userDict) { [weak self] error in            guard let self = self else { return }            if let error = error {                self.reviewPublisher.send(completion: .failure(error))            }        }    }    }일단은 이렇게 넘기기로 결정4. VC작성@objc func submitButtonTapped() {        guard            let uid = Auth.auth().currentUser?.uid,            let title = titleTextField.text,            let content = contentTextView.text        else {            return        }                uploadImages(images: selectedImages)            .sink(receiveCompletion: { completion in                switch completion {                case .finished:                    break                case .failure(let error):                    let alert = UIAlertController(title: \"에러 발생\", message: \"\\(error.localizedDescription)이 발생했습니다.\", preferredStyle: .alert)                    alert.addAction(UIAlertAction(title: \"확인\", style: .default))                    self.present(alert, animated: true)                }            }, receiveValue: { [weak self] imageURLs in                guard let self = self else { return }                                let dictionary: [String: Any] = [                    \"uid\": uid,                    \"title\": title,                    \"storeAddress\": addressText,                    \"storeName\": storeTitleText,                    \"content\": content,                    \"rating\": selectedRating,                    \"imageURL\": imageURLs,                    \"isActivate\": false,                    \"createdAt\": Timestamp(date: Date())                ]                                self.viewModel.createReview(userDict: dictionary)                            })            .store(in: &amp;cancellables)                let alert = UIAlertController(title: \"리뷰 저장\", message: \"리뷰가 등록 되었습니다.\", preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"확인\", style: .default, handler: { [unowned self] _ in            dismiss(animated: true)        }))        present(alert, animated: true)    }이미지를 여러개 등록func uploadImage(image: UIImage) -&gt; AnyPublisher&lt;String, Error&gt; {        Future&lt;String, Error&gt; { promise in            let storageRef = Storage.storage().reference()            guard let imageData = image.jpegData(compressionQuality: 0.5) else {                return            }                        let imageRef = storageRef.child(\"images/\\(UUID().uuidString).jpg\")            imageRef.putData(imageData, metadata: nil) { metadata, error in                if let error = error {                    promise(.failure(error))                    return                }                                imageRef.downloadURL { url, error in                    if let error = error {                        promise(.failure(error))                    } else if let downloadURL = url {                        promise(.success(downloadURL.absoluteString))                    }                }            }        }        .eraseToAnyPublisher()    }        func uploadImages(images: [UIImage]) -&gt; AnyPublisher&lt;[String], Error&gt; {        let publishers = images.map { uploadImage(image: $0) }        return Publishers.MergeMany(publishers)            .collect()            .eraseToAnyPublisher()    }  uploadImage          Future를 사용하여 이미지를 Firebase Storage에 업로드하고, 업로드가 완료되면 다운로드 URL을 반환하는 AnyPublisher&lt;String, Error&gt;를 생성      Future 초기화: Future는 비동기 작업의 결과를 promise를 통해 리턴      이미지 데이터 변환: 이미지를 JPEG 데이터로 변환합니다. 실패 시 promise를 반환하지 않고 종료      Firebase Storage 참조 생성: Storage.storage().reference()를 사용하여 Firebase Storage 참조를 생성      이미지 업로드: imageRef.putData(imageData, metadata: nil)를 사용하여 이미지를 업로드. 업로드가 완료되면 다운로드 URL을 요청      결과 반환: 다운로드 URL을 성공적으로 가져오면 promise(.success(downloadURL.absoluteString))을 호출하여 URL을 반환. 에러 발생 시 promise(.failure(error))를 호출        uploadImages          여러 uploadImage 호출을 Combine의 Publishers.MergeMany와 collect를 사용하여 결합한 AnyPublisher&lt;[String], Error&gt;를 반환      map 사용: 각 이미지를 uploadImage 함수로 매핑하여 AnyPublisher&lt;String, Error&gt;의 배열을 생성      Publishers.MergeMany: 이 연산자는 배열의 모든 퍼블리셔를 결합하여 하나의 퍼블리셔로 만듦              각 퍼블리셔의 출력은 하나의 스트림으로 합쳐지게 된다.    - collect: 모든 퍼블리셔가 완료될 때까지 대기한 후, 각 퍼블리셔의 출력값을 배열로 저장      "
  },
  
  {
    "title": "Chat app (4)",
    "url": "/posts/Chat-app-(4)/",
    "categories": "Udemy, ChatApp",
    "tags": "",
    "date": "2024-06-06 12:13:00 +0900",
    





    
    "snippet": "user 검색Firebase에 있는 유져를 검색한다.static func fetchUsers(completion: @escaping([User]) -&gt; Void) {        collection_User.getDocuments { snapshot, error in            guard let snapshot = snapshot els...",
    "content": "user 검색Firebase에 있는 유져를 검색한다.static func fetchUsers(completion: @escaping([User]) -&gt; Void) {        collection_User.getDocuments { snapshot, error in            guard let snapshot = snapshot else { return }            let users = snapshot.documents.map( {User(dictionary: $0.data())})            completion(users)        }    }document에 접속하여 유저 데이터를 가져오는 함수를 작성.NewChatVC에 user변수와 fetchUser함수 생성private var users: [User] = [] {        didSet {            self.tableView.reloadData()        }    }private func fetchUsers() {        showLoader(true)        UserServices.fetchUsers { users in            self.showLoader(false)            self.users = users            print(users)        }    }실행하면 현재 등록된 유져에 대한 추가한 내용이 print 된다.UserViewModel 생성struct UserViewModel {        let user: User        var fullname: String { return user.fullname }    var username: String { return user.username }        var profileImageView: URL? {        return URL(string: user.profileImageURL)    }            init(user: User) {        self.user = user    }    }UserCell에 추가var viewModel: UserViewModel? {        didSet {            configure()        }    }private func configure() {        guard let viewModel = viewModel else { return }        self.fullname.text = viewModel.fullname        self.username.text = viewModel.username        self.profileImageView.sd_setImage(with: viewModel.profileImageView)    }이후 Newchat VC에 셀 적용func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        let cell = tableView.dequeueReusableCell(withIdentifier: reuseIdentifier, for: indexPath) as! UserTableViewCell                let user = users[indexPath.row] // added        cell.viewModel = UserViewModel(user: user) // added                return cell    }확인 완료.User에서 자기자신은 제외하고 출력private func fetchUsers() {        showLoader(true)        UserServices.fetchUsers { users in            self.showLoader(false)            self.users = users                                    guard let uid = Auth.auth().currentUser?.uid else { return }            guard let index = self.users.firstIndex(where: {$0.uid == uid}) else { return }            self.users.remove(at: index)            print(users)        }    }이렇게 현재 유져의 uid에 해당하는 index를 제거.User에게 채팅을 보내는 프로토콜 구현// NewChatVCprotocol NewChatViewControllerDelegate: AnyObject {    func controller(_ vc: NewChatViewController, wnatChatWithUser otherUser: User)}func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        let user = users[indexPath.row]        delegate?.controller(self, wnatChatWithUser: user)    }// ConversationVC@objc func handleNewChat() {        let controller = NewChatViewController()        controller.delegate = self // added        let nav = UINavigationController(rootViewController: controller)        present(nav,animated: true)    }extension ConversationViewController: NewChatViewControllerDelegate {    func controller(_ vc: NewChatViewController, wnatChatWithUser otherUser: User) {        vc.dismiss(animated: true)        print(otherUser.fullname)    }}ChatVC에 나이외의 유저를 추가private var otherUser: Userinit(otherUser: User) {        self.otherUser = otherUser        super.init(collectionViewLayout: UICollectionViewFlowLayout())    }다시 ConversationViewController로 돌아가서didselectRowAt에 있던 내용을private func openChat(user: User) { // new        let controller = ChatViewController(otherUser: user)        navigationController?.pushViewController(controller, animated: true)    }func controller(_ vc: NewChatViewController, wantChatWithUser otherUser: User) {        vc.dismiss(animated: true)        print(otherUser.fullname)        openChat(user: otherUser) // added    }    이렇게 하면화면전환을 하면서 채팅창이 보여진다.Socket을 사용하여 메세지 기능 구현기본 틀을 만들어 준다.struct MessageServices {    static func fetchMessages() {            }        static func fetchRecentMessages() {            }        static func uploadMessage(message: String, currentUser: User, otherUser: User) {        let dataFrom: [String: Any]  = [            \"text\": message,            \"fromID\": currentUser.uid,            \"toID\": otherUser.uid,            \"timeStamp\": Timestamp(date: Date()),                        \"username\": otherUser.username,            \"fullname\": otherUser.fullname,            \"profileImageURL\": otherUser.profileImageURL        ]                let dataTo: [String: Any]  = [            \"text\": message,            \"fromID\": currentUser.uid,            \"toID\": otherUser.uid,            \"timeStamp\": Timestamp(date: Date()),                        \"username\": currentUser.username,            \"fullname\": currentUser.fullname,            \"profileImageURL\": currentUser.profileImageURL        ]                    }}여기서 주목해야할건 uploadMessage에 대한 내용.dictionary 형태로 하고, 이내용을 통헤 firebase에 저장이 되고, 또 로드를 하게된다.Constansts에 관련 내용도 추가let collection_Message = Firestore.firestore().collection(\"messages\")메세지를 올리는 함수의 내용은 다음과 같다static func uploadMessage(message: String, currentUser: User, otherUser: User, completion: ((Error?) -&gt; Void)?) {        let dataFrom: [String: Any]  = [            \"text\": message,            \"fromID\": currentUser.uid,            \"toID\": otherUser.uid,            \"timeStamp\": Timestamp(date: Date()),                        \"username\": otherUser.username,            \"fullname\": otherUser.fullname,            \"profileImageURL\": otherUser.profileImageURL        ]                let dataTo: [String: Any]  = [            \"text\": message,            \"fromID\": currentUser.uid,            \"toID\": otherUser.uid,            \"timeStamp\": Timestamp(date: Date()),                        \"username\": currentUser.username,            \"fullname\": currentUser.fullname,            \"profileImageURL\": currentUser.profileImageURL        ]                collection_Message.document(currentUser.uid).collection(otherUser.uid).addDocument(data: dataFrom) { _ in            collection_Message.document(otherUser.uid).collection(currentUser.uid).addDocument(data: dataTo, completion: completion)            collection_Message.document(currentUser.uid).collection(\"recent-message\").document(otherUser.uid).setData(dataFrom)            collection_Message.document(otherUser.uid).collection(\"recent-message\").document(currentUser.uid).setData(dataTo)        }    }  dataFrom          현재 사용자가 보낸 메세지의 데이터를 나타내며, 상대방의 사용자 정보를 포함        dataTo          상대방이 받은 메세지의 데이터를 나타내며, 현재 사용자의 정보를 포함      collection_Message 컬렉션에 두 개의 Documents를 저장.  현재 사용자의 컬렉션에 메세지 추가  상대방의 컬렉션에 같은 메세지 추가  최근 메세지를 업데이트          setData를 사용함으로써 기존 데이터를 덮어 씌우게 된다.      각 사용자의 recent-message라는 서브 컬렉션에 최근 메세지 정보를 저장.      ChatVC에서 해당 함수 호출private var currentUser: Userprivate var otherUser: User        // MARK: - Lifecycle    init(currentUser: User, otherUser: User) {        self.currentUser = currentUser        self.otherUser = otherUser        super.init(collectionViewLayout: UICollectionViewFlowLayout())    }init에 현재 유저가 추가되면서 관련 되어있던 메서드들을 변경해준다.private func openChat(currentUser: User, otherUser: User) {        let controller = ChatViewController(currentUser: currentUser, otherUser: user)        navigationController?.pushViewController(controller, animated: true)    }실행하여 작동확인hello라는 메세지를 보내본다.제대로 작동한다면 collection에 추가가 되어있을것이다.하나밖에 추가가 안되어 다시 코드를 보다가 문제를 찾았다.private func openChat(currentUser: User, otherUser: User) {        let controller = ChatViewController(currentUser: currentUser, otherUser: otherUser) // modified        navigationController?.pushViewController(controller, animated: true)    }otherUser가 user로 되어있어서 생긴 문제.해결완료.확인 완료.Message 모델만들기struct Message {    let text: String    let fromId: String    let toID: String    let timeStamp: Timestamp    let username: String    let fullname: String    let profileImageURL: String        var isFromCurrentUser: Bool        init(dictionary: [String: Any]) {        self.text = dictionary[\"text\"] as? String ?? \"\"        self.fromId = dictionary[\"fromId\"] as? String ?? \"\"        self.toID = dictionary[\"toID\"] as? String ?? \"\"        self.username = dictionary[\"username\"] as? String ?? \"\"        self.fullname = dictionary[\"fullname\"] as? String ?? \"\"        self.profileImageURL = dictionary[\"profileImageURL\"] as? String ?? \"\"                self.timeStamp = dictionary[\"timeStamp\"] as? Timestamp ?? Timestamp(date: Date())                self.isFromCurrentUser = fromId == Auth.auth().currentUser?.uid    }}여기서 특이점이라면init할때 self.isFromCurrentUser = fromId == Auth.auth().currentUser?.uid 이렇게 해서했다는것.현재 유져가 보낸건지 아닌지에대한 True or false를 위와 같이 구분한다.구분방법은  Firebase Authentication을 통해 현재 사용자 확인          Auth.auth().currentUser는 현재 로그인된 사용자를 리턴      사용자가 로그인되어 있지 않다면 currentUser는 nil이 된다.      currentUser?.uid를 통해 현재 사용자의 고유 ID를 가져온다.        메시지의 보낸 사람 ID와 현재 사용자 ID 비교          fromId와 currentUser?.uid를 비교하여 동일하면, 현재 사용자가 메시지를 보낸 것이므로 self.isFromCurrentUser를 true로 설정      그렇지 않으면 self.isFromCurrentUser를 false로 설정      이렇게 된다.Messsage ViewModel 만들기우선 만들기 전에 메세지를 가져오는 함수를 구현한다static func fetchMessages(otherUser: User, completion: @escaping([Message]) -&gt; Void) {        guard let uid = Auth.auth().currentUser?.uid else { return }                var messages = [Message]()        let query = collection_Message.document(uid).collection(otherUser.uid).order(by: \"timeStamp\", descending: true)                query.addSnapshotListener { snapshot, _ in            guard let documentChanges = snapshot?.documentChanges.filter({$0.type == .added}) else { return }            messages.append(contentsOf: documentChanges.map({Message(dictionary: $0.document.data())}))            completion(messages)        }    }query는 timeStamp를 기준으로 내림순으로 정렬를 하게 한다.최신 메세지가 먼저 오게 하기 위함query.addSnapshotListener를 통해 사용하여 쿼리에 대한 실시간 수신 대기를 설정  snapshot이 변경될 때마다(즉, 새로운 메시지가 추가될 때마다) 호출  documentChanges 배열에서 .added 타입의 변경만 필터링.          새로 추가된 문서(메시지)만을 가져오기 위함.        필터링된 문서 데이터를 Message 객체로 변환하여 messages 배열에 추가  업데이트된 messages 배열을 escaping Closure를 통해 전달.그리고 ChatVC에서 호출하는 메서드를 구현private func fetchMessages() {        MessageServices.fetchMessages(otherUser: otherUser) { messages in            self.messages = messages            print(messages)        }    }[ChatApp.Message(text: \"Hello\", fromID: \"ItlrMBBVskOUuenmDxNwocCowzS2\", toID: \"S91QM1IxdZYXNvxuBpgIFdYOHyf2\", timeStamp: &lt;FIRTimestamp: seconds=1717678529 nanoseconds=784600000&gt;, username: \"dd\", fullname: \"D D\", profileImageURL:이런식으로 출력이 되는걸 확인!이제 진짜 ViewModel 생성struct MessageViewModel {    let message: Message        var messageText: String { return message.text }    var messageBackgroundColor: UIColor { return message.isFromCurrentUser ? #colorLiteral(red: 0.4196078431, green: 0.831372549, blue: 0.431372549, alpha: 1) : #colorLiteral(red: 0.9058823529, green: 0.9098039216, blue: 0.9137254902, alpha: 1) }    var messageColor: UIColor { return message.isFromCurrentUser ? .white : .black }        var rightAnchorActive: Bool { return message.isFromCurrentUser }    var leftAnchorActive: Bool { return !message.isFromCurrentUser }    var shouldHideProfileImage: Bool { return message.isFromCurrentUser }        var profileImageURL: URL? { return URL(string: message.profileImageURL)}    var timeStampString: String? {        let date = message.timeStamp.dateValue()        let dateFormatter = DateFormatter()        dateFormatter.dateFormat = \"hh:mm a\"        return dateFormatter.string(from: date)    }        init(message: Message) {        self.message = message    }    }이걸 하면서 느끼지만 여기 강의에서의 ViewModel은 확실히 성격이 다르다.ViewModel과 데이터 바인딩// chatcell func configure() {        guard let viewModel = viewModel else { return }        bubbleContainer.backgroundColor = viewModel.messageBackgroundColor        textView.text = viewModel.messageText        textView.tintColor = viewModel.messageColor                bubbleRightAnchor.isActive = viewModel.rightAnchorActive        dateRightAnchor.isActive = viewModel.rightAnchorActive                bubbleLeftAnchor.isActive = viewModel.leftAnchorActive        dateLeftAnchor.isActive = viewModel.leftAnchorActive                profileImageView.sd_setImage(with: viewModel.profileImageURL)        profileImageView.isHidden = viewModel.shouldHideProfileImage                guard let timeStampString = viewModel.timeStampString else { return }        datelabel.text = timeStampString    }ChatVc에 적용private func fetchMessages() {        MessageServices.fetchMessages(otherUser: otherUser) { messages in            self.messages = messages            self.collectionView.reloadData() // added        }    }보낸쪽의 메세지가 시간이 조금 안으로 들어갔으나 전달이 되는걸 확인dateRightAnchor = datelabel.rightAnchor.constraint(equalTo: bubbleContainer.leftAnchor, constant: -12)-12인데 12로 되어서 안으로 말리는것도 수정완료.보낸사람의 textColor도 흰색이어야하는데 검은색인것도 수정완료textView.textColor = viewModel.messageColorTextColor인데 TintColor로 되어있었다.최근 보낸 메시지 Fetchstatic func fetchRecentMessages(completion: @escaping([Message]) -&gt; Void) {        guard let uid = Auth.auth().currentUser?.uid else { return }                let query = collection_Message.document(uid).collection(\"recent-message\").order(by: \"timeStamp\")                query.addSnapshotListener { snapshot, _ in            guard let documentChanges = snapshot?.documentChanges else { return }                        let messages = documentChanges.map({Message(dictionary: $0.document.data())})            completion(messages)        }    }그리고 ConversationVC에 다음과 같이 호출하는 함수를 구현private func fetchConversations() {        MessageServices.fetchRecentMessages { conversations in            print(conversations)        }    }우선 프린트로 확인[ChatApp.Message(text: \"Hello\", fromID: \"ItlrMBBVskOUuenmDxNwocCowzS2\", toID: \"ItlrMBBVskOUuenmDxNwocCowzS2\", timeStamp: &lt;FIRTimestamp: seconds=1717677153 nanoseconds=38753000&gt;, username: \"ttt\", fullname: \"Test\", profileImageURL:출력이 되는걸 확인.다음과 같이 변수를 만들어 준다. private var conversations: [Message] = []{        didSet {            tableView.reloadData()        }    }        private var conversationDictionary = [String: Message]()대화내용을 저장할 배열 conversation 이건 값이 들어올때마다 reload를 하기위해 didSet을 사용한다.그리고 conversationDictionary를 사용하기전Message 로가서var chatPartnerID: String { return isFromCurrentUser ? toID : fromID } 를 추가.대화 내용을 불러오는 메서드를 수정private func fetchConversations() {        MessageServices.fetchRecentMessages { conversations in            conversations.forEach { conversation in                self.conversationDictionary[conversation.chatPartnerID] = conversation            }                        self.conversations = Array(self.conversationDictionary.values)        }    }위에 언급하지 않았던 conversationDictionary는 내가 다른사람과 대화한 대상과, 그에 해당하는 메세지를 담는 딕셔너리형배열이다.MessageViewModel 에서var fullname: String { return message.fullname }var username: String { return message.username }이걸 추가해준다.추가하는 이유는 보낸사람의 이름을 확인하기 위함.그 확인은 ChatCell에서var viewModel: MessageViewModel? {        didSet{            configure()        }    }private func configure() {        guard let viewModel = viewModel else { return }                self.profileImageView.sd_setImage(with: viewModel.profileImageURL)        self.fullname.text = viewModel.fullname        self.recentMessage.text = viewModel.messageText        self.dateLabel.text = viewModel.timeStampString    }이렇게 추가해주었다.클릭했을때 대화창 열기ConversationVC에서 didSelectRowAt 메서드를 수정해주면된다.func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        let conversation = conversations[indexPath.row]                showLoader(true)        UserServices.fetchUser(uid: conversation.chatPartnerID) { [self] otherUser in            showLoader(false)            openChat(currentUser: user, otherUser: otherUser)        }    }이제 유져를 클릭하면 그 유져와의 대화가 열리게 된다."
  },
  
  {
    "title": "Chat app (3)",
    "url": "/posts/Chat-app-(3)/",
    "categories": "Udemy, ChatApp",
    "tags": "",
    "date": "2024-06-06 08:13:00 +0900",
    





    
    "snippet": "Chat 기능 구현우선 BarbuttonItem을 만들어 준다.let newConversationBarButton = UIBarButtonItem(barButtonSystemItem: .compose, target: self, action: #selector(handleNewChat))navigationItem.rightBarButtonItem = n...",
    "content": "Chat 기능 구현우선 BarbuttonItem을 만들어 준다.let newConversationBarButton = UIBarButtonItem(barButtonSystemItem: .compose, target: self, action: #selector(handleNewChat))navigationItem.rightBarButtonItem = newConversationBarButtonTableview 구현은 passCell 생성.이부분도 딱히 서술할게 없어서 pass구현하면 이렇게 나온다5개 나오는건현재 개수를 5개로 해두었기 때문.ChatVC 생성을 한다.이때 특이한적음 UICollectionViewController 라는 것.그리고 대화 셀 을 만들어준다.ChatVC의 특이점extension ChatViewController: UICollectionViewDelegateFlowLayout {        func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -&gt; UIEdgeInsets {                return .init(top: 15, left: 0, bottom: 15, right: 0)    }        func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -&gt; CGSize {        let frame = CGRect(x: 0, y: 0, width: view.frame.width, height: 50)        let cell = ChatCollectionViewCell(frame: frame)        cell.configure()        cell.layoutIfNeeded()                let targetSize = CGSize(width: view.frame.width, height: 1000)        let estimeSize = cell.systemLayoutSizeFitting(targetSize)                return .init(width: view.frame.width, height: estimeSize.height)    }}// Cellfunc configure(text: String) {        bubbleLeftAnchor.isActive = true        dateLeftAnchor.isActive = true                textView.text = text    }섹션의 인셋을 설정하고,셀의 크기를 동적으로 설정한다. 이게 포인트  임시로 ChatCollectionViewCell 객체를 생성하고, 필요한 구성 작업을 수행  layoutIfNeeded()를 호출하여 레이아웃 업데이트  systemLayoutSizeFitting 메서드를 사용하여 셀의 콘텐츠에 맞는 크기를 계산  targetSize는 레이아웃을 계산할 목표 크기. 여기서는 높이를 1000으로 설정하여 셀의 실제 높이를 측정할 수 있게 함  estimeSize는 실제 콘텐츠에 맞는 셀의 크기  최종적으로 계산된 셀의 크기를 반환결과는 다음과 같다.InputView 설정우선 UITextView를 사용하는데, 이것도 커스텀을 한다.class InputTextView: UITextView {        let placeHolderLabel = CustomLabel(text: \"Type a message...\", labelColor: .lightGray)        override init(frame: CGRect, textContainer: NSTextContainer?) {        super.init(frame: frame, textContainer: textContainer)                backgroundColor = #colorLiteral(red: 0.9656843543, green: 0.9657825828, blue: 0.9688259959, alpha: 1)        layer.cornerRadius = 20        isScrollEnabled = false                addSubview(placeHolderLabel)        placeHolderLabel.centerY(inView: self, leftAnchor: leftAnchor, rightAnchor: rightAnchor, paddingLeft: 8)    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }}크게 특이점은 없다단지 이걸 사용하는 ChatVC에 특이점이 존재class ChatViewController: UICollectionViewController {        // MARK: - Properties    private let reuseIdentifier = \"ChatCollectionViewCell\"    private var messages: [String] = [        \"Here's sample data\",        \"this the second line with more than one line\",        \"Just wanna add more text for testing or where ever, and thats it for this lessson, Cool\"    ]        private lazy var customInputView: CustomInputView = { //added        let frame = CGRect(x: 0, y: 0, width: view.frame.width, height: 50)        let iv = CustomInputView(frame: frame)        return iv    }()        // MARK: - Lifecycle    init() {        super.init(collectionViewLayout: UICollectionViewFlowLayout())    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        override func viewDidLoad() {        super.viewDidLoad()                configureUI()    }        override var inputAccessoryView: UIView? {        get { return customInputView }    }        override var canBecomeFirstResponder: Bool {        return true    }        // MARK: - Helpers    private func configureUI() {        collectionView.backgroundColor = .white                collectionView.register(ChatCollectionViewCell.self                                , forCellWithReuseIdentifier: reuseIdentifier)    }}바로 이녀석들이다override var inputAccessoryView: UIView? {        get { return customInputView }    }    override var canBecomeFirstResponder: Bool {        return true    }  inputAcceryView      inputAccessoryView는 UIView 타입의 속성으로, 키보드가 나타날 때 함께 표시될 커스텀 뷰를 반환inputAccessoryView는 읽기 전용 속성으로, get 접근자를 사용하여 customInputView를 반환    canBecomeFirstResponder      canBecomeFirstResponder는 Bool 타입의 속성으로, 뷰 컨트롤러가 첫 번째 응답자가 될 수 있는지 여부를 반환true를 반환하면, 이 뷰 컨트롤러가 첫 번째 응답자가 되어 키보드와 입력 액세서리 뷰를 표시기본적으로 UIViewController는 첫 번째 응답자가 될 수 없으므로, 이를 재정의하여 가능하게 한다.  그리고 inputview의 내용도 추가 한다.class CustomInputView: UIView {        // MARK: - Properties    let inputTextView = InputTextView()        // MARK: - Lifecycle    override init(frame: CGRect) {        super.init(frame: frame)        backgroundColor = .white        autoresizingMask = .flexibleHeight // added                addSubview(inputTextView)        inputTextView.anchor(top: topAnchor, left: leftAnchor, bottom: safeAreaLayoutGuide.bottomAnchor, right: rightAnchor, paddingTop: 12, paddingLeft: 8, paddingBottom: 5, paddingRight: 8)    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        override var intrinsicContentSize: CGSize { // added                return .zero    }        // MARK: - Helpers    }  autoresizingMask      autoresizingMask는 iOS에서 UIView가 부모 뷰의 크기가 변경될 때 자신의 크기나 위치를 자동으로 조정할 수 있도록 설정하는 속성autoresizingMask는 UIView.AutoresizingMask 타입으로, 여러 옵션을 조합하여 사용할 수 있다. 이 속성을 설정하면 뷰가 부모 뷰의 크기 변화에 적응할 수 있다.    intrinsicContentSize      intrinsicContentSize는 레이아웃 엔진이 뷰의 크기를 계산할 때 사용예를 들어, UILabel은 텍스트의 길이에 따라 크기가 결정되므로, UILabel의 intrinsicContentSize는 텍스트의 크기를 반영 한다기본적으로, UIView의 intrinsicContentSize는 CGSize.zero를 반환이 의미는 뷰가 자체적으로 크기를 결정하지 않으며, 외부 레이아웃 제약 조건에 따라 크기가 결정된다는 것이다.  그리고 TextView에 NotificationCenter를 추가해준다.입력의 변화에 대해 전달할 녀석이다.여기선 placeholder를 숨기기위해 사용한다.NotificationCenter.default.addObserver(self, selector: #selector(handleTextDidChange), name: UITextView.textDidChangeNotification, object: nil)@objc func handleTextDidChange() {        placeHolderLabel.isHidden = !text.isEmpty    }작동확인.또한extension UITextView {    func paddingView() {        self.textContainerInset = UIEdgeInsets(top: 10, left: 12, bottom: 10, right: 12)    }}paddingView 함수를 만들면서 글자입력시 text가 textview에 바짝 붙지않게 조정해두었다.send버튼 만들기버튼 구성에는 특이한게 없으나 어제도 비슷한게 있어 적는다protocol CustomInputViewDelegate: AnyObject {    func inputView(_ view: CustomInputView, wantUploadMessage message: String)}@objc func handlePostButton() {        delegate?.inputView(self, wantUploadMessage: inputTextView.text)    }해당 뷰에서 데이터를 전달할 text를 저렇게 delegate를 통해서 한다는것.ChatVC에서 해당 delegate를 채택 private lazy var customInputView: CustomInputView = {        let frame = CGRect(x: 0, y: 0, width: view.frame.width, height: 50)        let iv = CustomInputView(frame: frame)        iv.delegate = self // added        return iv    }()extension ChatViewController: CustomInputViewDelegate {    func inputView(_ view: CustomInputView, wantUploadMessage message: String) {        print(message)    }        }기본 뼈대 완성.우선은 메세지를 보내기 했을때 추가가 되는지 테스트func clearTextView() {        inputTextView.text = \"\"        inputTextView.placeHolderLabel.isHidden = false    }extension ChatViewController: CustomInputViewDelegate {    func inputView(_ view: CustomInputView, wantUploadMessage message: String) {        print(message)        messages.append(message) // added        view.clearTextView() // added        collectionView.reloadData() // added    }}확인 완료.이때 꼭 버튼이아니라 뒤에 있는 빨간색 배경을 눌렀을때도 되게 하기위해서 gesture를 추가private let postBackgroundColor: CustomImageView = {        let tap = UITapGestureRecognizer(target: self, action: #selector(handlePostButton))        let iv = CustomImageView(width: 40, height: 40, backgroundColor: .red, cornerRadius: 20)        iv.isUserInteractionEnabled = true        iv.addGestureRecognizer(tap)        return iv    }()"
  },
  
  {
    "title": "Final (7)",
    "url": "/posts/Final-(7)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-06 01:00:00 +0900",
    





    
    "snippet": "현재 로그인 된 유져의 프로필사진과 프로필 명 변경.우선 realtimeDatabase의 user안에 유져의 uid 안에 내용이 있다.func updateProfile(uid: String, nickName: String, profile: UIImage, completion: @escaping (Error) -&gt; Void) {           ...",
    "content": "현재 로그인 된 유져의 프로필사진과 프로필 명 변경.우선 realtimeDatabase의 user안에 유져의 uid 안에 내용이 있다.func updateProfile(uid: String, nickName: String, profile: UIImage, completion: @escaping (Error) -&gt; Void) {                let ref = Database.database().reference()        let storageRef = Storage.storage().reference(forURL: \"gs://tteoppokki4u.appspot.com\")        let storageProfileRef = storageRef.child(\"profile\").child(uid)        guard let imageData = profile.jpegData(compressionQuality: 0.8) else { return }                let metaData = StorageMetadata()        metaData.contentType = \"image/jpg\"                storageProfileRef.putData(imageData, metadata: metaData) { (metadata, error) in            if let error = error {                completion(error)                return            }                        storageProfileRef.downloadURL { (url, error) in                if let error = error {                    completion(error)                    return                }                                guard let downloadURL = url else { return }                ref.child(\"users\").child(uid).setValue([\"nickName\": nickName, \"profileImageUrl\": downloadURL])            }        }                            }UserManager를 다음과 같이 구현한다.그리고 VC로 가서func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {        picker.dismiss(animated: true, completion: nil)                guard let result = results.first else { return }                if result.itemProvider.canLoadObject(ofClass: UIImage.self) {            result.itemProvider.loadObject(ofClass: UIImage.self) { [weak self] (image, error) in                guard let self = self else { return }                if let image = image as? UIImage {                    DispatchQueue.main.async {                        self.profileImage = image                        self.profileImageView.image = image                    }                }            }        }    }        @objc func saveChanges() {        guard let uid = Auth.auth().currentUser?.uid else { return }        guard let image = profileImage else { return }        let userName = userNameTextField.text ?? \"\"                userManager.updateProfile(uid: uid, nickName: userName, profile: image) { error in            print(error)        }                    }이렇게 추가로 적어주었다.하지만 이미지를 선택하니3E5B4347-8A53-4164-A84C-FC47F4C2366E grantAccessClaim reply is an error: Error Domain=NSCocoaErrorDomain Code=4101 \"Couldn’t communicate with a helper application.\" UserInfo={NSUnderlyingError=0x600000cf7510 {Error Domain=PHAssetExportRequestErrorDomain Code=4 \"작업을 완료할 수 없습니다.(PHAssetExportRequestErrorDomain 오류 4.)\" UserInfo={NSLocalizedDescription=작업을 완료할 수 없습니다.(PHAssetExportRequestErrorDomain 오류 4.), NSUnderlyingError=0x600000cf6520 {Error Domain=CloudPhotoLibraryErrorDomain Code=1006 \"작업을 완료할 수 없습니다.(CloudPhotoLibraryErrorDomain 오류 1006.)\" UserInfo={NSLocalizedDescription=작업을 완료할 수 없습니다.(CloudPhotoLibraryErrorDomain 오류 1006.)}}}}}이런 오류가 발생.아무래도 사진첩에 대한 권한이 없어서 발생한 문제가 아닐까라고 생각이된다.우선 클라우드 사진을 다 빼니 해결.아마 사진 권한이 제대로 되어있지 않아서 생긴 문제가 맞아보인다.그리고 저장하려니 에러가 또 발생.알고보니 url을 그대로 써서 생긴문제.downloadURL.absoluteString로 바꿔서 해결.MyPageVC에서 데이터 로드func fetchUserData(uid: String, completion: @escaping((Error)?, DataSnapshot?) -&gt; Void) {        ref.child(\"users\").child(uid).getData(completion: completion)    }우선은 이렇게 로드하는걸 간단하게 적었다.이미지 로드도 우선은 간단하게 구현private func fetchUser() {        guard let uid = Auth.auth().currentUser?.uid else { return }        userManager.fetchUserData(uid: uid) { [self] error, snapshot in            if let error = error {                print(error)            }                        guard let dictionary = snapshot?.value as? [String: Any] else { return }                       myPageView.userProfile.kf.setImage(with: URL(string: dictionary[\"profileImageUrl\"] as! String))                              }}우선은 로드가 되나 위의 사진과 같이 field가 수정되었음.생각 해보니 email, uid는 저장할 필요가 없어보이기도하다…realtimedatabase는 merge가 없어서 update를 사용한다.    func updateProfile(uid: String, nickName: String, profile: UIImage, completion: @escaping (Error) -&gt; Void) {                        let storageRef = Storage.storage().reference(forURL: \"gs://tteoppokki4u.appspot.com\")        let storageProfileRef = storageRef.child(\"profile\").child(uid)        guard let imageData = profile.jpegData(compressionQuality: 0.8) else { return }                let metaData = StorageMetadata()        metaData.contentType = \"image/jpg\"                storageProfileRef.putData(imageData, metadata: metaData) { (metadata, error) in            if let error = error {                completion(error)                return            }                        storageProfileRef.downloadURL { (url, error) in                if let error = error {                    completion(error)                    return                }                                guard let downloadURL = url else { return }                let values = [\"nickName\": nickName, \"profileImageUrl\": downloadURL.absoluteString]                self.ref.child(\"users\").child(uid).updateChildValues(values) { error, reference in                    if let error = error {                        completion(error)                        return                    }                }            }        }            }"
  },
  
  {
    "title": "Chat app (2)",
    "url": "/posts/Chat-app-(2)/",
    "categories": "Udemy, ChatApp",
    "tags": "",
    "date": "2024-06-05 08:13:00 +0900",
    





    
    "snippet": "라이브러리 설치강의에선 cocoapod이지만 spm으로 설치한다.ApiServicestruct AuthCredential {        let email: String    let password: String    let username: String    let fullname: String    let profileImage: UIImage  ...",
    "content": "라이브러리 설치강의에선 cocoapod이지만 spm으로 설치한다.ApiServicestruct AuthCredential {        let email: String    let password: String    let username: String    let fullname: String    let profileImage: UIImage    }struct AuthServices {    static func loginUser() {            }        static func registerUser(credential: AuthCredential) {                    }}이번에는 틀을 이렇게 잡는다.확실히 강의 마다 다르다.@objc func handleSignUpVC() {        guard let email = emailTF.text else { return }        guard let password = passwordTF.text else { return }        guard let usernmae = usernameTF.text else { return }        guard let fullname = fullnameTF.text else { return }        guard let profileImage = profileImage else { return }                let credential = AuthCredential(email: email, password: password, username: usernmae, fullname: fullname, profileImage: profileImage)            }가입정보는 이렇게 text로 받고 struct를 사용하여 담았다.FileUploaderstruct FileUploader {        static func uploadImage(image: UIImage, completion: @escaping(String) -&gt; Void) {        guard let imageData = image.jpegData(compressionQuality: 0.75) else { return }        let uid = Auth.auth().currentUser?.uid ?? \"/profileImages/\"                let filename = NSUUID().uuidString        let ref = Storage.storage().reference(withPath: \"/\\(uid)/\\(filename)\")                ref.putData(imageData, metadata: nil) { metaData, error in            if let erorr = error {                print (erorr.localizedDescription)                return            }                        ref.downloadURL { url, error in                if let erorr = error {                    print (erorr.localizedDescription)                    return                }                                guard let fileURL = url?.absoluteString else { return }                completion(fileURL)            }                            }    }    }이미지를 업로드 하는 녀석이며 현재 로그인된 유져의 uid를 가져오고 그렇지 않으면 profileImages라고 한다.파일명은 중복을 막기위해 UUID를 사용.그리고 FirebaseStorage의 경로는 위와 같이 설정한다.그리고나서 해당 경로에 이미지를 업로드 하는 코드를 작성한다.struct AuthServices {    static func loginUser() {            }        static func registerUser(credential: AuthCredential) {        FileUploader.uploadImage(image: credential.profileImage) { imageURL in            print(imageURL)        }            }}가입페이지에서 이미지를 업로드하고 등록 버튼을 누르면 이미지url이 나와야한다.하지만 업로드가 안된다.Storage 규칙 변경규칙을 다시 설정후 시도.출력이 되는걸 확인.회원 가입 코드 구현static func registerUser(credential: AuthCredential, completion: @escaping(Error?) -&gt; Void) {        FileUploader.uploadImage(image: credential.profileImage) { imageURL in                        Auth.auth().createUser(withEmail: credential.email, password: credential.password) { result, error in                if let error = error {                    print(\"Error create account \\(error.localizedDescription)\")                    return                }                                guard let uid = result?.user.uid else { return }                                let data: [String: Any] = [                    \"email\": credential.email,                    \"username\": credential.username,                    \"fullname\": credential.fullname,                    \"uid\": uid,                    \"profileImageURL\": imageURL                ]                                collection_User.document(uid).setData(data, completion: completion)            }        }            }올라가는것 확인 완료.static func loginUser(withEmail email: String, withPassword password: String, completion: (AuthDataResultCallback?)) {                Auth.auth().signIn(withEmail: email, password: password, completion: completion)            }이렇게 유저 정보 로그인을 하던 도중AuthDataResultCallback 에러가 발생하여typealias AuthDataResultCallback = (AuthDataResult?, Error?) -&gt; Void 이걸 사용하여 해결.새로 올라온 강의에는static func loginUser(withEmail email: String, withPassword password: String, completion: @escaping(AuthDataResult?, Error?) -&gt; Void) {                Auth.auth().signIn(withEmail: email, password: password, completion: completion)            }이걸로 바꿔줌. @objc func handleLoginVC() {        guard let email = emailTF.text?.lowercased() else { return }        guard let password = passwordTF.text else { return }                AuthServices.loginUser(withEmail: email, withPassword: password) { result, error in            if let error = error {                print (\"error \\(error)\")                return            }                        print(\"success\")        }    }    로그인 버튼을 다음과 같이 구현로그인도 확인 완료Delegate 설정protocol RegisterVC_Delegate: AnyObject {    func didSuccessCreateAccount(_ vc: RegisterViewController)}class RegisterViewController: UIViewController {        weak var delegate: RegisterVC_Delegate?@objc func handleSignUpVC() {        guard let email = emailTF.text?.lowercased() else { return }        guard let password = passwordTF.text else { return }        guard let usernmae = usernameTF.text?.lowercased() else { return }        guard let fullname = fullnameTF.text else { return }        guard let profileImage = profileImage else { return }                let credential = AuthCredential(email: email, password: password, username: usernmae, fullname: fullname, profileImage: profileImage)                AuthServices.registerUser(credential: credential) { error in            if let error = error {                print(\"error \\(error.localizedDescription)\")                return            }            delegate?.didSuccessCreateAccount(self) // added        }                    }// LoginVC@objc func handleSignUpButton() {        let controller = RegisterViewController()        controller.delegate = self // added        navigationController?.pushViewController(controller, animated: true)            }extension LoginViewController: RegisterVC_Delegate {    func didSuccessCreateAccount(_ vc: RegisterViewController) {        vc.navigationController?.popViewController(animated: true)    }    }VC Extenstion 적용import UIKitimport JGProgressHUDextension UIViewController {    static let hud = JGProgressHUD(style: .dark)        func showLoader(_ show: Bool) {        view.endEditing(true)                if show {            UIViewController.hud.show(in: view)        } else {            UIViewController.hud.dismiss()        }    }            func showMessage(title: String, message: String, completion: (() -&gt; Void)? = nil) {        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: { _ in            completion?()        }))                present(alert, animated: true)    } } @objc func handleSignUpVC() {        guard let email = emailTF.text?.lowercased() else { return }        guard let password = passwordTF.text else { return }        guard let usernmae = usernameTF.text?.lowercased() else { return }        guard let fullname = fullnameTF.text else { return }        guard let profileImage = profileImage else { return }                let credential = AuthCredential(email: email, password: password, username: usernmae, fullname: fullname, profileImage: profileImage)                showLoader(true) // added        AuthServices.registerUser(credential: credential) { error in            self.showLoader(false) // added            if let error = error {                self.showMessage(title: \"Error\", message: error.localizedDescription) // modified                return            }        }                delegate?.didSuccessCreateAccount(self)    } @objc func handleLoginVC() {        guard let email = emailTF.text?.lowercased() else { return }        guard let password = passwordTF.text else { return }                showLoader(true) // added        AuthServices.loginUser(withEmail: email, withPassword: password) { result, error in            if let error = error {                self.showMessage(title: \"Error\", message: error.localizedDescription) // modified                return            }            self.showLoader(false) // added                        print(\"success\")            self.navToConversationVC()        }    }굿.SDWebImage 사용func getImage(withImageURL imageURL: URL, completion: @escaping(UIImage) -&gt; Void) {        SDWebImageManager.shared.loadImage(with: imageURL, options: .continueInBackground, progress: nil) { image, data, error, cashType, finished, url in            if let error = error {                self.showMessage(title: \"Error\", message: error.localizedDescription)                return            }                        guard let image = image else { return }            completion(image)        }    }새롭게 sturct도 만들어주고struct AuthCredentialEmail {        let email: String    let uid: String    let username: String    let fullname: String    let profileImage: UIImage    }static func registerWithGoogle(credential: AuthCredentialEmail, completion: @escaping(Error?) -&gt; Void) {        FileUploader.uploadImage(image: credential.profileImage) { imageURL in                        let data: [String: Any] = [                \"email\": credential.email,                \"username\": credential.username,                \"fullname\": credential.fullname,                \"uid\": credential.uid,                \"profileImageURL\": imageURL            ]                        collection_User.document(credential.uid).setData(data, completion: completion)        }    }모델링struct User {    let email: String    let username: String    let fullname: String    let uid: String    let profileImageURL: String        init(dictionary: [String: Any]) {        self.email = dictionary[\"email\"] as? String ?? \"\"        self.username = dictionary[\"username\"] as? String ?? \"\"        self.fullname = dictionary[\"fullname\"] as? String ?? \"\"        self.uid = dictionary[\"uid\"] as? String ?? \"\"        self.profileImageURL = dictionary[\"profileImageURL\"] as? String ?? \"\"    }}struct UserServices {    static func fetchUser(uid: String, completion: @escaping (User) -&gt; Void) {        collection_User.document(uid).getDocument { (snapshot, error) in            if let error = error {                print(error.localizedDescription)                return            }                        guard let dictionary = snapshot?.data() else { return }            let user = User(dictionary: dictionary)            completion(user)        }    }}func navToConversationVC() {        guard let uid = Auth.auth().currentUser?.uid else { return }        UserServices.fetchUser(uid: uid) { user in            print(user)        }        let controller = ConversationViewController()        let nav = UINavigationController(rootViewController: controller)        nav.modalPresentationStyle = .fullScreen        self.present(nav, animated: true)    }실행하면 유저 졍보가 프린트됨User(email: \"a@n.com\", username: \"ttt\", fullname: \"Test\", uid: \"ItlrMBBVskOUuenmDxNwocCowzS2\", profileImageURL: \"https://firebasestorage.googleapis ....CONVERSATION VC 설정class ConversationViewController: UIViewController {    // MARK: - Properties    private var user: User        // MARK: - Lifecycle    init(user: User) {        self.user = user        super.init(nibName: nil, bundle: nil)    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        override func viewDidLoad() {        super.viewDidLoad()                view.backgroundColor = .red           }      // MARK: - Helpers}의존성 주입을 해준다.func navToConversationVC() {        guard let uid = Auth.auth().currentUser?.uid else { return }        UserServices.fetchUser(uid: uid) { user in            print(user)            let controller = ConversationViewController(user: user)            let nav = UINavigationController(rootViewController: controller) // modified            nav.modalPresentationStyle = .fullScreen            self.present(nav, animated: true)        }            }해당 함수를 수정해준다. 위치도 안으로 넣어주었다.Splash VC 생성SplashVC는 현재 유져의 로그인 상태에 따라 다른 VC를 보여주는 역할을 한다.class SplashViewController: UIViewController {    // MARK: - Properties        override func viewDidLoad() {        super.viewDidLoad()        view.backgroundColor = .white    }        override func viewDidAppear(_ animated: Bool) {        super.viewDidAppear(animated)                if Auth.auth().currentUser?.uid == nil {            let controller = LoginViewController()            let nav = UINavigationController(rootViewController: controller)            nav.modalPresentationStyle = .fullScreen            self.present(nav, animated: true)        } else {            guard let uid = Auth.auth().currentUser?.uid else { return }            showLoader(true)            UserServices.fetchUser(uid: uid) { [self] user in                self.showLoader(false)                let controller = ConversationViewController(user: user)                let nav = UINavigationController(rootViewController: controller)                nav.modalPresentationStyle = .fullScreen                self.present(nav, animated: true)            }                    }    }}func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).        guard let scene = (scene as? UIWindowScene) else { return }        window = UIWindow(windowScene: scene)        let nav = UINavigationController(rootViewController: SplashViewController()) // modified        window?.rootViewController = nav        window?.makeKeyAndVisible()    }class ConversationViewController: UIViewController {    // MARK: - Properties    private var user: User        // MARK: - Lifecycle    init(user: User) {        self.user = user        super.init(nibName: nil, bundle: nil)    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        override func viewDidLoad() {        super.viewDidLoad()                       configureUI()    }      // MARK: - Helpers    private func configureUI() {        view.backgroundColor = .white        title = user.fullname                let logoutBarbutton = UIBarButtonItem(title: \"Logout\", style: .plain, target: self, action: #selector(handleLogout))                navigationItem.leftBarButtonItem = logoutBarbutton    }        @objc func handleLogout() {        do {            try Auth.auth().signOut()            dismiss(animated: true)        } catch {            print(\"Error\")        }    }    }로그인한 유져의 이름이 나오는걸 확인."
  },
  
  {
    "title": "Chat app (1)",
    "url": "/posts/Chat-app-(1)/",
    "categories": "Udemy, ChatApp",
    "tags": "",
    "date": "2024-06-04 08:13:00 +0900",
    





    
    "snippet": "파이널 프로젝트에서 우리가 사용할 필요 기술이 하나 있어서 준비할겸 적어본다.초반에는 딱히 서술할게 없을듯…extension UIButton {    func attributedText(firstString: String, secondString: String) {        let atts: [NSAttributedString.Key: Any] =...",
    "content": "파이널 프로젝트에서 우리가 사용할 필요 기술이 하나 있어서 준비할겸 적어본다.초반에는 딱히 서술할게 없을듯…extension UIButton {    func attributedText(firstString: String, secondString: String) {        let atts: [NSAttributedString.Key: Any] = [.foregroundColor: #colorLiteral(red: 0, green: 0, blue: 0, alpha: 1).withAlphaComponent(0.7), .font: UIFont.systemFont(ofSize: 16)]        let attributedTitle = NSMutableAttributedString(string: \"\\(firstString) \", attributes: atts)                let secondAtts: [NSAttributedString.Key: Any] = [.foregroundColor: #colorLiteral(red: 0, green: 0, blue: 0, alpha: 1).withAlphaComponent(0.88), .font: UIFont.boldSystemFont(ofSize: 16)]        attributedTitle.append(NSAttributedString(string: secondString, attributes: secondAtts))                setAttributedTitle(attributedTitle, for: .normal)    }}private lazy var forgetPasswordButton: UIButton = {        let button = UIButton(type: .system)        button.setTitle(\"Forget your password? Get Help Signing in\", for: .normal)        button.tintColor = .black        button.setHeight(50)        button.titleLabel?.font = .boldSystemFont(ofSize: 19)        button.addTarget(self, action: #selector(handleForgetPassword), for: .touchUpInside)        return button    }()private lazy var forgetPasswordButton: UIButton = {        let button = UIButton(type: .system)        button.attributedText(firstString: \"Forget your password?\", secondString: \"Get Help Signing in\")        button.tintColor = .black        button.setHeight(50)        button.titleLabel?.font = .boldSystemFont(ofSize: 19)        button.addTarget(self, action: #selector(handleForgetPassword), for: .touchUpInside)        return button    }()이렇게 함으로써 글자마다 다르게 표현이 가능해진다.LoginVM 만들기struct LoginViewModel {        var email: String?    var password: String?        var formIsFailed: Bool {        return email?.isEmpty == false &amp;&amp; password?.isEmpty == false    }        var backgroundColor: UIColor {        return formIsFailed ? (UIColor.black) : (UIColor.black.withAlphaComponent(0.5))    }        var buttonTitleColor: UIColor {        return formIsFailed ? (UIColor.white) : (UIColor(white: 1, alpha: 0.7))    }    }@objc func handleTextChanged(sender: UITextField) {        sender == emailTF ? (viewModel.email = sender.text) : (viewModel.password = sender.text)        updateForm()    }        private func updateForm() {        loginButton.isEnabled = viewModel.formIsFailed        loginButton.backgroundColor = viewModel.backgroundColor        loginButton.setTitleColor(viewModel.buttonTitleColor, for: .normal)    }TextField Customizingclass CustomTextField: UITextField {        init(placeholder: String, keyboardType: UIKeyboardType = .default, isSecure: Bool = false) {        super.init(frame: .zero)        let spacer = UIView()        spacer.setDimensions(height: 50, width: 12)        leftView = spacer        leftViewMode = .always                borderStyle = .none        textColor = .black        keyboardAppearance = .light        clearButtonMode = .whileEditing        backgroundColor = .systemGray6        setHeight(50)        self.keyboardType = keyboardType        isSecureTextEntry = isSecure                attributedPlaceholder = NSAttributedString(string: placeholder, attributes: [.foregroundColor: UIColor.black.withAlphaComponent(0.7)])    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }    }ImageView Customizingclass CustomImageView: UIImageView {        init(image: UIImage? = nil, width: CGFloat? = nil, height: CGFloat? = nil, cornerRadius: CGFloat = 0) {        super.init(frame: .zero)                contentMode = .scaleAspectFit        layer.cornerRadius = cornerRadius                if let image = image {            self.image = image        }                if let width = width {            setWidth(width)        }                if let height = height {            setHeight(height)        }                if let backgroundColor = backgroundColor {            self.backgroundColor = backgroundColor        }    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }    }Label Customizingclass CustomLabel: UILabel {        init(text: String, textFont: UIFont = .systemFont(ofSize: 14), labelColor: UIColor = .black) {        super.init(frame: .zero)                self.text = text        font = textFont        textColor = labelColor                textAlignment = .center        numberOfLines = 0    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }    }강의 초반이라 딱히 서술할게 없다…"
  },
  
  {
    "title": "Final (6)",
    "url": "/posts/Final-(6)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-03 08:00:00 +0900",
    





    
    "snippet": "Kakao Firebase 연동func kakaoLoginDidTapped() {        if AuthApi.hasToken() {            UserApi.shared.accessTokenInfo { [weak self] _, error in                if let error = error {               ...",
    "content": "Kakao Firebase 연동func kakaoLoginDidTapped() {        if AuthApi.hasToken() {            UserApi.shared.accessTokenInfo { [weak self] _, error in                if let error = error {                    print(\"Token info error: \\(error.localizedDescription)\")                    self?.openKakaoService()                } else {                    print(\"Token is valid\")                    self?.loadingInfoDidKakaoAuth()                }            }        } else {            print(\"No token, opening Kakao service\")            openKakaoService()        }    }        private func openKakaoService() {        if UserApi.isKakaoTalkLoginAvailable() {            UserApi.shared.loginWithKakaoTalk { [weak self] oauthToken, error in                if let error = error {                    self?.loginPublisher.send(completion: .failure(error))                    return                }                print(\"KakaoTalk login successful\")                _ = oauthToken                self?.loadingInfoDidKakaoAuth()            }        } else {            UserApi.shared.loginWithKakaoAccount { [weak self] oauthToken, error in                if let error = error {                    self?.loginPublisher.send(completion: .failure(error))                    return                }                print(\"KakaoAccount login successful\")                _ = oauthToken                self?.loadingInfoDidKakaoAuth()            }        }    }        private func loadingInfoDidKakaoAuth() {        UserApi.shared.me { [weak self] kakaoUser, error in            if let error = error {                self?.loginPublisher.send(completion: .failure(error))                return            }            guard let uid = kakaoUser?.id else {                return            }            let email = kakaoUser?.kakaoAccount?.email ?? \"\\(uid)@kakao.com\"                                    let userModel = UserModel(uid: String(uid), email: email)            self?.signInToFirebase(with: userModel)        }    }        private func signInToFirebase(with userModel: UserModel) {            let emailForSignIn = userModel.email            let passwordForSignIn = userModel.uid                        let credential = OAuthProvider.credential(withProviderID: \"oidc.kakao.com\", accessToken: passwordForSignIn)                        Auth.auth().signIn(with: credential) { [weak self] authResult, error in                if let error = error {                    self?.loginPublisher.send(completion: .failure(error))                    return                }                                print(\"Firebase sign in successful\")                self?.signManager.saveUserData(user: userModel)                self?.loginPublisher.send(())            }        }        private func signUpToFirebase(with userModel: UserModel) {        let emailForSignUp = userModel.email        let passwordForSignUp = userModel.uid                Auth.auth().createUser(withEmail: emailForSignUp, password: passwordForSignUp) { [weak self] authResult, error in            if let error = error {                self?.loginPublisher.send(completion: .failure(error))                return            }                        print(\"Firebase sign up successful\")            self?.signManager.saveUserData(user: userModel)            self?.loginPublisher.send(())        }    }현재 Error 발생으로 잠시 홀딩…현재 로그인 상태 확인.func configureInitialViewController () {            var initialVC = UIViewController()            if Auth.auth().currentUser != nil {               print(Auth.auth().currentUser)            } else {               print(\"nil\")            }        }로그아웃 구현// SignManagerfunc signOut(completion: @escaping (Result&lt;Void, Error&gt;) -&gt; Void) {        let firebaseAuth = Auth.auth()        do {            try firebaseAuth.signOut()            completion(.success(()))        } catch let signOutError {            completion(.failure(signOutError))        }    }        // Kakao 로그아웃    func signOutKakao(completion: @escaping (Error?) -&gt; Void) {        UserApi.shared.logout { error in            if let error = error {                print(\"DEBUG: Kakao 로그아웃 에러 \\(error.localizedDescription)\")            } else {                print(\"DEBUG: Kakao 로그아웃 성공\")            }            completion(error)        }    }        // Google 로그아웃    func signOutGoogle(completion: @escaping (Error?) -&gt; Void) {        GIDSignIn.sharedInstance.signOut()        print(\"DEBUG: Google 로그아웃 성공\")        completion(nil)    }        // Apple 로그아웃 함수    func signOutApple(completion: @escaping (Error?) -&gt; Void) {        let appleIDProvider = ASAuthorizationAppleIDProvider()        appleIDProvider.getCredentialState(forUserID: \"YOUR_USER_ID\") { (credentialState, error) in            switch credentialState {            case .authorized:                completion(nil)            case .revoked:                completion(nil)            case .notFound:                completion(nil)            default:                completion(error)            }        }    }        // 로그인된 서비스 확인 및 로그아웃    func signOutCurrentUser(completion: @escaping (Result&lt;Void, Error&gt;) -&gt; Void) {        if let user = Auth.auth().currentUser {            for provider in user.providerData {                switch provider.providerID {                case \"apple.com\":                    signOutApple { error in                        if let error = error {                            completion(.failure(error))                        } else {                            self.signOut(completion: completion)                        }                    }                case \"google.com\":                    signOutGoogle { error in                        if let error = error {                            completion(.failure(error))                        } else {                            self.signOut(completion: completion)                        }                    }                case \"kakao.com\":                    signOutKakao { error in                        if let error = error {                            completion(.failure(error))                        } else {                            self.signOut(completion: completion)                        }                    }                default:                    break                }            }        } else {            let error = NSError(domain: \"FirebaseService\", code: -1, userInfo: [NSLocalizedDescriptionKey: \"로그인된 사용자가 없습니다.\"])            completion(.failure(error))        }    }// VM func signOut() {            signManager.signOutCurrentUser { [weak self] result in                switch result {                case .success:                    self?.logoutPublisher.send()                case .failure(let error):                    self?.logoutPublisher.send(completion: .failure(error))                }            }        }각 메서드에 맞는 로그아웃 함수를 구현.provider를 통해 로그아웃.딱히 뭐 적을건 없을듯 하다."
  },
  
  {
    "title": "Final (5)",
    "url": "/posts/Final-(5)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-03 08:00:00 +0900",
    





    
    "snippet": "Social Login with Firebase지금까지 기본 기능만 구현했다면, 이젠 로그인 정보를 Firebase와 연동시켜야한다.Docs에는 구글 애플은 있는데, 카카오는 없지만, 카카오는 이메일형식으로 하는 케이스이므로, 그것을 Docs를 보고 하면 될것같다.1. Applefunc appleLoginDidTapped() {        let p...",
    "content": "Social Login with Firebase지금까지 기본 기능만 구현했다면, 이젠 로그인 정보를 Firebase와 연동시켜야한다.Docs에는 구글 애플은 있는데, 카카오는 없지만, 카카오는 이메일형식으로 하는 케이스이므로, 그것을 Docs를 보고 하면 될것같다.1. Applefunc appleLoginDidTapped() {        let provider = ASAuthorizationAppleIDProvider()        let request = provider.createRequest()                let nonce = signManager.randomNonceString()                currentNonce = nonce                request.requestedScopes = [.fullName, .email]        request.nonce = signManager.sha256(nonce)                let controller = ASAuthorizationController(authorizationRequests: [request])        controller.delegate = self        controller.presentationContextProvider = self                controller.performRequests()    }func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {                guard let credential = authorization.credential as? ASAuthorizationAppleIDCredential else { return }                let nonce = currentNonce        signManager.saveApple(appleCredential: credential, nonce: nonce!) { [weak self] result in            switch result {            case .success(let result):                if let user = result?.user {                    let email = credential.email ?? \"\"                    let userModel = UserModel(uid: user.uid, email: email)                    self?.signManager.saveUserData(user: userModel)                }            case .failure(let error):                self?.loginPublisher.send(completion: .failure(error))            }        }                loginPublisher.send()            }SignManager 구현func saveApple(appleCredential: ASAuthorizationAppleIDCredential, nonce: String, completion: @escaping (Result&lt;AuthDataResult?, Error&gt;) -&gt; Void) {                let appleToken = String(data: appleCredential.identityToken!, encoding: .utf8)!                let credential = OAuthProvider.appleCredential(withIDToken: appleToken,                                                       rawNonce: nonce,                                                       fullName: appleCredential.fullName)                Auth.auth().signIn(with: credential) { result, error in            if let error = error {                completion(.failure(error))            }            completion(.success(result))        }    }        func saveUserData(user: UserModel) {        let ref = Database.database().reference()        let userData: [String: Any] = [            \"uid\": user.uid,            \"nickName\": \"\",            \"email\": user.email,            \"profileImageUrl\": \"\"        ]        ref.child(\"users\").child(user.uid).setValue(userData)    }    아래는 docs에 있는 내용.    func sha256(_ input: String) -&gt; String {        let inputData = Data(input.utf8)        let hashedData = SHA256.hash(data: inputData)        let hashString = hashedData.compactMap { String(format: \"%02x\", $0) }.joined()        return hashString    }        func randomNonceString(length: Int = 32) -&gt; String {        precondition(length &gt; 0)        let charset: [Character] = Array(\"0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._\")        var result = \"\"        var remainingLength = length                while remainingLength &gt; 0 {            let randoms: [UInt8] = (0..&lt;16).map { _ in                var random: UInt8 = 0                let errorCode = SecRandomCopyBytes(kSecRandomDefault, 1, &amp;random)                if errorCode != errSecSuccess {                    fatalError(\"Unable to generate nonce. SecRandomCopyBytes failed with OSStatus \\(errorCode)\")                }                return random            }                        randoms.forEach { random in                if remainingLength == 0 {                    return                }                                if random &lt; charset.count {                    result.append(charset[Int(random)])                    remainingLength -= 1                }            }        }                return result    }뭐 코드보면 얼추 이해가 갈 내용이라 설명은 패스.2. GoogleDocs를 보고 다음과 같이 구현한다. func googleLoginDidTapped(presentViewController: UIViewController) {                guard let clientID = FirebaseApp.app()?.options.clientID else { return }        let config = GIDConfiguration(clientID: clientID)                GIDSignIn.sharedInstance.signIn(withPresenting: presentViewController) { [weak self] signInResult, error in            if let error = error {                self?.loginPublisher.send(completion: .failure(error))            }                                    guard let result = signInResult else { return }                        let user = result.user            let idToken = user.idToken?.tokenString                        let credential = GoogleAuthProvider.credential(withIDToken: idToken!, accessToken: user.accessToken.tokenString)                        Auth.auth().signIn(with: credential) { result, error in                if let error = error {                    self?.loginPublisher.send(completion: .failure(error))                }                                guard let user = result?.user else { return }                                let uid = user.uid                let email = user.email                                let model = UserModel(uid: uid, email: email!)                                self?.signManager.saveUserData(user: model)                            }                        self?.loginPublisher.send()        }    }완료여기까진 Docs가 잘되어있어서 크게 문제가 없다.카카오는 내일…"
  },
  
  {
    "title": "Final (4)",
    "url": "/posts/Final-(4)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-02 08:00:00 +0900",
    





    
    "snippet": "Social Login1. Google Login 구현우선 firebase에서 구글을 추가.그러면 새로운 plist파일을 주는데 그걸로 바꾼다.이후 docs에 있는대로 진행을 하다보면googlecloud에서 뭘 생성을 하는데 이부분을 사진을 찍지 못했다.무튼 여기서 이렇게 클라이언트 id와, url스키마를 따로 적어둔다.클라이언트 id를 info.pl...",
    "content": "Social Login1. Google Login 구현우선 firebase에서 구글을 추가.그러면 새로운 plist파일을 주는데 그걸로 바꾼다.이후 docs에 있는대로 진행을 하다보면googlecloud에서 뭘 생성을 하는데 이부분을 사진을 찍지 못했다.무튼 여기서 이렇게 클라이언트 id와, url스키마를 따로 적어둔다.클라이언트 id를 info.plist에 추가.Docs에서 AppDelegate에 인증 관련 메서드를 추가하라고 나와있어 해당 부분 추가import GoogleSignInfunc application(_ app: UIApplication,                     open url: URL,                     options: [UIApplication.OpenURLOptionsKey: Any] = [:]) -&gt; Bool {      return GIDSignIn.sharedInstance.handle(url)    }우선은 틀만 잡기 위해서vm을 이렇게 해두었다.func googleLoginDidTapped(presentViewController: UIViewController) {        GIDSignIn.sharedInstance.signIn(withPresenting: presentViewController) { [weak self] signInResult, error in            if let error = error {                self?.loginPublisher.send(completion: .failure(error))            }                        guard let result = signInResult else { return }            self?.loginPublisher.send()            print(result.user.userID)            print(result)        }    }물론 구글은 vc가 필요해서 프로토콜을 다음과 같이 한다.protocol LoginInput {    func appleLoginDidTapped ()    func kakaoLoginDidTapped ()    func googleLoginDidTapped (presentViewController: UIViewController) // added}그다음은 sceneDelegate 설정var greetingVC = GreetingViewController()                greetingVC = GreetingViewController(            appleTapped: { [weak signViewModel] in               signViewModel?.appleLoginDidTapped()            }            ,kakaoTapped: { [weak signViewModel] in                signViewModel?.kakaoLoginDidTapped()            }, googleTapped: { [weak signViewModel] in                signViewModel?.googleLoginDidTapped(presentViewController: greetingVC)}            , viewModel: signViewModel)지금은 이렇게 했지만처음에는let greetingVC = GreetingViewController(            appleTapped: { [weak signViewModel] in               signViewModel?.appleLoginDidTapped()            }            ,kakaoTapped: { [weak signViewModel] in                signViewModel?.kakaoLoginDidTapped()            }, googleTapped: { [weak signViewModel] in                                signViewModel?.googleLoginDidTapped(presentViewController: GreetingViewController())}            , viewModel: signViewModel)여기에다가 이렇게 했다.당연히 vc가 같을지언정 메모리는 다르기에 버튼누르면 카카오와같이 창은 뜨나 계속을 누를수도 없이 바로 사라지는 문제가 발생했다.처음에는 찾아보다가 GPT에게 도움을 요청하였으나, 해결이 안되었다.그러다가 vc를 인스턴스화할때 처음부터 이렇게 init을 안해도 생성이 된다는게 생각이나서위와 같이 하였고 성공.네이버는 objective-c라 안하는게 좋을듯 하다."
  },
  
  {
    "title": "Final (3)",
    "url": "/posts/Final-(3)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-06-01 08:00:00 +0900",
    





    
    "snippet": "Social Login1. Kakao Login 구현우선 Kakao Developer에 가서 로그인을 활성화로 설정.AppDelegate 설정 -&gt; 초기화를 해준다.import KakaoSDKCommon...func application(_ application: UIApplication, didFinishLaunchingWithOptions l...",
    "content": "Social Login1. Kakao Login 구현우선 Kakao Developer에 가서 로그인을 활성화로 설정.AppDelegate 설정 -&gt; 초기화를 해준다.import KakaoSDKCommon...func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {  KakaoSDK.initSDK(appKey: \"${NATIVE_APP_KEY}\")}SceneDelegate 설정. func scene(_ scene: UIScene, openURLContexts URLContexts: Set&lt;UIOpenURLContext&gt;) {        if let url = URLContexts.first?.url {            if (AuthApi.isKakaoTalkLoginUrl(url)) {                _ = AuthController.handleOpenUrl(url: url)            }        }    }VM 설정func kakaoLoginDidTapped() {        if (UserApi.isKakaoTalkLoginAvailable()) {            UserApi.shared.loginWithKakaoAccount {[weak self] (oauthToken, error) in                if let error = error {                    self?.loginPublisher.send(completion: .failure(error))                }                else {                    print(\"loginWithKakaoTalk() success.\")                    self?.loginPublisher.send()                    //do something                    _ = oauthToken                }            }        }    }우선은 기본적으로 제시되어있는거로만 해둔 상태.그리고 publisher를통해 전달만 하게 해두었다.그리고 VC에서 기존에 하던대로 연결을 해두었지만 실행이 되지는 않는 상태이다.아무래도func kakaoLoginDidTapped() {        print(\"tapped\")        if (UserApi.isKakaoTalkLoginAvailable()) {            UserApi.shared.loginWithKakaoAccount {[weak self] (oauthToken, error) in                if let error = error {                    self?.loginPublisher.send(completion: .failure(error))                }                else {                    self?.loginPublisher.send()                    print(\"loginWithKakaoTalk() success.\")                    //do something                    _ = oauthToken                }            }        }    }여기에서 실행이 안되는 것같다.혹시나해서 tapped를 프린트 해보았는데 출력은 되는 상태.찾아보니 카카오톡이 설치되어야만 isKakaoTalkLoginAvailable이게 호출이 되는듯하다.func kakaoLoginDidTapped() {        print(\"tapped\")        if (UserApi.isKakaoTalkLoginAvailable()) {            UserApi.shared.loginWithKakaoTalk {[weak self] (oauthToken, error) in                if let error = error {                    self?.loginPublisher.send(completion: .failure(error))                    print(error)                }                else {                    self?.loginPublisher.send()                    print(\"loginWithKakaoTalk() success.\")                    //do something                    _ = oauthToken                }            }        } else {            UserApi.shared.loginWithKakaoAccount {[weak self] (oauthToken, error) in                if let error = error {                    self?.loginPublisher.send(completion: .failure(error))                    print(error)                }                else {                    self?.loginPublisher.send()                    print(\"loginWithKakaoTalk() success.\")                    //do something                    _ = oauthToken                }            }        }    }카카오톡이 설치되어있을 경우 아닐경우로 나누었다.완료.db 이전은 네이버, 구글 완료이후에 하는걸로."
  },
  
  {
    "title": "TikTok Clone (11)",
    "url": "/posts/TikTok-Clone-(11)/",
    "categories": "Udemy, TikTok",
    "tags": "",
    "date": "2024-05-31 08:13:00 +0900",
    





    
    "snippet": "nextbutton 구현",
    "content": "nextbutton 구현"
  },
  
  {
    "title": "Final (2)",
    "url": "/posts/Final-(2)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-05-31 08:00:00 +0900",
    





    
    "snippet": "어제 구현했던게 튜터님에게 피드백을 받으면서, 나도 그렇고 팀원들도 그렇고 튜터님의 한가지 질문에 아무도 대답을 하지 못한게 있었다.  비밀번호 찾기기능은 어떻게 하실거에요?바로 이거였다.그냥 가입, 로그인만 생각했지 해당부분은 고려를 아예 하지 않은 상태였다.그래서 소셜로그인을 구현하려고한다.하지만 중요포인트라면 MVC가 아닌 MVVM으로 해당방식을...",
    "content": "어제 구현했던게 튜터님에게 피드백을 받으면서, 나도 그렇고 팀원들도 그렇고 튜터님의 한가지 질문에 아무도 대답을 하지 못한게 있었다.  비밀번호 찾기기능은 어떻게 하실거에요?바로 이거였다.그냥 가입, 로그인만 생각했지 해당부분은 고려를 아예 하지 않은 상태였다.그래서 소셜로그인을 구현하려고한다.하지만 중요포인트라면 MVC가 아닌 MVVM으로 해당방식을 구현한다는것.아마 빡셀것이다.Social Login1. Apple Login 구현우선 버튼을 다음과 같이 바꾼다.let appleLoginButton: ASAuthorizationAppleIDButton = {        let button = ASAuthorizationAppleIDButton(type: .signIn, style: .black)        button.cornerRadius = 25        button.addTarget(self, action: #selector(appleButtonDidTapped), for: .touchUpInside)        return button    }()사실 버튼의 구성엔 아무런 고민이 없었다.그다음에 ViewModel에 대해서 어떻게 함수를 정의해야할까? 라는 고민이 생겼다.참고자료를 보니 ViewModel에 여러가지를 상속하는데,처음에 내가 고민했던것과 같았다.또한 글을 보면서 튜터님이 프로토콜을 사용해서 가능 할 것 같다고 하셨는데, 지금 내가 참고하는글이 딱 그것에 대해 구현을 하고 있다.이걸 정리하면서 제대로 정리하면, 나머지 소셜로그인도 문제가 없을것 같아서 하나하나 제대로 좀 정리를 하면서 쓸 생각.1. protocol 구현protocol LoginInput {    func appleLoginDidTapped ()}protocol LoginOutput {    var loginPublisher: PassthroughSubject&lt;Void, Error&gt; { get set }}protocol LoginViewModelIO: LoginInput, LoginOutput {    }이전에 Udemy에서 봤을때의 강의에선 struct를 사용하여 Input과 output에 대해 정의를 하고 시작했는데, 여기글과, 튜터님은 프로토콜에 대해 언급을 하셨다.여러 방법으로 해보는것도 나에게는 아주 좋기에 이번엔 프로토콜로 해본다.우선 input, output 각각에 대해 프로토콜을 정의 해주었다.input은 로그인 버틀을 탭했을때 실행할 함수,output은 view, viewmodel간의 데이터바인딩이다.2. 함수 구현class SignViewModel: NSObject, ASAuthorizationControllerDelegate, LoginViewModelIO {        var loginPublisher = PassthroughSubject&lt;Void, any Error&gt;()        func appleLoginDidTapped() {        let provider = ASAuthorizationAppleIDProvider()        let request = provider.createRequest()        request.requestedScopes = [.fullName, .email]                let controller = ASAuthorizationController(authorizationRequests: [request])        controller.delegate = self        controller.presentationContextProvider = self                controller.performRequests()    }}controller의 delegate 설정을 하자마자 발생하는 에러바로 이녀석…이전에도 뭐하다가 해당 에러를 발견했는데, 에러를 제대로 읽지않고 바로 fix를 치면서 여러가지 함수를 구현해야한다고 하면서 여러 함수가 나열이 되었다.그때의 기억이 살아나, 이번엔 제대로 읽어보았다.바로 NSObject를 상속하라는것.보통은 Delegate의 주체가 VC였기에 해당부분에 있어 문제가 없었으나, ViewModel의 경우엔 그런것에 대해 상속을 받고있는 게 없었기에 발생한 문제,그래서 NSObject를 상속해 준다.그렇다면 여기서 드는 의문  NSObject란 무엇인가?      바로 이런녀석이라한다.          NSObject는 object-c 및 swift 프로그래밍 언어의 기본 클래스이며, 대부분의 다른 클래스의 루트 클래스를 역할을 한다.어플리케이션의대부분의 객체에 필요한 기본 동작을 정의하는 클래스이다. 객체를 생성, 복사, 비교 및 메모리에서 해제하는 메서드를 제공즉 이녀석이 근본.      그래서 NSobject를 상속하기로 결정. 그러면 위에 에러도 사라진다. 만약 NSobject를 상속하지않으면 수없이 많은 함수들을 구현해줘야한다.즉 너 상속 안할거면 너가 필요한부분 직접 커스터마이징 하라는것…controller.presentationContextProvider = self을 적으니 관련 프로토콜 ASAuthorizationControllerPresentationContextProviding 이녀석을 채택해야하고UIView가 필요하다.하지만 view를 사용하기위해선 UIkit을 import 해야하는데 이건 ViewModel의 취지와는 다르다.어떻게 해야할지 고민을 하다 참고글을 읽어보니 여기선 해당부분을 사용하지 않았다.하지만 해당 고민을 GPT에는 이녀석을 다음과 같이 처리했다.func presentationAnchor(for controller: ASAuthorizationController) -&gt; ASPresentationAnchor {             return UIApplication.shared.windows.first!    }우선은 이방법을 한번 사용해보는걸로!.extension SignViewModel: ASAuthorizationControllerDelegate, ASAuthorizationControllerPresentationContextProviding{        func presentationAnchor(for controller: ASAuthorizationController) -&gt; ASPresentationAnchor {             return UIApplication.shared.windows.first!    }        func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: any Error) {        loginPublisher.send(completion: .failure(error))    }        func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {                guard let credential = authorization.credential as? ASAuthorizationAppleIDCredential else { return }        loginPublisher.send()            }}우선은 파베에 넣지않고 작동 확인 후 파베에 정보를 저장 할 예정3. 의존성 주입해당부분은 어제 튜터님께 얼추 배웠기에 그것을 기반으로 의존성 주입을 해보도록 한다.우선 View에서 부터 시작.var appleTapped: (() -&gt; Void)? @objc func appleButtonDidTapped() {        appleTapped?()    }Apple 버튼이 탭 되었을때 클로저를 작동.ViewModel에는 다음과 같이 해준다.private let signManager: SignManager        init(signManager: SignManager) {        self.signManager = signManager    }    VC는 이렇게private lazy var greetingBodyView: GreetingBodyView = {        let view = GreetingBodyView()        view.appleTapped = appleTapped        return view    }()var appleTapped: (() -&gt; Void)!var viewModel: SignViewModel!        convenience init(appleTapped: @escaping () -&gt; Void, viewModel: SignViewModel) {        self.init()        self.appleTapped = appleTapped        self.viewModel = viewModel    }이제 view에서 클릭되는 버튼이 viewmodel의 appleLoginDidTapped를 실행하게만 하면 될것같다.SceneDelegate에서 해당부분을 구현한다.private lazy var signManager = SignManager() // addedprivate lazy var signViewModel = SignViewModel(signManager: signManager) // added        func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {                guard let windowScene = (scene as? UIWindowScene) else { return }                let window = UIWindow(windowScene: windowScene)        let greetingVC = GreetingViewController(appleTapped: { [weak self] in // modified            self?.signViewModel.appleLoginDidTapped()        }, viewModel: signViewModel)        self.window = window        window.makeKeyAndVisible()완료."
  },
  
  {
    "title": "Final (1)",
    "url": "/posts/Final-(1)/",
    "categories": "캠프, TheLast",
    "tags": "",
    "date": "2024-05-30 15:00:00 +0900",
    





    
    "snippet": "이틀간의 회의, 대략적인 와이어프레임 구성이 끝났다.이번에 우선적으로 내가 해야하는것은 Sign In, Sign Up, Sign out이 되겠다.Firebase Auth를 사용할 계획.Sign up 기능 구현우선 디자인은 얼추 했고, 물론 view로 세부적으로 다시 따는건 주말에 하고 가입 기능 부터 먼저 하나 해보려 한다이번엔 MVVM이므로 좀 더 ...",
    "content": "이틀간의 회의, 대략적인 와이어프레임 구성이 끝났다.이번에 우선적으로 내가 해야하는것은 Sign In, Sign Up, Sign out이 되겠다.Firebase Auth를 사용할 계획.Sign up 기능 구현우선 디자인은 얼추 했고, 물론 view로 세부적으로 다시 따는건 주말에 하고 가입 기능 부터 먼저 하나 해보려 한다이번엔 MVVM이므로 좀 더 생각을 해서 구현을 해야한다.우선 SignUpVM, SignManager 두개를 만들어준다SignManager를 통해 Firebase와 통신을 할 예정class SignManager {        func signUp(nickName: String, email: String, password: String, onError: @escaping((Error) -&gt; Void)) {        Auth.auth().createUser(withEmail: email, password: password) { authDataResult, error in                        // error를 escaping closure를 통해 전달.            if error != nil {                onError(error!)                return            }                        // error가 없을 경우            if let authData = authDataResult {                var dict: Dictionary&lt;String, Any&gt; = [                    \"uid\": authData.user.uid,                    \"email\": authData.user.email,                    \"username\": nickName,                    \"profileImageUrl\": \"\"                ]                   Database.database().reference().child(\"users\").child(authData.user.uid).updateChildValues(dict) { error, ref in                    if error != nil {                        onError(error!)                    }                }            }        }            }}우선은 이렇게 구현그리고 버튼에 대한 메서드는 다음과 같이 했다.이렇게 하게되면 Auth 뿐만아니라 DB에도 유져에 대한 데이터가 저장이 된다.@objc func signUpButtonDidTapped() {                signUpVM.signUp(nickName: nicknameTextField.text!, email: emailTextField.text!, password: passwordTextField.text!) { [weak self] error in            let alert = UIAlertController(title: \"에러 발생\", message: \"\\(error.localizedDescription)이 발생했습니다\", preferredStyle: .alert)            alert.addAction(UIAlertAction(title: \"확인\", style: .default))            self?.present(alert, animated: true)        }        let alert = UIAlertController(title: \"가입 완료\", message: \"회원 가입 되었습니다.\\n환영합니다.\", preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"확인\", style: .default))        self.present(alert, animated: true)    }완료.Sign in 구현func signIn(email: String, password: String, onError: @escaping((Error) -&gt; Void)) {        Auth.auth().signIn(withEmail: email, password: password) { authDataResult, error in            // error를 escaping closure를 통해 전달.            if error != nil {                onError(error!)                return            }             print(authDataResult?.user.email) // check        }    }로그인은 더 간단하다로그인 확인을 위해 print로 확인을 해보려고 적는다.@objc func signInButtonDidTapped() {        signVM.signIn(email: emailTextField.text!, password: passwordTextField.text!) { [weak self] error in            let alert = UIAlertController(title: \"에러 발생\", message: \"\\(error.localizedDescription)이 발생했습니다\", preferredStyle: .alert)            alert.addAction(UIAlertAction(title: \"확인\", style: .default))            self?.present(alert, animated: true)        }    }Optional(\"test1@gmail.com\")출력 확인 완료.즉 로그인이 된다는것.오늘은 심플하게 이걸로 끝"
  },
  
  {
    "title": "TikTok Clone (10)",
    "url": "/posts/TikTok-Clone-(10)/",
    "categories": "Udemy, TikTok",
    "tags": "",
    "date": "2024-05-29 10:13:00 +0900",
    





    
    "snippet": "여기부분은 강의에서도 그냥 타이핑만 하고 파일을 제공해주므로 각 function에 대해서 적어본다.VideoComposition Writer 만들기func mergeMultipleVideo(urls: [URL], onComplete: @escaping (Bool, URL?) -&gt; Void) {        var totalDuration = CM...",
    "content": "여기부분은 강의에서도 그냥 타이핑만 하고 파일을 제공해주므로 각 function에 대해서 적어본다.VideoComposition Writer 만들기func mergeMultipleVideo(urls: [URL], onComplete: @escaping (Bool, URL?) -&gt; Void) {        var totalDuration = CMTime.zero        var assets: [AVAsset] = []                for url in urls {            let asset = AVAsset(url: url)            assets.append(asset)            totalDuration = CMTimeAdd(totalDuration, asset.duration)        }                let outputURL = createOutputUrl(with: urls.first!)        let mixComposition = merge(arrayVideos: assets)        handleCreateExportSession(outputURL: outputURL, mixComposition: mixComposition, onComplete: onComplete)    }  에셋 준비          각 비디오 URL로부터 AVAsset 객체를 생성하여 assets 배열에 추가한다.      CMTimeAdd 함수를 사용하여 각 비디오의 지속 시간을 totalDuration에 더한다.      CMTimeAdd 함수는 두 개의 CMTime 값을 더하는데 사용한다, CMTime은 시간 값을 나타내는 구조체로, 비디오 및 오디오 처리에서 시간 계산에 사용된다.        출력 URL 생성          createOutputUrl(with:) 함수를 호출하여 첫 번째 비디오 URL을 기반으로 출력 파일의 경로를 생성        비디오 병합          merge(arrayVideos:) 함수를 호출하여 여러 비디오 에셋을 하나의 AVMutableComposition 객체로 병합      이 함수는 비디오와 오디오 트랙을 추가하고, 각 비디오의 시간 범위를 삽입하여 하나의 구성으로 만든다.        내보내기 세션 처리          handleCreateExportSession(outputURL:mixComposition:onComplete:) 함수를 호출하여 내보내기 세션을 설정하고 비동기로 내보내기 작업을 수행       func handleCreateExportSession(outputURL: URL, mixComposition: AVMutableComposition, onComplete: @escaping (Bool, URL?) -&gt; Void) {        exportSession = AVAssetExportSession(asset: mixComposition, presetName: AVAssetExportPresetHighestQuality)        exportSession?.outputURL = outputURL        exportSession?.shouldOptimizeForNetworkUse = true        exportSession?.outputFileType = AVFileType.mp4                var exportProgressBarTimer = Timer()        guard let exportSessionUnwrapped = exportSession else {             exportProgressBarTimer.invalidate()            return        }                exportProgressBarTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true, block: { timer in            let progress = Float((exportSessionUnwrapped.progress))            let dict: [String: Float] = [\"progress\": progress]            // NotificationCenter.default.post(name: .updateProgress, object: nil, userInfo: dict)        })                exportSession.exportAsynchronously {            exportProgressBarTimer.invalidate()            switch exportSession.status {            case .completed:                DispatchQueue.main.async {                    let dict: [String: Float] = [\"progress\": 1.0]                    // NotificationCenter.default.post(name: .updateProgress, object: nil, userInfo: dict)                    onComplete(true, exportSession.outputURL)                }            case .failed:                print(\"Failed \\(exportSession.error.debugDescription)\")                onComplete(false, nil)            case .cancelled:                print(\"Cancelled \\(exportSession.error.debugDescription)\")                onComplete(false, nil)            default:                break            }        }    }  내보내기 세션 초기화 및 설정          AVAssetExportSession 객체를 AVAssetExportPresetHighestQuality 프리셋으로 초기화      outputURL을 내보내기 세션의 출력 URL로 설정      shouldOptimizeForNetworkUse를 true로 설정하여 네트워크 사용을 최적화      outputFileType을 AVFileType.mp4로 설정        진행 상황 모니터링          Timer 객체를 사용하여 0.1초마다 내보내기 진행 상황을 체크      진행 상황을 progress 변수로 저장하고, 필요 시 알림(NotificationCenter)을 통해 업데이트를 전송할 수 있다.      타이머는 exportProgressBarTimer에 저장되며, 내보내기 세션이 종료되면 타이머를 무효화        비동기 내보내기          exportAsynchronously 메서드를 호출하여 비동기로 내보내기 작업을 시작      내보내기 작업이 완료되면 exportSession.status를 확인하여 완료, 실패, 취소 등의 상태에 따라 처리      내보내기 작업이 성공적으로 완료되면, 완료 핸들러(onComplete)를 호출하여 true와 출력 URL을 전달      실패하거나 취소된 경우, 오류 메시지를 출력하고 완료 핸들러를 호출하여 false와 nil을 전달      func createOutputUrl(with videoUrl: URL) -&gt; URL {        let fileManager = FileManager.default        let documentDirectory = NSURL.fileURL(withPath: NSTemporaryDirectory(), isDirectory: true)                var outputUrl = documentDirectory.appendingPathComponent(\"output\")        do {            try fileManager.createDirectory(at: outputUrl, withIntermediateDirectories: true)            outputUrl = outputUrl.appendingPathComponent(\"\\(videoUrl.lastPathComponent)\")        } catch let error {            print(error)        }                return outputUrl    }  임시 디렉토리 경로 가져오기          NSTemporaryDirectory() 함수를 사용하여 임시 디렉토리 경로를 가져온다.      NSURL.fileURL(withPath:isDirectory:) 함수를 사용하여 임시 디렉토리의 URL 객체를 생성        출력 디렉토리 생성          documentDirectory URL에 “output” 디렉토리를 추가하여 outputUrl을 생성      FileManager를 사용하여 해당 디렉토리를 생성, 이미 디렉토리가 있는 경우에도 에러 없이 중첩된 디렉토리를 생성        출력 파일 URL 생성          videoUrl.lastPathComponent를 사용하여 원본 비디오 파일의 이름을 가져온다      outputUrl에 파일 이름을 추가하여 최종 출력 파일의 URL을 생성한다.        에러 처리          디렉토리 생성 중 에러가 발생하면 에러 메시지를 출력        출력 URL 반환          최종 생성된 출력 파일의 URL을 리턴      func merge(arrayVideos: [AVAsset]) -&gt; AVMutableComposition {        let mainComposition = AVMutableComposition()                let compositionVideoTrack = mainComposition.addMutableTrack(withMediaType: .video, preferredTrackID: kCMPersistentTrackID_Invalid)                let compositionAudioTrack = mainComposition.addMutableTrack(withMediaType: .audio, preferredTrackID: kCMPersistentTrackID_Invalid)                let frontCameraTransform: CGAffineTransform = CGAffineTransform(scaleX: -1.0, y: 1.0).rotated(by: CGFloat(Double.pi/2))        let backCameraTransform: CGAffineTransform = CGAffineTransform(rotationAngle: .pi/2)                compositionVideoTrack?.preferredTransform = backCameraTransform                var insertTime = CMTime.zero                for videoAsset in arrayVideos {            try! compositionVideoTrack?.insertTimeRange(CMTimeRangeMake(start: CMTime.zero, duration: videoAsset.duration), of:                                                            videoAsset.tracks(withMediaType: .video)[0], at: insertTime)                        if videoAsset.tracks(withMediaType: .audio).count &gt; 0 {                try! compositionAudioTrack?.insertTimeRange(CMTimeRangeMake(start: CMTime.zero, duration: videoAsset.duration), of: videoAsset.tracks(withMediaType: .audio)[0], at: insertTime)            }            insertTime = CMTimeAdd(insertTime, videoAsset.duration)        }        return mainComposition            }  AVMutableComposition 객체 생성          AVMutableComposition 객체를 생성하여 비디오 및 오디오 트랙을 추가할 수 있는 구성 객체를 생성        비디오 및 오디오 트랙 추가          mainComposition에 비디오 및 오디오 트랙을 추가      compositionVideoTrack과 compositionAudioTrack을 생성        비디오 트랙의 변환 설정          frontCameraTransform과 backCameraTransform을 정의      여기에선 후면 카메라 변환(backCameraTransform)을 비디오 트랙의 기본 변환으로 설정한다.        비디오 및 오디오 트랙 삽입          insertTime을 초기화      각 비디오 에셋을 순회하며 해당 비디오와 오디오 트랙을 구성 객체에 삽입      CMTimeRangeMake를 사용하여 각 비디오의 전체 시간을 삽입      삽입된 각 비디오의 지속 시간을 insertTime에 더하여 다음 비디오의 삽입 시간을 갱신한다.      func saveVideoTobeUploadedToServerToTempDirectory(sourceURL: URL, completion: ((_ outputUrl: URL) -&gt; Void)? = nil) {    let fileManager = FileManager.default    //        let documentDirectory = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]    //    let documentDirectory = NSURL.fileURL(withPath: NSTemporaryDirectory(), isDirectory: true)        let asset = AVAsset(url: sourceURL)    let length = Float(asset.duration.value) / Float(asset.duration.timescale)    print(\"video length: \\(length) seconds\")        var outputURL = documentDirectory.appendingPathComponent(\"output\")    do {        try fileManager.createDirectory(at: outputURL, withIntermediateDirectories: true, attributes: nil)        outputURL = outputURL.appendingPathComponent(\"\\(sourceURL.lastPathComponent).mp4\")    }catch let error {        print(error)    }        //Remove existing file    try? fileManager.removeItem(at: outputURL)        guard let exportSession = AVAssetExportSession(asset: asset, presetName: AVAssetExportPresetHighestQuality) else { return }    exportSession.outputURL = outputURL    exportSession.outputFileType = AVFileType.mp4            exportSession.exportAsynchronously {        switch exportSession.status {        case .completed:            print(\"exported at \\(outputURL)\")            completion?(outputURL)        case .failed:            print(\"failed \\(exportSession.error.debugDescription)\")        case .cancelled:            print(\"cancelled \\(exportSession.error.debugDescription)\")        default: break        }    }}  파일 관리자 설정          FileManager.default를 사용하여 파일 관리자 객체를 가져온다.        임시 디렉토리 경로 설정          NSTemporaryDirectory() 함수를 사용하여 임시 디렉토리 경로를 가져오고, 이를 기반으로 documentDirectory URL 객체를 생성        AVAsset 객체 생성          AVAsset(url: sourceURL)을 사용하여 주어진 비디오 URL로부터 AVAsset 객체를 생성      비디오의 길이를 계산하여 출력. 비디오 길이는 asset.duration.value와 asset.duration.timescale을 사용하여 계산        출력 디렉토리 및 파일 경로 설정          outputURL을 생성하여 임시 디렉토리의 “output” 디렉토리에 비디오 파일 이름을 추가      FileManager를 사용하여 출력 디렉토리를 생성. 중첩된 디렉토리 생성을 허용한다.      기존 파일이 존재하면 삭제        AVAssetExportSession 설정          AVAssetExportSession(asset: asset, presetName: AVAssetExportPresetHighestQuality)를 사용하여 내보내기 세션을 생성      내보내기 세션의 출력 URL과 파일 형식을 설정        비동기 내보내기          exportAsynchronously 메서드를 호출하여 비동기로 내보내기 작업을 시작      내보내기 작업이 완료되면 상태에 따라 결과를 처리      내보내기 성공 시 완료 핸들러를 호출하여 출력 URL을 반환      실패하거나 취소된 경우, 오류 메시지를 출력하고 완료 핸들러를 호출하여 nil을 반환      "
  },
  
  {
    "title": "TikTok Clone (9)",
    "url": "/posts/TikTok-Clone-(9)/",
    "categories": "Udemy, TikTok",
    "tags": "",
    "date": "2024-05-28 10:13:00 +0900",
    





    
    "snippet": "Save 버튼 구현새로운 VC를 만들고 코드는 다음과 같다class PreviewCapturedViewController: UIViewController {        var currentlyPlayingVideoClip: VideoClips    var recordedClips: [VideoClips]    var viewWillDenitResta...",
    "content": "Save 버튼 구현새로운 VC를 만들고 코드는 다음과 같다class PreviewCapturedViewController: UIViewController {        var currentlyPlayingVideoClip: VideoClips    var recordedClips: [VideoClips]    var viewWillDenitRestartVideoSession: (() -&gt; Void)?        deinit {        print(\"PreviewCaptureVideoVC was deinited\")        (viewWillDenitRestartVideoSession)?()    }        override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.    }        init?(coder: NSCoder, recordedClips: [VideoClips]) {        self.currentlyPlayingVideoClip = recordedClips.first!        self.recordedClips = recordedClips        super.init(coder: coder)    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }    }init?(coder: NSCoder, recordedClips: [VideoClips])녹화된 클립 배열을 인수로 받아 현재 재생 중인 클립을 배열의 첫 번째 요소로 설정하고, recordedClips 속성에 할당한다.deinit을 통해 메모리에서 해제할때 viewWillDenitRestartVideoSession클로저를 호출다시 CreatePostVC로 가서@IBAction func saveButtonDidTapped(_ sender: Any) {        let previewVC = UIStoryboard(name: \"Main\", bundle: .main).instantiateViewController(identifier: \"PreviewCapturedViewController\", creator: { coder -&gt; PreviewCapturedViewController? in            PreviewCapturedViewController(coder: coder, recordedClips: self.recordedClips)        })        previewVC.viewWillDenitRestartVideoSession = { [weak self ] in            guard let self = self else { return }            if self.setupCaptureSession() {                DispatchQueue.global(qos: .background).async {                    self.captureSession.startRunning()                }            }        }        navigationController?.pushViewController(previewVC, animated: true)    }버튼과 관련된 기능을 구현여기서 조금 색다른 점이라면 기본적으로 인스턴스 화를 하는방식과는 다르다.creator를 사용 했는데, creator 클로저를 통해 PreviewCapturedViewController의 초기화 메서드인 init(coder:recordedClips:)를 호출하면서 인스턴스화 하게 된다.이후 인스턴스화를 한 상태에서 viewWillDenitRestartVideoSession 의 클로저를 정의PreviewCapturedViewController가 deinit될 때 호출되는 녀석이다.captureSession.startRunning()을 호출하여 캡처 세션을 시작한다.비디오 미리보기 구현우선 previewVC에 uiview, uiimageview를 추가해 주었고,3개의 변수가 추가되었다.var player: AVPlayer = AVPlayer()var playerLayer: AVPlayerLayer = AVPlayerLayer()var urlsForVids: [URL] = [] {        didSet {            print(\"outputURLunwrapped:\", urlsForVids)        }    }     override func viewDidLoad() {        super.viewDidLoad()                handleStartPlayingFirstClip()        hideStatusBar = true                print(\"\\(recordedClips.count)\")        recordedClips.forEach { clip in            urlsForVids.append(clip.videoUrl)        }    }    override func viewWillAppear(_ animated: Bool) {        super.viewWillAppear(animated)        self.tabBarController?.tabBar.isHidden = true        navigationController?.setNavigationBarHidden(true, animated: animated)        player.play()        hideStatusBar = true    }        override func viewWillDisappear(_ animated: Bool) {        super.viewWillDisappear(animated)        self.tabBarController?.tabBar.isHidden = false        navigationController?.setNavigationBarHidden(false, animated: animated)        player.pause()    }VC 생명주기를 고려하여 작성이 되었고 뭐 딱히 없다.    func handleStartPlayingFirstClip() {        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {            guard let firstClip = self.recordedClips.first else { return }            self.currentlyPlayingVideoClip = firstClip            self.setupPlayerView(with: firstClip)        }    }첫번째 클립에 대해 재생하는 메서드    func setupPlayerView(with videoClip: VideoClips) {        let player = AVPlayer(url: videoClip.videoUrl)        let playerLayer = AVPlayerLayer(player: player)        self.player = player        self.playerLayer = playerLayer        playerLayer.frame = thumbnailImageView.frame        self.player = player        self.playerLayer = playerLayer        thumbnailImageView.layer.insertSublayer(playerLayer, at: 3)        player.play()        NotificationCenter.default.addObserver(self, selector: #selector(avPlayerItemDidPlayToEndTime(notification:)), name: NSNotification.Name.AVPlayerItemDidPlayToEndTime, object: player.currentItem)        handleMirrorPlayer(cameraPosition: videoClip.cameraPosition)    }뭐 여기부분도 크게 언급할건 없을것같고플레이어와 플레이어레이어를 설정하고, 레이어 프레임에 썸네일 이미지 프레임을 넣어준다.thumbnailImageView.layer.insertSublayer(playerLayer, at: 3)는 4번째 레이어에 추가를 한다는 것.    func removePeriodicTimeobserver() {        player.replaceCurrentItem(with: nil)        playerLayer.removeFromSuperlayer()    }재생중인 플레이어를 초기화.그리고 레이어를 제거함으로써 비디오 제거    @objc func avPlayerItemDidPlayToEndTime(notification: Notification) {        if let currentIndex = recordedClips.firstIndex(of: currentlyPlayingVideoClip) {            let nextIndex = currentIndex + 1            if nextIndex &gt; recordedClips.count - 1 {                removePeriodicTimeobserver()                guard let firstClip = recordedClips.first else { return }                setupPlayerView(with: firstClip)                currentlyPlayingVideoClip = firstClip            } else {                for (index, clip) in recordedClips.enumerated() {                    if index == nextIndex {                        removePeriodicTimeobserver()                        setupPlayerView(with: clip)                        currentlyPlayingVideoClip = clip                    }                }            }        }                }현재 비디오가 재생이 끝났을때 다음 비디오를 재생하게 하는 로직이다.마지막 비디오 클립 재생이 끝나면 다시 첫번째 영상을 재생하도록 한다.removePeriodicTimeobserver를 호출하여 이전 클립의 플레이어 설정을 제거하고, setupPlayerView(with:)를 호출하여 새로운 클립을 설정한다.    func handleMirrorPlayer(cameraPosition: AVCaptureDevice.Position) {        if cameraPosition == .front {            thumbnailImageView.transform = CGAffineTransform(scaleX: -1, y: -1)        } else {            thumbnailImageView.transform = .identity        }    }카메라의 전후에 따라 이미지 뷰를 반전시킨다.대체텍스트확인 완료."
  },
  
  {
    "title": "TikTok Clone (8)",
    "url": "/posts/TikTok-Clone-(8)/",
    "categories": "Udemy, TikTok",
    "tags": "",
    "date": "2024-05-27 10:13:00 +0900",
    





    
    "snippet": "ProgressView 추가func timerTick() {        total_RecordedTime_In_Secs += 1        videoDurationOfLastClip += 1                let time_limit = currentMaxRecordingDuration * 10        if total_Recorde...",
    "content": "ProgressView 추가func timerTick() {        total_RecordedTime_In_Secs += 1        videoDurationOfLastClip += 1                let time_limit = currentMaxRecordingDuration * 10        if total_RecordedTime_In_Secs == time_limit {            handleDidTapRecord()        }        // added        let startTime = 0        let trimmedTime: Int = Int(currentMaxRecordingDuration) - startTime        let positiveOrZero = max(total_RecordedTime_In_Secs, 0)        let progress = Float(positiveOrZero) / Float(trimmedTime) / 10        segmentedProgressView.setProgress(CGFloat(progress))        let countDownSec: Int = Int(currentMaxRecordingDuration) - total_RecordedTime_In_Secs / 10        timerCounterLabel.text = \"\\(countDownSec)\"    }func stopRecording() {        if movieOutput.isRecording == true {            movieOutput.stopRecording()            handleAnimateRecordButton()            stopTimer()            segmentedProgressView.pauseProgress() // added            print(\"Stop Count\")        }    }대체텍스트그리고 stopRecording에 새로 추가를 했는데저건 멈추면이렇게 보인다.discard 기능 추가우선 discard 버튼을 눌렀을때 Alert를 띄우게 구현 @IBAction func discardButtonDidTapped(_ sender: Any) {        let alertVC = UIAlertController(title: \"Discard the last Clip?\", message: nil, preferredStyle: .alert)        let discardAction = UIAlertAction(title: \"Discard\", style: .default) { [weak self] (_) in            self?.handleDiscardLastRecordedClip()        }        let keepAction = UIAlertAction(title: \"Keep\", style: .cancel) { (_) in                    }        alertVC.addAction(discardAction)        alertVC.addAction(keepAction)        present(alertVC, animated: true)    }그리고 메서드는 다음과 같이 구현func handleDiscardLastRecordedClip() {        print(\"discard\")        outputURL = nil        thumbnailImage = nil        recordedClips.removeLast()        handleResetAllVisibilityToIdentity()        handleSetNewOutputURLAndThumbnailImage()        segmentedProgressView.handleRemoveLastSegment()                if recordedClips.isEmpty == true {            self.handleResetTimerAndProgressViewToZero()        } else if recordedClips.isEmpty == false {            self.handleCalculateDurationLeft()        }    }지금 여기는 그냥 기존에 있었던 값들을 nil로 바꾸고 마지막에 있던 클립을 지워준다.func handleSetNewOutputURLAndThumbnailImage() {        outputURL = recordedClips.last?.videoUrl        let currentUrl: URL? = outputURL        guard let currentUrlUnwrapped = currentUrl else { return }        guard let generatedThumbnailImage = generateVideoThumbnail(withfile: currentUrlUnwrapped) else { return }        if currentCameraDevice?.position == .front {            thumbnailImage = didTakePicture(generatedThumbnailImage, to: .upMirrored)        } else {            thumbnailImage = generatedThumbnailImage        }       }최근 녹화된 url을 가져온다. 그걸 unwrapping을 해주었다.그 뒤 썸네일 이미지를 생성.  func handleResetTimerAndProgressViewToZero() {        total_RecordedTime_In_Secs = 0        total_RecordedTime_In_Minutes = 0        videoDurationOfLastClip = 0        stopTimer()        segmentedProgressView.setProgress(0)        timerCounterLabel.text = \"\\(currentMaxRecordingDuration)\"            }설명 생략.func handleCalculateDurationLeft() {        let timeToDiscard = videoDurationOfLastClip        let currentCombineTime = total_RecordedTime_In_Secs        let newVideoDuration = currentCombineTime - timeToDiscard        total_RecordedTime_In_Secs = newVideoDuration        let countDownSec: Int = Int(currentMaxRecordingDuration) - total_RecordedTime_In_Secs / 10        timerCounterLabel.text = \"\\(countDownSec)\"    }    timeToDiscard 에 마지막 클립의 길이를 저장하고, currentCombineTime에는 현재까지 녹화된 시간을 저장한다.newVideoDuration를 통해 현재까지 녹화된 전체 시간을 담는다.countDownSec 에는 남는 시간을 계산 한다.대체텍스트discard를 하게되면 다시 리셋이 되는걸 볼 수 있다.오늘은 컨디션 관리를 위해 여기까지."
  },
  
  {
    "title": "TikTok Clone (7)",
    "url": "/posts/TikTok-Clone-(7)/",
    "categories": "Udemy, TikTok",
    "tags": "",
    "date": "2024-05-26 21:13:00 +0900",
    





    
    "snippet": "멀티 채널 영상 녹화우선 VideoClip에 대한 모델링을 하나 해준다.import UIKitimport AVKitstruct VideoClips: Equatable {        let videoUrl: URL    let cameraPosition: AVCaptureDevice.Position        init(videoUrl: URL, ca...",
    "content": "멀티 채널 영상 녹화우선 VideoClip에 대한 모델링을 하나 해준다.import UIKitimport AVKitstruct VideoClips: Equatable {        let videoUrl: URL    let cameraPosition: AVCaptureDevice.Position        init(videoUrl: URL, cameraPosition: AVCaptureDevice.Position?) {        self.videoUrl = videoUrl        self.cameraPosition = cameraPosition ?? .back    }        static func ==(lhs: VideoClips, rhs:VideoClips) -&gt; Bool {        return lhs.videoUrl == rhs.videoUrl &amp;&amp; lhs.cameraPosition == rhs.cameraPosition    }    }Equatable은 비교를 할 수 있는 프로토콜이다.Equatable 프로토콜을 구현하여 두 VideoClips 객체를 비교할 수 있게 한다.두 객체의 videoUrl과 cameraPosition이 모두 같을 때만 두 객체가 동일한 것으로 간주!우선 녹화를 시작하는 메서드를 구현func fileOutput(_ output: AVCaptureFileOutput, didStartRecordingTo fileURL: URL, from connections: [AVCaptureConnection]) {        let newRecordedClip = VideoClips(videoUrl: fileURL, cameraPosition: currentCameraDevice?.position)        recordedClips.append(newRecordedClip)        print(\"recordedClips\", recordedClips.count)            }AVCaptureFileOutputRecordingDelegate의 메서드 중 하나이며, 녹화가 시작되면 호출 된다.새로운 비디오 클립을 생성하고지금까지 녹화된 모든 비디오 클립을 저장하는 배열인 recordedClips 배열에 추가해준다.녹화 시작, 중단 함수 구현func startRecording() {        if movieOutput.isRecording == false {            guard let connection = movieOutput.connection(with: .video) else { return }            if connection.isVideoOrientationSupported {                connection.preferredVideoStabilizationMode = AVCaptureVideoStabilizationMode.auto                let device = activeInput.device                if device.isSmoothAutoFocusSupported {                    do {                        try device.lockForConfiguration()                        device.isSmoothAutoFocusEnabled = false                        device.unlockForConfiguration()                    } catch {                        print(\"Error setting configuration: \\(error.localizedDescription)\")                    }                }                outputURL = tempUrl()                movieOutput.startRecording(to: outputURL, recordingDelegate: self)            }        }    }        func stopRecording() {        if movieOutput.isRecording == true {            movieOutput.stopRecording()            print(\"Stop Count\")        }    }우선 movieOutput을 통해 녹화상태인지를 먼저 확인한다.그리고 비디오 연결 설정을 해준다.연결 설정을 통하여 비디오 안정화 및 자동 초점을 설정을 하게 된다.비디오 안정화 설정: 비디오 연결이 비디오 방향을 지원하는 경우, preferredVideoStabilizationMode를 auto로 설정하여 자동 비디오 안정화를 활성화자동 초점 설정: 현재 활성화된 입력 장치(activeInput.device)가 부드러운 자동 초점을 지원하는지 확인장치가 부드러운 자동 초점을 지원하는 경우, 장치 설정을 잠그고(lockForConfiguration), 부드러운 자동 초점을 비활성화(isSmoothAutoFocusEnabled = false)한 후 설정을 해제(unlockForConfiguration)이후 tempUrl을 통해 파일을 저장할 임시 url을 생성한다.func tempUrl() -&gt; URL? {        let directory = NSTemporaryDirectory() as NSString                if directory != \"\" {            let path = directory.appendingPathComponent(NSUUID().uuidString + \".mp4\")            return URL(fileURLWithPath: path)        }        return nil    }영상 녹화 시 버튼 애니메이션 추가var isRecording = false를 하나 만들어준다.그리고 함수를 하나 만들건데 함수의 위치는 다음과 같다func startRecording() {        if movieOutput.isRecording == false {            guard let connection = movieOutput.connection(with: .video) else { return }            if connection.isVideoOrientationSupported {                connection.preferredVideoStabilizationMode = AVCaptureVideoStabilizationMode.auto                let device = activeInput.device                if device.isSmoothAutoFocusSupported {                    do {                        try device.lockForConfiguration()                        device.isSmoothAutoFocusEnabled = false                        device.unlockForConfiguration()                    } catch {                        print(\"Error setting configuration: \\(error.localizedDescription)\")                    }                }                outputURL = tempUrl()                movieOutput.startRecording(to: outputURL, recordingDelegate: self)                handleAnimateRecordButton() // here            }        }    }func stopRecording() {        if movieOutput.isRecording == true {            movieOutput.stopRecording()            handleAnimateRecordButton() // added            print(\"Stop Count\")        }    }바로 영상 녹화가 시작될때 트리거된다.그리고 해당 함수의 코드를 작성한다.func handleAnimateRecordButton() {        UIView.animate(withDuration: 0.5, delay: 0, usingSpringWithDamping: 1, initialSpringVelocity: 1, options: .curveEaseIn, animations: {            [weak self] in            guard let self = self else { return }                        if self.isRecording == false {                self.captureButton.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)                self.cancelButton.layer.cornerRadius = 5                self.captureButtonRingView.transform = CGAffineTransform(scaleX: 1.7, y: 1.7)                                self.saveButton.alpha = 0                self.discardButton.alpha = 0                                [self.flipCameraButton, self.flipCameraLabel, self.speedLabel, self.speedButton, self.beatyLabel, self.beautyButton, self.filtersLabel, self.filtersButton, self.timerLabel, self.timerButton, self.galleryButton, self.effectsButton, self.soundsView, self.timerCounterLabel].forEach { subView in                    subView?.isHidden = true                }            } else {                self.captureButton.transform = CGAffineTransform.identity                self.captureButton.layer.cornerRadius = 68/2                self.captureButtonRingView.transform = CGAffineTransform.identity                                self.handleResetAllVisibilityToIdentity()            }        }) { [weak self] onComplete in            guard let self = self else { return }            self.isRecording = !self.isRecording        }    }func handleResetAllVisibilityToIdentity() {                if recordedClips.isEmpty == true {            [self.flipCameraButton, self.flipCameraLabel, self.speedLabel, self.speedButton, self.beatyLabel, self.beautyButton, self.filtersLabel, self.filtersButton, self.timerLabel, self.timerButton, self.galleryButton, self.effectsButton, self.soundsView, self.timerCounterLabel].forEach { subView in                subView?.isHidden = false            }            saveButton.alpha = 0            discardButton.alpha = 0            print(\"recordedClips:\", \"is empty\")        } else {            [self.flipCameraButton, self.flipCameraLabel, self.speedLabel, self.speedButton, self.beatyLabel, self.beautyButton, self.filtersLabel, self.filtersButton, self.timerLabel, self.timerButton, self.galleryButton, self.effectsButton, self.soundsView, self.timerCounterLabel].forEach { subView in                subView?.isHidden = true            }            saveButton.alpha = 1            discardButton.alpha = 1            print(\"recordedClips:\", \"is not empty\")        }            }사실 버튼에 관한 애니메이션이다.CGAffineTransform 이건 사이즈를 조절할때 사용한다.self.captureButton.transform = CGAffineTransform(scaleX: 0.5, y: 0.5)이건 캡처버튼을 절반으로 줄이겠다는 의미.작동 영상.대체텍스트타이머 생성var videoDurationOfLastClip = 0var recordingTimer: Timer?var currentMaxRecordingDuration: Int = 15 {    didSet {        timerCounterLabel.text = \"\\(currentMaxRecordingDuration)s\"    }    }    var total_RecordedTime_In_Secs = 0var total_RecordedTime_In_Minutes = 0extension CreatePostViewController {    func startTimer() {        videoDurationOfLastClip = 0        stopTimer()        recordingTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true, block: { [weak self] _ in            self?.timerTick()        })    }videoDurationOfLastClip: 마지막 클립의 비디오 녹화 시간을 초 단위로 저장currentMaxRecordingDuration: 최대 녹화 시간을 저장 하고, 이 값이 변경될 때마다 timerCounterLabel에 업데이트된 시간을 표시한다.StartTimer 함수는타이머가 실행되고 있다면 중지를 먼저 하고, 새로운 타이머를 0.1초 간격으로 반복적으로 timerTick 메서드를 호출한다.func timerTick() {        total_RecordedTime_In_Secs += 1        videoDurationOfLastClip += 1                let time_limit = currentMaxRecordingDuration * 10        if total_RecordedTime_In_Secs == time_limit {            handleDidTapRecord()        }        let countDownSec: Int = Int(currentMaxRecordingDuration) - total_RecordedTime_In_Secs / 10        timerCounterLabel.text = \"\\(countDownSec)\"    }func stopTimer() {        recordingTimer?.invalidate()    }}TimerTick 함수는total_RecordedTime_In_Secs와 videoDurationOfLastClip을 0.1초 간격으로 1씩 증가시킨다.이유는 위에있는 타이머가 반복실행 되므로time_limit을 계산하여 최대 녹화 시간(초 단위로 10배)을 설정전체 녹화 시간이 time_limit에 도달하면 handleDidTapRecord()를 호출하여 녹화를 중지남은 시간을 계산하여 timerCounterLabel에 표시한다.func stopRecording() {        if movieOutput.isRecording == true {            movieOutput.stopRecording()            handleAnimateRecordButton()            stopTimer() // added            print(\"Stop Count\")        }    }func fileOutput(_ output: AVCaptureFileOutput, didStartRecordingTo fileURL: URL, from connections: [AVCaptureConnection]) {        let newRecordedClip = VideoClips(videoUrl: fileURL, cameraPosition: currentCameraDevice?.position)        recordedClips.append(newRecordedClip)        print(\"recordedClips\", recordedClips.count)        startTimer() // added       }대체텍스트15초 카운트가 끝나면 자동으로 레코딩이 멈추게 된다."
  },
  
  {
    "title": "TikTok Clone (6)",
    "url": "/posts/TikTok-Clone-(6)/",
    "categories": "Udemy, TikTok",
    "tags": "",
    "date": "2024-05-26 09:13:00 +0900",
    





    
    "snippet": "게시글 등록 VC 만들기스토리보드 디자인은 다음과 같다.해당 VC의 배경을 검게한이유는 카메라의 화면이 나올 예정이기 때문class CreatePostViewController: UIViewController {        @IBOutlet weak var cancelButton: UIButton!    @IBOutlet weak var captur...",
    "content": "게시글 등록 VC 만들기스토리보드 디자인은 다음과 같다.해당 VC의 배경을 검게한이유는 카메라의 화면이 나올 예정이기 때문class CreatePostViewController: UIViewController {        @IBOutlet weak var cancelButton: UIButton!    @IBOutlet weak var captureButton: UIButton!    @IBOutlet weak var captureButtonRingView: UIView!        override func viewDidLoad() {        super.viewDidLoad()        setupView()    }        override func viewWillAppear(_ animated: Bool) {        super.viewWillAppear(animated)        self.tabBarController?.tabBar.isHidden = true        navigationController?.setNavigationBarHidden(true, animated: animated)    }        override func viewDidDisappear(_ animated: Bool) {        super.viewDidDisappear(animated)        self.tabBarController?.tabBar.isHidden = false        navigationController?.setNavigationBarHidden(false, animated: animated)    }        func setupView() {        captureButton.backgroundColor = UIColor(red: 254/255, green: 44/255, blue: 85/255, alpha: 1.0)        captureButton.layer.cornerRadius = 68/2        captureButtonRingView.layer.borderColor = UIColor(red: 254/255, green: 44/255, blue: 85/255, alpha: 1.0).cgColor        captureButtonRingView.layer.borderWidth = 6        captureButtonRingView.layer.cornerRadius = 85/2    }    }그래서 설정을 다음과 같이한다.VC LifeCycle을 활용하여, 탭바를 사라지게했다가, 다시 보여지게 한다.왜냐 다른화면에서는 탭바가 다시 보여야하기 때문.제법 카메라 화면다워보인다.카메라 세션 설정먼저 AVFoundation이걸 임포트 해주고let photoFileOutput = AVCapturePhotoOutput()let captureSession = AVCaptureSession()다음과 같이 인스턴스화 해준다.  AVCapturePhotoOutput          스틸 사진촬영과 관련이 있는 캡처 작업흐름을 위한 인터페이스를 제공        AVCaptureSession          Capture 관련 행동들을 다루며, input device에서 output을 캡쳐할수 있도록 데이터의 흐름을 관리하는 오브젝트                  Capture의 중심이며, input(카메라, 마이크 등), output(사진, 동영상 파일 등)을 관리함.                    func setupCaptureSession() -&gt; Bool {        captureSession.sessionPreset = AVCaptureSession.Preset.high                // 1. setup inputs        if let captureVideoDevice = AVCaptureDevice.default(for: AVMediaType.video),           let captureAudioDevice = AVCaptureDevice.default(for: AVMediaType.audio) {            do {                let inputVideo = try AVCaptureDeviceInput(device: captureVideoDevice)                let inputAudio = try AVCaptureDeviceInput(device: captureAudioDevice)                                if captureSession.canAddInput(inputVideo) {                    captureSession.addInput(inputVideo)                }                                if captureSession.canAddInput(inputAudio) {                    captureSession.addInput(inputAudio)                }                            } catch let error {                print(\"Could not setup camera input:\", error)                return false            }        }                // 2. setup outputs        if captureSession.canAddOutput(photoFileOutput) {            captureSession.addOutput(photoFileOutput)        }                // 3. setup output previwes.        let previewLayer = AVCaptureVideoPreviewLayer(session: captureSession)        previewLayer.frame = view.frame        previewLayer.videoGravity = .resizeAspectFill        view.layer.addSublayer(previewLayer)        return true    }우선 코드는 다음과 같다.주석에 있듯이 크게 3개의 과정을 포인트로 한다1. 인풋 설정이건 영상과 오디오를 사용하기 위해 설정을 하는 것이다.처음에 캡쳐 세션의 프리셋을 high로 하면서 고화질 비디오를 캡쳐하도록 한다.이후 비디오 및 오디오 입력 장치를 설정하고, AVCaptureDevice.default(for: AVMediaType.video)와 AVCaptureDevice.default(for: AVMediaType.audio)를 사용하여 기본 비디오 및 오디오 장치를 가져 오도록 한다.각각의 장치로 AVCaptureDeviceInput을 생성하고 이를 캡처 세션에 추가한다.canAddInput 메서드를 사용하여 입력을 추가할 수 있는지 확인한 후, 가능한 경우 세션에 추가canAddOutput 메서드를 사용하여 출력(movieOutput)을 추가할 수 있는지 확인한 후, 가능한 경우 세션에 추가물론 이때 여러가지를 인풋으로 받아올 수 있다.그리고 이렇게 다양한 카메라 설정이 가능!그리고 어떤 형태를 내가 input으로 따올건지 설정도 가능. 여기선 비디오와 오디오를 했다.또한 position을 통해 전, 후면 설정도 가능.2. 아웃풋 설정AVCapturePhotoOutput을 캡처 세션에 추가한다.지금은 이렇게 심플하게 아웃풋을 인풋과 비슷하게 add로 했지만여기서도 좀 더 디테일하게 들어갈 수 있다.이렇게 코덱 타입이라던가.. 무수히 많으니 나중에 좀 더 알아보기로 하자.3. 미리보기 설정캡쳐하는 세션으로 부터 받아오고 그걸 띄워주는 레이어를 하나 만들고.그것의 프레임을 설정한 뒤, 어떻게 채워지게 보일지 설정을 하고, 그걸 view의 서브 뷰 개념식으로 추가를 해준다.4. info.plist 설정사진으로 퉁.실행하면 다음과 같다.대체텍스트이렇게 잘되는걸 확인.다만 이것 역시도 시뮬레이터에서는 안된다.시뮬레이터는 카메라가 없기때문카메라 전, 후 변경 설정@IBAction func flipButtonDidTapped(_ sender: Any) {        captureSession.beginConfiguration()                let currentInput = captureSession.inputs.first as? AVCaptureDeviceInput        let newCameraDevice = currentInput?.device.position == .back ? getDeviceFront(position: .front) : getDeviceBack(position: .back)                let newVideoInput = try? AVCaptureDeviceInput(device: newCameraDevice!)                if let inputs = captureSession.inputs as? [AVCaptureDeviceInput] {            for input in inputs {                captureSession.removeInput(input)            }        }                if captureSession.inputs.isEmpty {            captureSession.addInput(newVideoInput!)        }                captureSession.commitConfiguration()    }        func getDeviceFront(position: AVCaptureDevice.Position) -&gt; AVCaptureDevice? {        AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .front)    }        func getDeviceBack(position: AVCaptureDevice.Position) -&gt; AVCaptureDevice? {        AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back)    }        @IBAction func handleDismiss(_ sender: Any) {        tabBarController?.selectedIndex = 0    }세션에 설정 시작을 알리는 beginConfiguration을 사용.현재 카메라의 인풋이 뭔지를 알려주는 currentInput과 flip을 시킬 카메라 newCameraDevice 변수를 만들어준다newCameraDevice의 경우 삼항연산자를 통해 뒷면이라면 앞면을, 아니라면 뒷면을 보이게한다.카메라가 바뀌게 되면 새롭게 input값이 바뀌어야 한다.그리고 기존에 input값을 지워주고, 세션에 새롭게 인풋값을 담아주게 된다.그리고 나서 세션에는 현재 설정에 대해 적용하는 commitConfiguration를 사용한다.아래 2개의 함수는 카매라 전, 후를 변경하는 함수이다이걸 통해 위에있는 newCameraDevice에 설정하게 한다.동영상 캡쳐 기능 추가let movieOutput = AVCaptureMovieFileOutput() 이걸 추가해주고 똑같이if captureSession.canAddOutput(movieOutput) {                    captureSession.addOutput(movieOutput)                }이것도 포함시킨다그리고if captureSession.canAddInput(inputVideo) {                    captureSession.addInput(inputVideo)                    activeInput = inputVideo // added                }if captureSession.inputs.isEmpty {            captureSession.addInput(newVideoInput!)            activeInput = newVideoInput        }var activeInput: AVCaptureDeviceInput!var outputURL: URL!var currentCameraDevice: AVCaptureDevice?var thumbnailImage: UIImage?extension CreatePostViewController: AVCaptureFileOutputRecordingDelegate {    func fileOutput(_ output: AVCaptureFileOutput, didFinishRecordingTo outputFileURL: URL, from connections: [AVCaptureConnection], error: (any Error)?) {        if error != nil {            print(\"Error recording moview: \\(error?.localizedDescription ?? \"\")\")        } else {            let urlOfVideoRecorded = outputURL! as URL                        guard let generatedThumbnailImage = generateVideoThumbnail(withfile: urlOfVideoRecorded) else { return }                        if currentCameraDevice?.position == .front {                thumbnailImage = didTakePicture(generatedThumbnailImage, to: .upMirrored)            } else {                thumbnailImage = generatedThumbnailImage            }                    }    }        func didTakePicture(_ picture: UIImage, to orientation: UIImage.Orientation) -&gt; UIImage {        let flippedImage = UIImage(cgImage: picture.cgImage!, scale: picture.scale, orientation: orientation)        return flippedImage    }        func generateVideoThumbnail(withfile videoUrl: URL) -&gt; UIImage? {        let asset = AVAsset(url: videoUrl)                let imageGenerator = AVAssetImageGenerator(asset: asset)        imageGenerator.appliesPreferredTrackTransform = true                do {            let cmTime = CMTimeMake(value: 1, timescale: 60)            let thumbnailCGImage = try imageGenerator.copyCGImage(at: cmTime, actualTime: nil)            return UIImage(cgImage: thumbnailCGImage)        } catch let error {            print (error)        }        return nil    }    }첫번쨰 함수는 protocol을 채택하면 자동으로 생성되는 메서드인데 녹화 완료를 처리한다.우선 녹화된 비디오의 url을 가져오고, generateVideoThumbnail 함수를 사용해 비디오 썸네일 이미지를 생성한다.그리고 카메라가 전면일 경우, 이미지를 뒤집는다 즉 좌우 반전처리orientation을 통해 이미지의 방향을 처리한다.generateVideoThumbnail 은 위에 언급했다시피 비디오 썸네일을 만드는데우선 녹화된 비디오의 파일주소(url)을 가져온다.AVAssetImageGenerator를 생성하여 비디오에서 썸네일 이미지를 생성할 준비를 하고appliesPreferredTrackTransform을 true로 설정하여 비디오의 기본 변환(회전, 비율 등)을 적용한다.이후 do-catch 블럭을 통해 썸네일을 리턴하게 되는데CMTimeMake(value:timescale:)를 사용하여 비디오의 특정 시간(여기서는 1/60초)을 지정.copyCGImage(at:actualTime:) 메서드를 사용하여 지정된 시간에서 썸네일 이미지를 생성하고,생성된 썸네일 이미지를 UIImage로 변환하여 리턴시키게 된다."
  },
  
  {
    "title": "모의면접",
    "url": "/posts/%EB%AA%A8%EC%9D%98%EB%A9%B4%EC%A0%91/",
    "categories": "캠프, 모의면접",
    "tags": "",
    "date": "2024-05-26 08:00:00 +0900",
    





    
    "snippet": "생각해보니 모의 면접 질문에 대해 답을 한다는걸 까먹어서 정리한다.데일리로 업데이트를 해볼 예정.애매한건 나중에 적어야할 듯 하다.질문지  Storyboard를 이용해 UI를 구현하는 방법을 설명해주세요.[05.14]          StoryBoard를 사용하여 UI를 구현할때는 Commnad + Shift + L을 눌러서 UIComponent를 추...",
    "content": "생각해보니 모의 면접 질문에 대해 답을 한다는걸 까먹어서 정리한다.데일리로 업데이트를 해볼 예정.애매한건 나중에 적어야할 듯 하다.질문지  Storyboard를 이용해 UI를 구현하는 방법을 설명해주세요.[05.14]          StoryBoard를 사용하여 UI를 구현할때는 Commnad + Shift + L을 눌러서 UIComponent를 추가할 수 있는 창을 띄우고 원하는 Component를 검색 후 드래그하여 추가한다.      이때 StoryBoard로 추가한 Component는 말그대로 보이기만 하고 아무런 기능이 없기에, 우리가 여기에 기능을 부여하거나, 외적인 부분을 코드로 접근을 하려고 하는 경우엔 VC로 Control을 누른채로 드래그를 해서 IBOutlet / IBAction을 만들어 주어야 한다.        UserDefaults로 저장해놓은 데이터를 UICollectionView에 보여주는 방법을 설명해주세요. [05.16]          우선 UserDefaults는 프로젝트 내에 있는 데이터 저장소 이며, Key, Value로 이루어 진다.      Data를 저장할때는 UserDefaults.standard.set(value, forKey:””) 를 사용한다.      Data를 로드할때는 타입을 알고있다면 다음과 같이 한다.              integer(forKey:) : key값이 존재하면 정수값를 반환하고, 그렇지 않으면 0 반환      bool(forKey:) : key값이 존재하면 boolean를 반환하고, 그렇지 않으면 false 반환      float(forKey:) : key값이 존재하면 float을 반환하고, 그렇지 않으면 0.0 반환      double(forKey:) : key값이 존재하면 double을 반환하고, 그렇지 않으면 0.0 반환      object(forKey:) : 데이터 타입에 맞게 조건부로 typecast할 수 있도록 Any?를 반환      object에 대한 예시 let array = defaults.object(forKey: \"SavedArray\") as? [String] ?? [string]()        디자인과 동일한 UI를 구현하는 방법을 설명해주세요. [05.17] [GPT 사용]          디자인과 동일한 UI를 구현하려면 디자인 시스템을 명확히 이해하고, UIKit 컴포넌트를 적절히 사용해야 한다. 우선, 디자인 가이드를 분석하고 색상, 폰트, 레이아웃을 정확하게 반영한다. UIKit에서 제공하는 UILabel, UIButton, UIImageView 등을 사용하고, AutoLayout을 통해 다양한 해상도에서 동일한 레이아웃이 유지되도록 구현한다. 필요하다면 Custom View를 생성해 디테일한 UI 요소를 반영하고, UIKit Appearance를 활용해 전역 스타일을 설정할 수 있다.        present를 사용해 화면 전환을 구현하는 방법을 설명해주세요. [05.20]          present를 사용해 화면 전환을 구현하는 방법은 3가지가 있다.                        VC에서 present 사용                                      NavigationController.pushViewController 사용                                      segue를 통환 화면 전환                      동영상 재생 화면 구현 시, 불러온 이미지 리스트는 어떻게 보여지는지 설명해주세요. [05.21]          불러온 이미지 리스트는, 컬렉션뷰나, 테이블 뷰의 셀에 보여주면 된다.        두 검색 결과를 datetime 필드를 이용해 정렬하여 출력하는 방법을 설명해주세요. [05.22]          우선 두 검색 결과를 하나의 배열에 넣어주고, orderby 오름차순, 내림차순으로 정렬해준다.        AutoLayout을 사용해 제약조건을 기반으로 반응형 UI를 구현하는 방법을 설명해주세요. [05.23] [GPT 사용]          AutoLayout은 UI 요소 간의 제약 조건(Constraints)을 설정해 다양한 화면 크기와 방향에 대응하는 반응형 UI를 만들 수 있게 해준다. 주로 NSLayoutConstraint나 Interface Builder에서 UI 요소 간의 상대적인 위치, 크기, 간격을 설정해 반응형 UI를 구현한다. 예를 들어, 뷰의 상하좌우 여백을 슈퍼뷰에 고정하거나, 비율을 유지한 채 크기를 조정하도록 제약 조건을 설정할 수 있다. Safe Area와 Dynamic Type을 고려하여 접근성을 지원하는 것도 중요하다.        Storyboard를 이용한 UI구현과 코드를 이용한 UI구현의 차이를 설명해주세요. [05.27]          StoryBoard로 UI를 구현하게되면 직관적으로 실행시 어떻게 UI가 보여지는지 확인이 가능하다. 그리고, 제약조건을 설정해도 잘못되면 Warning or Error 형식으로 보여지기에, 코드보다는 확실히 직관적인 설정이 가능하지만, 메모리적인 측면에서는 효율적이지 않다(StoryBoard가 보이는것과는 다르게 XML 파일로 되어있어서 해당 파일을 코드로 변환시키는 작업이 별도로 필요하기 떄문). 그리고 Merge시 Conflict가 발생하는 경우 수정하기가 쉽지않다는 단점이 존재.      Codebase로 UI를 구현하게 되면 우선 실행하거나 또는 #Preview를 사용하지(iOS 17 이후부터 가능) 않으면 UI를 확인 할 수 없다, 그리고 VC에 일일이 UIComponent를 할당할경우 VC가 상당히 Massive해지면서 코드가 길어지는 치명적인 단점이 존재한다. 하지만 메모리적인 측면에서는 훨씬 효율적이다.        Storyboard를 이용해 내부 reference를 두고, ViewController에 접근하는 방법을 설명해주세요. [05.28]          VC에 접근할때는 크게 2가지 방법으로 정의를 할수가 있다.              a. Storyboard의 InstantiateViewController 메서드를 사용하여 접근                  메서드는 다음과 같다 storyboard?.instantiateViewController          해당 메서드의 경우 먼저 VC에 일종의 Identifier가 있어야한다.          다운캐스팅을 반드시 해준다.                    b. Segue의 Detination으로 접근                  메서드 역시 segue.destination as? VC이름 으로 한다.          VC의 Destination 타입이 UIViewController 이므로 다운캐스팅을 반드시 해줘야함.                      UICollectionView의 Scroll 영역을 조절하는 방법을 설명해주세요. [05.29] [GPT 사용]          UICollectionView의 Scroll 영역은 contentInset과 contentSize를 통해 조절할 수 있다. contentInset을 사용해 상하좌우에 여백을 추가해 스크롤 가능 영역을 늘리거나 줄일 수 있으며, contentSize를 명시적으로 조정해 스크롤 범위를 정의할 수 있다. 또한, UICollectionViewFlowLayout의 sectionInset을 조정하면 섹션별 여백을 설정할 수 있다. UICollectionView 자체의 스크롤 동작을 커스터마이징하려면 UIScrollViewDelegate를 구현해 세부적인 스크롤 동작을 제어할 수 있다.        ViewController를 기준으로 기능별 관계 및 구조를 설명해 주세요.                            UIView                            컨텐츠를 담아 이를 스크린 상에 표시하고 사용자의 입력에 반응 하는 객체      필요한 컨텐츠를 채워넣어 스크린에 나타내는 역할을 함      - 2. UIScene      화면의 컨텐츠를 표현하고 view를 관리      한개의 VC당 한개의 UIScene이 필요        ViewModel 및 View 바인딩으로 쌍방향 소통에 대해 설명해주세요. [06.03]          데이터 바인딩으로는 클로저, observable, Combine, RxSwift등 을 사용하여 바인딩을 할 수 있다.      Observer Design Pattern 사용.        iOS 메모리 관리는 어떻게 이루어지나                            ARC(Automatic Reference Counting)의 동작 원리를 설명해주세요.                            ARC는 Heap 영역의 객체에 대한 Strong Reference(강한 참조) count를 추적하고, 객체가 더 이상 필요하지 않을 때 (참조 count가 없을 때) 해당 객체에 대한 메모리를 자동으로 해제하는 방식으로 메모리를 관리      - 2. 강한 참조(Strong Reference)와 약한 참조(Weak Reference)의 차이점은 무엇인가요?      기본적으로 Swift에서 변수나 상수는 Strong Reference(강한 참조)를 한다. 객체에 대한 Strong Reference(강한 참조) count가 증가되어 있다면, 해당 객체는 메모리에 유지된다.      약한 참조는 Strong Reference(강한 참조)와는 달리 객체의 참조 count 증가시키지 않는다. 객체의 생명 주기에 영향을 주지 않으면서 참조를 유지할 수 있다      - 3. 순환 참조(Retain Cycle)가 발생하는 경우와 해결 방법을 설명해주세요.      ARC 작동 방식의 특성상 두 객체가 서로를 강하게 참조하는 경우, 순환참조가 발생. 두 객체 모두 더이상 사용되지 않더라도 두 객체가 서로를 강하게 참조하는 경우, Strong Reference count가 감소하지 않아, 메모리에서 해제되지 못하고 메모리가 누수되는 문제가 발생      - 4. 강한 참조, 약한 참조, 미소유 참조의 차이점을 설명해주세요.      약한 참조와 달리 자신이 참조하는 인스턴스가 항상 메모리에 존재할 것이라는 전제를 기반으로한다. 즉 해당 인스턴스가 nil이 아닐것이라는 확신을 가지고 미소유 참조를 사용. 메모리에 해제된 인스턴스에 접근하려하면 런타임 에러가 발생하며 강제종료 된다.      - 5. iOS 앱의 메모리 사용량 최적화를 위한 방안과 고려 사항에 대해 설명해주세요.      고려사항 우선 불필요한 객체가 메모리에 남아있는지를 확인하여 그에 맞게 변수를 설정                  instrument나, memory hierarchy를 통해 확인.                    앱의 생명 주기를 고려하여 메모리에서 해제                  NotificationCenter의 경우 메모리에 남아 있을 경우가 있어, 직접 해제하는 방식                      Task Entity를 생성 후 CoreData에 생성, 읽기, 수정, 삭제 기능을 구현하는 방법을 설명해주세요.          우선 Coredata는 Container의 viewContext 파일을 통하여 CRUD를 수행한다.      Framework이다.                        Create                            보통 entity class를 가져와서 class의 Attribute에 값을 넣고, context.save를 통해 Create한다.      - 2. Read      NSFetchRequest타입을 통해 코어데이터를 로드 한다. 보통은 request 변수를 사용      context.fetch 메서드를 통해 Read한다.      이때 값을 저장하는 배열의 타입은 Entity명을 그대로 사용.      Entity도 Class 가능하다.      - 3. Update      setValue를 통해 조건에 맞는 부분을 업데이트를 한다.      - 4. Delete      context.delete를 사용한다. 이때 원하는 내용만 삭제도가능하고, 전체 삭제도 가능하다.        메모리와 View의 생명주기에 따라 데이터의 업데이트 시점과 호출 시점에 따른 데이터 저장 및 불러오기를 구분해서 설명해주세요. [06.07]          앱의 상태는 여섯가지로 구분이 된다.              Not Running                  앱이 실행이 되지 않았거나, 종료되어 더이상 동작하지 않는 상태. -             application(_:willFinishLaunchingWithOptions:) application(_:didFinishLaunchingWithOptions:)                                          Foreground - Inactive     - Inactive는 앱이 실행중이지만, 사용자로부터 이벤트를 받을 수 없는 상태     - 멀티 태스킹 윈도우로 진입하거나 앱 실행중 전화, 알림 등에 의해 앱을 사용할 수 없게 되는 경우 이상태로 진입을 하게 됨.     -         applicationWillResignActive(_:)                    Foreground - Active                  Active는 앱이 실행중이고 사용자로부터 이벤트를 받아 서로 상호작용을 할 수 있는 상태          Inactive → Active로 된다. 바로 Active로 활성화는 불가능하다. -             applicationDidBecomeActive(_:)                                          Background - Running                  Background는 홈 화면으로 나가거나 다른 앱으로 전환 되어 현재 앱이 더이상 동작을 하지 않는 상태를 말한다.          백그라운드에서 코드를 실행하는 상태이며, 데이터 저장, 네트워크 작업, 음악 재생등의 작업이 가능하다. -             applicationDidEnterBackground(_:)                                          Background - Suspended                  Suspended는 앱을 다시 실행했을 때 최근 작업을 빠르게 로드하기 위해서 메모리에 관련 데이터만 저장되어있는 상태를 말한다.          백그라운드에서 코드 실행이 없는 상태          앱이 Background상태에 진입 했을 때 다른 작업을 하지 않으면 Suspended 상태로 진입을 하게 됨          Suspended 상태 앱은 시스템이 메모리가 부족해지면 필요에 따라 가장 먼저 메모리에서 해제 된다.          앱을 종료시킨적이 없어도 다시 실행하려고 하면 처음부터 다시 실행되는 경우가 바로 메모리에서 해제가 되었기 때문.                    Termination                  앱이 종료된 상태.                       applicationWillTerminate(_:)                                      생명주기는 AppDelegate / SceneDelegate로 나뉘어진다. (iOS13부터)              이전에는 AppDelegate에서 통흡으로 관리했었다.              AppDelegate                                  Process LifeCycle 관리.                  앱의 중요한 데이터 구조를 초기화                  Scene을 환경설정                  앱 밖에서 발생하는 알림에 대응                  특정 Scene, View, VC에 한정되지 않고, 앱 자체를 타겟으로 하는 이벤트에 대응                  애플 푸시 알림 서비스처럼 실행 시 요구되는 모든 서비스를 등록한다.                  VC 생명주기    1. LoadView()                                            View를 로드한다 → View를 메모리에 올린다.              일반적으로 직접 호출하지 않으며, 뷰 계층 구조를 프로그래밍 방식으로 설정할 때 오버라이드된다.              Apple에서는              LoadView는 직접 호출 하면 안되고 iOS Framework가 실행해줘야 한다고 되어있음.      2. ViewDidLoad()              View가 메모리에 올라온 후 호출 된다.              메모리에 올라온 후 한번만 호출 된다.              뷰가 메모리에서 해제 된다면 다시 호출 된다 (deinit)              처음 한번만 실행 되는 코드를 여기서 작성해둔다.              ex) 뷰 요소의 초기 속성 설정, 데이터 모델의 초기화….                               override func viewDidLoad() { super.viewDidLoad() tableView.dataSource = self tableView.delegate = self  }                                 3. **`ViewWillAppear`**                                             View가 화면에 나타나기 전에 호풀된다.              ViewDidLoad와달리 화면이 나타날 때마다 호출된다.              화면 갱신이 필요할떄, 뷰를 업데이트할떄(Table, CollectionView Reload) 사용된다.              ex) 화면이 나타나기 전에 데이터를 갱신하거나 사용자 인터페이스 업데이트 ()                               override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) tableView.reloadData() }                                                              ViewIsAppearing                          WWDC23에서 새로 추가됨.              ViewWillAppear와 ViewDidAppear사이에서 View가 추가된 후 불리게 된다.              Apple에서는 View를 업데이트할때 사용하라고 권고              즉 화면이 전환될 때 실행할 특정 작업이 필요하거나, 화면의 특성과 관계없이 실행할 작업이 있을 때 사용한다.              ex) 화면 전환 시 애니메이션 시작.                                override func viewIsAppearing(_ animated: Bool) {  super.viewIsAppearing(animated)  startAnimation()  }                                                              ViewDidAppear                          뷰가 화면에 나타난 후 호출된다.              화면이 나타난 후 필요한 작업을 처리              ex) 뷰가 나타난 후 애니메이션을 시작하거나 데이터를 가져오는 작업.  -                  override func viewDidAppear(_ animated: Bool) {  super.viewDidAppear(animated)  fetchData()  }                                                              ViewWillDisappear                          뷰가 사라지기 직전에 호출              애니메이션을 멈추거나, 타이머를 종료시키는 등의 작업을 처리              ex) 뷰가 사라지기 전에 진행 중인 작업을 정리.                                override func viewWillDisappear(_ animated: Bool) {  super.viewWillDisappear(animated)  timer.invalidate()  }                                                              ViewDidDisappear                          뷰가 사라진 후 호출 된다.              메모리에서 해제 된건 아님.              ex) 화면에서 사라진 후 데이터 정리 또는 상태 저장.                                override func viewDidDisappear(_ animated: Bool) {  super.viewDidDisappear(animated)  saveCurrentState()  }                                            SceneDelegate                                  UI LifeCycle 관리                  iOS13 부터 새로 생김                  앱당 하나의 Window만을 가졌던 과거에 비해 앱당 여러개의 Scene을 가질 수 있게되며 생겨남                  Scene에는 UI의 인스턴스를 나타내는 Windows와 ViewController들이 들어있습니다.                  Scene에 해당하는 UIWindowSceneDelegate를 가지고 있어 UIKit과 앱간 상호작용에 사용됨.                  Scene들은 같은 메모리와 앱 프로세스 공간을 공유하면서 동시에 실행됨.                  하나의 앱이 여러개의 Scene과 SceneDelegate 객체를 동시에 활성화할 수 있게 도와줌                                                                        scene(_:willConnectTo:options:)                  새 장면이 생성될 때 호출이 된다.          UI의 초기 상태를 설정하고 장면의 Root ViewController를 설정함.                       func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) { guard let windowScene = (scene as? UIWindowScene) else { return } let window = UIWindow(windowScene: windowScene) let rootViewController = ViewController()  window.rootViewController = rootViewController self.window = window window.makeKeyAndVisible() }                                          sceneDidBecomeActive(_:)                  장면이 활성 상태가 될 때 호출 된다.          장면이 활성화 될때 해야할 작업을 구현한다                       func sceneDidBecomeActive(_ scene: UIScene) { DataSyncManager.shared.startSync() NetworkManager.shared.resumeRequests() }                                          sceneWillResignActive(_:)                  장면이 비활성화 되기 직전에 호출          애니메이션 중지, 타이머 일시정지 등 비활성화 준비 작업을 할때 사용                       func sceneWillResignActive(_ scene: UIScene) { AnimationManager.shared.stopAllAnimations() GameStateManager.shared.saveCurrentState() }                                          sceneWillEnterForeground(_:)                  장면이 백그라운드에서 포그라운드로 전환될 때 호출됩니다. 장면이 화면에 나타나기 전에 필요한 준비 작업을 여기에 구현합니다.                       func sceneWillEnterForeground(_ scene: UIScene) { UserInterfaceManager.shared.updateUI() TimerManager.shared.resumeAllTimers() SessionManager.shared.refreshSessionIfNeeded() }                                          sceneDidEnterBackground(_:)                  장면이 포그라운드에서 백그라운드로 전환될 때 호출됩니다. 데이터 저장, 공유 자원 해제 등의 작업을 여기에 구현합니다.                       func sceneDidEnterBackground(_ scene: UIScene) { DataManager.shared.saveImportantData() NetworkManager.shared.pauseRequests() ResourceManager.shared.releaseSharedResources() BackgroundTaskManager.shared.   startBackgroundTasks() }                                            UserDefaults와 CoreData의 차이점에 대해 설명해주세요. [06.10]          UserDefaults              UserDefaults는 보통 Key와 Value로 이루어져 있다.      데이터도 보통은 간단한 정보값을 영구적으로 저장한다.      plist파일에 xml형식으로 저장이됨.      JSON Encoder를 통해 Encoding 후 데이터 저장함.      스레드 안전성을 지님.      Notification을 사용하여 특정 기본값에 대한 업데이트 알림을 받을 수 있다.      - Coredata      FrameWork이며, UserDefaults와 달리 크고 복잡한 데이터를 영구적으로 저장한다.      데이터 작업이 백그라운드 단위에서 이루어 진다.      테이블, 컬렉션 뷰에 대한 데이터 소스 제공으로 뷰와 데이터 동기화를 유지하는데 도움이 됨        데이터 모델링을 기반으로 각 Entity, Attribute, Relationship의 역할을 설명해주세요. [06.11]          Database에서 Entity는 Table의 역할을 하고, Attribute는 Field의 역할을 한다. RelationShip은 각 Entity 간의 관계를 설정할때 사용하는데, ParentRelationShip / ChildRelationShip으로 나뉜다        MVC, MVVM 각 아키텍쳐의 장단점과, MVC to MVVM으로의 리팩토링시 고려해야 할 점을 설명해주세요. [06.12]          MVC와 MVVM의 궁극적인 목적은 비즈니스 로직과 뷰를 분리 하는 것이다.              MVC                  View: 사용자 인터페이스를 담당, 모델의 데이터를 보여주고, 사용자 입력을 받아 Model에 전달          Controller: 모델과 뷰를 연결하고, 어플리케이션 흐름을 제어, 뷰에서 입력을 받아 모델에 전달하거나, 모델에서 변경된 데이터를 가져와 뷰에 반영          Model: 어플리케이션의 데이터와 비즈니스 로직을 담당, 데이터를 가져오고 변경하는 메서드를 가지고 있음.                    MVVM                  View: 사용자 인터페이스를 담당, 모델의 데이터를 보여주고, 사용자 입력을 받아 Model에 전달          Model: 어플리케이션의 데이터와 비즈니스 로직을 담당, 데이터를 가져오고 변경하는 메서드를 가지고 있음.          ViewModel: 모델의 데이터를 뷰에서 필요한 형태로 가공후 컨트롤러에 제공                    장,단점                  MVC                          장점: 간단한 패턴으로, 구조파악과 확장이 쉽게 가능              단점: 뷰와 모델의 분리가 어려우며, 컨트롤러가 뷰와 모델을 모두 알고 있어야 한다. 즉 코드가 많아지면서 가독성이 떨어지며 이에따라 유지 보수가 어려움                                MVVM                          장점: 뷰와 비즈니스로직의 분리가 분명하여, 유지 보수에 용이함, 서로가 독립적이다.              단점: 진입장벽이 높다, 데이터 바인딩이 반드시 필요함. 이에따라 불필요한 코드가 발생 하게 된다.                                          튜터님 모의면접 이후 피드백  두 검색 결과를 datetime 필드를 이용해 정렬하여 출력할때 sorted 만 사용해서 소팅이 된다면?          Data 다 Comparable 프로토콜 준수할때, Sorted()가 가능.        VC 설명          viewcontroller 에서 항상 나오는 내용 : ⭐️⭐️view의 lifecycle 을 관리. viewisappearing 최근에 추가(ios 13부터, 애니메이션 사용하기 위한 라이프 사이클.). 라이프 사이클 순서.        ViewModel에 대해 좀 더 디테일하게 설명  총평          먼저 키워드를 이야기해서 정의를하고 설명. 두괄식으로.      애매하면 역질문을 통해 어떤것에 대한 대답을 원하는지?      같이 일하기 힘든 사람. -&gt; 소통의 부재…      "
  },
  
  {
    "title": "단어장 프로젝트 (fin)",
    "url": "/posts/%EB%8B%A8%EC%96%B4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-(fin)/",
    "categories": "캠프, 프로젝트3",
    "tags": "",
    "date": "2024-05-25 14:00:00 +0900",
    





    
    "snippet": "2주간의 프로젝트 끝.KPT1. K  다양한 예외 상황을 생각하고 해당 내용을 처리  추가 기능 구현에 대한 고민  프로젝트 진행 중 원활한 의사소통  애매한것은 회의를 통해 결정2. P  코드 컨벤션 세부 디테일 설정  초기 디자인 설정이나 기능 구체화 및 세부화  초기 프로젝트파일 설정시, 라이브러리, 디렉토리 구조 등 초기 세팅이 미흡하여 머지시...",
    "content": "2주간의 프로젝트 끝.KPT1. K  다양한 예외 상황을 생각하고 해당 내용을 처리  추가 기능 구현에 대한 고민  프로젝트 진행 중 원활한 의사소통  애매한것은 회의를 통해 결정2. P  코드 컨벤션 세부 디테일 설정  초기 디자인 설정이나 기능 구체화 및 세부화  초기 프로젝트파일 설정시, 라이브러리, 디렉토리 구조 등 초기 세팅이 미흡하여 머지시 문제 발생3. T  이번에 완성한 프로젝트 앱스토어 출시 도전  지속적인 유지보수를 통해 앱 완성도  로그인 기능 활용해 커뮤니티 기능 활성화  더 많은 소셜로그인 기능 구현  위젯, Notification 구현개선방향  View 계층 구조 통일          현재는 팀원마다 VC에 만든 방식이 다름.        MVC에서 MVVM으로 변경          MVC가 안좋다는건 아니지만, VC가 Massive 해지는 경향이 있음      View와 Business Logic을 분리 함으로써, 유지보수를 쉽게 하기 위함        단어와 단어장 추가시 중복 확인  단어장 추가시 단어 추가페이지 자동 연결  단어장 전체 삭제 기능 추가  단어, 단어장 추가시 텍스트 제한 추가  캘린더에서도 단어 상세보기 기능 추가  마이페이지의 리뷰작성, 앱 공유 기능 추가  Apple 계정 로그아웃시 단어의 연동이 풀리는 문제 수정튜터님 피드백  DiffableDatasource, Combine을 사용한것에대해 이유가 궁금했다고 하셨다.          답할기회가 없어서 pass        Notification이 있으면 좋을 것 같다고 하셨다.          해당부분은 인지하고 있었지만 시간이 없었고, 아이디어가 늦게 떠올라서 구현을 하지 못했다.        iCloud를 사용했는데, Firebase도 있는데 그것도 해보면 좋겠다.          나의 경우는 2달전, TodoList를 할때, 그걸로 구현을 해본적이 있어, 크게 어렵지 않은 부분이다.      상용화를 고려 했을때, iCloud가 더 편할것같아서 공부를 할겸 적용을 해보았다.      해당부분도 두 DB의 차이를 생각해서 더 좋은쪽으로 전환 예정        단어 추가할때도, 단어장 추가하는 것처럼 Animation으로 Alert를 표시해도 좋을 것 같다.          이건 내가 이쪽 파트를 담당하지 않았기에, 이후 담당한 팀원분께서 수정을 하실걸로 보인다.      나는 팀원분이 작성한 코드에 있어, 가급적이면 터치를 안하려는 편이다.      생각나는건 이정도?개인 회고1. 좋았던 점이전에 같이했던분이 2분이나 계셨고, 처음 뵌분도 좋으신분이어서 팀프로젝트함에 있어 수월했다. 다들 책임감도 있으시고, 기능구현도 크게 문제가 없었던걸로 기억한다.즉 나만 잘하면 되는 부분이었기에, 최선을 다했다.프로젝트 결과도 우리팀의 Identity가 보이는것같아 만족스럽다.이번에 튜터님도 뭔가 도전정신이 보인것 같다고 했는데, 그게 맞는듯하다.2. 아쉬운 점크게 아쉬운점은 없다.iCloud 사용에 있어 많은 부족함을 느꼈다. 보통은 검색을 하면 나오는데, 해당부분은 너무 Ambiguous 하다고나할까? 그래서 찾아보고 gpt한테도 물어보고 시간을 많이 썼다. 그래도 작동되는 코드를 보며 매커니즘을 이해하게 된다.이부분은 확실해 내것으로 만들어가야겠다는 생각이든다그리고 Social Login이 구현되어있으나, 지금은 뭐랄까 따로 노는 개념으로 존재한다. 이부분도 로그인 정보가 Firebase Auth라던가, 아니면 팀원분이 적용한 Userdefaults로 가던가 해서, Auth.currentUser에 대해 작업을 처리하는 걸 더 발전시켜야겠다는 생각이 든다.3. 총평항상 프로젝트를 할때는 잘하는것보다 재미있게 한다는 마인드로 하는데, 이번에도 그랬다. 다들 좋으신분이어서 같은 방향을 보고 프로젝트를 했기에 가능했던 것.팀프로젝트를 하면서 항상 인복이 좋았음을 느끼게 된다.너무 재미있었다.파이널 끝나고 이 프로젝트를 다시 손볼것 같은데, 6주 이후 팀원분들이 얼마나 달라졌을지, 그리고 나도 얼마나 달라졌을지 기대를 하게 된다."
  },
  
  {
    "title": "단어장 프로젝트 (11)",
    "url": "/posts/%EB%8B%A8%EC%96%B4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-(11)/",
    "categories": "캠프, 프로젝트3",
    "tags": "",
    "date": "2024-05-24 10:00:00 +0900",
    





    
    "snippet": "iCloud에서 데이터 가져왔을때의 문제 해결1. 기존데이터와 중복되는 경우이건 근본적으로 코어데이터의 중복을 피하기위해클라우드에 데이터를 저장할때 uuid를 넣어 데이터의 무결성을 지키기 위해 사용이 되는데코어데이터 등록할때는 해당 부분이 없어서 생긴 문제이다.//단어 저장    func saveWord(word: String, definition:...",
    "content": "iCloud에서 데이터 가져왔을때의 문제 해결1. 기존데이터와 중복되는 경우이건 근본적으로 코어데이터의 중복을 피하기위해클라우드에 데이터를 저장할때 uuid를 넣어 데이터의 무결성을 지키기 위해 사용이 되는데코어데이터 등록할때는 해당 부분이 없어서 생긴 문제이다.//단어 저장    func saveWord(word: String, definition: String, detail: String, pronunciation: String, synonym: String, antonym: String, to bookCase: BookCase, to bookCaseName: String, errorHandler: @escaping (Error) -&gt; Void) {        guard let context = managedContext else {            print(\"Error: managedContext is nil\")            return        }                let newWord = WordEntity(context: context)        newWord.uuid = UUID().uuidString // added        newWord.word = word        newWord.definition = definition        newWord.detail = detail        newWord.pronunciation = pronunciation        newWord.synonym = synonym        newWord.antonym = antonym        newWord.date = Date()        newWord.memory = false                newWord.bookCase = bookCase        newWord.bookCaseName = bookCase.name                do {            try context.save()            print(\"단어가 저장되었습니다.\")        } catch let error as NSError {            errorHandler(error)        }    }//단어장 추가    func saveBookCase(name: String, explain: String, word: String, meaning: String, image: Data, errorHandler: @escaping (Error) -&gt; Void) {        guard let context = managedContext else {            print(\"Error: managedContext is nil\")            return        }                let entity = NSEntityDescription.entity(forEntityName: \"BookCase\", in: context)!        let bookCase = NSManagedObject(entity: entity, insertInto: context)                bookCase.setValue(UUID().uuidString, forKey: \"uuid\") // added        bookCase.setValue(name, forKey: \"name\")        bookCase.setValue(explain, forKey: \"explain\")        bookCase.setValue(word, forKey: \"word\")        bookCase.setValue(meaning, forKey: \"meaning\")        bookCase.setValue(image, forKey: \"image\")                do {            try context.save()            print(\"코어데이터가 저장되었습니다.\")        } catch let error as NSError {            errorHandler(error)        }    }이렇게 코어데이터에 추가할때 바로 uuid를 추가하게 해주었다.이로써 코어데이터에 저장되는 데이터도 무결성을 가지게 된다.2. 클라우드에서 불러온 단어장 삭제시 단어장만 삭제되는 문제 해결기능을 구현한 팀원분께 여쭤보니 cascade를 통해 해당 애초에 코어데이터 모델링을 하면서 해당 방식이 적용이 되어 로컬에서는 그방식이 채택이 되어있는지그기능이 작동하여 문제없이 삭제가 되었으나,클라우드에서 복원한 데이터는 그런 기능이 없다.그래서 데이터 삭제할때 entity에 접근하여 삭제를 하는 코드를 작성했다.//단어장 삭제    func deleteBookCase(bookCase: NSManagedObject, errorHandler: @escaping (Error) -&gt; Void) {        // 단어장 삭제        managedContext?.delete(bookCase)                // 해당 단어장과 관련된 단어 삭제        guard let bookname = bookCase as? BookCase else {            return        }                let request: NSFetchRequest&lt;WordEntity&gt; = WordEntity.fetchRequest()        let predicate = NSPredicate(format: \"bookCaseName == %@\", bookname.name!)        request.predicate = predicate                do {                        let words = try managedContext!.fetch(request)            for word in words {                managedContext!.delete(word)            }            try managedContext?.save()        } catch let error as NSError {            errorHandler(error)        }    }해결.iCloud 데이터 삭제지금은 CRUD중CRU만 될것이다.이제 D를 구현해본다.func deleteAllRecordsFromCloudKit(recordType: String) {        let database = CKContainer(identifier: \"iCloud.com.teamproject.Vocabularytest\").privateCloudDatabase        let query = CKQuery(recordType: recordType, predicate: NSPredicate(value: true))                database.perform(query, inZoneWith: nil) { records, error in            if let error = error {                print(\"Error fetching records from CloudKit: \\(error)\")                return            }                        guard let records = records else { return }                        let recordIDs = records.map { $0.recordID }            let operation = CKModifyRecordsOperation(recordsToSave: nil, recordIDsToDelete: recordIDs)                        operation.modifyRecordsCompletionBlock = { savedRecords, deletedRecordIDs, operationError in                if let operationError = operationError {                    print(\"Error deleting records: \\(operationError)\")                } else {                    print(\"\\(deletedRecordIDs?.count ?? 0) records deleted from CloudKit\")                }            }                        database.add(operation)        }    }    func deleteAllCloudKitData() {        deleteAllRecordsFromCloudKit(recordType: \"BookCase\")        deleteAllRecordsFromCloudKit(recordType: \"WordEntity\")    }완료앞으로도 보강할게 많다.그만큼 더 공부해야한다는 뜻.벌써부터 신나네"
  },
  
  {
    "title": "단어장 프로젝트 (10)",
    "url": "/posts/%EB%8B%A8%EC%96%B4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-(10)/",
    "categories": "캠프, 프로젝트3",
    "tags": "",
    "date": "2024-05-22 10:00:00 +0900",
    





    
    "snippet": "예외처리게임을 설정하고도 시작이 안되는 상황이 발생하여 코드를 다듬어야한다.코어데이터에 값이 하나도 없는 상태에서 값이 들어오고 설정하기를 하면 데이터가 넘어가지 않는 상황이 발생하는걸로 보인다.이전에 메모리를 고려하여 notificationCenter의 observer를 다 지웠는데 거기서 문제가 생긴듯하다.지우고나니 잘되는걸 확인.Cloud to ...",
    "content": "예외처리게임을 설정하고도 시작이 안되는 상황이 발생하여 코드를 다듬어야한다.코어데이터에 값이 하나도 없는 상태에서 값이 들어오고 설정하기를 하면 데이터가 넘어가지 않는 상황이 발생하는걸로 보인다.이전에 메모리를 고려하여 notificationCenter의 observer를 다 지웠는데 거기서 문제가 생긴듯하다.지우고나니 잘되는걸 확인.Cloud to Coredatafunc syncDataFromCloudKit() {        syncEntityFromCloudKit(recordType: \"BookCase\", entityType: BookCase.self)        syncEntityFromCloudKit(recordType: \"WordEntity\", entityType: WordEntity.self)    }func syncEntityFromCloudKit&lt;T: NSManagedObject&gt;(recordType: String, entityType: T.Type) {        let database = CKContainer(identifier: \"iCloud.com.teamproject.Vocabularytest\").publicCloudDatabase        let query = CKQuery(recordType: recordType, predicate: NSPredicate(value: true))                database.perform(query, inZoneWith: nil) { records, error in            if let error = error {                print(\"Error fetching records from CloudKit: \\(error)\")                return            }                        guard let records = records else { return }                        let context = self.managedContext!                        context.perform {                for record in records {                    self.updateOrInsertRecord(record, entityType: entityType, context: context)                }                                do {                    try context.save()                    print(\"\\(recordType) records synced to Core Data successfully\")                } catch {                    print(\"Error saving context: \\(error)\")                }            }        }    }func updateOrInsertRecord&lt;T: NSManagedObject&gt;(_ record: CKRecord, entityType: T.Type, context: NSManagedObjectContext) {        let fetchRequest = T.fetchRequest()        fetchRequest.predicate = NSPredicate(format: \"uuid == %@\", record.recordID.recordName)                do {            let results = try context.fetch(fetchRequest)                        if let existingObject = results.first as? T {                populateManagedObject(existingObject, withRecord: record)            } else {                let newObject = T(context: context)                populateManagedObject(newObject, withRecord: record)            }        } catch {            print(\"Error fetching object: \\(error)\")        }    }func populateManagedObject(_ object: NSManagedObject, withRecord record: CKRecord) {        if let bookCase = object as? BookCase {            bookCase.uuid = record.recordID.recordName            bookCase.name = record[\"name\"] as? String            bookCase.explain = record[\"explain\"] as? String            bookCase.meaning = record[\"meaning\"] as? String            bookCase.image = record[\"image\"] as? Data            bookCase.word = record[\"word\"] as? String        } else if let wordEntity = object as? WordEntity {            wordEntity.uuid = record.recordID.recordName            wordEntity.antonym = record[\"antonym\"] as? String            wordEntity.bookCaseName = record[\"bookCaseName\"] as? String            wordEntity.date = record[\"date\"] as? Date            wordEntity.definition = record[\"definition\"] as? String            wordEntity.detail = record[\"detail\"] as? String            wordEntity.memory = (record[\"memory\"] as? Bool)!            wordEntity.pronunciation = record[\"pronunciation\"] as? String            wordEntity.synonym = record[\"synonym\"] as? String            wordEntity.word = record[\"word\"] as? String        }    }그래도 얼추 매커니즘은 알듯.주말에 느긋하게 분석해보는걸로.로그인 상태가 아닐때는 로딩이나, 저장이 안되게 해야하므로    func checkiCloudLoginStatus(completion: @escaping (Bool) -&gt; Void) {        let container = CKContainer.default()        container.accountStatus { status, error in            if let error = error {                print(\"Error checking iCloud account status: \\(error)\")                completion(false)                return            }            if status == .available {                print(\"iCloud account is available and logged in.\")                completion(true)            } else {                print(\"No iCloud account is logged in.\")                completion(false)            }        }    }CoreDataManager.shared.checkiCloudLoginStatus { loginStatus in                if loginStatus {                    ProgressHUD.animate(\"데이터를 저장하는 중 입니다.\")                    DispatchQueue.main.asyncAfter(deadline: .now() + 2) {                        CoreDataManager.shared.syncData()                        ProgressHUD.succeed(\"데이터 저장에 성공했습니다.\")                    }                } else {                    ProgressHUD.failed(\"로그인 상태를 확인해 주세요.\")                }            }이렇게 처리를 한다.Toolbar 추가정확하게는 키보드 위에 버튼을 추가하여 약간의 interface를 제공한다.textfield에 대해 추가를 하는데, textfield는 팀원분이 factory형식으로 만들어둬서, 그부분을 수정한다.func makeTextField(placeholder: String, action: Selector, dictAction: Selector) -&gt; UITextField {                let textField = UITextField()                textField.placeholder = placeholder        textField.autocorrectionType = .no        textField.spellCheckingType = .no        textField.autocapitalizationType = .none        textField.clearButtonMode = .always        textField.clearsOnBeginEditing = false        textField.returnKeyType = .done                //테두리 색상 추가        textField.layer.borderColor = ThemeColor.mainCgColor        textField.layer.borderWidth = 2        textField.layer.cornerRadius = 8                // 텍스트 필드 높이 설정        let heightConstraint = NSLayoutConstraint(item: textField, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1, constant: 46)        textField.addConstraint(heightConstraint)                // Placeholder 왼쪽에 여백 추가        let paddingView = UIView(frame: CGRect(x: 0, y: 0, width: 20, height: 0))        textField.leftView = paddingView        textField.leftViewMode = .always                // Toolbar 추가        let toolBar = UIToolbar(frame: CGRect(x: 0, y: 0, width: UIView().frame.size.width, height: 36))        toolBar.barStyle = .default        toolBar.sizeToFit()                let doneButton = UIBarButtonItem(            title: \"Done\",            style: .plain,            target: self,            action: action) // 매개변수를 직접 사용                        let dictButton = UIBarButtonItem(            image: UIImage(systemName: \"character.book.closed\"),            style: .plain,            target: self,            action: dictAction)         toolBar.items = [            UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil),            dictButton,doneButton        ]                toolBar.isUserInteractionEnabled = true        textField.inputAccessoryView = toolBar                return textField    }Toolbar가 내가 추가한 부분Selector함수가 필요해서 파라미터로 받게 한다.버튼이 2개이므로 두개를 구현해준다.이렇게하면 두개의 버튼이 생성해당 기능을 사용할 objc 함수 구현이건 심플하다@objc func doneButtonTapped() {        self.view.endEditing(true)    }    @objc func showDict() {        let url = URL(string: \"https://dict.naver.com/\")        UIApplication.shared.open(url!)    }이렇게 프로젝트가 끝.2주 길줄알았는데, 생각보다 짧다.그만큼 재미있게 했다는 뜻."
  },
  
  {
    "title": "단어장 프로젝트 (9)",
    "url": "/posts/%EB%8B%A8%EC%96%B4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-(9)/",
    "categories": "캠프, 프로젝트3",
    "tags": "",
    "date": "2024-05-22 10:00:00 +0900",
    





    
    "snippet": "예외처리현재 코드들이 코어데이터에 값이 있는것을 기반으로 하다보니 아무것도 없는 상태에서 처리를 하는 예외처리가 필요하다.우선 코어데이터를 가져와서 단어장의 이름이 있는지를 확인checkData()            if data.filter({ $0.bookCaseName!.count != 0 }).count == 0 { // added      ...",
    "content": "예외처리현재 코드들이 코어데이터에 값이 있는것을 기반으로 하다보니 아무것도 없는 상태에서 처리를 하는 예외처리가 필요하다.우선 코어데이터를 가져와서 단어장의 이름이 있는지를 확인checkData()            if data.filter({ $0.bookCaseName!.count != 0 }).count == 0 { // added                let alert = alertController.makeNormalAlert(title: \"데이터가 없습니다.\", message: \"단어장과 단어를 생성해주세요\\n게임을 진행하려면 한 단어장에 최소 4개의 단어가 필요합니다.\")                self.present(alert, animated: true)            } else {                let vc = SelectVocaViewController()                vc.modalPresentationStyle = .custom                vc.transitioningDelegate = self                self.present(vc, animated: true, completion: nil)            }그리고 단어장이 있는 상태에서 설정하기를 누를때 마지막으로 한번더 체크func setUpGame () {        guard let currentVC = currentViewController as? SelectVocaViewController else { return }        let count = currentVC.quizCount        let category = currentVC.selectedCategory        if currentVC.checkDataCount(query: category) &lt; 4 {            let alert = currentVC.alertController.makeNormalAlert(title: \"갯수 부족\", message: \"한 단어장에 최소 4개의 단어가 있어야합니다.\")            currentVC.present(alert, animated: true)        } else {            let data = GenQuizModel(category: category, quizCount: count)            NotificationCenter.default.post(name: .sender, object: data)            currentVC.dismiss(animated: true)        }            }시작할때 데이터를 못받는 문제가 있어서 위치 조정func setUpGame () {        guard let currentVC = currentViewController as? SelectVocaViewController else { return }        let count = currentVC.quizCount        let category = currentVC.selectedCategory        let data = GenQuizModel(category: category, quizCount: count) // moved        if currentVC.checkDataCount(query: category) &lt; 4 {            let alert = currentVC.alertController.makeNormalAlert(title: \"갯수 부족\", message: \"한 단어장에 최소 4개의 단어가 있어야합니다.\")            currentVC.present(alert, animated: true)        } else {            NotificationCenter.default.post(name: .sender, object: data)            currentVC.dismiss(animated: true)        }    }완료.CloudKit 사용여기서 추가.그다음 cloudkit을 체크하고아래 + 버튼을 클릭하여 identifier이름의 컨테이너를 추가해본다.cloudkit console을 들어가면 추가한 identifier에 해당하는 내용이 보인다.여기까지 세팅은 여기를 참고했다.물론 빠졌지만 background도 해주었다.Background modes - Remote Notifications를 체크하는 이유는 새로운 컨텐츠가 생겼을 때, 어떠한 알림 없이 조용하게 알리기 위해 사용한다.여기서 부터는 여기를 참고한다. 필요한 Docs를 별도로 정리해 줘서 그걸 보면서 만들 수 있을 듯 하다.그리고 우리가 만든 코어데이터로 가서여기를 체크해주었다.Docs를 보니 container를 바꿔주어야 한다고 한다.1. Appdelegate 변경심플하다 NSPersistentContainer 이녀석을 NSPersistentCloudKitContainer 이녀석으로 바꿔준다.lazy var persistentContainer: NSPersistentCloudKitContainer = { // modified        /*         The persistent container for the application. This implementation         creates and returns a container, having loaded the store for the         application to it. This property is optional since there are legitimate         error conditions that could cause the creation of the store to fail.        */        let container = NSPersistentCloudKitContainer(name: \"Vocabulary\") // modified        container.loadPersistentStores(completionHandler: { (storeDescription, error) in            if let error = error as NSError? {                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")            }        })        return container    }()swift아래 보니 configure가 나는 하나라서 크게 의미가 없을 듯저건 여러 configure에 따른 세팅이라 지금은 추가 안해도 될듯하다.2. Cloudkit을 위한 CoreData Model 생성어찌 저찌 하다가func saveCloud() {            // 모든 엔터티에 대한 fetch 요청 생성            let entityNames = managedContext!.persistentStoreCoordinator?.managedObjectModel.entities.map { $0.name } ?? []                        let database = CKContainer(identifier: \"iCloud.com.teamproject.Vocabularytest\")                        for entityName in entityNames {                let request: NSFetchRequest&lt;WordEntity&gt; = WordEntity.fetchRequest()                let predicate = NSPredicate(format: \"bookCaseName == %@\", entityName!)                request.predicate = predicate                                do {                    let items = try managedContext!.fetch(request)                    for item in items {                                                                    }                } catch {                    print(\"Failed to fetch items for entity \\(entityName!): \\(error)\")                }                                do {                    try managedContext!.save()                } catch {                    print(\"Failed to save context: \\(error)\")                }            }    }저장이 되질 않아 변경func saveCloud() {        // 모든 엔터티에 대한 fetch 요청 생성        let entityNames = managedContext!.persistentStoreCoordinator?.managedObjectModel.entities.map { $0.name } ?? []                let database = CKContainer(identifier: \"iCloud.com.teamproject.Vocabularytest\").publicCloudDatabase                managedContext?.automaticallyMergesChangesFromParent = true                for entityName in entityNames {            let request: NSFetchRequest&lt;WordEntity&gt; = WordEntity.fetchRequest()            let predicate = NSPredicate(format: \"bookCaseName == %@\", entityName!)            let record = CKRecord(recordType: entityName!)            request.predicate = predicate            do {                let items = try managedContext!.fetch(request)                for item in items {                    record.setValue(item.antonym, forKey: \"antonym\")                    record.setValue(item.bookCaseName, forKey: \"bookCaseName\")                    record.setValue(item.date, forKey: \"date\")                    record.setValue(item.definition, forKey: \"definition\")                    record.setValue(item.detail, forKey: \"detail\")                    record.setValue(item.memory, forKey: \"memory\")                    record.setValue(item.pronunciation, forKey: \"pronunciation\")                    record.setValue(item.synonym, forKey: \"synonym\")                    record.setValue(item.word, forKey: \"word\")                                        database.save(record) { record, error in                        print(\"saved\")                    }                                    }            } catch {                print(\"Failed to fetch items for entity \\(entityName!): \\(error)\")            }                        do {                try managedContext!.save()            } catch {                print(\"Failed to save context: \\(error)\")            }        }    }하지만 그래도 저장이 되질 않는다.혹시나 싶어 request의 결과의 갯수를 확인해보니 0이나온다.즉 애초에 가져오는것도 안되었던것.GPT사용결국 gpt에 의존한다. 이것도 여러차례 질문하며 내나름대로 코드도 수정하고 그걸 다시 적용하고 안되면검색해서 좀 찾아보고 그러다 자료가없으면 물어보고를 몇시간 했는지 모르겠다.func syncData() {        syncEntity(BookCase.self, recordType: \"BookCase\")        syncEntity(WordEntity.self, recordType: \"WordEntity\")    }    func syncEntity&lt;T: NSManagedObject&gt;(_ entityType: T.Type, recordType: String) {        let fetchRequest = T.fetchRequest()                do {            let results = try managedContext!.fetch(fetchRequest)            for object in results {                saveToCloudKit(object as! NSManagedObject, recordType: recordType)            }        } catch {            print(\"Failed to fetch data from Core Data: \\(error)\")        }    }    func saveToCloudKit(_ object: NSManagedObject, recordType: String) {        let database = CKContainer(identifier: \"iCloud.com.teamproject.Vocabularytest\").publicCloudDatabase        let record = CKRecord(recordType: recordType)                // Set record fields based on entity type        if let bookCase = object as? BookCase {            record[\"name\"] = bookCase.name as CKRecordValue?            record[\"explain\"] = bookCase.explain as CKRecordValue?            record[\"meaning\"] = bookCase.meaning as CKRecordValue?            record[\"image\"] = bookCase.image as CKRecordValue?            record[\"word\"] = bookCase.word as CKRecordValue?                    } else if let wordEntity = object as? WordEntity {            record[\"antonym\"] = wordEntity.antonym as CKRecordValue?            record[\"bookCaseName\"] = wordEntity.bookCaseName as CKRecordValue?            record[\"date\"] = wordEntity.date as CKRecordValue?            record[\"definition\"] = wordEntity.definition as CKRecordValue?            record[\"detail\"] = wordEntity.detail as CKRecordValue?            record[\"memory\"] = wordEntity.memory as CKRecordValue?            record[\"pronunciation\"] = wordEntity.pronunciation as CKRecordValue?            record[\"synonym\"] = wordEntity.synonym as CKRecordValue?            record[\"word\"] = wordEntity.word as CKRecordValue?        }                database.save(record) { record, error in            if let error = error {                print(\"Error saving record to CloudKit: \\(error)\")            } else {                print(\"\\(recordType) saved to CloudKit successfully\")            }        }    }Gpt가 제안한거에서 조금 수정을 했다.하지만 중복문제가 발생func syncData() {        syncEntity(BookCase.self, recordType: \"BookCase\")        syncEntity(WordEntity.self, recordType: \"WordEntity\")    }    func syncEntity&lt;T: NSManagedObject&gt;(_ entityType: T.Type, recordType: String) {        let fetchRequest = T.fetchRequest()                do {            let results = try managedContext!.fetch(fetchRequest)            for object in results {                // Ensure the object has a UUID                if let bookCase = object as? BookCase, bookCase.uuid == nil {                    bookCase.uuid = UUID().uuidString                } else if let wordEntity = object as? WordEntity, wordEntity.uuid == nil {                    wordEntity.uuid = UUID().uuidString                }                saveToCloudKit(object as! NSManagedObject, recordType: recordType)            }        } catch {            print(\"Failed to fetch data from Core Data: \\(error)\")        }    }    func saveToCloudKit(_ object: NSManagedObject, recordType: String) {        let database = CKContainer(identifier: \"iCloud.com.teamproject.Vocabularytest\").privateCloudDatabase        var recordID: CKRecord.ID                // Generate a unique identifier for the record        if let bookCase = object as? BookCase {            recordID = CKRecord.ID(recordName: bookCase.uuid ?? UUID().uuidString)        } else if let wordEntity = object as? WordEntity {            recordID = CKRecord.ID(recordName: wordEntity.uuid ?? UUID().uuidString)        } else {            print(\"Unknown object type\")            return        }                // Check if the record already exists        database.fetch(withRecordID: recordID) { fetchedRecord, error in            if let fetchedRecord = fetchedRecord {                // Record already exists, update it if necessary                self.updateRecord(fetchedRecord, withObject: object, recordType: recordType, database: database)            } else if let ckError = error as? CKError, ckError.code == .unknownItem {                // Record does not exist, create a new one                let newRecord = CKRecord(recordType: recordType, recordID: recordID)                self.populateRecord(newRecord, withObject: object, recordType: recordType)                self.saveRecord(newRecord, toDatabase: database)            } else {                print(\"Error fetching record from CloudKit: \\(error?.localizedDescription ?? \"Unknown error\")\")            }        }    }    func updateRecord(_ record: CKRecord, withObject object: NSManagedObject, recordType: String, database: CKDatabase) {        populateRecord(record, withObject: object, recordType: recordType)        saveRecord(record, toDatabase: database)    }    func populateRecord(_ record: CKRecord, withObject object: NSManagedObject, recordType: String) {        // Set record fields based on entity type        if let bookCase = object as? BookCase {            record[\"name\"] = bookCase.name as CKRecordValue?            record[\"explain\"] = bookCase.explain as CKRecordValue?            record[\"meaning\"] = bookCase.meaning as CKRecordValue?            record[\"image\"] = bookCase.image as CKRecordValue?            record[\"word\"] = bookCase.word as CKRecordValue?        } else if let wordEntity = object as? WordEntity {            record[\"antonym\"] = wordEntity.antonym as CKRecordValue?            record[\"bookCaseName\"] = wordEntity.bookCaseName as CKRecordValue?            record[\"date\"] = wordEntity.date as CKRecordValue?            record[\"definition\"] = wordEntity.definition as CKRecordValue?            record[\"detail\"] = wordEntity.detail as CKRecordValue?            record[\"memory\"] = wordEntity.memory as CKRecordValue?            record[\"pronunciation\"] = wordEntity.pronunciation as CKRecordValue?            record[\"synonym\"] = wordEntity.synonym as CKRecordValue?            record[\"word\"] = wordEntity.word as CKRecordValue?        }    }    func saveRecord(_ record: CKRecord, toDatabase database: CKDatabase) {        database.save(record) { savedRecord, error in            if let error = error {                print(\"Error saving record to CloudKit: \\(error)\")            } else {                print(\"\\(record.recordType) saved to CloudKit successfully\")            }        }    }여기서 변경점은 uuid를 각 entity마다 attribute로 추가해주었다는 점이다.나름대로 분석.GPT가 알려준 코드를 내 나름대로 분석을 해본다.내가 이해한 매커니즘은 다음과 같다.우선 syncEntity를 호출하면서 이때 우리가 사용하는 Entity에 대한 값을 가져온다.함수를 2번 호출하기에 그중에서도 Attribute 가 많은 WordEntity로 기준을 하여 작성해본다.이때 제너릭을 사용하는데, NSManagedObject 즉 coredata의 Entity를 가져온다.1. syncEntityWordEntity를 요청하는 request 변수를 만든다. 그리고 값을 가져오게 한다.그리고 wordEntity에 uuid가 있는지 확인하고 없다면 값을 부여하게 된다.2. SaveToCloudKit저장할 database를 만들고,entity에 해당하는 uuid를 가진 recordID를 만든다.그리고 그걸 이용하여 database에 작업을 수행한다.값이 존재할경우, 그리고 만약 업데이트가 필요하면 (값이바뀌거나) 그럴때 업데이트를 하고, 값이 없을땐 등록을 해준다.1. populateRecord해당 코드를 통해 key, value 형식으로 어떻게 저장이 될건지를 세팅2. saveRecord데이터베이스에 저장.뭐 이런식으로 가게된다.이건 주말에 다시 정리를 해야할듯…"
  },
  
  {
    "title": "단어장 프로젝트 (8)",
    "url": "/posts/%EB%8B%A8%EC%96%B4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-(8)/",
    "categories": "캠프, 프로젝트3",
    "tags": "",
    "date": "2024-05-21 10:00:00 +0900",
    





    
    "snippet": "예외처리func gameStart () {        failCount = 0        score = 0        isGameEnd = false                if !labelList.isEmpty {            resetLabel()        }                hangManBottomView = Han...",
    "content": "예외처리func gameStart () {        failCount = 0        score = 0        isGameEnd = false                if !labelList.isEmpty {            resetLabel()        }                hangManBottomView = HangManBottomView()                vStackView.addSubview(hangManBottomView!)                hangManBottomView!.snp.makeConstraints {            $0.top.equalTo(hangManBodyView.snp.bottom)            $0.leading.equalToSuperview()            $0.trailing.equalToSuperview()            $0.bottom.equalToSuperview().offset(-60)        }        if currentCount &lt; quizArray.count {            answer = quizArray[currentCount].word!            makeWordLabel(word: answer)                        updateUI()        } else {            let alert = alertController.makeNormalAlert(title: \"게임종료\", message: \"게임이 끝났습니다.\")            self.present(alert, animated: true)        }    }지금은 심플하게 이렇게 구현해두었다.게임 기록 페이지 구현게임 기록 페이지를 만들어본다.우선 기능구현이 우선이기에 디자인은 심플하게 해둘 예정이며.UISegmentController를 사용해볼 예정.해당부분을 코드로 구현해본적은 없는것같아. 기록해두려 한다.기록하기엔 생각보다 property가 없어서lazy var segControl: UISegmentedControl = {        let control = UISegmentedControl(items: [\"Quiz\", \"HangMan\"])        control.selectedSegmentIndex = 0        return control    }()우선은 이렇게 기본세팅만 한다.위에서 언급한대로 특이점은 바로Segcontrol이 있다는 것.이전에는 StoryBoard를 통해 IBAction으로 바로 따와서 sender를 통해 값의 변화를 감지 할 수 있었다.하지만 지금은 sender를 가져올수가 없다.왜냐 현재 구성한 VC는 Header, BodyView를 가져오고각각의 View들 안에 UIComponent가 있기 때문.Segcontrol만 seg의 변화에 따라 해당 index를 출력하게 끔 테스트를 해서 작동이 되면 그다음에 다른 로직을 구현 하면 될것같다.우선 다음과 같은 함수를 만들어 주었다.func changeSegment() {        let selectedIndex = recordBodyView.segControl.selectedSegmentIndex        switch selectedIndex {        case 0:            print(\"select 0\")        case 1:            print(\"select 1\")        default:            return        }    }하지만 VC에서는 작동이 되질않았다.그냥 처음에 ViewDidload나 ViewDidapper 같은 VC의 생명주기를 고려하여 해당 함수를 트리거 해서 작동을 확인 해보려 했으나 되지 않았다.이게 VC에서 해야하는걸까? 라는 생각이 들었다.view에서 addAction 통해 클로저로 구현 하면 어떨까라는 생각이 들었고 그걸 해보려한다.lazy var segControl: UISegmentedControl = {        let control = UISegmentedControl(items: [\"Quiz\", \"HangMan\"])        control.selectedSegmentIndex = 0        control.addAction(UIAction(handler: { [weak self] _ in            let index = control.selectedSegmentIndex            self?.changeIndex(index: index)        }), for: .valueChanged)        return control    }()다음과 같이 action을 만들어 준다,이젠 작동을 한다.물론 해당 방식을 응용해서func addSegAction () {        recordBodyView.segControl.addAction(UIAction(handler: { [weak self] _ in            print(self?.recordBodyView.segControl.selectedSegmentIndex)        }), for: .valueChanged)    }VC에 이렇게 적어도 작동은 한다.혹시나 메모리 누수가 있을까 싶어 확인했지만 그건 없는듯 하다.cell을 만들어주고,이번 TableView는 Diffable Datasource를 적용한다.섹션을 만들어준다.enum DiffableSection {        case quiz    case hangMan    }그리고 모델이 필요할거 같아서 별도로 레코드 모델을 만들어 준다.데이터 결정단순히 게임횟수보다는 게임을 했을때 틀린단어를 보여주는게 좋겠다고 팀회의로 결정.Api 구현class NetworkManager {            func fetchRequest (query: String, complete: @escaping (Result&lt;TranslatedModel,Error&gt;) -&gt; Void) {                let url = \"https://api-free.deepl.com/v2/translate\"        let header = [\"Authorization\" : \"DeepL-Auth-Key \\(Secret.apiKey)\"]        let component = [URLQueryItem(name: \"text\", value: query), URLQueryItem(name: \"target_lang\", value: \"KO\")]        var urlComponent = URLComponents(string: url)        urlComponent?.queryItems = component                if let urlRequest = urlComponent?.url {            var request = URLRequest(url: urlRequest)            request.httpMethod = \"POST\"            request.allHTTPHeaderFields = header                        let session = URLSession(configuration: .default)            let task = session.dataTask(with: request) { data, response, error in                if let e = error {                    complete(.failure(e))                }                                if let safeData = data {                    if let decodedData = try? JSONDecoder().decode(TranslatedModel.self, from: safeData) {                        complete(.success(decodedData))                    }                }            }            task.resume()        }            }}딱히 할말이 없다.Combine style로 변경class NetworkManager {        private var cancellables = Set&lt;AnyCancellable&gt;()        func fetchRequest (query: String) -&gt; Future&lt;[Translation], Error&gt; {                return Future&lt;[Translation], Error&gt; { [weak self] promise in                        let url = \"https://api-free.deepl.com/v2/translate\"            let header = [\"Authorization\" : \"DeepL-Auth-Key \\(Secret.apiKey)\"]            let component = [URLQueryItem(name: \"text\", value: query), URLQueryItem(name: \"target_lang\", value: \"KO\")]            var urlComponent = URLComponents(string: url)            urlComponent?.queryItems = component                        guard let urlRequest = urlComponent?.url else {                return            }            var request = URLRequest(url: urlRequest)            request.httpMethod = \"POST\"            request.allHTTPHeaderFields = header            let session = URLSession(configuration: .default)                        session.dataTaskPublisher(for: request)                .map(\\.data)                .decode(type: [Translation].self, decoder: JSONDecoder())                .eraseToAnyPublisher()                .replaceError(with: [])                .sink { data in                    promise(.success(data))                }.store(in: &amp;self!.cancellables)        }    }}이번에는 MVVM이 아니라서 VC에 직접 구현해야할듯싶다.textfield 값 가져오기textfield에 대한 값을 가져오기 위해 extension을 사용extension UITextField {    var textPublisher: AnyPublisher&lt;String, Never&gt; {        NotificationCenter.default            .publisher(for: UITextField.textDidChangeNotification, object: self)            .map { ($0.object as? UITextField)?.text  ?? \"\" }            .eraseToAnyPublisher()    }}func observe() {        wordTextField.textPublisher.sink { value in            print(value)        }.store(in: &amp;cancellables)    }이렇게하면 출력이 된다.그냥 간단하게 작동만 되게 구현한다.func observe() {        wordTextField.textPublisher            .debounce(for: 1, scheduler: DispatchQueue.main)            .sink { [weak self] value in                self?.networkManager.fetchRequest(query: value)                    .sink(receiveCompletion: { completion in                        switch completion {                        case .finished:                            return                        case .failure(_):                            return                        }                    }, receiveValue: { documents in                        self!.result = documents.first!                    }).store(in: &amp;self!.cancellables)        }.store(in: &amp;cancellables)    }Diffable Datasourece 사용.var tableDatasource: UITableViewDiffableDataSource&lt;DiffableSectionModel, Translation&gt;?var tableSnapshot: NSDiffableDataSourceSnapshot&lt;DiffableSectionModel, Translation&gt;?이렇게 만들어주고.extension InsertVocaViewController {    func configureDiffableDataSource () {        tableDatasource = UITableViewDiffableDataSource(tableView: resultTable, cellProvider: { tableView, indexPath, model in                        let cell = tableView.dequeueReusableCell(withIdentifier: Constants.resultCell, for: indexPath) as! ResultTableViewCell                        cell.wordLabel.text = model.text            cell.selectionStyle = .none                        return cell        })    }        func configureSnapshot() {        tableSnapshot = NSDiffableDataSourceSnapshot&lt;DiffableSectionModel, Translation&gt;()        tableSnapshot?.deleteAllItems()        tableSnapshot?.appendSections([.requestResult])        tableSnapshot?.appendItems(result)        tableDatasource?.apply(tableSnapshot!,animatingDifferences: true)    }    }이렇게 적용하게 했다.그리고 셀을 선택했을때 textField에 들어가게 해야하므로lazy var resultTable: UITableView = {        let table = UITableView()        table.register(ResultTableViewCell.self, forCellReuseIdentifier: Constants.resultCell)        table.didSelectRowPublisher.sink { [weak self] indexPath in            self?.definitionTextField.text = self?.result[0].text        }.store(in: &amp;cancellables)        return table    }()combinecocoa를 사용했다.이전에도 느꼈지만 컴바인과 디퍼블은 최고의 조합이다.기록 로직 구현여기에도 디퍼블을 사용할 예정인데,데이터를 저장을 해야한다.현재 recordVC에func addSegAction () {        recordBodyView.segControl.addAction(UIAction(handler: { [unowned self] _ in            let index = recordBodyView.segControl.selectedSegmentIndex            print (index)        }), for: .valueChanged)    }이녀석이 있는데 index값이 변화한다.이 index값을 이용해서 소팅을 하면 될듯하다.해당 데이터를 모델링을 먼저 하면 될듯한데.index 번호와 단어, 그리고 뜻 이렇게 3개만 있으면 충분할것으로 보여서 모델링을 먼저 한다.struct ReminderModel {        var index: Int    var word: String    var meaning: String    }1. QuizVC에 NotificationCenter 등록.우선 다음과 같이 등록static let inCorrect = Notification.Name(\"inCorrect\")이걸 받을 vc에 observer를 등록해준다.NotificationCenter.default.addObserver(self, selector: #selector(getData), name: .inCorrect, object: nil)@objc func getData(_ notification: Notification) {        if let data = notification.object as? ReminderModel {            dataList.append(data)        }    }2. 관련 view에 등록그리고 문제 정답과 오답을 판별하는 함수가 있는 quizbottomview에 notificationcenter 등록func checkAnswer(title: String) -&gt; Bool {        var flag = false        guard let currentVC = currentViewController as? QuizViewController else { return flag }        let currentQuestion = currentVC.quizBodyView.gameTitle.text        let gameArray = currentVC.quizData        let answer = gameArray.filter{ $0.question == currentQuestion }.map{ $0.answer }.joined()                if title == answer {            currentVC.currentNumber += 1            currentVC.score += 1            currentVC.gameStart()            flag = true        } else {            // added            let currentData = currentVC.quizData[currentVC.currentNumber]            let data = ReminderModel(index: 0, word: currentData.question, meaning: currentData.answer)            NotificationCenter.default.post(name: .inCorrect, object: data)            currentVC.currentNumber += 1            currentVC.gameStart()        }        return flag    }그리고 또 hangman에도 있기에 심어둔다.이건 게임이 끝났을때 이므로func updateUI () {                if failCount &gt;= 7 {            hangManBodyView.hangManImageView.image = UIImage(named: imageList[failCount])            let alert = alertController.makeAlertWithCompletion(title: \"게임종료\", message: \"게임이 끝났습니다.\\n다시 시작하시겠습니까?\") { [weak self] _ in                self?.hangManBottomView?.removeFromSuperview()                                // added                guard let word = self?.quizArray[self!.currentCount].word, let meaning = self?.quizArray[self!.currentCount].definition else {                    return                }                                let data = ReminderModel(index: 1, word: word, meaning: meaning)                NotificationCenter.default.post(name: .inCorrect, object: data)                                self?.resetLabel()                self?.currentCount += 1                self?.gameStart()                self?.isGameEnd = false            }            self.present(alert, animated: true)            isGameEnd = true                    } else {            hangManBodyView.hangManImageView.image = UIImage(named: imageList[failCount])        }    }이렇게 등록.하지만 recordvc가 호출이 되지않아 넘어가지않는 상황이 발생하여 우회를 하기로 결정gaimmainvc에서 받아서 화면 전환시 넘기기로 했다.NotificationCenter.default.addObserver(self, selector: #selector(getData), name: .quiz, object: nil)NotificationCenter.default.addObserver(self, selector: #selector(getData), name: .hangman, object: nil)@objc func getData(_ notification: Notification) {        if let data = notification.object as? ReminderModel {            //print(data)            dataList.append(data)        }    }DiffableDatasource 구현고차함수인 filter와 map을 사용하여 각 인덱스에 해당하는 것만 적용하게 한다.extension RecordViewController {    func configureDiffableDataSource () {        tableDiffableDatasoure = UITableViewDiffableDataSource(tableView: recordBodyView.tableView, cellProvider: { tableView, indexPath, model in                        let cell = tableView.dequeueReusableCell(withIdentifier: Constants.recordCell, for: indexPath) as! RecordTableViewCell                        cell.wordLabel.text = model.word            cell.meaningLabel.text = model.meaning                        cell.selectionStyle = .none                        return cell        })    }        func configureQuizSnapshot() {        quizSnapshot = NSDiffableDataSourceSnapshot&lt;DiffableSectionModel, ReminderModel&gt;()        quizSnapshot?.deleteAllItems()        quizSnapshot?.appendSections([.quiz])        quizSnapshot?.appendItems(dataList.filter{ $0.index == 0}.map { $0 } )        tableDiffableDatasoure?.apply(quizSnapshot!,animatingDifferences: true)    }        func configureHangmanSnapshot() {        hangmanSnapshot = NSDiffableDataSourceSnapshot&lt;DiffableSectionModel, ReminderModel&gt;()        hangmanSnapshot?.deleteAllItems()        hangmanSnapshot?.appendSections([.hangman])        hangmanSnapshot?.appendItems(dataList.filter{ $0.index == 1}.map { $0 })        tableDiffableDatasoure?.apply(hangmanSnapshot!,animatingDifferences: true)    }}중복에러가 나서 어딘가 했는데func updateUI () {        guard let word = quizArray[currentCount].word, let meaning = quizArray[currentCount].definition else {            return        }        let data = ReminderModel(index: 1, word: word, meaning: meaning)        if failCount &gt;= 7 {            hangManBodyView.hangManImageView.image = UIImage(named: imageList[failCount])            let alert = alertController.makeAlertWithCompletion(title: \"게임종료\", message: \"게임이 끝났습니다.\\n다시 시작하시겠습니까?\") { [weak self] _ in                self?.hangManBottomView?.removeFromSuperview()                self?.resetLabel()                 NotificationCenter.default.post(name: .hangman, object: data) // wrong                self?.currentCount += 1                self?.gameStart()                self?.isGameEnd = false            }            NotificationCenter.default.post(name: .hangman, object: data) // correct            self.present(alert, animated: true)            isGameEnd = true                    } else {            hangManBodyView.hangManImageView.image = UIImage(named: imageList[failCount])        }    }wrong이라고 쓴곳이 잘못되었다.취소를 염두하고 아래에도 쓴게 화근이었다.생각해보니 확인이나 취소를 눌러도 무조건 등록이 되어야하기에 correct 부분에 넣는게 맞다.하지만 단점은 디퍼블은 Hashable이라서 중복값이 있어서는 안된다. 그것을 방지하기위해 set으로 한번 걸러낸다. func removeDuplicate () {        dataList = Array(Set(dataList)).sorted(by: { $0.word &lt; $1.word })    }중복제거와 동시에 정렬을 해서 보여주게 했다.하지만 카테고리가 없어서 좀 아쉽다.카테고리도 모델에 넣으면 좋을듯하다.모델 변경struct ReminderModel: Hashable {        var index: Int    var word: String    var meaning: String    var category: String // added}카테고리 정보는 어차피 receivedData가 가지고 있다.guard let word = quizArray[currentCount].word, let meaning = quizArray[currentCount].definition, let category = receivedData?.category else {            return        }let data = ReminderModel(index: 1, word: word, meaning: meaning, category: category)적용 완료.하지만 하나 아쉬운건 보여줄때 레이블이 어떤걸 의미하는지 모를 수 있다.tableview의 header에 uiview를 추가하여 보여주면 좋을듯하다.Tableview Header View 생성lazy var tableView: UITableView = {        let table = UITableView()        table.register(RecordTableViewCell.self, forCellReuseIdentifier: Constants.recordCell)        table.rowHeight = 60        table.tableHeaderView = headerView        return table    }()lazy var headerView: UIView = {        let view = UIView()        view.addSubview(hStackView)        return view    }()    lazy var categoryLabel = LabelFactory().makeLabel(title: \"단어장\", size: 20, isBold: true)lazy var wordLabel = LabelFactory().makeLabel(title: \"단어\", size: 20, isBold: false)lazy var defLabel = LabelFactory().makeLabel(title: \"의미\", size: 20, isBold: false)    lazy var hStackView: UIStackView = {        let stackView = UIStackView(arrangedSubviews: [            categoryLabel,            wordLabel,            defLabel        ])        stackView.axis = .horizontal        stackView.distribution = .fillEqually        return stackView    }()    다음과 같이 잡아준다.그리고 레이아웃을 또 잡아줘야 하는데 검색해보니private func layout () {        self.addSubview(vStackView)                vStackView.snp.makeConstraints {            $0.top.leading.equalToSuperview().offset(20)            $0.bottom.trailing.equalToSuperview().offset(-20)        }                headerView.frame = CGRect(x: 0, y: 0, width: tableView.bounds.width, height: 40) // important                hStackView.snp.makeConstraints { // added            $0.edges.equalToSuperview()        }            }headerview는 레이아웃보다는 프레임으로 잡는다고 한다. 기억해두자.실행하면 다음과 같다.끄읏.예외처리현재 문제를 하나 발견했는데 같은 문제가 두번 연속나오면 답을 못맞추는것같다.확인해보니 정답인데 색을 잘못 인식하는듯하다.추가로 확인해보니 오답으로 인식도 하는듯하다.아무래도 버튼이 변하면서 cache가 남는 느낌인데 initialize가 필요할것으로 보인다.우선 깜빡거리는 타이머를 0.2에서 0.1초로 바꾼다.그리고 @objc func updateBackground () {        [firstButton, secondButton, thirdButton, forthButton].forEach { button in            button.setTitle(\"\", for: .normal) // added            button.backgroundColor = ThemeColor.mainColor        }    }빈값으로 한번 초기화를 해보기로했다.문제가 사라진다. 아무래도 초기화를 해주는 시점을 다르게 잡아야할듯하다.우선 확인해보니 현재 배열의 개수보다 더 많이 만들때 발생을 하는데quiz에는 그 부분이 적용이 안되어있던걸로 보인다.func checkException () {        if receivedData!.quizCount &gt; quizArray.count {            receivedData?.quizCount = quizArray.count        }    }        func getData () {            quizArray = CoreDataManager.shared.getSpecificData(query: receivedData!.category, onError: { [unowned self] error in            let alert = alertController.makeNormalAlert(title: \"에러발생\", message: \"\\(error.localizedDescription)가 발생했습니다.\")            self.present(alert, animated: true)        })        // added        checkException()        quizArray = Array(quizArray.prefix(receivedData!.quizCount))    }그리고 또 문제를 발견했다.private func generate(count: Int) { // 문제배열이 생성        for _ in 0..&lt;count {            let numberArray = (0...quizArray.count - 1).map{ $0 }.shuffled()            let getFourNumberArray = numberArray.prefix(4).map { numberArray[$0] }            let number1 = getFourNumberArray[0]            let number2 = getFourNumberArray[1]            let number3 = getFourNumberArray[2]            let number4 = getFourNumberArray[3]                                    let answerInfo = quizArray[number1]            let question = answerInfo.word!            let answer = answerInfo.definition!            let first = quizArray[number2].definition!            let second = quizArray[number3].definition!            let third = quizArray[number4].definition!                        let dummy = VocaQuizModel(question: question, answer: answer, incorrectFirst: first, incorrectSecond: second, incorrectThird: third)            quizData.append(dummy)        }            }여기서 계속 랜덤으로 하다보니 문제가 발생한것.중복을 피하기 위해 이미 사용한 문제를 따로 추가하는 배열을 생성private func generate(count: Int) {                var usedQuestions = Set&lt;String&gt;() // added                for _ in 0..&lt;count {            var numberArray = (0...quizArray.count-1).map { $0 }.shuffled()                        var getFourNumberArray = numberArray.prefix(4).map { numberArray[$0] }            var answerInfo = quizArray[getFourNumberArray[0]]                        while usedQuestions.contains(answerInfo.word!) {                numberArray = (0...quizArray.count-1).map { $0 }.shuffled()                getFourNumberArray = numberArray.prefix(4).map { numberArray[$0] }                answerInfo = quizArray[getFourNumberArray[0]]            }                        let question = answerInfo.word!            let answer = answerInfo.definition!            let first = quizArray[getFourNumberArray[1]].definition!            let second = quizArray[getFourNumberArray[2]].definition!            let third = quizArray[getFourNumberArray[3]].definition!                        let dummy = VocaQuizModel(question: question, answer: answer, incorrectFirst: first, incorrectSecond: second, incorrectThird: third)            quizData.append(dummy)            usedQuestions.insert(question)        }            }완료."
  },
  
  {
    "title": "TikTok Clone (5)",
    "url": "/posts/TikTok-Clone-(5)/",
    "categories": "Udemy, TikTok",
    "tags": "",
    "date": "2024-05-20 09:13:00 +0900",
    





    
    "snippet": "TabBar controller 생성VC는 3개를 추가로 더 이어주었다.Home, Discover, Add, Inbox, Profile 총 5개이다.우선 NavController의 Storyboard id를 mainvc, tabbar controller의 Storyboard id를 TabbarVC로 해준다.이렇게.자동 로그인, 로그아웃 설정SceneD...",
    "content": "TabBar controller 생성VC는 3개를 추가로 더 이어주었다.Home, Discover, Add, Inbox, Profile 총 5개이다.우선 NavController의 Storyboard id를 mainvc, tabbar controller의 Storyboard id를 TabbarVC로 해준다.이렇게.자동 로그인, 로그아웃 설정SceneDelegat에서 다음과 같이 설정func configureInitialViewController () {        var initialVC = UIViewController()        let storyboard = UIStoryboard(name: \"Main\", bundle: nil)        if Auth.auth().currentUser != nil {            initialVC = storyboard.instantiateViewController(withIdentifier: IDENTIFIER_TABBAR)        } else {            initialVC = storyboard.instantiateViewController(withIdentifier: IDENTIFIER_MAIN)        }        window?.rootViewController = initialVC        window?.makeKeyAndVisible()    }func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {                configureInitialViewController() // added                guard let _ = (scene as? UIWindowScene) else { return }    }이렇게 해준다.Auth.auth().currentUser를 통해 현재 로그인 한 정보가 있다면 vc의 탭바를 띄우고 아니면 다른 페이지를 띄우라는것.실행하니 탭바가 나온다, 즉 현재 로그인이 되어있다는 의미ProfileVC에 로그아웃 기능을 설정해본다.우선 UserApi에 로그아웃 함수를 하나 만들어준다.간단하다Auth를 통해 signout 메서드를 호출하면 끝func logOut() {        do {            try Auth.auth().signOut()        } catch {            ProgressHUD.error(error.localizedDescription)            return        }        let scene = UIApplication.shared.connectedScenes.first        if let sd: SceneDelegate = (scene?.delegate as? SceneDelegate) {            sd.configureInitialViewController()        }    }그리고 로그아웃 시 어떤 화면을 보여줄지도 정해준다.이전에 Signin할때도 화면전환이 되게 하기 위해@IBAction func signInDidTapped(_ sender: Any) {        self.view.endEditing(true)        self.validateFields()        self.signIn { // added            let scene = UIApplication.shared.connectedScenes.first            if let sd: SceneDelegate = (scene?.delegate as? SceneDelegate) {                sd.configureInitialViewController()            }        } onError: { errorMessage in            ProgressHUD.failed(errorMessage)        }            }화면전환에 대한내용을 추가해준다.Signup도 마찬가지!@IBAction func signUpDidTapped(_ sender: Any) {        self.validateFields()        self.signUp {            let scene = UIApplication.shared.connectedScenes.first            if let sd: SceneDelegate = (scene?.delegate as? SceneDelegate) {                sd.configureInitialViewController()            }        } onError: { errorMessage in            ProgressHUD.failed(errorMessage)        }            }로그아웃, 로그인 전부 잘된다.로그인 할때 왜 화면이 안넘어가나 했는데func signIn(onSuccess: @escaping() -&gt; Void, onError: @escaping (_ errorMessage: String) -&gt; Void) {        ProgressHUD.animate(\"Loading...\")        Api.User.signIn(email: self.emailTextfield.text!, password: self.passwordTextfield.text!) {            ProgressHUD.dismiss()            onSuccess() // missed!        } onError: { errorMessage in            onError(errorMessage)        }    }저부분이 빠져있었다."
  },
  
  {
    "title": "단어장 프로젝트 (7)",
    "url": "/posts/%EB%8B%A8%EC%96%B4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-(7)/",
    "categories": "캠프, 프로젝트3",
    "tags": "",
    "date": "2024-05-20 09:00:00 +0900",
    





    
    "snippet": "게임을 클릭하면 ModalView가 떠오르고단어장과, 출제 단어를 선택할수있게 한다.우선 ModalVC가 필요하다.이전에 ModalVC를 몇번 구현해봤으나.새로운 방식이 있다 하여 그걸로 해본다.출처는 여기.ModalVC를 띄울 presentationController 만들기우선은 Controller를 하나 만들어준다.하나 독특하다면 UIPresent...",
    "content": "게임을 클릭하면 ModalView가 떠오르고단어장과, 출제 단어를 선택할수있게 한다.우선 ModalVC가 필요하다.이전에 ModalVC를 몇번 구현해봤으나.새로운 방식이 있다 하여 그걸로 해본다.출처는 여기.ModalVC를 띄울 presentationController 만들기우선은 Controller를 하나 만들어준다.하나 독특하다면 UIPresentationController 이녀석을 상속 받는다.import UIKitclass ManageModalPresentationController: UIPresentationController {}물론 이 클래스는 Cocoa Touch Class에서 만들면 된다.앵간한게 다있다.해당글의 순서에 맞게 Modal의 크기와 위치를 잡는 메서드를 만든다.1. 크기와 위치 설정.frameOfPresentedViewInContainerView 이녀석을 override 한다.해당 메서드를 통해 크기와 위치를 설정할 수 있게된다.여기서도 이전에 ModalVC 구현했던것과 비슷한 매커니즘으로 DimmingView를 사용한다.DimmingView의 가장 큰 목적은 시각적 효과 + 해당 view를 탭했을때 vc를 dismiss해주는데 있다.private lazy var dimmingView: UIView = {        let dimmingView = UIView()        dimmingView.translatesAutoresizingMaskIntoConstraints = false        dimmingView.backgroundColor = UIColor(white: 0.0, alpha: 0.5)        dimmingView.alpha = 0.0                let recognizer = UITapGestureRecognizer(target: self,                                                action: #selector(handleTap(recognizer:)))        dimmingView.addGestureRecognizer(recognizer)                return dimmingView    }()@objc func handleTap(recognizer: UITapGestureRecognizer) {           presentingViewController.dismiss(animated: true)       }override var frameOfPresentedViewInContainerView: CGRect {        let screenBounds = UIScreen.main.bounds            let size = CGSize(width: screenBounds.width,                              height: screenBounds.height * 0.25)            let origin = CGPoint(x: .zero, y: screenBounds.height * 0.75)                        return CGRect(origin: origin, size: size)    }이전에 ModalVC를 해봐서 그런가 크게 헷갈리는 부분은 없다.2. Modal 시작과 사라질때의 작동할 코드 구현// 시작override func presentationTransitionWillBegin() {        super.presentationTransitionWillBegin()         guard let containerView = containerView else {            return        }        containerView.insertSubview(dimmingView, at: 0)                dimmingView.snp.makeConstraints {            $0.edges.equalToSuperview()        }                guard let coordinator = presentedViewController.transitionCoordinator else {            dimmingView.alpha = 1.0            return        }                coordinator.animate(alongsideTransition: { _ in            self.dimmingView.alpha = 1.0        })    }// 화면이 사라질때override func dismissalTransitionWillBegin() {        super.dismissalTransitionWillBegin()                guard let coordinator = presentedViewController.transitionCoordinator else {            dimmingView.alpha = 0.0            return        }                coordinator.animate(alongsideTransition: { _ in            self.dimmingView.alpha = 0.0        })    }viewDidload, viewDidDisappear 개념으로 보면될듯.3. Modal Delegate 상속extension GameMainPageViewController: UIViewControllerTransitioningDelegate {        func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -&gt; UIPresentationController? {        return ManageModalPresentationController(presentedViewController: presented, presenting: presenting)        }}해당 기능을 사용할 VC에서 UIViewControllerTransitioningDelegate를 상속받게 한다.이때 return하는 VC는 VCtype이 UIPresentationController 이녀석이다.4. ModalView 생성 &amp; Delegate설정class SelectVocaViewController: UIViewController {            override func viewDidLoad() {        super.viewDidLoad()        view.backgroundColor = .darkGray        // Do any additional setup after loading the view.    }}let vc = SelectVocaViewController()            vc.modalPresentationStyle = .custom            vc.transitioningDelegate = self            self.present(vc, animated: true, completion: nil)이렇게 하면 modalVC가 보이게 된다.ModalVC 디자인이렇게 해둔상태.기능 구현.1. Picker에 category에 대한 정보 입력.extension SelectVocaViewController: UIPickerViewDelegate, UIPickerViewDataSource {        func setup () {        selectBodyView.bookPicker.delegate = self        selectBodyView.bookPicker.dataSource = self    }        // picker의 갯수    func numberOfComponents(in pickerView: UIPickerView) -&gt; Int {        return 1    }        // 휠의 갯수    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {        return category.count    }        // 내용.    func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -&gt; String? {        return category[row]    }    }그리고 가장 중요한 게임 시작 버튼이 빠져서 디자인을 했다.2. 게임 시작 버튼 클릭시 vc 출력아마 가장 어려운 기능으로 보인다. lazy var startButton = ButtonFactory().makeButton(title: \"게임시작\") { [weak self] _ in        self?.launchGame(complete: { [unowned self] in            if let currentVC = self?.currentViewController as? GameMainPageViewController {                let flashVC = FlashCardViewController()                             currentVC.present(flashVC,animated: true)            }        }) }func launchGame (complete: @escaping () -&gt; Void) {        if let currentVC = currentViewController as? SelectVocaViewController {            complete()            currentVC.dismiss(animated: true)        }            }우선 이렇게 해두고,화면 전환만 확인이 되면 끝나는데, 여기가 제일 고비로 보인다.escaping closure를 통해서 뭔가 가능하지 않을까 라는 막연한 생각을 가지고 있는데.현재는 되지 않는 상황.1. 첫번째 시도dismiss의 complete를 사용 하여 도전func launchGame () {        if let currentVC = currentViewController as? SelectVocaViewController {            currentVC.dismiss(animated: true) {                let mainVC = GameMainPageViewController()                let flashVC = FlashCardViewController()                                mainVC.present(flashVC,animated: true)            }        }            }하지만 아래 에러가 뜸Attempt to present &lt;Vocabulary.FlashCardViewController: 0x106f4af10&gt; on &lt;Vocabulary.GameMainPageViewController: 0x10fd05c10&gt; (from &lt;Vocabulary.GameMainPageViewController: 0x10fd05c10&gt;) whose view is not in the window hierarchy.아마 view계층에 대한 문제로 생각이 된다.두번째로 GPT로 검색을 한번 했다가, 이건 온전히 나의 능력으로 하고싶어서 방식을 변경하기로 결정3. 방식 변경원래 의도한건 게임을 클릭하면 바로 설정이 나오고 그 이후에 dismiss를 하면서 원래 의도한 게임이 실행 되는 것이었는데,아무런 값이 없을때 해당 modal이 뜨게하는걸로 결정했다.Delegate를 통해 값을 전달을 해보려 한다.집중이 되질 않기도하고, view에서 그 view를 포함하는 vc까지는 데이터가 넘어갔지만, GameMainPageViewController 로는 delegate로 안되는걸 확인.NotificationCenter를 사용해서 전달 해보려 한다.extension Notification.Name {        static let sender = Notification.Name(\"sender\")    }그리고 GameMainPageViewController 에서 observer를 만든다.NotificationCenter.default.addObserver(self, selector: #selector(getSetting), name: .sender, object: nil)그리고 @objc func getSetting (_ notification: Notification) {        if let data = notification.object as? GenQuizModel {            receivedData = data        }    }이렇게 해준다.전달이 되는걸 확인했다.우선적으로 세팅을 하지않으면 alert를 띄우고 modalvc가 나오게 했다.func checkSetting() {        if receivedData == nil {            let alert = alertController.makeAlertWithCompletion(title: \"설정값이 없습니다.\", message: \"게임 설정이 필요합니다.\\n설정 페이지로 이동합니다.\") { _ in                let vc = SelectVocaViewController()                vc.modalPresentationStyle = .custom                vc.transitioningDelegate = self                self.present(vc, animated: true, completion: nil)            }            self.present(alert, animated: true)        }    }이렇게 하면alert를 띄우고 확인을 누르면 설정페이지로 간다.이젠 Coredata에서 가져오는 함수를 구현한다.func getSpecificData(query: String, onError: @escaping (Error) -&gt; Void) -&gt; [WordEntity] {        var array = [WordEntity]()        let request: NSFetchRequest&lt;WordEntity&gt; = WordEntity.fetchRequest()        let predicate = NSPredicate(format: \"bookCaseName == %@\", query)        request.predicate = predicate                do {                array = try managedContext!.fetch(request)        } catch {           onError(error)        }                return array    }다음과 같이 구현했다.private func getData () {        quizArray = CoreDataManager.shared.getSpecificData(query: receivedData!.category, onError: { [unowned self] error in            let alert = alertController.makeNormalAlert(title: \"에러발생\", message: \"\\(error.localizedDescription)가 발생했습니다.\")            self.present(alert, animated: true)        })    }vc에서 받게끔 처리를 하고.generate(count: receivedData!.quizCount) 여기도 이제 카운트를 설정한 값으로 받게 해준다.완료.이젠 dummydata를 썼던 곳에 모두 적용을 해준다.flashcard에서는 특이하게private func getData () {        quizArray = Array(CoreDataManager.shared.getSpecificData(query: receivedData!.category, onError: { [unowned self] error in            let alert = alertController.makeNormalAlert(title: \"에러발생\", message: \"\\(error.localizedDescription)가 발생했습니다.\")            self.present(alert, animated: true)        }).shuffled().prefix(receivedData!.quizCount))    }값을 가져오고, 셔플을 한 뒤, 슬라이싱을 했다.private func checkException () {        if receivedData!.quizCount &gt; quizArray.count {            receivedData?.quizCount = quizArray.count        }    }혹시나 현재 배열보다 더 많은 값을 추가를 하는 경우를 대비하여 맥시멈은 count에 맞춰놨다.private func getData () {        quizArray = CoreDataManager.shared.getSpecificData(query: receivedData!.category, onError: { [unowned self] error in            let alert = alertController.makeNormalAlert(title: \"에러발생\", message: \"\\(error.localizedDescription)가 발생했습니다.\")            self.present(alert, animated: true)        }).shuffled()        checkException() // added        quizArray = Array(quizArray.prefix(receivedData!.quizCount))    }Hangman예외처리는 내일해야할듯싶다."
  },
  
  {
    "title": "TikTok Clone (4)",
    "url": "/posts/TikTok-Clone-(4)/",
    "categories": "Udemy, TikTok",
    "tags": "",
    "date": "2024-05-19 19:13:00 +0900",
    





    
    "snippet": "Storage Service 구현사진을 저장하는것도 코드를 다시 세분화하여 나눠본다.class StorageService {    static func savePhoto (username: String, uid: String, data: Data, metaData: StorageMetadata, storageProfileRef: StorageRefer...",
    "content": "Storage Service 구현사진을 저장하는것도 코드를 다시 세분화하여 나눠본다.class StorageService {    static func savePhoto (username: String, uid: String, data: Data, metaData: StorageMetadata, storageProfileRef: StorageReference ,dict: Dictionary&lt;String, Any&gt;, onSuccess: @escaping() -&gt; Void, onError: @escaping (_ errorMessage: String) -&gt; Void) {                storageProfileRef.putData(data, metadata: metaData) { storageMetaData, error in            if error != nil {                print(error!.localizedDescription)                return            }                        storageProfileRef.downloadURL { url, error in                if let metaImageUrl = url?.absoluteString {                    print(metaImageUrl)                                        if let changeRequest = Auth.auth().currentUser?.createProfileChangeRequest() {                        changeRequest.photoURL = url                        changeRequest.displayName = username                        changeRequest.commitChanges { error in                            if let error = error {                                ProgressHUD.failed(error.localizedDescription)                            }                        }                    }                    var dictTemp = dict                    dictTemp[\"profileImageUrl\"] = metaImageUrl                    Database.database().reference().child(\"users\").child(uid).updateChildValues(dict) { error, ref in                        if error == nil {                            onSuccess()                        } else {                            onError(error!.localizedDescription)                        }                    }                }            }        }    }}Storage와 관련된 부분을 다시 클래스를 만들어 세분화를 한것인데,여기서 변경점이라면if let changeRequest = Auth.auth().currentUser?.createProfileChangeRequest() {                        changeRequest.photoURL = url                        changeRequest.displayName = username                        changeRequest.commitChanges { error in                            if let error = error {                                ProgressHUD.failed(error.localizedDescription)                            }                        }}바로 이부분이 추가가 되었다는 것.Docs에 의하면,사용자 프로필을 업데이트 할때 사용을 한다고 한다.즉 사용자의 이름, 프로필 사진등을 업데이트할때 사용을 한다는것.그리고 userapi의 signup에서도class UserApi {    func signUp (withUsername username: String, email: String, password: String, image: UIImage?, onSuccess: @escaping() -&gt; Void, onError: @escaping (_ errorMessage: String) -&gt; Void) {        guard let imageSelected = image else {            ProgressHUD.failed(\"Please enter a Profile Image\")            return        }        guard let imageData = imageSelected.jpegData(compressionQuality: 0.4) else {return}                Auth.auth().createUser(withEmail: email, password: password) { authDataResult, error in            if error != nil {                print(error!.localizedDescription)                return            }            if let authData = authDataResult {                print(authData.user.email)                var dict: Dictionary&lt;String, Any&gt; = [                    \"uid\": authData.user.uid,                    \"email\": authData.user.email,                    \"username\": username,                    \"profileImageUrl\": \"\",                    \"status\": \"\"                ]                let storageRef = Storage.storage().reference(forURL: \"gs://tiktoktutorial-d9129.appspot.com\")                let storageProfileRef = storageRef.child(\"profile\").child(authData.user.uid)                let metaData = StorageMetadata()                metaData.contentType = \"image/jpg\"                // modified                StorageService.savePhoto(username: username, uid: authData.user.uid, data: imageData, metaData: metaData, storageProfileRef: storageProfileRef, dict: dict) {                    onSuccess()                } onError: { errorMessage in                    onError(errorMessage)                }                            }        }    }}이렇게 심플하게 된다.Ref 세분화.Firebase정보를 담고있는 plist file에 다음과 같이 추가해준다.let REF_USER = \"users\"let STORAGE_PROFILE = \"profile\"let URL_STORAGE_ROOT = \"gs://~~~~.appspot.com\"let EMAIL = \"email\"let UID = \"uid\"let USERNAME = \"username\"let PROFILE_IMAGE_URL = \"profileImageUrl\"let STATUS = \"status\"class Ref {    let databaseRoot = Database.database().reference()        var databaseUsers: DatabaseReference {        return databaseRoot.child(REF_USER)    }        // storage Ref    let storageRoot = Storage.storage().reference(forURL: URL_STORAGE_ROOT)        var storageProfile: StorageReference {        return storageRoot.child(STORAGE_PROFILE)    }}다음과 같이 적는다, 주소는 storage 그 주소를 가져오면된다.이렇게 한것은 UserAPI에 있는 Stringvalue를 변수로 바꾸겠다는 것이다.// beforevar dict: Dictionary&lt;String, Any&gt; = [                    \"uid\": authData.user.uid,                    \"email\": authData.user.email,                    \"username\": username,                    \"profileImageUrl\": \"\",                    \"status\": \"\"                ]// aftervar dict: Dictionary&lt;String, Any&gt; = [                    UID: authData.user.uid,                    EMAIL: authData.user.email,                    USERNAME: username,                    PROFILE_IMAGE_URL: \"\",                    STATUS: \"\"                ]이렇게 바꾸겠다는것.다시 ref로 가서func databaseSpecificUser(uid: String) -&gt; DatabaseReference {        return databaseUsers.child(uid)    }func storageSpecificProfile(uid: String) -&gt; StorageReference {        return storageProfile.child(uid)    }두개의 함수를 만들어 준다.다시 UserApi로 가서// beforelet storageRef = Storage.storage().reference(forURL: \"gs://tiktoktutorial-d9129.appspot.com\")let storageProfileRef = storageRef.child(\"profile\").child(authData.user.uid)// after                let storageProfileRef = Ref().storageSpecificProfile(uid: authData.user.uid)두줄이었던걸 한줄로 바꿔주었다.그리고 StorageService로 가서// beforeDatabase.database().reference().child(\"users\").child(uid).updateChildValues(dict) { error, ref in                        if error == nil {                            onSuccess()                        } else {                            onError(error!.localizedDescription)                        }                    }// afterRef().databaseSpecificUser(uid: uid).updateChildValues(dict) { error, ref in                        if error == nil {                            onSuccess()                        } else {                            onError(error!.localizedDescription)                        }                    }변경.VC로 가서signup함수에 escaping closure와 hud를 사용해준다.func signUp(onSuccess: @escaping() -&gt; Void, onError: @escaping (_ errorMessage: String) -&gt; Void) {        ProgressHUD.animate()        Api.User.signUp(withUsername: self.usernameTextfield.text!, email: self.emailTextfield.text!, password: self.passwordTextfield.text!, image: self.image) {            ProgressHUD.dismiss()            onSuccess()        } onError: { errorMessage in            onError(errorMessage)        }    }@IBAction func signUpDidTapped(_ sender: Any) {        self.validateFields()        self.signUp {            // switch view        } onError: { errorMessage in            ProgressHUD.failed(errorMessage)        }    }실행하면 등록되는 동안 로딩 애니메이션이 작동잘된다. 저 애니메이션이 끝난다는건 firebase와의 통신이 완료되어 유저 졍보 등록이 되었다는걸 의미.Sign In 구현VC에func signIn(onSuccess: @escaping() -&gt; Void, onError: @escaping (_ errorMessage: String) -&gt; Void) {        ProgressHUD.animate()        Api.User.signUp(withUsername: self.usernameTextfield.text!, email: self.emailTextfield.text!, password: self.passwordTextfield.text!, image: self.image) {            ProgressHUD.dismiss()            onSuccess()        } onError: { errorMessage in            onError(errorMessage)        }    }signUp함수를 그대로 가져와서 이름만 바꿔주었다.해당 함수를 이용할 예정.UserApi로 가서 다음과 같이 틀을 잡고, 확인을위해 프린트만 적어준다.func signIn(email: String, password: String, onSuccess: @escaping() -&gt; Void, onError: @escaping (_ errorMessage: String) -&gt; Void) {        Auth.auth().signIn(withEmail: email, password: password) { authData, error in            if error != nil {                onError(error!.localizedDescription)                return            }            print(authData?.user.uid)            onSuccess()        }            }    VC에도 다음과 같이 해준다.func signIn(onSuccess: @escaping() -&gt; Void, onError: @escaping (_ errorMessage: String) -&gt; Void) {        ProgressHUD.animate()        Api.User.signIn(email: self.emailTextfield.text!, password: self.passwordTextfield.text!) {            ProgressHUD.dismiss()        } onError: { errorMessage in            onError(errorMessage)        }    }signUpVC에 있던 validateFields 이 함수도 가져와서 username부분만 지워주면된다.그리고 ibaction을 다듬어준다.@IBAction func signInDidTapped(_ sender: Any) {        self.view.endEditing(true) // added        self.validateFields() // added        self.signIn {            // switch view        } onError: { errorMessage in            ProgressHUD.failed(errorMessage)        }            }텍스트필드를 터치하면 올라오는 키보드를 Signin버튼을 누르면 키보드를 사라지게 하고, 바로 각 텍스트필드의 유효성을 검사 후 로그인 시도를 하게 된다.버튼을 눌러보니 콘솔에 uid가 출력이 되는걸 알 수 있다."
  },
  
  {
    "title": "TikTok Clone (3)",
    "url": "/posts/TikTok-Clone-(3)/",
    "categories": "Udemy, TikTok",
    "tags": "",
    "date": "2024-05-19 18:13:00 +0900",
    





    
    "snippet": "Textfield 유효 함수 구현여러 Textfield 값이 입력이 될때 해당 컴포넌트에 제대로 값이 있는지 확인하는 함수를 구현한다.func validateFields() {        guard let username = self.usernameTextfield.text, !username.isEmpty else {            print...",
    "content": "Textfield 유효 함수 구현여러 Textfield 값이 입력이 될때 해당 컴포넌트에 제대로 값이 있는지 확인하는 함수를 구현한다.func validateFields() {        guard let username = self.usernameTextfield.text, !username.isEmpty else {            print(\"Please enter an username\")            return        }        guard let email = self.emailTextfield.text, !email.isEmpty else {            print(\"Please enter an username\")            return        }        guard let password = self.passwordTextfield.text, !password.isEmpty else {            print(\"Please enter an username\")            return        }    }우선은 틀만 이렇게 잡는다.그리고 버튼을 클릭했을때 작동이 먼저되게@IBAction func signUpDidTapped(_ sender: Any) {        self.validateFields()여기에 바로 구현.버튼을 클릭하니Please enter an usernameAvatar is nil이렇게 나온다.Progress HUD 사용.주소는 여기에SPM으로 추가한다.이전에는 showError 메서드가 있었으나 지금은 없다. 그래서 failed로 대체func validateFields() {        guard let username = self.usernameTextfield.text, !username.isEmpty else {            ProgressHUD.failed(\"Please enter an username\")            return        }        guard let email = self.emailTextfield.text, !email.isEmpty else {            ProgressHUD.failed(\"Please enter a email\")            return        }        guard let password = self.passwordTextfield.text, !password.isEmpty else {            ProgressHUD.failed(\"Please enter a password\")            return        }    }실행하니 아주 괜찮다.이미지에도 적용을 해주자.guard let imageSelected = self.image else {            ProgressHUD.failed(\"Please enter a Profile Image\")            return        }textfield값 적용이전까지는 이메일주소, 비밀번호를 미리 파라미터에 입력했다면 이젠 textfield의 값을 받도록 변경한다.@IBAction func signUpDidTapped(_ sender: Any) {        self.validateFields()                        guard let imageSelected = self.image else {            ProgressHUD.failed(\"Please enter a Profile Image\") // modified            return        }        guard let imageData = imageSelected.jpegData(compressionQuality: 0.4) else {return}                Auth.auth().createUser(withEmail: self.emailTextfield.text!, password: self.passwordTextfield.text!) { authDataResut, error in // modified            if error != nil {                print(error!.localizedDescription)                return            }            if let authData = authDataResut {                print(authData.user.email)                var dict: Dictionary&lt;String, Any&gt; = [                    \"uid\": authData.user.uid,                    \"email\": authData.user.email,                    \"username\": self.usernameTextfield.text!, // added                    \"profileImageUrl\": \"\",                    \"status\": \"\"                ]DB를 리셋시키고 테스트를 해보자.그전에 비밀번호를 보이지 않게 하기위해여기 부분을 체크해주자.아직 이후 액션이 없어서 저기서 멍때리지만DB에는 값이 잘 들어온걸로 확인이 된다.사진은 pass그리고 extension을 통해 signUp이라는 함수로 코드를 옮겨준다.extension SignUpViewController {        func signUp() {        guard let imageSelected = self.image else {            ProgressHUD.failed(\"Please enter a Profile Image\")            return        }        guard let imageData = imageSelected.jpegData(compressionQuality: 0.4) else {return}                Auth.auth().createUser(withEmail: self.emailTextfield.text!, password: self.passwordTextfield.text!) { authDataResut, error in            if error != nil {                print(error!.localizedDescription)                return            }            if let authData = authDataResut {                print(authData.user.email)                var dict: Dictionary&lt;String, Any&gt; = [                    \"uid\": authData.user.uid,                    \"email\": authData.user.email,                    \"username\": self.usernameTextfield.text!,                    \"profileImageUrl\": \"\",                    \"status\": \"\"                ]                let storageRef = Storage.storage().reference(forURL: \"gs://tiktoktutorial-d9129.appspot.com\")                let storageProfileRef = storageRef.child(\"profile\").child(authData.user.uid)                let metaData = StorageMetadata()                metaData.contentType = \"image/jpg\"                storageProfileRef.putData(imageData, metadata: metaData) { storageMetaData, error in                    if error != nil {                        print(error!.localizedDescription)                        return                    }                    storageProfileRef.downloadURL { url, error in                        if let metaImageUrl = url?.absoluteString {                            print(metaImageUrl)                            dict[\"profileImageUrl\"] = metaImageUrl                            Database.database().reference().child(\"users\").child(authData.user.uid).updateChildValues(dict) { error, ref in                                if error != nil {                                    print(\"Done\")                                }                            }                        }                    }                }            }        }    }    }그리고 원래 objc 함수에는@IBAction func signUpDidTapped(_ sender: Any) {        self.validateFields()        self.signUp()    }이렇게 단순하게 해준다.Api 구현정확하게는 위에 정리한 함수를 클래스처럼해서 모듈화 해주는것이다.struct Api {    static var User = UserApi()}이렇게 만들고UserApi 부분에import UIKitimport FirebaseAuthimport FirebaseStorageimport FirebaseDatabaseimport ProgressHUDclass UserApi {    func signUp (withUsername username: String, email: String, password: String, image: UIImage?, onSuccess: @escaping() -&gt; Void, onError: @escaping (_ errorMessage: String) -&gt; Void) {        guard let imageSelected = image else {            ProgressHUD.failed(\"Please enter a Profile Image\")            return        }        guard let imageData = imageSelected.jpegData(compressionQuality: 0.4) else {return}                Auth.auth().createUser(withEmail: email, password: password) { authDataResult, error in            if error != nil {                print(error!.localizedDescription)                return            }            if let authData = authDataResult {                print(authData.user.email)                var dict: Dictionary&lt;String, Any&gt; = [                    \"uid\": authData.user.uid,                    \"email\": authData.user.email,                    \"username\": username,                    \"profileImageUrl\": \"\",                    \"status\": \"\"                ]                let storageRef = Storage.storage().reference(forURL: \"gs://tiktoktutorial-d9129.appspot.com\")                let storageProfileRef = storageRef.child(\"profile\").child(authData.user.uid)                let metaData = StorageMetadata()                metaData.contentType = \"image/jpg\"                storageProfileRef.putData(imageData, metadata: metaData) { storageMetaData, error in                    if error != nil {                        print(error!.localizedDescription)                        return                    }                    storageProfileRef.downloadURL { url, error in                        if let metaImageUrl = url?.absoluteString {                            print(metaImageUrl)                            dict[\"profileImageUrl\"] = metaImageUrl                            Database.database().reference().child(\"users\").child(authData.user.uid).updateChildValues(dict) { error, ref in                                if error == nil {                                    onSuccess()                                } else {                                    onError(error!.localizedDescription)                                }                            }                        }                    }                }            }        }    }}이 내용을 모두 옮겼다.특이점이라면 CompletionHandler를 사용하였고, success와 failure를 나눠서 구현했다.VC로 돌아와서는func signUp() {        Api.User.signUp(withUsername: self.usernameTextfield.text!, email: self.emailTextfield.text!, password: self.passwordTextfield.text!, image: self.image) {            print(\"Done\")        } onError: { errorMessage in            print(errorMessage)        }    }이렇게 심플하게 처리해주면 끝.실행해서 확인작동이 된다."
  },
  
  {
    "title": "단어장 프로젝트 (6)",
    "url": "/posts/%EB%8B%A8%EC%96%B4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-(6)/",
    "categories": "캠프, 프로젝트3",
    "tags": "",
    "date": "2024-05-18 21:00:00 +0900",
    





    
    "snippet": "Apple Login 구현.먼저 애플 개발자 계정에서 해야하는것이 있다.해당 내용은 출처를 보고 작성한다.App Id로 들어가서 추가.그다음 바로 continue를 하면다음과 같이 나오는데 프로젝트 번들 identifier를 입력하고밑에 내려가면 Sign in with Apple이 있다.이걸 체크해주고 continue를 하자.그러면 생성이 된다.그리고...",
    "content": "Apple Login 구현.먼저 애플 개발자 계정에서 해야하는것이 있다.해당 내용은 출처를 보고 작성한다.App Id로 들어가서 추가.그다음 바로 continue를 하면다음과 같이 나오는데 프로젝트 번들 identifier를 입력하고밑에 내려가면 Sign in with Apple이 있다.이걸 체크해주고 continue를 하자.그러면 생성이 된다.그리고 좌측에 있는 Key로 가서 키를 만들면다음과 같이 뜨는데 키이름을 입력하고sign in을 체크한뒤 configure를 클릭,그럼 이렇게 우리가 등록한 앱이 나온다.그리고 쭉 진행하면 다운로드 하라고 뜨는데, 키를 다운로드 해준다.그리고 done을 누르면 끝.프로젝트로 간다.다음과 같이 추가를 해준다.해당 내용은 출처Firebase를 통해 프로젝트를 하나 만들어 준다.해당내용은 passFirebase Auth페이지로 간다.그리고 Apple을 클릭도메인처럼 생긴 값을 별도로 저장을 해둔다.그리고 저장을 꼭 클릭하자.Apple 개발자 사이트로 간다.그리고Identifier에다가 현재 bundleIdentifier뒤에 하나를 더 적어주었다.위에 App id로 만든것과 중복이 발생하기 때문.continue를 해서 넘어가면이렇게 나오는데도메인은여기에 있고,auth url은 아까 위에 언급한 녀석이다.저장하면 끝났다.이제 로그인 기능을 구현해보도록 하겠다.Apple Docs와 Firebase Docs 를 보면서 만든다.그리고 거기에 Youtube 영상도 같이 참고를 한다.lazy var appleBtn = ASAuthorizationAppleIDButton() 우선 버튼을 하나 만든다.initialize를 할때lazy var appleBtn = ASAuthorizationAppleIDButton(authorizationButtonType: .signIn, authorizationButtonStyle: .black)이런식으로 안에 설정이 가능하다.private var currentNonce: String?그리고 변수를 하나 만들어 주는데 Nonce는 Firebase Auth에도 쓰인다.func handleAppleIDRequest() {        let provider = ASAuthorizationAppleIDProvider()        let request = provider.createRequest()        request.requestedScopes = [.fullName, .email]                let controller = ASAuthorizationController(authorizationRequests: [request])        controller.delegate = self        controller.performRequests()    }기본 세팅을 해주고,Firebase Docs에 있는 코드를 복사해서 가져온다.가져온다음 코드를 살짝 수정.func handleAppleIDRequest() {        let nonce = randomNonceString() // added        currentNonce = nonce // added        let provider = ASAuthorizationAppleIDProvider()        let request = provider.createRequest()        request.requestedScopes = [.fullName, .email]        request.nonce = sha256(nonce) // added                let controller = ASAuthorizationController(authorizationRequests: [request])        controller.delegate = self        controller.performRequests()    }nonce에 관한것만 추가가 되었다.그리고 다음 함수를 만들어 준다.func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: any Error) {            }    func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {            }인증실패와, 성공에 관한 함수.실패할때는 alert를 띄우게 했다.구현완료.// VClazy var appleBtn = ASAuthorizationAppleIDButton(authorizationButtonType: .signIn, authorizationButtonStyle: .black)private var currentNonce: String?// MARK: - Apple Signinextension LoginModalViewController: ASAuthorizationControllerDelegate {        @objc func handleAppleIDRequest() {        let nonce = randomNonceString()        currentNonce = nonce        let provider = ASAuthorizationAppleIDProvider()        let request = provider.createRequest()        request.requestedScopes = [.fullName, .email]        request.nonce = sha256(nonce)                let controller = ASAuthorizationController(authorizationRequests: [request])        controller.delegate = self        controller.performRequests()    }        func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: any Error) {        let alert = alertController.makeNormalAlert(title: \"에러발생\", message: \"로그인 할 수 없습니다.\")                self.present(alert, animated: true)    }        func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {        if let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential {                        guard let nonce = currentNonce else {                fatalError(\"Invalid state: A login callback was received, but no login request was sent.\")                return            }                        guard let token = appleIDCredential.identityToken else {                print(\"Unable to fetch identity token\")                return            }                        guard let tokenString = String(data: token, encoding:  .utf8) else {                print(\"Unable to serialize token string from data: \\(token.debugDescription)\")                return            }                        let oAuthCredential = OAuthProvider.credential(withProviderID: \"apple.com\", idToken: tokenString, rawNonce: nonce)                        Auth.auth().signIn(with: oAuthCredential) { [weak self] (result, error) in                                if let error = error {                    print(error.localizedDescription)                    return                }                                self?.dismiss(animated: true)                            }        }                    }            // MARK: - from Firebase Docs    private func randomNonceString(length: Int = 32) -&gt; String {        precondition(length &gt; 0)        var randomBytes = [UInt8](repeating: 0, count: length)        let errorCode = SecRandomCopyBytes(kSecRandomDefault, randomBytes.count, &amp;randomBytes)        if errorCode != errSecSuccess {            fatalError(                \"Unable to generate nonce. SecRandomCopyBytes failed with OSStatus \\(errorCode)\"            )        }                let charset: [Character] =        Array(\"0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._\")                let nonce = randomBytes.map { byte in            // Pick a random character from the set, wrapping around if needed.            charset[Int(byte) % charset.count]        }                return String(nonce)    }        @available(iOS 13, *)    private func sha256(_ input: String) -&gt; String {        let inputData = Data(input.utf8)        let hashedData = SHA256.hash(data: inputData)        let hashString = hashedData.compactMap {            String(format: \"%02x\", $0)        }.joined()                return hashString    }    }대체텍스트그리고 유저 정보를 Firebase에서 가져오게 했다.extension MyPageViewController {        func getUserData() {        if let user = Auth.auth().currentUser {            let uid = user.uid            let email = user.email                        DispatchQueue.main.async{ [weak self] in                self?.subLabel.text = uid                self?.mailLabel.text = email            }                    }    }}"
  },
  
  {
    "title": "TikTok Clone (2)",
    "url": "/posts/TikTok-Clone-(2)/",
    "categories": "Udemy, TikTok",
    "tags": "",
    "date": "2024-05-18 18:13:00 +0900",
    





    
    "snippet": "이미지 업로드프로필 이미지 클릭시 ImagePicker 나오게 구현우선func setupView() {        avatar.layer.cornerRadius = 60        avatar.clipsToBounds = true        avatar.isUserInteractionEnabled = true        signUpButton....",
    "content": "이미지 업로드프로필 이미지 클릭시 ImagePicker 나오게 구현우선func setupView() {        avatar.layer.cornerRadius = 60        avatar.clipsToBounds = true        avatar.isUserInteractionEnabled = true        signUpButton.layer.cornerRadius = 18                let tapGesture = UITapGestureRecognizer(target: self, action: #selector(presentPicker))        avatar.addGestureRecognizer(tapGesture)    }여기서 avatar.isUserInteractionEnabled = true 이걸 통해 유져의 이벤트를 무시하고 이벤트 큐에서 제거할지 여부를 결정한다.true를 하면 원래대로 View에 이벤트가 전달된다.false를 하면 touch, press, keyboard 그리고 focus의 이벤트가 무시되고 이벤트 큐에서 제거됨.지금은 true를 함으로써 tapgesture를 사용하여 touch의 이벤트를 작동시키기 위함이다.ImagePicker는 WWDC20에서 공개한 PHPicker를 사용한다.WWDC20 링크 참고.extension을 사용하여 구현해주었다.extension SignUpViewController: PHPickerViewControllerDelegate {    func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {        for item in results {            item.itemProvider.loadObject(ofClass: UIImage.self) { image, error in                if let imageSelected = image as? UIImage {                    print(imageSelected)                }            }        }    }                @objc func presentPicker() {        var configuration: PHPickerConfiguration = PHPickerConfiguration()        configuration.filter = PHPickerFilter.images        configuration.selectionLimit = 1                let picker: PHPickerViewController = PHPickerViewController(configuration: configuration)        picker.delegate = self        self.present(picker, animated: true)    }}출력이 되는걸 알 수 있다.&lt;UIImage:0x600003006010 anonymous {217, 232} renderingMode=automatic(original)&gt;이제 이미지를 ui에 띄워야하니 DispatchQueue를 사용한다.extension SignUpViewController: PHPickerViewControllerDelegate {    func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {        for item in results {            item.itemProvider.loadObject(ofClass: UIImage.self) { image, error in                if let imageSelected = image as? UIImage {                    DispatchQueue.main.async { // added                        self.avatar.image = imageSelected                    }                }            }        }        dismiss(animated: true) // added    }                @objc func presentPicker() {        var configuration: PHPickerConfiguration = PHPickerConfiguration()        configuration.filter = PHPickerFilter.images        configuration.selectionLimit = 1                let picker: PHPickerViewController = PHPickerViewController(configuration: configuration)        picker.delegate = self        self.present(picker, animated: true)    }}그리고 dismiss를 하는 이유는 이것도 하나의 VC의 개념이라 dismiss를 통해 해당 vc를 사라지게 해준다.이렇게 이미지가 뜨는걸 확인할 수 있다.이미지 저장var image: UIImage? = nil 이렇게 초기값을 잡아주고.func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {        for item in results {            item.itemProvider.loadObject(ofClass: UIImage.self) { image, error in                if let imageSelected = image as? UIImage {                    DispatchQueue.main.async {                        self.avatar.image = imageSelected                        self.image = imageSelected // added                    }                }            }        }        dismiss(animated: true)    }저기에 저장을 해준다.이제 저 이미지를 사용해서 Database에 등록할 것이다.Firebase Storage를 빌드해주고, 이것도 역시 테스트로 한다.그리고 Storage 주소를 복하해준다.바로 이녀석.그리고 다음과 같이 적는다@IBAction func signUpDidTapped(_ sender: Any) {                // added        guard let imageSelected = self.image else {            print(\"Avatar is nil\")            return        }        guard let imageData = imageSelected.jpegData(compressionQuality: 0.4) else {return}                Auth.auth().createUser(withEmail: \"test2@gmail.com\", password: \"123456\") { authDataResut, error in            if error != nil {                print(error!.localizedDescription)                return            }            if let authData = authDataResut {                print(authData.user.email)                let dict: Dictionary&lt;String, Any&gt; = [                    \"uid\": authData.user.uid,                    \"email\": authData.user.email,                    \"profileImageUrl\": \"\",                    \"status\": \"\"                ]                // added                let storageRef = Storage.storage().reference(forURL: \"gs://tiktoktutorial-d9129.appspot.com\")                let storageProfileRef = storageRef.child(\"profile\").child(authData.user.uid)                let metaData = StorageMetadata()                metaData.contentType = \"image/jpg\"                storageProfileRef.putData(imageData, metadata: metaData) { storageMetaData, error in                    if error != nil {                        print(error!.localizedDescription)                        return                    }                    storageProfileRef.downloadURL { url, error in                        if let metaImageUrl = url?.absoluteString {                            print(metaImageUrl)                        }                    }                }                                Database.database().reference().child(\"users\").child(authData.user.uid).updateChildValues(dict) { error, ref in                    if error != nil {                        print(\"Done\")                    }                }            }        }    }저기가 바로 추가된 부분인데,우리가 선택한 이미지를 가져와서 이미지 데이터라는 변수에 담는데 jpeg로 담고 0~1사이의 퀄리티로 해서 전환을 하는데 높을수록 퀄리티가 좋다.그리고, 레퍼런스라는 변수를 만들어서 복사한 주소값을 넣음으로써 저 주소로 된 스토리지를 사용하겠다는 것이다.storageProfileRef이건 이전의 글에서 한것처럼 db가 어떤 구조로 저장이 될건지에 대해 계층구조를 나타내는 것,metadata를 가져와서, 우리가 사용할 이미지 형식이 어떤것인지를 정해준다. 위에서 적은것처럼 jpg를 사용하겠다라는 것이다.completionHandler를 통해 이미지를 스토리지에 저장하고 그 url주소를 출력하게 했다.콘솔로 이미지 주소가 출력이 되고, 또한 사이트에서도 확인이 된다.이제 이미지를 저장하고 그걸 유저 정보를 가진 database에도 올리기 위해@IBAction func signUpDidTapped(_ sender: Any) {                guard let imageSelected = self.image else {            print(\"Avatar is nil\")            return        }        guard let imageData = imageSelected.jpegData(compressionQuality: 0.4) else {return}                Auth.auth().createUser(withEmail: \"test3@gmail.com\", password: \"123456\") { authDataResut, error in            if error != nil {                print(error!.localizedDescription)                return            }            if let authData = authDataResut {                print(authData.user.email)                var dict: Dictionary&lt;String, Any&gt; = [                    \"uid\": authData.user.uid,                    \"email\": authData.user.email,                    \"profileImageUrl\": \"\",                    \"status\": \"\"                ]                let storageRef = Storage.storage().reference(forURL: \"gs://tiktoktutorial-d9129.appspot.com\")                let storageProfileRef = storageRef.child(\"profile\").child(authData.user.uid)                let metaData = StorageMetadata()                metaData.contentType = \"image/jpg\"                storageProfileRef.putData(imageData, metadata: metaData) { storageMetaData, error in                    if error != nil {                        print(error!.localizedDescription)                        return                    }                    storageProfileRef.downloadURL { url, error in                        if let metaImageUrl = url?.absoluteString {                            print(metaImageUrl)                            dict[\"profileImageUrl\"] = metaImageUrl // moved                            Database.database().reference().child(\"users\").child(authData.user.uid).updateChildValues(dict) { error, ref in                                if error != nil {                                    print(\"Done\")                                }                            }                        }                    }                }            }        }    }주석친 부분이 원래는 아래에 있었지만 위로 올려준다.다시 이메일 주소를 바꿔서 등록을 해보면?이렇게 database 에도 확인이 되고,auth도 확인 완료,마지막으로Storage에서도 확인이 된다."
  },
  
  {
    "title": "TikTok Clone (1)",
    "url": "/posts/TikTok-Clone-(1)/",
    "categories": "Udemy, TikTok",
    "tags": "",
    "date": "2024-05-18 14:13:00 +0900",
    





    
    "snippet": "틱톡 클론 앱 과정을 정리해본다.아마 모르는 개념 위주로만 정리할듯.UIDesgin  사진으로 대체한다.AppDelegate 설정func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: ...",
    "content": "틱톡 클론 앱 과정을 정리해본다.아마 모르는 개념 위주로만 정리할듯.UIDesgin  사진으로 대체한다.AppDelegate 설정func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {        UINavigationBar.appearance().tintColor = UIColor(red: 0/255, green: 0/255, blue: 0/255, alpha: 1)        let backImg = UIImage(systemName: \"chevron.backward\")        UINavigationBar.appearance().backIndicatorImage = backImg        UINavigationBar.appearance().backIndicatorTransitionMaskImage = backImg        UIBarButtonItem.appearance().setBackButtonTitlePositionAdjustment(.init(horizontal: -1000, vertical: 0), for: .default)                return true    }이렇게 해서 backButton을 설정 해준다.Sign In VC 설정1. NavigationTitle 설정func setupNavigationBar() {        navigationItem.title = \"Create new account\"        navigationController?.navigationBar.prefersLargeTitles = true    }이렇게 해주면 위에 타이틀이 생긴다.2. TextField, ContainerView 설정func setupUsernameTextfield() {        usernameContainerView.layer.borderWidth = 1        usernameContainerView.layer.borderColor = CGColor(red: 217/255, green: 217/255, blue: 217/255, alpha: 0.8)        usernameContainerView.layer.cornerRadius = 20        usernameContainerView.clipsToBounds = true        usernameTextfield.borderStyle = .none    }현재 디자인이 TextField가 UIview안에 들어있는데, 그 uiview를 ContainerView라고 이름을 지었고, 그것을 설정해준다.Sign up도 동일Firebase 설정.Auth, Database, Storage(swift도 혹시몰라 설치) 이렇게 설치를 해주었다.Sign Up VC에서import FirebaseAuth를 해주고sign up 버튼을 클릭하여 회원가입을 하기 위해버튼에 다음과 같이 작성해본다.@IBAction func signUpDidTapped(_ sender: Any) {        Auth.auth().createUser(withEmail: \"test1@gmail.com\", password: \"123456\") { authDataResut, error in            if error != nil {                print(error?.localizedDescription)                return            }            if let authData = authDataResut {                print(authData.user.email)            }        }    }현재는 Firebase 에서 로그인 방식을 email / password로 해둔상태이다.버튼을 눌러보면Optional(\"test1@gmail.com\")이 출력되고,이렇게 Firebase, Auth에도 등록이 된걸 알 수 있다.Realtime Database 설정.이전과 동일하게 테스트모드로 만들어 주면 된다.유저정보를 데이터 베이스에 저장하는 코드를 작성한다.if let authData = authDataResut {                print(authData.user.email)                let dict: Dictionary&lt;String, Any&gt; = [                    \"uid\": authData.user.uid,                    \"email\": authData.user.email,                    \"profileImageUrl\": \"\",                    \"status\": \"\"                ]                                Database.database().reference().child(\"users\").child(authData.user.uid).updateChildValues(dict) { error, ref in                    if error != nil {                        print(\"Done\")                    }                }            }dict라는 dictionary를 만드는데 uid, email, profileImageUrl, status의 정보를 가지는 배열이다.그리고 Database.database().reference().child(\"users\").child(authData.user.uid).updateChildValues(dict) 이건users라는 table에서, 또 거기서 유저의 uid table을 만들고 거기에 유져의 데이터가 담기는 방식이다.그러면 이렇게 정보가 담기게 된다."
  },
  
  {
    "title": "Anchors (1)",
    "url": "/posts/Anchors-(1)/",
    "categories": "Udemy, Auto Layout",
    "tags": "",
    "date": "2024-05-17 22:13:00 +0900",
    





    
    "snippet": "Anchor?Auto Layout Anchor는 Auto Layout이 어떻게 배치되는지를 정의하는 제약 조건이라고 볼 수 있다.이런식으로 사용된다.일반적으로 레이아웃을 잡을때는다음과 같이 얼만큼 떨어지는지, 그리고 가로, 세로 길이값이 필요하다.위와 같은 방식을 우리는 Framebase Layout이라고 한다.방식은 다음과 같다.아까 위에서 언급한대...",
    "content": "Anchor?Auto Layout Anchor는 Auto Layout이 어떻게 배치되는지를 정의하는 제약 조건이라고 볼 수 있다.이런식으로 사용된다.일반적으로 레이아웃을 잡을때는다음과 같이 얼만큼 떨어지는지, 그리고 가로, 세로 길이값이 필요하다.위와 같은 방식을 우리는 Framebase Layout이라고 한다.방식은 다음과 같다.아까 위에서 언급한대로 x,y 좌표식으로 얼만큼 떨어지는지, 그리고 거기서부터 가로 세로를 디자인해서 프레임을 만드는 형식으로 이루어 진다.해당 방식은, 하나의 Device에서 적용을 할때는 괜찮다.하지만 여러 기기에 대해서 적용을 할때는? 그렇게 좋은 방식은 아니다.왜냐 기기마다 Screen의 가로 세로 값이 다 다르기 때문.그다음 사용하는 방식이 바로 Auto Layout 이다.iOS 개발자에게 있어 가장 권고하는 방식이며제약 조건에 따라 사이즈가 자유롭게 조절이 된다.구현방식은 아래 사진과 같다.이렇게 유동적으로 사이즈를 조절 할 수 있지만그렇다고해서 가로 세로의 값을 조절 못하는 것도 아니다.이렇게 설정이 가능.말고도 이렇게 여러 방식으로 설정이 가능하다.이렇게 Auto Layout을 사용하게 되면 어떤 기기를 사용하든 가로 세로값을 기기에 맞게 유동적으로 할 수가 있게된다."
  },
  
  {
    "title": "단어장 프로젝트 (5)",
    "url": "/posts/%EB%8B%A8%EC%96%B4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-(5)/",
    "categories": "캠프, 프로젝트3",
    "tags": "",
    "date": "2024-05-17 06:00:00 +0900",
    





    
    "snippet": "게임 정답처리와 재시작할때 UI가 reset이 되도록 구현을 해야한다.button 초기화고민을 하다가 기존에 view가 로딩이 이미 되어서 리셋이 안되는거라면 새로 시작할때마다 addsubview를 하면 되지않을까 라는 생각이 들었다.private func gameStart () {        let hangManBottomView = HangMan...",
    "content": "게임 정답처리와 재시작할때 UI가 reset이 되도록 구현을 해야한다.button 초기화고민을 하다가 기존에 view가 로딩이 이미 되어서 리셋이 안되는거라면 새로 시작할때마다 addsubview를 하면 되지않을까 라는 생각이 들었다.private func gameStart () {        let hangManBottomView = HangManBottomView()                vStackView.addSubview(hangManBottomView)                hangManBottomView.snp.makeConstraints {            $0.top.equalTo(hangManBodyView.snp.bottom)            $0.leading.equalToSuperview()            $0.trailing.equalToSuperview()            $0.bottom.equalToSuperview().offset(-60)        }                dummyList = dummyGenerator.makeDummy()        makeWordLabel()                updateMan()    }이렇게 게임 시작할때 추가하고 레이아웃을 잡게 한다.시작해보면리셋이 잘된다.예외처리alert가 뜨고 취소를 한상태에서 버튼을 클릭하면 failCount가 증가하면서 out of range 에러가 발생한다.이부분을 막기 위해서변수를 추가한다.var isGameEnd = false 게임이 종료되었는지 감지하는녀석이다.그리고 게임 과 관련된 코드를 일부 수정했다.func gameStart () {        failCount = 0 // added        isGameEnd = false // added        let hangManBottomView = HangManBottomView()                vStackView.addSubview(hangManBottomView)                hangManBottomView.snp.makeConstraints {            $0.top.equalTo(hangManBodyView.snp.bottom)            $0.leading.equalToSuperview()            $0.trailing.equalToSuperview()            $0.bottom.equalToSuperview().offset(-60)        }                dummyList = dummyGenerator.makeDummy()        makeWordLabel()                updateMan()    }        func updateMan () {        if failCount &gt;= 7 {            hangManBodyView.hangManImageView.image = UIImage(named: imageList[failCount])            let alert = alertController.makeAlertWithCompletion(title: \"게임종료\", message: \"게임이 끝났습니다.\\n다시 시작하시겠습니까?\\n취소하여도 버튼 터치시 재시작이 가능합니다.\") { [weak self] _ in                self?.gameStart()                self?.isGameEnd = false            }            self.present(alert, animated: true)            isGameEnd = true        } else {            hangManBodyView.hangManImageView.image = UIImage(named: imageList[failCount])        }    }그리고 view쪽도 checkWord의 함수내용도 살짝 수정한다.func checkWord(button: UIButton) {        guard let currentVC = currentViewController as? HangManGameViewController else { return }                if currentVC.dummyList[currentVC.gameCount].words.contains(button.currentTitle!.lowercased()) {            if currentVC.isGameEnd == false {                button.isEnabled = false                button.setTitle(\"\", for: .normal)                button.backgroundColor = .blue                button.setImage(UIImage(systemName: \"checkmark\"), for: .normal)            } else {                currentVC.gameStart()            }        } else {            if currentVC.isGameEnd == false {                button.isEnabled = false                button.setTitle(\"\", for: .normal)                button.backgroundColor = .red                button.setImage(UIImage(systemName: \"xmark\"), for: .normal)                currentVC.failCount += 1                currentVC.updateMan()            } else {                currentVC.gameStart()            }        }    }이렇게 하게되면 게임이 진행중일땐 버튼이 정답과 오답만 구분하고게임끝나고선 유져가 취소를 눌러도 다시 버튼만 탭해도 게임이 재시작하게 된다.하지만 Hierarchy를 보면 계속 메모리에 쌓이게 된다.이걸 어떻게든 없애야한다.단지 우리 눈에만 새로 보이는것일 뿐 메모리에는 남아있는 상황.즉 강한 순환참조를 하고 있다는 말이 된다.순환참조 해결우선 해당문제를 해결하기 위해 nil을 부여를 해야할것같아서var hangManBottomView: HangManBottomView? 이렇게 바꿔주었다.그리고나서func gameStart () {        failCount = 0        isGameEnd = false                hangManBottomView = HangManBottomView()                vStackView.addSubview(hangManBottomView!)                hangManBottomView!.snp.makeConstraints {            $0.top.equalTo(hangManBodyView.snp.bottom)            $0.leading.equalToSuperview()            $0.trailing.equalToSuperview()            $0.bottom.equalToSuperview().offset(-60)        }                dummyList = [dummyGenerator.makeDummy().shuffled().first!]                makeWordLabel()                updateMan()    }        func updateMan () {        if failCount &gt;= 7 {            hangManBodyView.hangManImageView.image = UIImage(named: imageList[failCount])            let alert = alertController.makeAlertWithCompletion(title: \"게임종료\", message: \"게임이 끝났습니다.\\n다시 시작하시겠습니까?\\n취소하여도 버튼 터치시 재시작이 가능합니다.\") { [weak self] _ in                self?.hangManBottomView = nil                self?.gameStart()                self?.isGameEnd = false            }            self.present(alert, animated: true)            isGameEnd = true        } else {            hangManBodyView.hangManImageView.image = UIImage(named: imageList[failCount])        }    }그리고 시작할때 객체를 인스턴스화 하고 추가를 했는데도 불구하고게임이 끝난뒤에 nil을 해도 메모리에 남아있었다.무엇이 문제인지 몰랐다.Stackoverflow을 통해 nil이 아닌self?.hangManBottomView?.removeFromSuperview()이것을 통해 날려야 한다는걸 알게 되었다.하지만 이해가 가지않는건 nil로도 날릴 수 있는게 아닌가? 라는게 내 생각이었다.튜터님께 여쭤보니 애초에 Stackview를 참조하기에, count가 1이 증가한 상태로 시작. 하므로 nil을 하더라도 view 계층에 남아있는 이상은 순환참조가 발생할 수 밖에없다는 것. view쪽은 nil보다는 removeFromSuperview를 사용하도록 하자.우선 버튼은 해결하지만 아직 label이 남아있다.아무래도 tag를 부여했으나 누적이 되면서 기존의 tag값이 날아간것같다.private func makeWordLabel () {        for i in 1 ... dummyList[0].words.count {            print(dummyList[0].words)            print(dummyList[0].words.count)            label = LabelFactory().hangManLabel(title: \"_\", size: 20, tag: i, isBold: true)            print(\"label tag: \\(String(describing: label?.tag))\")            hangManBodyView.wordFrameView.addSubview(label!)                        label!.snp.makeConstraints {                $0.leading.equalTo(hangManBodyView.wordFrameView.snp.leading).offset(i * 20)            }        }    }label이 변수명이 하나라서 그런듯하다.하지만 hierarchy를 확인해보니Printing description of $19:&lt;UILabel: 0x104b2a640; frame = (40 0; 11.6667 24); text = '_'; userInteractionEnabled = NO; tag = 2; backgroundColor = UIExtendedGrayColorSpace 0 0; layer = &lt;_UILabelLayer: 0x600002650f60&gt;&gt;Printing description of $20:&lt;UILabel: 0x104b29bb0; frame = (20 0; 11.6667 24); text = '_'; userInteractionEnabled = NO; tag = 1; backgroundColor = UIExtendedGrayColorSpace 0 0; layer = &lt;_UILabelLayer: 0x600002650d80&gt;&gt;Printing description of $21:&lt;UILabel: 0x104b2b0d0; frame = (60 0; 11.6667 24); text = '_'; userInteractionEnabled = NO; tag = 3; backgroundColor = UIExtendedGrayColorSpace 0 0; layer = &lt;_UILabelLayer: 0x600002651140&gt;&gt;tag가 다 살아있다.하지만레이블을 지우기 위해 함수를 만들고 print를 찍어보았으나.private func resetLabel () {        for i in 1 ... dummyList[0].words.count {            print(\"resetLabel : \\(String(describing: label?.viewWithTag(i)))\")            label?.viewWithTag(i)?.removeFromSuperview()        }    }    결과는 이렇다. 분명히 Hierarchy에는 남아있으나, 찾지를 못하는건가 싶다.resetLabel : nilresetLabel : nilresetLabel : nilresetLabel : nilresetLabel : nilresetLabel : nilresetLabel : Optional(&lt;UILabel: 0x106539ef0; frame = (140 0; 11.6667 24); text = '_'; userInteractionEnabled = NO; tag = 7; backgroundColor = UIExtendedGrayColorSpace 0 0; layer = &lt;_UILabelLayer: 0x6000026376c0&gt;&gt;)새벽이라 머리가 돌아가지 않아서 아이디어만 gpt에게 구했다.확실히 UI를 다시 보여주는 이런부분에 내가 많이 취약하다는것을 알게된다.이번 팀프로젝트하면서 더 많은걸 배우게 된다.가장 큰 아이디어는 바로 uilabel을 배열에 저장시켜주고, 지울때도 그 배열에서 꺼내서 지우면 되는것이었다.var labelList = [UILabel]() // private func makeWordLabel () {        for i in 1 ... dummyList[0].words.count {            label = LabelFactory().hangManLabel(title: \"_\", size: 20, tag: i, isBold: true)            hangManBodyView.wordFrameView.addSubview(label!)            labelList.append(label!) // added                        label!.snp.makeConstraints {                $0.leading.equalTo(hangManBodyView.wordFrameView.snp.leading).offset(i * 20)            }        }    }private func resetLabel () {        for label in labelList {            print(\"resetLabel : \\(label)\")            label.removeFromSuperview()        }        labelList.removeAll()    }이렇게 하면 UIlabel도 reset이 된다.정답 처리.버튼을 눌렀을때 단어에서 알파벳의 위치를 가져와서 그 위치에 해당하는 label에 그 단어를 리턴시켜주면 될듯하다.우선 다음과 같이 만들었다.func getIndex(alphabet: Character) {        print(answer.firstIndex(of: alphabet))    }Optional(Swift.String.Index(_rawBits: 15))Optional(Swift.String.Index(_rawBits: 65799))Optional(Swift.String.Index(_rawBits: 131335))Optional(Swift.String.Index(_rawBits: 196871))우선을 값을 가져오는것으로 확인.Stackoverflow에 인덱스 값을 인트로 변환할수 있는 글이 있어 사용해보려한다.시도를 해보려다가 굳이 이렇게 할필요가 있을까? 라는 생각이 들었고,단어를 배열로 바꿔서 하면 더 쉽다고 판단 하여 다음과 같이 구성을 했다.func guessAnswer(alphabet: Character) {        let words = answer.map { $0 }                for i in words.indices {            if words[i] == alphabet {                labelList[i].text = String(alphabet)                score += 1                monitorScore()            }        }            }func monitorScore() {        if score == answer.count {            let alert = alertController.makeAlertWithCancelCompletion(title: \"축하합니다.\", message: \"정답을 맞추셨습니다\\n다시 시작하시겠습니까?\") { [weak self] _ in                self?.hangManBottomView?.removeFromSuperview()                self?.resetLabel()                self?.gameStart()                self?.isGameEnd = false            }            self.present(alert, animated: true)            isGameEnd = true        }    }    배열을 만들고 for문을 쓰면 알파벳이 중복이 되더라도 다 걸러낼수가 있기에 이 방법이 훨씬 낫다고 판단했다.그리고 score가 정답의 글자수와 같다면 정답이라고 인식하게 하였다.이렇게 실행하면 정답인상태에서 취소를 누르고 다시 시작할때 기존 값이 남아있게 된다. func gameStart () {        failCount = 0        score = 0        isGameEnd = false                if !labelList.isEmpty { // added            resetLabel()        }                hangManBottomView = HangManBottomView()                vStackView.addSubview(hangManBottomView!)                hangManBottomView!.snp.makeConstraints {            $0.top.equalTo(hangManBodyView.snp.bottom)            $0.leading.equalToSuperview()            $0.trailing.equalToSuperview()            $0.bottom.equalToSuperview().offset(-60)        }                answer = dummyGenerator.makeDummy().shuffled().first!.words        print(answer)        makeWordLabel(word: answer)                updateUI()    }그래서 취소를 대비하여 labelList가 비어있지 않으면 한번 리셋을 하게 해주었다.완료.Hangman 좀 빡셌는데, 그래도 부족한점 두개를 배워간다.또 한단계 발전할 수 있는 Insight를 얻어간다."
  },
  
  {
    "title": "단어장 프로젝트 (4)",
    "url": "/posts/%EB%8B%A8%EC%96%B4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-(4)/",
    "categories": "캠프, 프로젝트3",
    "tags": "",
    "date": "2024-05-16 10:00:00 +0900",
    





    
    "snippet": "4일차 시작.사실 오래걸릴것같았던 기능들이 하루만에 해결이 되어서 뭘 할지 고민이 많다.추가로 게임기능 하나정도만 더하면 아마 괜찮지 않을까? 싶어서 하나 더 구현해본다.아마 제일 빡세지 않을까? 라는 생각이 좀 든다.우선 알파벳 버튼을 만들어야하는데 A to Z 너무 많다.이것도 LabelFactory처럼, ButtonFactory를 만들어 준다.c...",
    "content": "4일차 시작.사실 오래걸릴것같았던 기능들이 하루만에 해결이 되어서 뭘 할지 고민이 많다.추가로 게임기능 하나정도만 더하면 아마 괜찮지 않을까? 싶어서 하나 더 구현해본다.아마 제일 빡세지 않을까? 라는 생각이 좀 든다.우선 알파벳 버튼을 만들어야하는데 A to Z 너무 많다.이것도 LabelFactory처럼, ButtonFactory를 만들어 준다.class ButtonFactory {        func makeButton(title: String, color: UIColor = .black, backgroundColor: UIColor = .lightGray, completion: @escaping (UIAction) -&gt; Void) -&gt; UIButton {        let button = UIButton()        button.setTitle(title, for: .normal)        button.setTitleColor(color, for: .normal)        button.backgroundColor = backgroundColor        button.layer.borderWidth = 0.3        button.addAction(UIAction(handler: completion), for: .touchUpInside)        return button    }    }이렇게 되면 addaction도 만들면서 직접 설정이 가능.그리고 UIDesign을 시작.결과는 다음과 같다.이제 Hangman 이미지를 만들어 준다.이런식으로 디자인을 했다.실패횟수는 7회로 하면 될듯하다.Word 부분을 UIView로 만들고 안에 단어의 글자 만큼 _ 로 나오게 표현을 해보았다.private func makeWordLabel () {        for i in 0 ... dummyList[gameCount].words.count - 1 {            print(dummyList[gameCount].words)            let label = LabelFactory().hangManLabel(title: \"_\", size: 20, isBold: true)            hangManBodyView.wordFrameView.addSubview(label)                        label.snp.makeConstraints {                $0.leading.equalTo(hangManBodyView.wordFrameView.snp.leading).offset(i * 20)            }        }    }그리고 HangMan게임용 Label을 또 만들어주었다.func hangManLabel (title: String, color: UIColor = .black, size: CGFloat, tag:Int, textAlignment: NSTextAlignment = .center, isBold: Bool) -&gt; UILabel {        let label = UILabel()        label.text = title        label.textColor = color        if isBold == true {            label.font = UIFont.boldSystemFont(ofSize: size)        } else {            label.font = UIFont.systemFont(ofSize: size)        }        label.tag = tag        label.textAlignment = textAlignment        label.numberOfLines = 0                return label    }이것을 만든 목적은 바로 저 tag를 사용하는데 있다.이제 게임과 관련된 로직을 구현해야하는데 순환참조가 발생한다.lazy var buttonA = ButtonFactory().makeButton(title: \"A\") { [weak currentVC, weak self] _ in        if currentVC?.dummyList[currentVC!.gameCount].words.contains(\"A\") == true {                    } else {                    }    }바로 여기서 buttonA 자기 자신에 대해서 처리를 해야하다보니. 순환참조 에러가 발생.고민을 하다가 이 부분을 튜터님께 여쭤보니 Notification Center를 사용을 해보는게 어떠냐고 하신다.  Notification Center 란?      Notification Center에 등록된 Event가 발생하면 해당 Event에 대한 행동을 취한다.  우선 ture / false에 따른 Notification Name을 extension을 통해 만들어 준다.extension Notification.Name {    static let trueNotification = Notification.Name(\"trueNotification\")    static let falseNotification = Notification.Name(\"falseNotification\")}static을 사용함으로써, 쉽게 사용할수있게 해둠.그리고 VC로 가서 addObserver를 해준다. (Viewdidload)NotificationCenter.default.addObserver(self, selector: #selector(trueAnswer), name: .trueNotification, object: nil)NotificationCenter.default.addObserver(self, selector: #selector(falseAnswer), name: .falseNotification, object: nil)그리고 버튼에다가는lazy var buttonA = ButtonFactory().makeButton(title: \"A\") { [weak currentVC] buttonA in        if currentVC?.dummyList[currentVC!.gameCount].words.contains(\"A\") == true {            print(\"true\")            NotificationCenter.default.post(name: .trueNotification, object: buttonA)        } else {            print(\"false\")            NotificationCenter.default.post(name: .falseNotification, object: buttonA)        }    }이렇게 하다가 도저히 @objc에서 안되어서 결국 또 Combine에 이어 GPT에게 도움을 요청 근본적으로 button을 만들때 기존처럼 button.addAction을 통해서 바로 접근하던게 떠올랐는데 그걸 전부 다 길게 할 수 없어서 factory처럼 가능한지 물어봤다.func makeButton(title: String, color: UIColor = .black, backgroundColor: UIColor = .lightGray, completion: @escaping (UIButton) -&gt; Void) -&gt; UIButton {    let button = UIButton()    button.setTitle(title, for: .normal)    button.setTitleColor(color, for: .normal)    button.backgroundColor = backgroundColor    button.layer.borderWidth = 0.3    button.addAction(UIAction { action in        guard let button = action.sender as? UIButton else { return }        completion(button)    }, for: .touchUpInside)    return button}이녀석은 이렇게 제시를 했다.코드를 보니 일리가 있다.애초에 내가 처음에 만들었던 buttonFactory에서 completion을 저 버튼으로 넘기면 되었는데, 생각이 너무 짧았다.그냥 UIAction을 리턴시켜야한다는 그 고정관념에 빠져있었다.Combine에 이어 이번에 이렇게 button 그자체를 넘기는것도 GPT에게 배워간다.위의 코드는 꼭 잊지않도록 해야겠다.lazy var buttonA = ButtonFactory().makeButton(title: \"A\") { [weak currentVC, weak self] button in        if currentVC?.dummyList[currentVC!.gameCount].words.contains(\"A\") == true {            self?.checkWord(button: button, backgroundColor: .blue, systemName: \"checkmark\")        } else {            self?.checkWord(button: button, backgroundColor: .red, systemName: \"xmark\")            currentVC?.failCount += 1        }    }이렇게 해서 체크를 했는데다른 알파벳들도 모두 빨간색으로 리턴한다확인해보니 currentVC?.dummyList[currentVC!.gameCount].words가 애초에 없다.전역변수로 첨에 vc를 만든게 문제로 판단.func checkWord(button: UIButton) {        guard let currentVC = currentViewController as? HangManGameViewController else { return }                if currentVC.dummyList[currentVC.gameCount].words.contains(button.currentTitle!.lowercased()) {            button.isEnabled = false            button.setTitle(\"\", for: .normal)            button.backgroundColor = .blue            button.setImage(UIImage(systemName: \"checkmark\"), for: .normal)        } else {            button.isEnabled = false            button.setTitle(\"\", for: .normal)            button.backgroundColor = .red            button.setImage(UIImage(systemName: \"xmark\"), for: .normal)            currentVC.failCount += 1            currentVC.updateMan()        }    }단어문제처럼 이렇게 함수에서 모든걸 처리하게 바꿨다.버튼도 위와같이 바꿔주었다. lazy var buttonA = ButtonFactory().makeButton(title: \"A\") { [weak self] button in        self?.checkWord(button: button)    }그리고 VC로 돌아가서private func gameStart () {        dummyList = dummyGenerator.makeDummy()        makeWordLabel()                updateMan()        hangManBottomView.isHidden = false    }    func updateMan () {        if failCount &gt;= 7 {            hangManBodyView.hangManImageView.image = UIImage(named: imageList[failCount])            let alert = alertController.makeAlertWithCompletion(title: \"게임종료\", message: \"게임이 끝났습니다.\\n다시 시작하시겠습니까?\") { [weak self] _ in                self?.failCount = 0                self?.gameStart()            }            hangManBottomView.isHidden = true            self.present(alert, animated: true)        } else {            hangManBodyView.hangManImageView.image = UIImage(named: imageList[failCount])        }    }이렇게 코드를 작성.어차피 영단어는 소문자로 입력이 될거같아서, 소문자만 받게처리했는데, 이건 나중에 상황봐서 고치면 될듯하다.우선은 구색만 갖춘다.Notification을 했어도 되었을듯…. Notification도 buttonFactory의 내용을 바꾼 시점에서는 가능했을듯 하다.다음 추가 기능때 NotificationCenter를 사용해보는걸로…현재 다시시작을 하게되면 저 버튼이 그대로 남아있어서 저걸 돌리는 방법은 내일 찾아봐야할듯…그리고 정답일때 표시가 되게도 해야한다.할게많다."
  },
  
  {
    "title": "단어장 프로젝트 (3)",
    "url": "/posts/%EB%8B%A8%EC%96%B4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-(3)/",
    "categories": "캠프, 프로젝트3",
    "tags": "",
    "date": "2024-05-15 20:00:00 +0900",
    





    
    "snippet": "3일차 시작오늘은 휴일인데 게임 기본적인건 구현이 완료되어서 그래도 쉬는날이어도 하루에 하나는 해야하지 않을까 싶어서간단하게 FlashCard쪽 UI를 디자인 해본다.기본 틀은 비슷하게 가면서 안에 UILabel을 크게 하면 좋을듯 하다.일단 디자인은 완료…특이점이라면lazy var frameView: UIView = {        let view ...",
    "content": "3일차 시작오늘은 휴일인데 게임 기본적인건 구현이 완료되어서 그래도 쉬는날이어도 하루에 하나는 해야하지 않을까 싶어서간단하게 FlashCard쪽 UI를 디자인 해본다.기본 틀은 비슷하게 가면서 안에 UILabel을 크게 하면 좋을듯 하다.일단 디자인은 완료…특이점이라면lazy var frameView: UIView = {        let view = UIView()        view.addSubview(wordLabel)        view.addSubview(answerLabel)        view.layer.borderWidth = 1        view.layer.cornerRadius = 10        return view    }()UIView를 써서 두 label을 안에 넣어줬다는 것이다.기본 기능 구현우선은 단어를 가져와야하므로 이전에 썼던 Generator를 그대로 이용한다.private func generate() {        wordList = dummyGenerator.makeDummy()    }그뒤에 이것도 사지선다형 게임과 비슷한데 UIupdate가 필요하므로 함수를 하나 만들고 그전에 했던것과 비슷하게 함수를 만들어준다.private func updateUI () {        if currentNumber &gt; wordList.count - 1 {            let alert = alertController.makeAlertWithCompletion(title: \"마지막 단어입니다.\", message: \"다시 시작하시겠습니까?\\n단어는 랜덤으로 다시 만들어집니다.\") { [weak self] _ in                self?.currentNumber = 0                self?.generate()            }            self.present(alert, animated: true)        } else {            flashBodyView.wordLabel.text = wordList[currentNumber].words            flashBodyView.answerLabel.isHidden = true            flashBodyView.answerLabel.text = wordList[currentNumber].meaning        }            }포인트는 항상 정답 레이블은 보이지 않는 상태가 되어야 한다. 그래서 hidden을 default로 잡아두었고,마지막 페이지일때 다시 연습하게끔 유도를 하면 어떨까 싶어 Alert를 띄운다.Alert역시 클래스로 만들어서 가져다 쓰는게 나을것으로 판단.class AlertController {        func makeAlertWithCompletion(title: String, message: String, completion: @escaping (UIAlertAction) -&gt; Void) -&gt; UIAlertController {        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"확인\", style: .default, handler: completion))        alert.addAction(UIAlertAction(title: \"취소\", style: .cancel))        return alert    }            func makeNormalAlert(title: String, message: String) -&gt; UIAlertController {        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"확인\", style: .default))        return alert    }}다음과 같이 handler가 있고 없고의 함수로 나눠준다.updateUI의 alertController가 바로 지금 위에 구현한 저녀석이다.이젠 gesture를 만들어준다.터치를 하면 단어뜻이나오고, swipe를 하면 다음 단어를 보이게 할생각이다.private func addGesture () {        let touchGesture = UITapGestureRecognizer(target: self, action: #selector(showAnswer))        let swipeLeftGesture = UISwipeGestureRecognizer(target: self, action: #selector(showNext))        let swipeRightGesture = UISwipeGestureRecognizer(target: self, action: #selector(showNext))        swipeLeftGesture.direction = .left        swipeRightGesture.direction = .right        flashBodyView.gestureRecognizers = [touchGesture, swipeLeftGesture, swipeRightGesture]    }다음과 같이 구현해준다.몰랐는데 swipeGesture의 경우엔 반드시 direction을 설정해 주어야 한다.지금같은 경우엔 gesture가 여러개이므로 addGesture 보다는 gestureRecognizers를 사용하여 배열에 담아주는게 더 낫다.그리고 selector의 함수들은 이렇게 적었따. @objc func showAnswer() {        flashBodyView.answerLabel.isHidden = false    }    @objc func showNext() {        currentNumber += 1        updateUI()    }아주 심플하다.지금은 문제를 가져올때 20개를 가져오지만 나중엔 저것도 바꾸게끔 해야할듯하다.실행하면?잘된다.단어의 마지막에서 다음을 눌렀을때 마지막의 단어가 그대로 보이는 상태에서 다음 단어가 시작되는 문제가 있어 코드를 하나 추가한다.private func updateUI () {        if currentNumber &gt; wordList.count - 1 {            let alert = alertController.makeAlertWithCompletion(title: \"마지막 단어입니다.\", message: \"다시 시작하시겠습니까?\\n단어는 랜덤으로 다시 만들어집니다.\") { [weak self] _ in                self?.generate()                self?.currentNumber = 0                self?.flashBodyView.wordLabel.text = self?.wordList[self!.currentNumber].words // added            }            self.present(alert, animated: true)        } else {            flashBodyView.wordLabel.text = wordList[currentNumber].words            flashBodyView.answerLabel.isHidden = true            flashBodyView.answerLabel.text = wordList[currentNumber].meaning        }    }오늘은 여기까지."
  },
  
  {
    "title": "단어장 프로젝트 (2)",
    "url": "/posts/%EB%8B%A8%EC%96%B4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-(2)/",
    "categories": "캠프, 프로젝트3",
    "tags": "",
    "date": "2024-05-14 14:00:00 +0900",
    





    
    "snippet": "2일차 시작 우선 중요기능중 한가지를 먼저 구현하려고한다그전에 Sparta에서 Daily 면접질문? 그런거에 대한 답을 먼저 하고 시작오늘의 질문  Storyboard를 이용해 UI를 구현하는 방법을 설명해주세요.StoryBoard를 사용하여 UI를 구현할때는 Commnad + Shift + L을 눌러서 UIComponent를 추가할 수 있는 창을 띄...",
    "content": "2일차 시작 우선 중요기능중 한가지를 먼저 구현하려고한다그전에 Sparta에서 Daily 면접질문? 그런거에 대한 답을 먼저 하고 시작오늘의 질문  Storyboard를 이용해 UI를 구현하는 방법을 설명해주세요.StoryBoard를 사용하여 UI를 구현할때는 Commnad + Shift + L을 눌러서 UIComponent를 추가할 수 있는 창을 띄우고 원하는 Component를 검색 후 드래그하여 추가한다.이때 StoryBoard로 추가한 Component는 말그대로 보이기만 하고 아무런 기능이 없기에, 우리가 여기에 기능을 부여하거나, 외적인 부분을 코드로 접근을 하려고 하는 경우엔 VC로 Control을 누른채로 드래그를 해서 IBOutlet / IBAction을 만들어 주어야 한다.기능 구현1. DummyData 생성단어를 추가하는 기능이 구현되기 전까지 마냥 기다릴수는 없다. DummyData를 만들어서 내가 담당한 기능을 구현해야한다.약 20개정도 만들것이다.우선 모델링을 해주고struct DummyModel {    var words: String    var meaning: String}DummyGenerator라는 파일을 하나 만들어 주었다.머리가 멍해져서 우선은 이렇게 구현했다 func makeDummy () -&gt; [DummyModel] {        var array = [DummyModel]()        let letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"                for _ in 0...19 {            let int = (1...5).randomElement()!            let secondInt = (1...5).randomElement()!            let word = String((0..&lt;int).map{ _ in letters.randomElement()! })            let meaning = String((0..&lt;secondInt).map{ _ in letters.randomElement()! })            let dummy = DummyModel(words: word, meaning: meaning)            array.append(dummy)        }        return array    }배열이 생성되는걸 확인했다.현재 문제점이라면, 배열의 개수만큼 셀이 전부 다 나오고 있다.즉 해당부분을 다시 재수정해야한다는 말이 된다.이전에 Udemy에서 공부했던 내용이 생각나서 그 글을 다시 보고있는데,애초에 UIButton 통해서 만들었다.그냥 셀같은 화면에 꽂혀서 그렇게했는데 생각이 바뀌었다.UI디자인을 재수정해야한다.컬렉션 뷰에서 UI 버튼으로 전부 교체 완료.우선 이렇게 배열에 담으면 새롭게 문제를 만드는 과정이 필요하다.모델링을 하나 더 해준다.struct VocaQuizModel {        let question: String    let answer: String    let incorrectFirst: String    let incorrectSecond: String    let incorrectThird: String    }다음과 같이 모델링을 해준다.그리고 DummyGenerator라는 클래스를 하나 만들어 준다.테스트용 더미단어와 뜻을 만드는 녀석이다.class DummyGenerator {        func makeDummy () -&gt; [DummyModel] {        var array = [DummyModel]()        let letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"                for _ in 0...19 {            let int = (1...5).randomElement()!            let secondInt = (1...5).randomElement()!            let word = String((0..&lt;int).map{ _ in letters.randomElement()! })            let meaning = String((0..&lt;secondInt).map{ _ in letters.randomElement()! })            let dummy = DummyModel(words: word, meaning: meaning)            array.append(dummy)        }        return array    }    }이렇게 그냥 알파벳으로 대충 가져오게 한다.2. 문제 배열 생성그다음 다시 게임페이지 VC로 이동.문제, 정답, 3개의 오답이 들어가야한다. 왜냐 4지선다이므로.다음과 같이 코드를 작성한다.문제를 만드는 함수이다.우선 makeDummy를 통해 더미데이터를 가져온다.private func generate() {                for _ in 0...9 {            var dummyData = dummyGenerator.makeDummy()            var numberArray = (0...dummyData.count-1).map{ $0 }.shuffled() // 숫자를 섞음                        let getFourNumberArray = numberArray.prefix(4).map { numberArray[$0]  }            let number1 = getFourNumberArray[0]            let number2 = getFourNumberArray[1]            let number3 = getFourNumberArray[2]            let number4 = getFourNumberArray[3]                                    let answerInfo = dummyData[number1]            let question = answerInfo.words            let answer = answerInfo.meaning            let first = dummyData[number2].meaning            let second = dummyData[number3].meaning            let third = dummyData[number4].meaning                        let dummy = VocaQuizModel(question: question, answer: answer, incorrectFirst: first, incorrectSecond: second, incorrectThird: third)            quizData.append(dummy)        }    }함수안에 또 선언한게 많은데요지는 이거다. 더미데이터를 가져와서현재 단어의 추가한 개수만큼 숫자를 뽑아서 shuffle그리고 거기서 4개의 숫자만 추출.첫번째 숫자는 문제와, 정답을 위해서나머지 3개의 숫자는 오답용이다.이렇게 되면 하나의 dummy에는 문제, 정답, 3개의 오답이 생긴다.이걸 10번 반복하여 총 10개의 임의의 문제가 생기게 된다.3. 버튼에 임의로 띄우기private func gameStart () {        generate(count: 5)        var answerList = [quizData[currentNumber].answer, quizData[currentNumber].incorrectFirst, quizData[currentNumber].incorrectSecond, quizData[currentNumber].incorrectThird]        answerList.shuffle()                gamePageBottomView.firstButton.setTitle(answerList[0], for: .normal)        gamePageBottomView.secondButton.setTitle(answerList[1], for: .normal)        gamePageBottomView.thirdButton.setTitle(answerList[2], for: .normal)        gamePageBottomView.forthButton.setTitle(answerList[3], for: .normal)}quizData에서 퀴즈를 제외한 나머지를 다시 배열에 담고, 그걸 셔플을 하여 분배를 한다.이렇게 되면 정답도 계속 랜덤으로 출제가 된다.4. Button Addtarget 구현이제 문제의 버튼을 눌렀을때 action이 필요하다.responder를 사용해서 현재의 title을 가져올 수 있다면 되는데현재 계속 nil이 뜨는상황이다.자기전에 누워서 검색을 해보다가 addtarget아닌 addAction이 생긴걸 발견, 이건 closure를 통해 실행이 되므로, 뭔가 가능할것으로 판단이 들었다.lazy var firstButton: UIButton = {        let button = UIButton()        button.setTitle(\"첫번째\", for: .normal)        button.backgroundColor = .lightGray        button.setTitleColor(.black, for: .normal)        button.layer.cornerRadius = 15        button.layer.borderWidth = 0.5        button.addAction(UIAction(handler: { [weak self] _ in // added            guard let title = button.titleLabel?.text else { return }            if self?.checkAnswer(title: title) == true {                button.backgroundColor = .blue            } else {                button.backgroundColor = .red            }        }), for: .touchUpInside)        return button    }()이렇게 closure를 사용하게 되면 현재 버튼의 title을 사용할 수 있게된다.그리고 값을 확인하는 함수는 다음과 같이 구현한다.func checkAnswer(title: String) -&gt; Bool {        var flag: Bool = false        guard let currentVC = currentViewController as? GamePageViewController else { return flag }        let currentQuestion = currentVC.gamePageBodyView.gameTitle.text        let gameArray = currentVC.quizData        let answer = gameArray.filter{$0.question == currentQuestion}.map{ $0.answer }.joined()                if title == answer {            flag = true        } else {            flag = false        }                return flag    }이렇게 해서 VC의 퀴즈데이터를 가져오고, 거기서 현재 문제와 일치하는 답을 가지고 온다.그것과 현재 문제의 title값이 같은지를 보고 true or false를 리턴하게 된다.구현 완료.5. 버튼클릭할때마다 문제 정답 갱신func checkAnswer(title: String) {        guard let currentVC = currentViewController as? GamePageViewController else { return }        let currentQuestion = currentVC.gamePageBodyView.gameTitle.text        let gameArray = currentVC.quizData        let answer = gameArray.filter{$0.question == currentQuestion}.map{ $0.answer }.joined()                if title == answer {            currentVC.currentNumber += 1            currentVC.score += 1            currentVC.gameStart()        } else {            currentVC.currentNumber += 1            currentVC.gameStart()        }    }lazy var firstButton: UIButton = {        let button = UIButton()        button.setTitle(\"첫번째\", for: .normal)        button.backgroundColor = .lightGray        button.setTitleColor(.black, for: .normal)        button.layer.cornerRadius = 15        button.layer.borderWidth = 0.5        button.addAction(UIAction(handler: { [weak self] _ in            guard let title = button.titleLabel?.text else { return }           self?.checkAnswer(title: title)        }), for: .touchUpInside)        return button    }()우선은 backgroundColor는 없앴다. 기능구현을 포커스를 두기위해서.아마 타이머를 통해서 깜빡거리게 하면 될듯한데, 그렇게할경우 selector를 사용해서 하나하나 노가다를 해야할것같아서 잠시 보류한다.이에따라 버튼의 addAction도 간소화.그리고 게임시작 함수는 보강을하고, 업데이트라는 함수를 새로 만들었다.func gameStart () {        if currentNumber &gt; quizData.count - 1 { // added &amp; modified            gamePageBodyView.gameTitle.text = \"게임이 종료 되었습니다.\"        } else {            update()            var answerList = [quizData[currentNumber].answer, quizData[currentNumber].incorrectFirst, quizData[currentNumber].incorrectSecond, quizData[currentNumber].incorrectThird]            answerList.shuffle()                        gamePageBottomView.firstButton.setTitle(answerList[0], for: .normal)            gamePageBottomView.secondButton.setTitle(answerList[1], for: .normal)            gamePageBottomView.thirdButton.setTitle(answerList[2], for: .normal)            gamePageBottomView.forthButton.setTitle(answerList[3], for: .normal)        }    }    func update() { //added        gamePageBodyView.gameTitle.text = quizData[currentNumber].question        gamePageHeaderView.scoreLabel.text = \"Score: \\(score) 점\"            }gameStart에는 update를 하되 outofrange를 고려하여 카운트가 마지막에 다다르고 한번 더 클릭하면 게임 종료의 글자가 뜨게 했다.완료.역시 자기전에 검색이나 아이디어는 항상 옳다.6. 색으로 정답 오답 표현하기.이대로 끝내기에 좀 찝찝해서 이것까지 구현을 해둔다.lazy var firstButton: UIButton = {        let button = UIButton()        button.setTitle(\"첫번째\", for: .normal)        button.backgroundColor = .lightGray        button.setTitleColor(.black, for: .normal)        button.layer.cornerRadius = 15        button.layer.borderWidth = 0.5        button.addAction(UIAction(handler: { _ in            guard let title = button.titleLabel?.text else { return }            if self.checkAnswer(title: title) == true { // modified                button.backgroundColor = .green                Timer.scheduledTimer(timeInterval: 0.2,target: self, selector: #selector(self.updateBackground), userInfo: nil, repeats: false)            } else {                button.backgroundColor = .red                Timer.scheduledTimer(timeInterval: 0.2,target: self, selector: #selector(self.updateBackground), userInfo: nil, repeats: false)            }                    }), for: .touchUpInside)        return button    }() func checkAnswer(title: String) -&gt; Bool { // modified        var flag = false        guard let currentVC = currentViewController as? GamePageViewController else { return flag }        let currentQuestion = currentVC.gamePageBodyView.gameTitle.text        let gameArray = currentVC.quizData        let answer = gameArray.filter{$0.question == currentQuestion}.map{ $0.answer }.joined()                if title == answer {            currentVC.currentNumber += 1            currentVC.score += 1            currentVC.gameStart()            flag = true        } else {            currentVC.currentNumber += 1            currentVC.gameStart()        }        return flag    }   우선 checkAnswer를 bool로 리턴하게 해서 정답과 오답일때의 리턴을 다르게하고addAction에서는 리턴값이 참과 거짓에 따라 색을 바꾼다.이때 타이머를 통해서 원래의 색을 돌아오게 한다.원래 의도한건 자체의 색깔 하나만 리턴하게 하고싶었으나, selector의 objc함수에서 호출한 당사자의 버튼을 특정할수가 없다.그래서 전부 다 바뀌게 했다@objc func updateBackground () {        [firstButton, secondButton, thirdButton, forthButton].forEach { button in            button.backgroundColor = .lightGray        }    }그리고 마지막 게임때 정답을 맞췄는데 스코어가 올라가지 않아서 코드를 한줄 추가해준다.게임이 끝나고 버튼이 눌려지면 안되므로 버튼을 disable로 바꾼다.func gameStart () {        if currentNumber &gt; quizData.count - 1 {            gamePageBodyView.gameTitle.text = \"게임이 종료 되었습니다.\"            gamePageHeaderView.scoreLabel.text = \"Score: \\(score) 점\" // added            [gamePageBottomView.firstButton, gamePageBottomView.secondButton, gamePageBottomView.thirdButton, gamePageBottomView.forthButton].forEach { button in // added                button.isEnabled = false            }        } else {            update()            var answerList = [quizData[currentNumber].answer, quizData[currentNumber].incorrectFirst, quizData[currentNumber].incorrectSecond, quizData[currentNumber].incorrectThird]             answerList.shuffle()                        gamePageBottomView.firstButton.setTitle(answerList[0], for: .normal)            gamePageBottomView.secondButton.setTitle(answerList[1], for: .normal)            gamePageBottomView.thirdButton.setTitle(answerList[2], for: .normal)            gamePageBottomView.forthButton.setTitle(answerList[3], for: .normal)        }    }완료큰고비를 하나 넘겼다."
  },
  
  {
    "title": "단어장 프로젝트 (1)",
    "url": "/posts/%EB%8B%A8%EC%96%B4%EC%9E%A5-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-(1)/",
    "categories": "캠프, 프로젝트3",
    "tags": "",
    "date": "2024-05-13 14:00:00 +0900",
    





    
    "snippet": "새로운 팀프로젝트가 시작디자인은 Codebase로 간다.내가 담당하는건 단어 외우기 기능이다.우선은 간단하게 Figma로 디자인을 했는데 그것을 기반으로 디자인을 하려고한다.UIDesign디자인은 이렇게 할 예정이다.사실 디자인부분은 크게 언급할게 없을듯 하다.디자인을 하다가 셀간격에서 막혔다.현재 셀간격을 줄수가 없다.아무래도 CollectionVi...",
    "content": "새로운 팀프로젝트가 시작디자인은 Codebase로 간다.내가 담당하는건 단어 외우기 기능이다.우선은 간단하게 Figma로 디자인을 했는데 그것을 기반으로 디자인을 하려고한다.UIDesign디자인은 이렇게 할 예정이다.사실 디자인부분은 크게 언급할게 없을듯 하다.디자인을 하다가 셀간격에서 막혔다.현재 셀간격을 줄수가 없다.아무래도 CollectionView로 바꿔야 할듯 하다.컬렉션뷰로 바로 전환에 들어갔다.lazy var collectionView: UICollectionView = {        let layout = UICollectionViewFlowLayout()        layout.scrollDirection = .vertical        layout.minimumLineSpacing = 10        layout.itemSize = .init(width: UIScreen.main.bounds.width, height: 50)        var view = UICollectionView(frame: .zero, collectionViewLayout: layout)        view.register(VocaQuizMainCollectionViewCell.self, forCellWithReuseIdentifier: \"VocaQuizMainCollectionViewCell\")        return view    }()갑자기 width가 기억이 나지 않았다.UIScreen.main.bounds.width 잊지 말자.lineSpacing을 통해 셀간 간격을 줄수가 있게 되었다.우선 구현은 완료이제 셀의 corner를 주면 될듯하다.왜 안보이나 고민했는데width: UIScreen.main.bounds.width 이녀석인것같다.값을 낮춰보니 적용 완료.아무래도 width가 너무 길었던것같다.게임 페이지도 디자인을 한다.갈색으로 뜨는 warning잡느라 시간이 오래걸렸다.오늘은 기본 뼈대 디자인 완료내일부터는 코드 시작."
  },
  
  {
    "title": "10주차 과제 (Fin)",
    "url": "/posts/10%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(Fin)/",
    "categories": "캠프, 10주차",
    "tags": "",
    "date": "2024-05-12 20:00:00 +0900",
    





    
    "snippet": "didSelectPublisher 사용.지금도 충분히 끝나긴 했는데, tableview의 didSelectRowAt 메서드 대신이걸 이용해보려고 한다.tableView.didSelectRowPublisher.sink { indexPath in            print(indexPath.row)        }.store(in: &amp;cance...",
    "content": "didSelectPublisher 사용.지금도 충분히 끝나긴 했는데, tableview의 didSelectRowAt 메서드 대신이걸 이용해보려고 한다.tableView.didSelectRowPublisher.sink { indexPath in            print(indexPath.row)        }.store(in: &amp;cancellables)코드를 이렇게 작성한다.lazy var tableView: UITableView = {        let tableView = UITableView()        tableView.backgroundColor = .systemBackground        tableView.register(ResultTableViewCell.self, forCellReuseIdentifier: Constants.tableViewCellIdentifier)        //tableView.allowsSelection = true // 셀을 선택할수있게 한다.        tableView.didSelectRowPublisher.sink { [weak self] indexPath in            if let mainVC = self?.childViewController as? MainViewController {                let detailVC = DetailViewController()                                // DetailVC에 전달                mainVC.searchVM.$document                    .map{ document in                        return document[indexPath.row]                    }                    .eraseToAnyPublisher()                    .receive(on: DispatchQueue.main)                    .sink { [weak detailVC] document in                        let imageURL = URL(string: document.thumbnail)                        detailVC?.titleView.titleLabel.text = document.title                        detailVC?.titleView.authorLabel.text = document.authors.joined()                        detailVC?.imageView.imageView.kf.setImage(with: imageURL)                        detailVC?.imageView.priceLabel.text = document.price.stringValue                        detailVC?.bodyView.bodyLabel.text = document.contents                        detailVC?.wishSubject.send(document)                    }.store(in: &amp;detailVC.cancellables)                                // CoreData에 등록                mainVC.searchVM.$document                    .map{  document in                        if !document.isEmpty {                            return document[indexPath.row]                        } else {                            return document[0]                        }                    }                    .eraseToAnyPublisher()                    .sink(receiveValue: { [unowned self] document in                        mainVC.recentVM.saveDataToRecent(data: document)                    }).cancel()                                detailVC.modalPresentationStyle = .fullScreen                mainVC.present(detailVC, animated: true)                            }                    }.store(in: &amp;cancellables)        tableView.rowHeight = 80        return tableView    }()단지 차이점이라면, mainVC를 uiview에서 찾아서 해야한다는것.이건 이전에 UIresponder Extension을 통해 구현을 해두었기에 사용이 가능.다만 이것 역시 delegate를 비활성해야 가능하다.collection view도 위와 같이 고쳐준다.lazy var collectionView: UICollectionView = {                let layout = UICollectionViewFlowLayout()        layout.scrollDirection = .horizontal        layout.minimumLineSpacing = 5        layout.itemSize = .init(width: 220, height: 220)                var view = UICollectionView(frame: .zero, collectionViewLayout: layout)        view.register(RecentCollectionViewCell.self, forCellWithReuseIdentifier: Constants.collectionViewCellIdentifier)                view.didSelectItemPublisher            .sink { [weak self] indexPath in                if let mainVC = self?.childViewController as? MainViewController {                    let detailVC = DetailViewController()                                        mainVC.recentVM.$recentDocument                        .map { document in                            return document[indexPath.row]                        }                        .eraseToAnyPublisher()                        .receive(on: DispatchQueue.main)                        .sink { [weak detailVC] model in                            let imageURL = URL(string: model.image ?? \"\")                            detailVC?.titleView.titleLabel.text = model.title                            detailVC?.titleView.authorLabel.text = model.author                            detailVC?.imageView.imageView.kf.setImage(with: imageURL)                            detailVC?.imageView.priceLabel.text = model.price.stringValue                            detailVC?.bodyView.bodyLabel.text = model.content                            detailVC?.wishSubject.send((mainVC.recentVM.convertModel(input: model)))                        }.store(in: &amp;mainVC.cancellables)                                        mainVC.present(detailVC, animated: true)                }            }.store(in: &amp;cancellables)                return view    }()완료.willdisplay 변경lazy var tableView: UITableView = {        let tableView = UITableView()        tableView.backgroundColor = .systemBackground        tableView.register(ResultTableViewCell.self, forCellReuseIdentifier: Constants.tableViewCellIdentifier)        tableView.rowHeight = 80        tableView.didSelectRowPublisher            .sink { [weak self] indexPath in                if let mainVC = self?.childViewController as? MainViewController {                    let detailVC = DetailViewController()                                        // DetailVC에 전달                    mainVC.searchVM.$document                        .map{ document in                            return document[indexPath.row]                        }                        .eraseToAnyPublisher()                        .receive(on: DispatchQueue.main)                        .sink { [weak detailVC] document in                            let imageURL = URL(string: document.thumbnail)                            detailVC?.titleView.titleLabel.text = document.title                            detailVC?.titleView.authorLabel.text = document.authors.joined()                            detailVC?.imageView.imageView.kf.setImage(with: imageURL)                            detailVC?.imageView.priceLabel.text = document.price.stringValue                            detailVC?.bodyView.bodyLabel.text = document.contents                            detailVC?.wishSubject.send(document)                        }.store(in: &amp;detailVC.cancellables)                                        // CoreData에 등록                    mainVC.searchVM.$document                        .map{  document in                            if !document.isEmpty {                                return document[indexPath.row]                            } else {                                return document[0]                            }                        }                        .eraseToAnyPublisher()                        .sink(receiveValue: { [unowned self] document in                            mainVC.recentVM.saveDataToRecent(data: document)                        }).cancel()                                        detailVC.modalPresentationStyle = .fullScreen                    mainVC.present(detailVC, animated: true)                }            }.store(in: &amp;cancellables)        tableView.willDisplayCellPublisher.sink { [weak self] cell, indexPath in            if let mainVC = self?.childViewController as? MainViewController {                if indexPath.section == 0 &amp;&amp; indexPath.row == mainVC.searchVM.document.count - 1 { // 마지막에 도달했을때                    Timer.scheduledTimer(timeInterval: 0.5, target: self!, selector: #selector(self?.loadData), userInfo: nil, repeats: false)                }            }        }.store(in: &amp;cancellables)        return tableView    }()        @objc func loadData() {        if let mainVC = childViewController as? MainViewController {            mainVC.searchVM.currentPage += 1            mainVC.searchVM.numberSubject.send(mainVC.searchVM.currentPage)            mainVC.searchVM.$document                .receive(on: DispatchQueue.main)                .eraseToAnyPublisher()                .sink { _ in                    mainVC.resultView.tableView.reloadData()                }.store(in: &amp;cancellables)        }    }전부 옮겨 준다.근데 생각보다 길어지는데 이게 맞나 싶다.작동은 된다.swipeaction이 가능한지는 좀 더 확인해봐야할듯.해당 코드가 너무 길어져서 튜터님께 여쭤보니해당부분을 VM에서 해보는것도 좋다고 하신다.VC의 bind 함수부분 변경[2024.05.15 수정] CoredataManager.shared.routerSubject            .receive(on: DispatchQueue.main)            .sink { router in            switch router {            case .alert(let title, let message):                let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)                alert.addAction(UIAlertAction(title: \"확인\", style: .default))                self.present(alert, animated: true)            }        }.store(in: &amp;cancellables)이부분이 observe와 다른 개념으로 존재.그 이유는 CoredataManager.shared.routerSubject 저 부분은 변화를 관측하고 alert를 띄우는게 아니기때문이다.현재 모든 기능의 예외처리가do {    try context.save()    } catch {              routerSubject.send(Router.alert(title: \"예외 발생\", message: \"\\(error.localizedDescription) 이 발생했습니다.\"))    }이렇게 되어있다.우선 열거형인 Router를 파일로 만들어준다.enum Router {    case alert(title: String, message: String)}그리고 catch 부분을 다음과 같이 수정func getWishDocumentfromCoreData () -&gt; Future&lt;[WishListModel] ,Error&gt;{                return Future&lt;[WishListModel], Error&gt; { [unowned self] complete in            do {                try context.fetch(wishRequest).publisher.flatMap { data in                    Publishers.Sequence(sequence: [data])                }                .collect()                .eraseToAnyPublisher()                .sink(receiveValue: { model in                    complete(.success(model))                })                .store(in: &amp;cancellables)            } catch {                complete(.failure(error)) // modified            }        }    }그리고 vm에서는 다음과 같이 수정을 해준다.func getDocument () {        coredataManager.getRecentDocumentfromCoreData().sink { complete in            switch complete {            case .finished:                return            case .failure(let error):                self.routerSubject.send(Router.alert(title: \"예외 발생\", message: \"\\(error.localizedDescription) 이 발생했습니다.\")) // added            }        } receiveValue: {[weak self] model in            self?.recentDocument = model        }        .store(in: &amp;cancellables)    }이젠 실패하게되면 routerSubject로 전달을 하고,VC에선 이걸 받기만 하면된다.private func bind () {                searchVM.transform(input: SearchVM.Input(searchPublisher: searchView.valuePublisher, numberPublisher: searchVM.valuePublisher))        searchVM.numberSubject.send(1)        searchVM.$document            .receive(on: DispatchQueue.main)            .sink { [weak self] _ in                self?.configureSnapshot()            }            .store(in: &amp;cancellables)                recentVM.getDocument()        recentVM.$recentDocument            .receive(on: DispatchQueue.main)            .sink { [weak self] data in                self?.collectionConfigureSnapshot()            }.store(in: &amp;cancellables)                        recentVM.routerSubject.sink { router in // modified            switch router {            case .alert(let title, let message):                 let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)                alert.addAction(UIAlertAction(title: \"확인\", style: .default))                self.present(alert, animated: true)            }        }.store(in: &amp;cancellables)            }wishVM도 동일하게 수정.그리고 return이 없는 기능들은func saveWishDocumentToCoredata (data: Document, completion: @escaping ((Result&lt;Void, Error&gt;) -&gt; Void)) {                let newItem = WishListModel(context: context)        newItem.title = data.title        newItem.author = data.authors[0]        newItem.content = data.contents        newItem.image = data.thumbnail        newItem.price = Int64(data.price)                do {            completion(.success(                try context.save()            ))        } catch {            completion(.failure(error))        }            }다음과 같이 escaping closure를 사용했다.그리고 vm에서도 이렇게 바꿔주었다.func saveDatatoWish (data: Document) {        coredataManager.saveWishDocumentToCoredata(data: data) { result in            switch result {            case .success(_):                print(\"등록 완료\")                return            case .failure(let error):                self.routerSubject.send(Router.alert(title: \"예외 발생\", message: \"\\(error.localizedDescription) 이 발생했습니다.\"))            }        }    }테스트를 해본다.만약 success로 간다면 등록완료가 콘솔에 출력이될것.콘솔에 출력이 되는걸 확인했다.나머지도 바꿔준다.func deleteSpeificData (selectedCell: NSManagedObject, completion: @escaping ((Result&lt;Void, Error&gt;) -&gt; Void)) {        do {            context.delete(selectedCell)            try context.save()            completion(.success(()))        } catch {            completion(.failure(error))        }            }여기서 success에는 void이므로 context.delete(selectedCell) 이게 success안에 들어갈 수가 없다.그래서 어차피 실행되면 저장을 하고 success에도 그냥 빈걸 리턴시켜버린다.vm에서도 그냥 이렇게 처리func deleteSelectedData(selectedCell: NSManagedObject) {        coredataManager.deleteSpeificData(selectedCell: selectedCell) { result in            switch result {            case .success(_): // 이렇게 그냥 리턴                return            case .failure(let error):                self.routerSubject.send(Router.alert(title: \"예외 발생\", message: \"\\(error.localizedDescription) 이 발생했습니다.\"))            }        }    }완료.의존성 주입[2024.05.14 수정]SearchVM 쪽에 싱글턴으로 구현했는데 의존성 주입을 하면 좋다고 하셔서 고쳐본다.NetworkManager.shared.fetchTotalRequest(queryValue: value, page: page)                    .sink { completion in                        switch completion {                        case .finished:                            return                        case .failure(_):                            return                        }                    } receiveValue: { [weak self] documents in                        documents.forEach { doc in                            self?.document.append(doc)                        }                    }.store(in: &amp;self!.cancellables)위의 코드는 싱글턴 패턴을 적용.let networkManager = NetworkManager()self?.networkManager.fetchTotalRequest(queryValue: value, page: page) // modified                    .sink { completion in                        switch completion {                        case .finished:                            return                        case .failure(_):                            return                        }                    } receiveValue: { [weak self] documents in                        documents.forEach { doc in                            self?.document.append(doc)                        }                    }.store(in: &amp;self!.cancellables)수정완료.AlertManager 구현[2024.05.14 수정]class AlertManager {        func makeAlert (title: String, message: String, style: UIAlertController.Style = .alert, completionHandler: @escaping ((UIAlertAction) -&gt; Void)) -&gt; UIAlertController {        let alert = UIAlertController(title: title, message: message, preferredStyle: style)        alert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: completionHandler))                return alert    }}다음과 같이 구현한다.그리고 vc도 수정func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {                let deleteButton = UIContextualAction(style: .normal, title: \"삭제\") { (UIContextualAction, UIView, success: @escaping (Bool) -&gt; Void)  in                        let alert = self.alertManager.makeAlert(title: \"삭제하기\", message: \"정말 삭제하실 건가요?\") { [unowned self] _ in                wishVM.deleteSelectedData(selectedCell: wishVM.wishDocument[indexPath.row])                wishVM.wishDocument.remove(at: indexPath.row)                            }            success(true)            self.present(alert,animated: false)                    }                deleteButton.backgroundColor = .red        return UISwipeActionsConfiguration(actions: [deleteButton])    }"
  },
  
  {
    "title": "Computed Property",
    "url": "/posts/Computed-Property/",
    "categories": "Udemy, Advanced",
    "tags": "",
    "date": "2024-05-12 10:13:00 +0900",
    





    
    "snippet": "Computed Property그동안 과제나, 팀프로젝트를 하면서 Computed Property를 잘 안쓴것 같다.이번에 좀 적어보려한다.let pizzaInInches: Int = 10var numberOfSlices: Int = 6이렇게 두 변수에 값이 할당 되어있다.현재는 값이 모두 수동으로 설정이 되어있다.우리는 이 변수의 값을 변경하려면 다...",
    "content": "Computed Property그동안 과제나, 팀프로젝트를 하면서 Computed Property를 잘 안쓴것 같다.이번에 좀 적어보려한다.let pizzaInInches: Int = 10var numberOfSlices: Int = 6이렇게 두 변수에 값이 할당 되어있다.현재는 값이 모두 수동으로 설정이 되어있다.우리는 이 변수의 값을 변경하려면 다음과 같이 한다.numberOfSlices = 4만약 numberOfSlices라는 변수가 위에있는 pizzaInInches의 값에 따라 변화를 주고싶다면?이때사용하는게 바료 Computed Property이다.var numberOfSlices: Int {    return pizzaInInches - 4}이런식으로 약간 함수처럼 연산을 하게 하는것인데. 이때 return을 적어서 반환하게 해준다.이때 꼭 지켜야하는게 있다.  반드시 변수는 var로 선언해야 한다는 것  반드시 변수의 타입을 명시해줘야 한다는 것이렇게 하면 변수에 대해 동적으로 사용할 수 있게 된다.Getter사실 지금 위에 있는 부분이 바로 getter 이다엄밀히 말하면 getter의 생략된 버전.var numberOfSlices: Int {    return pizzaInInches - 4}getter는 말 그대로 값을 가져오는 것이다.FM으로는 이렇게 사용한다.var numberOfSlices: Int {    get {        return pizzaInInches - 4    }}Settervar numberOfSlices: Int {    get {        return pizzaInInches - 4    }    set {        print(\"numberOfSlices now has a new value which is \\(newValue)\")    }}print(numberOfSlices) // 6numberOfSlices = 12 // numberOfSlices now has a new value which is 12값이 변화하거나 우리가 설정을 하게 되면 set이 실행이 된다.이때 newValue가 바로 우리가 새롭게 설정한 값이다.setter를 사용하는 목적은 연산이나 다양한 코드 내에서 새 값을 사용할 수 있게 하고, 속성이 업데이트되는 정확한 시간에 실행할 수 있게 해준다.이때 setter를 설정해두지않은 상태에서 값을 부여하면 error가 발생.예시피자의 인치가 있고, 사람수가 있고, 한사람당 먹을수있는 슬라이스 조각이 있다.조건을 만들어 본다.  피자의 인치는 16  사람 수는 12  한 사람당 피자조각은 4이때 피자가 몇판이 필요할까?우선 조건은 이렇게 표현이 가능하다.var pizzaInInches: Int = 16  // 1번조건var numberOfPeople: Int = 12 // 2번조건let slicesPerPerson: Int = 4 // 3번조건이걸 Computed Property를 사용해서 몇판의 피자가 필요한지 계산을 해보자.var numberOfSlices: Int {    get {        return pizzaInInches - 4    }}var numberOfPizza: Int {    get {        let numberOfPeopleFedPerPizza = numberOfSlices / slicesPerPerson        return numberOfPeople / numberOfPeopleFedPerPizza    }}우선 인치에서 4를뺀 만큼 피자조각이 나온다고 가정, 그걸 동적으로 리턴하기위해 getter를 사용했다.이렇게 하니 유동적으로 우리가 몇판의 피자가 필요한지 알 수 있다.이젠 Setter를 사용해서 피자의 개수를 알면 몇사람이 먹을 수 있는지 계산을 할 수 있다.왜냐 setter를 사용해서 값을 입력하면 set이 실행되기 때문.Setter에 있는 newValue는 우리가 임의대로 변경할수없다.var numberOfPizza: Int {    get {        let numberOfPeopleFedPerPizza = numberOfSlices / slicesPerPerson        return numberOfPeople / numberOfPeopleFedPerPizza    }    set {        let totalSlices = numberOfSlices * newValue        numberOfPeople = totalSlices / slicesPerPerson    }}이렇게 setter를 구성하고 다음과 같이 피자의 개수를 설정하면?numberOfPizza = 8print(numberOfPeople) // 24이렇게 값이 출력이된다.이렇게 값을 동적으로 받을 수도 있고, 값을 받음으로써 동적으로 어떤 변수의 값을 바꿀수도있다.Observed Property값이 변할때 코드를 트리거 할수 있는데 바로 willSet과 didSet이다.willSet은 변경 직전에 트리거 되며didSet은 변경 직후에 트리거 된다."
  },
  
  {
    "title": "10주차 과제 (11)",
    "url": "/posts/10%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(11)/",
    "categories": "캠프, 10주차",
    "tags": "",
    "date": "2024-05-12 05:00:00 +0900",
    





    
    "snippet": "Datasource에서 DiffableDatasource로 변경하면서 생긴 Exception이 있다.  검색 후 cell 클릭 시 발생하는 에러  WishList에서 셀 삭제 시 에러 발생이렇게 2개의 문제가 발생했다.1. 첫번째 문제*** Assertion failure in -[_UIDiffableDataSourceUpdate initWithIde...",
    "content": "Datasource에서 DiffableDatasource로 변경하면서 생긴 Exception이 있다.  검색 후 cell 클릭 시 발생하는 에러  WishList에서 셀 삭제 시 에러 발생이렇게 2개의 문제가 발생했다.1. 첫번째 문제*** Assertion failure in -[_UIDiffableDataSourceUpdate initWithIdentifiers:sectionIdentifiers:action:desinationIdentifier:relativePosition:destinationIsSection:], _UIDiffableDataSourceHelpers.m:504그냥 셀을 클릭하면 이런 에러문구가 나온다.혹시나해서 Coredata에 저장이되면서의 문제일까 싶어 주석을 달았지만 에러는 그대로 발생하는걸로 확인이 되었다.확인해본결과 viewDiddisappear에서 발생하는것으로 보인다.bind함수에서 문제 발생으로 추정 override func viewDidDisappear(_ animated: Bool) {        super.viewDidDisappear(animated)        recentVM.getDocument()        recentVM.$recentDocument            .receive(on: DispatchQueue.main)            .sink { [weak self] data in                self?.collectionConfigureSnapshot()            }.store(in: &amp;cancellables)        checkEmpty()    }이렇게 바꿔주니 해결이 되었다.계속 에러가 프린트될때 collectionview쪽이 아닌 검색한 결과에대해 나온것을 보고 혹시나 해서 컬렉션뷰만 리로드 하게끔 했는데, 문제가 해결 되었다.아무래도, 같은 정보가 그대로 있는상태 에서 그대로 또 적용을 하려다보니 duplicate가 발생한것으로 생각이 된다.viewDidDisappear를 내가 VC LifeCycle을 고려해서 작성했던 이유는 collectioView를 화면에 가려졌을때 미리 갱신을 시키기 위함이었는데,diffable 적용하기 전까진 bind를 해도 상관이 없었으나, diffable의 경우 Hashable 이 가장 중요했는데, 내가 그걸 망각하고 있었다.귀찮아서 bind로 퉁치려고 했다가 예외가 발생했던 것.해결 완료.그러면 searchVM.document에 대해서 removeAll()을 해서 다시 초기화 하고 bind를 트리거하면 되지 않을까? 해서 해봤는데 override func viewDidDisappear(_ animated: Bool) {        super.viewDidDisappear(animated)        searchVM.document.removeAll()        bind()        checkEmpty()    }바로 여기서func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        let detailVC = DetailViewController()                // DetailVC에 전달        searchVM.$document            .map{ document in                return document[indexPath.row] // out of range error 발생            }            .eraseToAnyPublisher()            .receive(on: DispatchQueue.main)            .sink { [weak detailVC] document in                let imageURL = URL(string: document.thumbnail)                detailVC?.titleView.titleLabel.text = document.title                detailVC?.titleView.authorLabel.text = document.authors.joined()                detailVC?.imageView.imageView.kf.setImage(with: imageURL)                detailVC?.imageView.priceLabel.text = document.price.stringValue                detailVC?.bodyView.bodyLabel.text = document.contents                detailVC?.wishSubject.send(document)            }.store(in: &amp;detailVC.cancellables)                // CoreData에 등록        searchVM.$document            .map{  document in                if !document.isEmpty {                    return document[indexPath.row]                } else {                    return document[0]                }            }            .eraseToAnyPublisher()            .sink(receiveValue: { [unowned self] document in                recentVM.saveDataToRecent(data: document)            }).cancel()                detailVC.modalPresentationStyle = .fullScreen        present(detailVC, animated: true)    }out of range가 발생한다. 아마 화면이 사라지면서 올라오다보니. 미리 데이터를 다 지워버리게 되는꼴 그래서 document가 empty 상태가 되어버려서 문제가 발생한것이다.이것저것 시도해봤지만 결론은  그냥 의도했던대로 CollectionView 갱신만 하자오히려 viewwillappear에 해두니 collectionview에 셀이 추가되는것도 볼 수 있어서 더 좋은듯하다.viewwillappear에 적용 한 사진.2. 두번째 문제*** Assertion failure in -[UITableView deleteRowsAtIndexPaths:withRowAnimation:], UITableView.m:8630*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'UITableView must be updated via the UITableViewDiffableDataSource APIs when acting as the UITableView's dataSource: please do not call mutation APIs directly on UITableView.이건 전체삭제에서는 문제가 없지만 부분삭제에서 발생한다.Stackoverflow를 읽다가직접적인 해답은 없었으나 힌트를 얻어서 한번 해보려고한다.그리고 Youtube 를 보는데 snapshot을 VC에 적용해서 하길래 역시 이부분이 문제인 것 같다고 확신이 들었다.우선 snapshot을 VC로 빼주기로 결정var snapshot: NSDiffableDataSourceSnapshot&lt;DiffableSectionModel, WishListModel&gt;?그리고 snapshot 함수도 변경해준다.기존에는 지역변수였다면, vc전체에서 쓰는 전역변수로 바꿨다는게 가장 큰 의미. func configureSnapshot() {                snapshot = NSDiffableDataSourceSnapshot&lt;DiffableSectionModel, WishListModel&gt;()        snapshot?.deleteAllItems()        snapshot?.appendSections([.wish])        snapshot?.appendItems(wishVM.wishDocument)        wishTableDatasource?.apply(snapshot!,animatingDifferences: true)            }뭔가 직접적으로 tableview에 접근하는건 tableView.deleteRows(at: [indexPath], with: .fade) 이거였는데,지워버렸다.처음에는 어딘지 고민을 했는데, 문제를 해결하고 보니 저부분에서 문제가 발생했을것으로 짐작하긴 했는데, 역시나였다.func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {                let deleteButton = UIContextualAction(style: .normal, title: \"삭제\") { (UIContextualAction, UIView, success: @escaping (Bool) -&gt; Void)  in            let alert = UIAlertController(title: \"삭제하기\", message: \"정말 삭제하실 건가요?\", preferredStyle: .alert)                        let ok = UIAlertAction(title: \"OK\", style: .destructive, handler: { [unowned self] _ in                                wishVM.deleteSelectedData(selectedCell: wishVM.wishDocument[indexPath.row])                wishVM.wishDocument.remove(at: indexPath.row)                            })                        let cancel = UIAlertAction(title: \"취소\", style: .default)                        alert.addAction(ok)            alert.addAction(cancel)            self.present(alert,animated: false)                        success(true)        }        deleteButton.backgroundColor = .red        return UISwipeActionsConfiguration(actions: [deleteButton])    }확인 완료snapshot을 적용하지 않는 이유는 combine을 사용해서wishVM.$wishDocument            .receive(on: DispatchQueue.main)            .sink { [unowned self] _ in                configureSnapshot()            }.store(in: &amp;cancellables)여기서 값이 변하면 바로 snapshot을 적용하기 떄문. 이게바로 Combine의 편리함. 쓰면 쓸수록 매력적인 녀석이다.생각해보니 굳이 안뺐어도 크게 지장은 없을것 같다. 하지만 나중에 또 적용할지 모르는 일이 생길 수 있기에 빼둔다.이번에 이렇게 적용해보면서 디퍼블에대해 여러 에러도 접해보고 많이 배우게 되었다.역시 뭐든 직접 부딪히면서 에러를 수정해야 많이 배우고 느낀다. 디퍼블 이번에 처음 사용해봤지만, 아주 기본적인건 이제 할 수 있을것같다.아마 다듬어도 layout warning 정도만 해결하면 될 듯하다. (디자인 쓰레기)Combine + DiffableDatasource 조합은 진짜 제대로 이해하고 사용하면 엄청 편할것같다.진짜 끝."
  },
  
  {
    "title": "10주차 과제 (10)",
    "url": "/posts/10%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(10)/",
    "categories": "캠프, 10주차",
    "tags": "",
    "date": "2024-05-11 04:00:00 +0900",
    





    
    "snippet": "예외처리도 끝났고, 남은건 내가 원래 과제에서 제출하고자 했던DataSource → DiffableDataSource의 변환과,튜터님의 피드백인 VM에서 Network 와, Coredata 함수의 분리를 하고 이번 과제의 종점을 찍으려 한다.DataSource → DiffableDataSource로 변환.1. 기존방식.BeforeUI가 Controll...",
    "content": "예외처리도 끝났고, 남은건 내가 원래 과제에서 제출하고자 했던DataSource → DiffableDataSource의 변환과,튜터님의 피드백인 VM에서 Network 와, Coredata 함수의 분리를 하고 이번 과제의 종점을 찍으려 한다.DataSource → DiffableDataSource로 변환.1. 기존방식.BeforeUI가 Controller에 각 Section에 Item들은 몇개인지, contents를 렌더링 할때 Cell 제공하라고 요청Controller가 Response에 관한 웹서비스 요청을 가지고 있는 경우(API)엔 조금 까다로워진다.웹 서비스 응답을 통해 data의 변경사항을 알린다면, 변경사항을 반영 하기 위해 UI를 업데이트 하여 변경사항이 반영 될 수 있다.UI 업데이트가 실패할 경우 이런 에러를 마주하게 된다.이때 reloadData()를 호출하여 문제를 해결 할지도 모른다.출처기존에는 위와 같이 했는데 WWDC에서 DiffableDatasource를 소개했다.2. DiffableDataSource 란?이건 TableViewDataSource  테이블 뷰들은 데이터의 표시만 관리하며 데이터 자체는 관리하지 않습니다. 데이터를 관리하기 위해 UITableViewDataSource 프로토콜을 구현하는 개체인 데이터 소스 개체를 테이블에 제공합니다. 데이터 소스 개체는 테이블의 데이터 관련 요청에 응답합니다. 또한 테이블의 데이터를 직접 관리하거나 앱의 다른 부분과 조정하여 데이터를 관리합니다. 데이터 소스 개체의 다른 책임은 다음과 같습니다.          테이블에서 섹션과 행의 수를 보고합니다.      각 행의 각 행의 셀을 제공합니다.      섹션 헤더 및 발명의 제목을 제공합니다.      테이블 인덱스를 구성합니다.      기본 데이터에 대한 변경 사항이 필요한 사용자 또는 테이블 시작 업데이트에 응답합니다.      (From, Docs)이건 TableViewDiffableDataSource  DiffableDatasource 개체는 테이블 뷰 개체와 함께 작동하는 특수한 유형의 데이터 소스입니다. 테이블 뷰의 데이터와 UI에 대한 업데이트를 관리하는 데 필요한 동작을 간단하고 효율적인 방법으로 제공합니다. 또한 UITableViewDataSource 프로토콜을 준수하며 프로토콜의 모든 방법에 대한 구현을 제공합니다.          테이블 보기에서 다양한 데이터 소스를 연결합니다.      테이블 뷰의 셀 제공자를 구성합니다.      데이터 현재 상태를 생성합니다.      UI에서 데이터를 표시합니다.      (From, Docs)가장 큰 차이점이라면, 전자는 protocol 후자는 class 이다.정의는 둘다 거의 같다고 볼 수 있다.위에 Docs에서 가져온 내용이 있으니 한번 보는것도 좋다.컬렉션뷰도 상동하므로 첨부는 하지 않는다.그리고 우리는 DiffableDataSource에서 Hashable에 주목해야한다.나중에 저걸 채택해야하기 때문.3. 왜 DiffableDatasource를 쓰는가?Hashable은 우리가 알고있는 그 Hash가 맞다.  Hash가 뭔데요? 난 처음듣는데?      원본 데이터를 특정한 규칙에따라 처리하여 숫자로 만든 것Hash값이 같다는건 두 데이터가 같다는것.          Hashable을 사용함으로써 데이터의 서로 다름을 보장한다는것.      뭐 이정도로 생각하면 되겠다.다시 돌아와서 DiffableDatasource는 새로운 Snapshot 데이터 유형을 추가하여 UI 상태 관리를 크게 단순화 한다.snapshot은 고유한 section 및 item 식별자를 사용하여 전체 UI 상태를 캡슐화한다.Bold로 한게 포인트.따라서 TableView, CollectionView를 업데이트 할때 먼저 새로운 Snapshot을 생성하고 현재 UI 상태로 채우고 Datasource에 적용한다.장점  애니메이션          데이터를 추가, 업데이트, 삭제할 때마다 자동으로 데이터 변경 애니메이션이 적용된다.        자동 데이터 동기화          UI 데이터의 동기화 부분 대신 앱의 동적인 데이터와 내용에 집중할 수 있다.-Centralized Truth를 사용하기 때문에 UI와 데이터소스간의 Truth가 맞지 않아 크래시가 발생하는 일이 없음        코드감소          전반적으로 더 적은 코드를 작성할 수 있다.      출처1. Section SnapshotsCollectionView와 TableView의 단일 섹션에 대한 데이터를 캡슐화 한다.  data source를 섹션크기의 덩어리로 구성 할 수 있게 한다.  outline-style UI 렌더링(iOS14 전체에서 볼 수 있는 공통적인 시각적인 디자인)을 지원하는 데 필요한 계층적 데이터 모델링을 허용하기 위해출처4. 적용 (WWDC)WWDC의 pdf를 그대로 가져와서 옮겼는데, 이제 이걸 실제로 적용을 해보려 한다.5. 실제 적용.우선 우리가 적용한 모델에 Hashable 프로토콜을 채택해준다.struct BookModel: Codable, Hashable { // modified        var meta: Meta    var documents: [Document]    }struct Meta: Codable, Hashable { // modified        var isEnd: Bool    var pageableCount: Int    var totalCount: Int        enum CodingKeys: String, CodingKey {        case isEnd = \"is_end\"        case pageableCount = \"pageable_count\"        case totalCount = \"total_count\"    }        init(isEnd: Bool, pageableCount: Int, totalCount: Int) {        self.isEnd = isEnd        self.pageableCount = pageableCount        self.totalCount = totalCount    }}struct Document: Codable,Hashable { // modified        var authors: [String]    var contents: String    var price: Int    var title: String    var thumbnail: String            init(authors: [String], contents: String, price: Int, title: String, thumbnail: String) {        self.authors = authors        self.contents = contents        self.price = price        self.title = title        self.thumbnail = thumbnail    }}DiffableModel이라는 파일을 하나 만들어주고그 다음 섹션과, 섹션의 아이템을 열거형으로 만들어 준다.enum DiffableSectionModel {        case recent    case search    }enum DiffableSectionItemModel: Hashable {        case recent(RecentModel)    case search(Document)    }이때 ItemModel에는, 이전에 TableView와 CollectionView에서 사용하던 item Type을 가져왔다.이때 ItemModel에는 반드시 Hashable을 해준다.이제 DiffableDatasource 를 만든다.Diffable Extension을 하나 만들어 주었다.거기에 적용을 해볼 예정.Datasource를 만들때 UIkit을 import를 할수밖에 없는 상황이 발생하므로 VM에서 변경한다.이제 DiffableDatasource 객체를 하나 만들어준다.extension에서는 불가하므로 이녀석만 mainVC로 이동    var tableDatasource: UITableViewDiffableDataSource&lt;DiffableSectionModel, DiffableSectionItemModel&gt;?    var collectinDatasource: UICollectionViewDiffableDataSource&lt;DiffableSectionModel, DiffableSectionItemModel&gt;?미리 둘다 만들어 준다옵셔널인 이유는 ? 를 안하면 Initializing이 필요하기 때문extension으로 가서 함수를 하나 만들어 준다.1. TableView func configureDiffableDataSource () {        tableDatasource = UITableViewDiffableDataSource(tableView: resultView.tableView, cellProvider: { tableView, indexPath, itemIdentifier in                        switch itemIdentifier {            case .search(let document):                let cell = tableView.dequeueReusableCell(withIdentifier: Constants.tableViewCellIdentifier, for: indexPath) as! ResultTableViewCell                                cell.configure(model: document)                                return cell            case .recent(_): // recent는 CollectionView에 사용할것                return UITableViewCell()            }                    })    }item에 search, recent 두개를 한번에 해두어서recent일 때는 그냥 UItableviewcell을 리턴하게 했다.그다음엔 snapshot을 적용할 함수를 만들어 준다.함수를 만들다가 내방식과 튜터님의 방식이 적용이 안된다는걸 파악했고, 다시 고친다.우선 sectionitemModel을 지웠다.그리고var tableDatasource: UITableViewDiffableDataSource&lt;DiffableSectionModel, Document&gt;? datasource도 item을 그냥 document로 반환시킨다.그리고 diffable에 적용할 함수를 구현한다.func configureDiffableDataSource () {        tableDatasource = UITableViewDiffableDataSource(tableView: resultView.tableView, cellProvider: { tableView, indexPath, itemIdentifier in                        let cell = tableView.dequeueReusableCell(withIdentifier: Constants.tableViewCellIdentifier, for: indexPath) as! ResultTableViewCell                        cell.configure(model: itemIdentifier)            cell.selectionStyle = .none                        return cell        })    }        func configureSnapshot() {        var snapshot = NSDiffableDataSourceSnapshot&lt;DiffableSectionModel, Document&gt;()        snapshot.appendSections([.search])        snapshot.appendItems(searchVM.document)                tableDatasource?.apply(snapshot)    }그 후, VC의 bind에서searchVM.$document            .receive(on: DispatchQueue.main)            .sink { [weak self] _ in                self?.configureSnapshot() // modified            }            .store(in: &amp;cancellables)reloaddata에서 이렇게 스냅샷 적용으로 바꿔준다.작동 완료.이제 tableview의 cellForRowAt, numberOfRowsInSection은 필요가 없어졌다.하지만 무한스크롤은 필요해서 그부분만 제외하고 나머지는 살려둔다.wishlistVC도 상동2. CollectionView이것도 역시 var collectionDatasource: UICollectionViewDiffableDataSource&lt;DiffableSectionModel, RecentModel&gt;? 이렇게 실제 사용한 모델로만 해준다.func configureDiffableDataSource () {        tableDatasource = UITableViewDiffableDataSource(tableView: resultView.tableView, cellProvider: { tableView, indexPath, itemIdentifier in                        let cell = tableView.dequeueReusableCell(withIdentifier: Constants.tableViewCellIdentifier, for: indexPath) as! ResultTableViewCell                        cell.configure(model: itemIdentifier)            cell.selectionStyle = .none                        return cell        })                // added        collectionDatasource = UICollectionViewDiffableDataSource(collectionView: recentView.collectionView, cellProvider: { collectionView, indexPath, itemIdentifier in                        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: Constants.collectionViewCellIdentifier, for: indexPath) as! RecentCollectionViewCell                        cell.configure(model: itemIdentifier)                        return cell        })            }    func collectionConfigureSnapshot () {        var collectionSnapshot = NSDiffableDataSourceSnapshot&lt;DiffableSectionModel, RecentModel&gt;()        collectionSnapshot.appendSections([.recent])        collectionSnapshot.appendItems(recentVM.recentDocument)                collectionDatasource?.apply(collectionSnapshot, animatingDifferences: true)    }Fatal: supplied item identifiers are not unique. Duplicate identifiers문제가 발생이건 나중에 다시 해결해야할듯 하다.피드백 보완Service Group 생성DiffableDatasource를 검색하다 보니 VM에는 UIKit도 import할 이유가 없다고 한다.생각해보니, 그게 맞는말이다 UIKit는 View와 관련이 있는데, 이걸 할 필요가 없었다. 근데 지금 RecentVM이나 WishVM의 경우 Coredata를 쓰기위해 Context를 만들다보니 자연스럽게 import UIKit를 하고있다.그래서 이부분도 고려하셔서 피드백을 주신게 아닌가? 라는 생각이 든다.특히 network의 경우는 처음에 나누었다가 나중에, VM으로 넣어버렸는데, 아직도 공부가 더 필요하다는 생각이 든다.1. NetworkManager 이관class NetworkManager {        static let shared = NetworkManager()        private init () {}        let searchVM = SearchVM()        func fetchTotalRequest(queryValue: String, page: Int, cancellables: Set&lt;AnyCancellable&gt;) {                let urlString = \"https://dapi.kakao.com/v3/search/book?target=title\"        let headers = [\"Authorization\" : \"KakaoAK \\(Secret.apikey)\"]                var urlComponent = URLComponents(string: urlString)        urlComponent?.queryItems?.append(URLQueryItem(name: \"query\", value: queryValue))        urlComponent?.queryItems?.append(URLQueryItem(name: \"page\", value: page.stringValue))                guard let url = urlComponent?.url else {            return        }                var request = URLRequest(url: url)        request.allHTTPHeaderFields = headers        request.httpMethod = \"GET\"                let session = URLSession(configuration: .default)        session.dataTaskPublisher(for: request)            .map(\\.data)            .decode(type: BookModel.self, decoder: JSONDecoder())            .eraseToAnyPublisher()            .map { model in                if model.meta.isEnd == false {                    return model.documents                } else {                    return []                }            }            .replaceError(with: [])            .assign(to: \\.document, on: searchVM)            .store(in: &amp;searchVM.cancellables)    }    }다음과 같이 만들어 준다.하지만 문제는 검색결과 값이 넘어가지 않는 상태이다.YouTube를 보고 내용을 좀 수정해야할 필요성을 느낀다.문득 이부분을 Completion Handler를 통해서 전달을 해볼까 했는데, 위와같은 방법이 있어서 적용을 해보려한다.안그래도 Future 써보고 싶었는데 잘되었다.class NetworkManager {        static let shared = NetworkManager()        private init () {}        let searchVM = SearchVM()        private var cancellables = Set&lt;AnyCancellable&gt;()        func fetchTotalRequest(queryValue: String, page: Int) -&gt; Future&lt;[Document], Error&gt; {                return Future&lt;[Document], Error&gt; { [weak self] complete in                        let urlString = \"https://dapi.kakao.com/v3/search/book?target=title\"            let headers = [\"Authorization\" : \"KakaoAK \\(Secret.apikey)\"]                        var urlComponent = URLComponents(string: urlString)            urlComponent?.queryItems?.append(URLQueryItem(name: \"query\", value: queryValue))            urlComponent?.queryItems?.append(URLQueryItem(name: \"page\", value: page.stringValue))                        guard let url = urlComponent?.url else {                return            }                        var request = URLRequest(url: url)            request.allHTTPHeaderFields = headers            request.httpMethod = \"GET\"                        let session = URLSession(configuration: .default)            session.dataTaskPublisher(for: request)                .map(\\.data)                .decode(type: BookModel.self, decoder: JSONDecoder())                .eraseToAnyPublisher()                .map { model in                    if model.meta.isEnd == false {                        return model.documents                    } else {                        return []                    }                }                .replaceError(with: [])                .sink(receiveValue: { document in                    complete(.success(document))                })                .store(in: &amp;self!.cancellables)        }    }    }우선 다음과 같이 코드를 수정하고.VM에서도 다음과 같이 수정했다. func transform(input: Input) {                Publishers.CombineLatest(input.searchPublisher, input.numberPublisher)            .map { [unowned self] (value, page) in                if value.isEmpty {                    currentPage = 1                    document = []                }                return (value, currentPage)            }            .eraseToAnyPublisher()            .print()            .sink { [weak self] (value, page) in                guard !value.isEmpty else { return } // value가 빈 문자열인 경우 fetchTotalRequest 호출하지 않음                NetworkManager.shared.fetchTotalRequest(queryValue: value, page: page).sink { completion in                    switch completion {                    case .finished:                        print(\"success\")                    case .failure(let error):                        print(\"erorr is \\(error)\")                    }                } receiveValue: { document in                    self!.document = document                }.store(in: &amp;self!.cancellables)            }            .store(in: &amp;cancellables)            }우선 출력은 되나, document에 바꿔치기가 되므로 해당 부분을 append하게 해줘야한다. func transform(input: Input) {                Publishers.CombineLatest(input.searchPublisher, input.numberPublisher)            .map { [unowned self] (value, page) in                if value.isEmpty {                    currentPage = 1                    document = []                }                return (value, currentPage)            }            .eraseToAnyPublisher()            .print()            .sink { [weak self] (value, page) in                guard !value.isEmpty else { return } // value가 빈 문자열인 경우 fetchTotalRequest 호출하지 않음                NetworkManager.shared.fetchTotalRequest(queryValue: value, page: page).sink { completion in                    switch completion {                    case .finished:                        print(\"success\")                    case .failure(let error):                        print(\"erorr is \\(error)\")                    }                } receiveValue: { document in                    document.forEach { doc in                        self!.document.append(doc)                    }                }.store(in: &amp;self!.cancellables)            }            .store(in: &amp;cancellables)            }receiveValue에 다음과 같이 결과를 하나씩 append하게 바꿔주었다.작동 확인 완료.2. CoreDataManager 이관이건 Recent / Wish VM 에 해당하는 부분을 옮기면 될 것 같다.이것도 역시 그냥 singleton pattern을 사용해서 할 예정func saveWishDocumentToCoredata (data: Document) {                let newItem = WishListModel(context: context)        newItem.title = data.title        newItem.author = data.authors[0]        newItem.content = data.contents        newItem.image = data.thumbnail        newItem.price = Int64(data.price)                do {            try context.save()            print(\"담기 완료\")        } catch {            routerSubject.send(Router.alert(title: \"예외 발생\", message: \"\\(error.localizedDescription) 이 발생했습니다.\"))        }            }        func getWishDocumentfromCoreData () -&gt; Future&lt;[WishListModel] ,Error&gt;{                return Future&lt;[WishListModel], Error&gt; { [unowned self] complete in            do {                try context.fetch(wishRequest).publisher.flatMap { data in                    Publishers.Sequence(sequence: [data])                }                .collect()                .eraseToAnyPublisher()                .sink(receiveValue: { model in                    complete(.success(model))                })                .store(in: &amp;cancellables)            } catch {                routerSubject.send(Router.alert(title: \"예외 발생\", message: \"\\(error.localizedDescription) 이 발생했습니다.\"))            }        }    }        func getSpecificData (title: String) -&gt; Future&lt;[WishListModel] ,Error&gt; {                return Future&lt;[WishListModel], Error&gt; { [unowned self] complete in                        let predicateRequest: NSFetchRequest&lt;WishListModel&gt; = WishListModel.fetchRequest()            let predicate = NSPredicate(format: \"title == %@\", title)            predicateRequest.predicate = predicate                        do {                try context.fetch(predicateRequest).publisher.flatMap { data in                    Publishers.Sequence(sequence: [data])                }                .collect()                .eraseToAnyPublisher()                .sink(receiveValue: { model in                    complete(.success(model))                })                .store(in: &amp;cancellables)            } catch {                routerSubject.send(Router.alert(title: \"예외 발생\", message: \"\\(error.localizedDescription) 이 발생했습니다.\"))            }        }    }        func deleteAllData () {        let fetchRequest: NSFetchRequest&lt;NSFetchRequestResult&gt; = NSFetchRequest(entityName: \"WishListModel\")        let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)                do {            try context.execute(deleteRequest)            try context.save()        } catch {            routerSubject.send(Router.alert(title: \"예외 발생\", message: \"\\(error.localizedDescription) 이 발생했습니다.\"))        }    }        func deleteSpeificData (selectedCell: NSManagedObject) {        do {            try context.delete(selectedCell)            try context.save()        } catch {            routerSubject.send(Router.alert(title: \"예외 발생\", message: \"\\(error.localizedDescription) 이 발생했습니다.\"))        }            }다음과 같이 코드를 모두 이관시켜준다특징이라면 network와 같이 배열에 저장해야하는경우엔 Future를 사용하여 리턴시켰다.VM도 다음과 같이 정리func checkDuplicate (title: String) -&gt; Bool {                var flag = false        getSpecificDocument(title: title)                if wishDocument.isEmpty {            flag = false        } else {            flag = true        }        return flag    }        func getWholeDocument () {        CoredataManager.shared.getWishDocumentfromCoreData().sink { complete in            switch complete {            case .finished:                return            case .failure(let error):                print(error)            }        } receiveValue: { [weak self] model in            self?.wishDocument = model        }        .store(in: &amp;cancellables)    }        func getSpecificDocument (title: String) {        CoredataManager.shared.getSpecificData(title: title).sink { complete in            switch complete {            case .finished:                return            case .failure(let error):                print(error)            }        } receiveValue: { [weak self] model in            self?.wishDocument = model        }        .store(in: &amp;cancellables)    }        func deleteSelectedData(selectedCell: NSManagedObject) {        CoredataManager.shared.deleteSpeificData(selectedCell: selectedCell)    }        func removeAllData () {        CoredataManager.shared.deleteAllData()    }생각해보니 coredata에 저장하는것도 vm에서 해도 될것같아서 이렇게 적는다.func saveDataToRecent (data: Document) {        CoredataManager.shared.saveRecentDocumentToCoredata(data: data)    }paramter가 꼬리에 꼬리를 물어도 어차피 같은 타입이므로 괜찮기 때문.완료.예외처리만 하면 될듯하다."
  },
  
  {
    "title": "10주차 과제 (9)",
    "url": "/posts/10%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(9)/",
    "categories": "캠프, 10주차",
    "tags": "",
    "date": "2024-05-10 04:00:00 +0900",
    





    
    "snippet": "우선 과제제출은 끝났다.하지만 Combine이라는 새로운 녀석을 쓰다보니 예외처리하는 부분이 상당히 빡세다.우선 시급한 예외처리      서치바에 내용이 지워졌을때 빈배열 만들기 &amp; page init        현재 최근 본 리스트에 coredata에 이상하게 입력이 되는 문제  1. 첫번째 문제Publishers.CombineLatest(i...",
    "content": "우선 과제제출은 끝났다.하지만 Combine이라는 새로운 녀석을 쓰다보니 예외처리하는 부분이 상당히 빡세다.우선 시급한 예외처리      서치바에 내용이 지워졌을때 빈배열 만들기 &amp; page init        현재 최근 본 리스트에 coredata에 이상하게 입력이 되는 문제  1. 첫번째 문제Publishers.CombineLatest(input.searchPublisher, input.numberPublisher)            .map { [unowned self] (value, page) in                if value.isEmpty {                    currentPage = 1                    document = []                }                return (value, currentPage)            }            .eraseToAnyPublisher()            .sink { [weak self] (value, page) in                guard !value.isEmpty else { return } // value가 빈 문자열인 경우 fetchTotalRequest 호출하지 않음                self?.fetchTotalRequest(queryValue: value, page: page)            }            .store(in: &amp;cancellables)value가 empty일때 즉 값이 없을때 currentPage를 1로, 그리고 document도 빈배열로 초기화를 해준다.작동은 하지만 다시 겁색을 하게 되면 무한스크롤을 해서 페이지가 4까지 증가했다면, 다시 글을 지우고 검색을 다시하면api호출을 4번 하는걸로 확인이 된다.즉 searchVM에서 손을 봐야한다는 말이된다.func fetchTotalRequest(queryValue: String, page: Int) {        let urlString = \"https://dapi.kakao.com/v3/search/book?target=title\"        let headers = [\"Authorization\" : \"KakaoAK \\(Secret.apikey)\"]                var urlComponent = URLComponents(string: urlString)        urlComponent?.queryItems?.append(URLQueryItem(name: \"query\", value: queryValue))        urlComponent?.queryItems?.append(URLQueryItem(name: \"page\", value: page.stringValue))                guard let url = urlComponent?.url else {            return        }                var request = URLRequest(url: url)        request.allHTTPHeaderFields = headers        request.httpMethod = \"GET\"                let session = URLSession(configuration: .default)        session.dataTaskPublisher(for: request)            .map(\\.data)            .decode(type: BookModel.self, decoder: JSONDecoder())            .eraseToAnyPublisher()            .replaceError(with: totalDocumnet)            .sink(receiveValue: { [weak self] model in                if model.meta.isEnd == false {                    print(\"document Count is \\(model.documents.count)\")                    self?.document.append(contentsOf: model.documents)                } else {                    return                }            })            .store(in: &amp;cancellables)    }document Count is 10document Count is 10document Count is 10document Count is 10이렇게 같은걸 4번 출력을 한다. 그래서 같은내용의 셀이 반복이 되었던것.내선에서는 안될것같아 튜터님을 찾아갔다.@objc func loadData() {        searchVM.currentPage += 1        searchVM.numberSubject.send(searchVM.currentPage)        //searchVM.transform(input: SearchVM.Input(searchPublisher: searchView.valuePublisher, numberPublisher: searchVM.valuePublisher))        searchVM.$document            .receive(on: DispatchQueue.main)            .eraseToAnyPublisher()            .sink { [weak self] _ in                self?.resultView.tableView.reloadData()            }.store(in: &amp;cancellables)        print(searchVM.currentPage)    }바로 주석친 저부분이 문제가 되었던것.어차피 subject에서 데이터를 전달하기에 그냥 1회 구독에서 계속 값만 갱신을 하면 되었는데 아무 생각없이 함수처럼 한번 더 사용을 해야되나 라는 생각으로 transform을 그대로 사용함으로써 무한스크롤 할때마다 구독도 계속 증가를 했기에, 초기화를 하고 검색을 다시하면 증가한 구독횟수만큼 호출하는것이다.receive value: ((\"해리\", 1))receive value: ((\"해리\", 2))receive value: ((\"해리\", 3))receive value: ((\"해리\", 4))receive value: ((\"해리\", 5))receive value: ((\"해리\", 6))receive value: ((\"해리\", 7))receive value: ((\"해리\", 8))receive value: ((\"해리\", 9))receive value: ((\"해리\", 10))호출이 잘된다.즉 loadData에서는 page값만 보내주면 되었다. 함수처럼 생각해서 다시 재호출을 해버리면 재호출 한만큼 Publisher와 Subscriber 사이의 구독 횟수도 같이 증가한다는걸 잊지말자.2. 두번째 문제이건 어느순간 갑자기 발생하기 시작했다.정확하게 어느부분이 문제인지 파악이 필요한 상태.1. 내방식func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        let detailVC = DetailViewController()                // DetailVC에 전달        searchVM.$document            .map{ document in                return document[indexPath.row]            }            .eraseToAnyPublisher()            .receive(on: DispatchQueue.main)            .sink { document in                let imageURL = URL(string: document.thumbnail)                detailVC.titleView.titleLabel.text = document.title                detailVC.titleView.authorLabel.text = document.authors.joined()                detailVC.imageView.imageView.kf.setImage(with: imageURL)                detailVC.imageView.priceLabel.text = document.price.stringValue                detailVC.bodyView.bodyLabel.text = document.contents                detailVC.wishSubject.send(document)            }.store(in: &amp;cancellables)                // CoreData에 등록        searchVM.$document            .map{  document in                if !document.isEmpty {                    return document[indexPath.row]                } else {                    return document[0]                }            }            .eraseToAnyPublisher()            .sink(receiveValue: { [weak self] document in                self?.recentVM.saveDocumentToCoredata(data: document)            })            .cancel() // modified                detailVC.modalPresentationStyle = .fullScreen        present(detailVC, animated: true)    }뭔가 계속해서 메모리에 남은건가? 라는 생각이 들었고, 이전에도 컬렉션뷰에서 로딩했을때 담기 버튼 할때 구독을 끊음으로써 해결이 되었던걸 생각하고여기도 끊어버렸다.문제해결 그래도 덕분에 alert 작동하는걸 확인했다.2. 튜터님 방식튜터님께 이부분을 말씀드리니 DetailVC에서 강한 순환참조가 발생한다고 하신다.func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        let detailVC = DetailViewController()                // DetailVC에 전달        searchVM.$document            .map{ document in                return document[indexPath.row]            }            .eraseToAnyPublisher()            .receive(on: DispatchQueue.main)            .sink { [weak detailVC] document in // modified                let imageURL = URL(string: document.thumbnail)                detailVC?.titleView.titleLabel.text = document.title                detailVC?.titleView.authorLabel.text = document.authors.joined()                detailVC?.imageView.imageView.kf.setImage(with: imageURL)                detailVC?.imageView.priceLabel.text = document.price.stringValue                detailVC?.bodyView.bodyLabel.text = document.contents                detailVC?.wishSubject.send(document)            }.store(in: &amp;detailVC.cancellables) // modified                // CoreData에 등록        searchVM.$document            .map{  document in                if !document.isEmpty {                    return document[indexPath.row]                } else {                    return document[0]                }            }            .eraseToAnyPublisher()            .sink(receiveValue: { [weak self] document in                self?.recentVM.saveDocumentToCoredata(data: document)            }).cancel() // modified                detailVC.modalPresentationStyle = .fullScreen        present(detailVC, animated: true)    }위에 코드도 적어놨지만, 현재 detailVC에 강한 순환 참조를 피하기 위해[weak detailVC]를 하셨다. 항상 클로저 안에서 [weak self]만 쓰다보니 저렇개 쓸 생각을 하질 못했다.첫번째 사진 셀을 클릭하고 DetailVC로 들어간 상태 무난해보인다.두번째 사진 닫기 버튼을 클릭 한상태detailVC가 남아있다.weak으로 약한 참조를 한 상태의 사진 DetailVC로 들어간 상태닫기 버튼을 클릭 한상태DetailVC가 보이지 않는다.그리고 detailvc의 cancellables에 저장을 해둔다.그러면 deinit 하면서 해당 내용은 사라진다.이렇게 강한 순환 참조로 인해 발생하던 문제를 해결하게되었다.그리고 wishSubject가 CurrentValueSubject 값을 들고있기에 최근 본 데이터에 같이 누적되는것으로 판단하여 cancel로 바로 끊어버렸다.후기이번에는 처음에 시작할때부터 Combine + MVVM 을 사용하는데 의미를 두고 시작했다.MVVM은 솔직히 크게 문제가 없었는데, Combine 사용에 있어서 많은 부족함을 느꼈다.사실 부족함 느끼는게 정상이긴 하다 4~5일 정도 공부하고 바로 적용을 해봤는데, 하면서 느낀건, Data 전달이 뭔가 명확하다는 것이고,Publisher - Subscriber 와의 관계가 얼마나 중요한지 새삼 느끼게 된다.이번에 하는 예외 처리 역시 이미 Subsciption이 형성이 되어있기에 Data만 계속해서 send를 해주어도 API통신이 되면서 해당 값을 가져오게 되는데, 기존의 방식에 익숙해져서 일까 함수를 호출하면서 생긴 문제였다.Combine 사용하면서 과제나 팀프로젝트에서도 단 한번도 사용하지 않은 GPT를 두번이나 사용했다. 그래도 그걸가지고 왜 이렇게 사용을 했는지 내 나름대로 자료를 검색하면서 그 의도를 생각해보니 괜찮았다.물론 GPT 사용은 이번 Combine에서 끝.그래도 이번 프로젝트에서 나름 재미있는 경험을 한것같아 만족한다.다행히도 튜터님에게 과제를 진행하면서 Insight가 필요할때마다 여쭤 봤는데, Combine 이정도로 사용한것만으로도 대단하다고 하시긴 해서, 4~5일간의 공부와 프로젝트기간 약 6일정도를 합치면 10~11일 동안 내가 무모한 시도를 한건 아니었다는 생각이 든다.원래 이렇게 개인프로젝트하면서 후기를 잘 쓰지 않는데, Combine 공부할거 앞으로 산더미겠지만, 그래도 약간의 자신감은 갖고 간다."
  },
  
  {
    "title": "10주차 과제 (8)",
    "url": "/posts/10%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(8)/",
    "categories": "캠프, 10주차",
    "tags": "",
    "date": "2024-05-09 04:00:00 +0900",
    





    
    "snippet": "이제 무한스크롤만하면 할건 다했다, 그리고 VM에서 alert 구현하면 끝날것같다.무한스크롤 기능 추가.보아하니 meta가 관리하는걸로 보인다.BookModel에 meta를 추가struct BookModel: Codable {        var meta: Meta // added    var documents: [Document]    }struct...",
    "content": "이제 무한스크롤만하면 할건 다했다, 그리고 VM에서 alert 구현하면 끝날것같다.무한스크롤 기능 추가.보아하니 meta가 관리하는걸로 보인다.BookModel에 meta를 추가struct BookModel: Codable {        var meta: Meta // added    var documents: [Document]    }struct Meta: Codable { //added        var isEnd: Bool    var pageCount: Int    var totalCount: Int        enum Codingkeys: String, CodingKey {                case isEnd = \"is_end\"        case pageCount = \"pageable_count\"        case totalCount = \"total_count\"    }}이게 추가되자마자 검색이 먹지 않는다 왜냐하면위에는 바꿨지만 meta가 배열안에 있는걸로 봐버렸다.[Meta] -&gt; Meta로 수정한다그리고 테스트를하는데 nil값이 확인되는것같다.struct Meta: Codable {        var isEnd: Bool? // modified    var pageCount: Int? // modified    var totalCount: Int? // modified        enum Codingkeys: String, CodingKey {                case isEnd = \"is_end\"        case pageCount = \"pageable_count\"        case totalCount = \"total_count\"    }}이렇게 수정을 해주니 보인다.도대체 쿼리가 어디있나 했더니위에 있었다.그냥 예시를 보고 하다보니 이렇게 된 결과였다.이젠 url도 docs의 예시가 아닌 진짜 다른걸로 사용할때가 되었다.하지만 여전히 meta의 값이 nil이 나온다.주소가 잘못된걸까?아직도 나타나지 않는 meta 너란녀석.문제를 찾았다 codingKey의 문제였다.분명히 틀린게 없는데 왜 잘못되었는지 모르겠다.무튼 다시적으니 제대로 인식이 된다.willDisplay를 쓰려고하니 검색결과가 나오자마자 함수가 호출이 되버린다. 그말은 즉 검색 하자마자 스크롤이 된다는뜻.우선 새롭게 함수를 짜서 테스트를 해보려한다.그에따라 Publisher또 한 새롭게 준비.Model 그자체라 Initializeing이 필요하여 이렇게 부여를 해둔 상태.func fetchTotalRequest(queryValue: String) {        let urlString = \"https://dapi.kakao.com/v3/search/book?target=title\"        let headers = [\"Authorization\" : \"KakaoAK \\(Secret.apikey)\"]                var urlComponent = URLComponents(string: urlString)        urlComponent?.queryItems?.append(URLQueryItem(name: \"query\", value: queryValue))        urlComponent?.queryItems?.append(URLQueryItem(name: \"page\", value: \"1\"))                guard let url = urlComponent?.url else {            return        }                var request = URLRequest(url: url)        request.allHTTPHeaderFields = headers        request.httpMethod = \"GET\"        request.setValue(\"application/json; charset=utf-8\", forHTTPHeaderField: \"Content-Type\")        let session = URLSession(configuration: .default)                session.dataTaskPublisher(for: request)            .map(\\.data)            .decode(type: BookModel.self, decoder: JSONDecoder())            .replaceError(with: totalDocumnet) // modified → 에러가 발생할땐 아무것도 없는 init 상태의 값 리턴.             .assign(to: \\.totalDocumnet, on: self)            .store(in: &amp;cancellables)    }이렇게 세팅을 하고 willDisplay를 구현한다.func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {        if indexPath.section == 0 &amp;&amp; indexPath.row == searchVM.document.count - 1 { // 마지막에 도달했을때                    }            }여기서 함수를 그대로 호출을 하면 될듯하다.구성func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {        if indexPath.section == 0 &amp;&amp; indexPath.row == searchVM.document.count - 1 { // 마지막에 도달했을때            page += 1            searchVM.transform(input: SearchVM.Input(searchPublisher: searchView.valuePublisher),page: page)            searchVM.$document                .receive(on: DispatchQueue.main)                .sink { [weak self] _ in                    self?.resultView.tableView.reloadData()                }.store(in: &amp;cancellables)        }            }page를 받아야 하므로 vm도 수정한다.func fetchTotalRequest(queryValue: String, page: Int) { // modified        let urlString = \"https://dapi.kakao.com/v3/search/book?target=title\"        let headers = [\"Authorization\" : \"KakaoAK \\(Secret.apikey)\"]                var urlComponent = URLComponents(string: urlString)        urlComponent?.queryItems?.append(URLQueryItem(name: \"query\", value: queryValue))        urlComponent?.queryItems?.append(URLQueryItem(name: \"page\", value: page.stringValue)) // added                guard let url = urlComponent?.url else {            return        }                var request = URLRequest(url: url)        request.allHTTPHeaderFields = headers        request.httpMethod = \"GET\"                let session = URLSession(configuration: .default)        session.dataTaskPublisher(for: request)            .map(\\.data)            .decode(type: BookModel.self, decoder: JSONDecoder())            .map { model in                if model.meta.isEnd == false {                    return model.documents                } else {                    return []                }            }            .replaceError(with: []) // 에러가 발생할땐 아무것도 없는 init 상태의 값 리턴.            .assign(to: \\.document, on: self)            .store(in: &amp;cancellables)    }실행하니 엄청나게 빠르게 로딩이 되어버린다. 뭔가 로직 개선이 필요하다.현재 의심이 되는건 searchVM.document.count - 1 여기파트이다.역시나 문제였다. searchVM의 count가 갱신이 되지않고 10개인채로 유지가 되었기에 무한 로딩이 발생.아무래도 vm에서 fetchRequest부분을 수정할 때가 된듯 하다.func fetchTotalRequest(queryValue: String, page: Int) {        let urlString = \"https://dapi.kakao.com/v3/search/book?target=title\"        let headers = [\"Authorization\" : \"KakaoAK \\(Secret.apikey)\"]                var urlComponent = URLComponents(string: urlString)        urlComponent?.queryItems?.append(URLQueryItem(name: \"query\", value: queryValue))        urlComponent?.queryItems?.append(URLQueryItem(name: \"page\", value: page.stringValue))                guard let url = urlComponent?.url else {            return        }                var request = URLRequest(url: url)        request.allHTTPHeaderFields = headers        request.httpMethod = \"GET\"                let session = URLSession(configuration: .default)        session.dataTaskPublisher(for: request)            .map(\\.data)            .decode(type: BookModel.self, decoder: JSONDecoder())            .map { model in                if model.meta.isEnd == false {                    return model.documents                } else {                    return []                }            }            .replaceError(with: []) // 에러가 발생할땐 아무것도 없는 init 상태의 값 리턴.            .assign(to: \\.document, on: self)            .store(in: &amp;cancellables)    }그리고 page를 증가시켜도 현재 출력되는 값이 같다.즉 page에 대한 query가 안먹는건지 의심이 든다.페이지에 대한 쿼리는 작동하는걸로 확인했다.그러면 willDisplay에서 호출한게 잘못된건지에 대한 생각도 드는데 그건 아닌것 같다 숫자는 제대로 들어가지만func transform(input: Input, page: Int) {        input.searchPublisher            .print()            .sink { [weak self] value in            //self?.fetchRequest(queryValue: value)                self?.fetchTotalRequest(queryValue: value, page: page)                print(page)        }.store(in: &amp;cancellables)    }여기에 파라미터로 넣은 page가 문제이다. 즉 적용이 되지않는다는것,struct Input { // searchBar input을 받기위함.        let searchPublisher: AnyPublisher&lt;String, Never&gt;        let numberPublisher: AnyPublisher&lt;Int, Never&gt; // added    }publisher를 추가하면 될것 같아서 하나 만들어주고 publisher들을 하나로 통합해준다.func transform(input: Input) {                Publishers.CombineLatest(input.searchPublisher, input.numberPublisher).flatMap { value, page in            let tuple = (value, page)            return Just(tuple)        }        .eraseToAnyPublisher()        .sink { [weak self] data in            self?.fetchTotalRequest(queryValue: data.0, page: data.1)        }.store(in: &amp;cancellables)            }그리고 vc로 가서let numberSubject = PassthroughSubject&lt;Int, Never&gt;()        var valuePublisher: AnyPublisher&lt;Int, Never&gt; {        return numberSubject.eraseToAnyPublisher()    }하나 만들어주고,viewdidload에 numberSubject.send(currentPage)플 하나 넣어준다.input의 순서의 영향일까 저 트리거를 뒤에다가 해야 실행이 된다.이제는 갱신이 된다.지금은 vm에서 assign을 통해 계속 바꿔치기가 되고있다.이제 이부분을 수정해야한다.func fetchTotalRequest(queryValue: String, page: Int) {        let urlString = \"https://dapi.kakao.com/v3/search/book?target=title\"        let headers = [\"Authorization\" : \"KakaoAK \\(Secret.apikey)\"]                var urlComponent = URLComponents(string: urlString)        urlComponent?.queryItems?.append(URLQueryItem(name: \"query\", value: queryValue))        urlComponent?.queryItems?.append(URLQueryItem(name: \"page\", value: page.stringValue))                guard let url = urlComponent?.url else {            return        }                var request = URLRequest(url: url)        request.allHTTPHeaderFields = headers        request.httpMethod = \"GET\"                let session = URLSession(configuration: .default)        session.dataTaskPublisher(for: request)            .map(\\.data)            .decode(type: BookModel.self, decoder: JSONDecoder())            .map { model in                if model.meta.isEnd == false {                    return model.documents                } else {                   return []                }            }            .replaceError(with: [])            .eraseToAnyPublisher()            .sink(receiveValue: { model in                self.document.append(contentsOf: model)            })            .store(in: &amp;cancellables)    }아무리 생각을 해봐도 이것방법 말곤 떠오르지도 않고 찾아봐도 원하는게 잘 안보여서 이렇게 바꾼다.우선 완료.타이머를 통한 스크롤시 과한 로딩 방지func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {        if indexPath.section == 0 &amp;&amp; indexPath.row == searchVM.document.count - 1 { // 마지막에 도달했을때            Timer.scheduledTimer(timeInterval: 0.5, target: self, selector: #selector(loadData), userInfo: nil, repeats: false)                   }            }        @objc func loadData() {        searchVM.currentPage += 1        searchVM.numberSubject.send(searchVM.currentPage)        searchVM.transform(input: SearchVM.Input(searchPublisher: searchView.valuePublisher, numberPublisher: searchVM.valuePublisher))        searchVM.$document            .receive(on: DispatchQueue.main)            .eraseToAnyPublisher()            .sink { [weak self] _ in                self?.resultView.tableView.reloadData()            }.store(in: &amp;cancellables)        print(searchVM.currentPage)    }타이머를 사용했다.이렇게 0.5초마다 한번씩 실행하게 했다.페이지가 과하게 올라가지 않음을 확인했다.VM에서 alert 구현현재 Coredata의 catch부분이 전부 비어있는데 이부분을 해결해보려 한다. 처음에 잘안되어서 잠시 보류했는데 어느정도 기능이 구현이 되고 튜터님께 여쭤보니 publisher를 통해 mainvc로 bool같은 데이터를 전달해서 mainvc가 그걸 받으면 처리해보는게 어떠냐고 하셨다.이걸 다른 튜터님께도 여쭤봤는데 직접 사용 예시를 보여주셨기에 그부분을 구현해본다.이글을 작성하는 시점에선 위의 방법을 쓰고 싶지만 머리가 돌아가지않아 이후에 다시 수정을 해보는걸로enum Router {        case alert(title: String, message: String, completion: (() -&gt; Void)?)    }우선 alert에 대한 case하나 만들어주고, 안에는 UIAlertController 구성에 필요한 내용을 담아준다.그리고 전달할 subject도 하나 만들어 준다.var routerSubject = PassthroughSubject&lt;Router, Never&gt;()그리고 do - catch 블럭에 다 넣어준다.do {    try context.save()    } catch {        routerSubject.send(Router.alert(title: \"예외 발생\", message: \"\\(error.localizedDescription) 이 발생했습니다.\"))    }그리고 vc에가서 호출wishVM.routerSubject.sink { alert in            switch alert {            case .alert(let title, let message) :                let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)                alert.addAction(UIAlertAction(title: \"확인\", style: .default))                self.present(alert, animated: true)            }        }.store(in: &amp;cancellables)실제로 예외가 발생하고있다 어느순간 갑자기 발생하기 시작.Wish 중복 걸러내기.func getSpecificData (title: String) {        let predicateRequest: NSFetchRequest&lt;WishListModel&gt; = WishListModel.fetchRequest()        let predicate = NSPredicate(format: \"title == %@\", title)        predicateRequest.predicate = predicate                do {            try context.fetch(predicateRequest).publisher.flatMap { data in                Publishers.Sequence(sequence: [data])            }            .collect()            .assign(to: \\.wishDocument, on: self)            .store(in: &amp;cancellables)        } catch {                    }    }    func checkDuplicate (title: String) -&gt; Bool {                var flag = false        getSpecificData(title: title)                if wishDocument.isEmpty {            flag = false        } else {            flag = true        }        return flag    }다음과 같이 중복확인을 위한 함수를 만들어 준다.getSpecificData는 predicate를 통해 parameter로 받는 title과 Coredata에 있는 데이터의 title이 일치하는값을 가져온다.그때 없으면 false, 있으면 true를 주어서 bool을 리턴한다.처음에는 그냥 다시 다가져와서 filter를 통해서 카운트가 0이면 중복이 아니니 false를 리턴하게 했는데,하나의 중복확인을 위해 데이터를 다 가져오는게 뭔가 별로라고 판단해서 아래의 코드는 폐기func checkDuplicate (title: String) -&gt; Bool {                var flag = false        getDocumentfromCoreData()                if wishDocument.filter({ $0.title == title }).count == 0 {            flag = false        } else {            flag = true        }        return flag    }이건 버튼 수정 내용private lazy var getButton: UIButton = {        let button = UIButton ()        button.backgroundColor = .green        button.setImage(UIImage(systemName: \"bookmark.square\"), for: .normal)        button.tapPublisher.sink { [unowned self] _ in            let vc = childViewController as? DetailViewController            vc?.wishSubject.sink(receiveValue: { [unowned self] document in                if vc?.wishVM.checkDuplicate(title: document.title) == false {                    vc?.wishVM.saveDocumentToCoredata(data: document)                    let alert = UIAlertController(title: \"담기 완료\", message: \"책이 담겼습니다.\", preferredStyle: .alert)                    alert.addAction(UIAlertAction(title: \"확인\", style: .default, handler: { [unowned self] _ in                        goToMainVC()                    }))                    vc?.present(alert, animated: true)                } else {                    let alert = UIAlertController(title: \"중복 확인\", message: \"이미 리스트에 등록된 책입니다.\", preferredStyle: .alert)                    alert.addAction(UIAlertAction(title: \"확인\", style: .default))                    vc?.present(alert, animated: true)                }                            }).cancel()        }.store(in: &amp;cancellables)        return button    }()완료최근 본 책에서 담기를 누르고 wish를 탭하면 계속 담기가 활성되는 문제 수정lazy var getButton: UIButton = {        let button = UIButton ()        button.backgroundColor = .green        button.setImage(UIImage(systemName: \"bookmark.square\"), for: .normal)        button.tapPublisher.sink { [unowned self] _ in            let vc = childViewController as? DetailViewController            vc?.wishSubject.sink(receiveValue: { [unowned self] document in                vc?.wishVM.saveDocumentToCoredata(data: document)                let alert = UIAlertController(title: \"담기 완료\", message: \"책이 담겼습니다.\", preferredStyle: .alert)                alert.addAction(UIAlertAction(title: \"확인\", style: .destructive, handler: { [unowned self] _ in                    goToMainVC()                }))                vc?.present(alert, animated: true)            }).cancel() // modified        }.store(in: &amp;cancellables)        return button    }()이상하게 컬렉션뷰에서 상세페이지를 띄우고 담은뒤, 위시버튼을 누르면 계속 똑같은게 담기길래메모리에 해당 데이터가 계속 남는다고 판단하여 store(in: &amp;cancellables) 대신 cancel()을 사용하여 subscription을 해제했다.그리고 실행하여 테스트를하니 아무런 문제가 없음을 확인했다."
  },
  
  {
    "title": "10주차 과제 (7)",
    "url": "/posts/10%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(7)/",
    "categories": "캠프, 10주차",
    "tags": "",
    "date": "2024-05-08 04:00:00 +0900",
    





    
    "snippet": "현재 디자인도 개판이고, 전체 삭제, 추가버튼도 이제 실행이 되게 해야한다.전체삭제는 말 그대로 그냥 다 지우면 되고, 추가버튼은 화면전환을 한뒤 서치바 활성이다.그리고 SwipeAction을 통해 부분 삭제를 가능하게 해야한다.여기까지 구현을 하고서, level5 무한스크롤 까지 끝내고 과제의 요구사항 및 선택적으로 있는 추가기능도 확인을 하면 될 ...",
    "content": "현재 디자인도 개판이고, 전체 삭제, 추가버튼도 이제 실행이 되게 해야한다.전체삭제는 말 그대로 그냥 다 지우면 되고, 추가버튼은 화면전환을 한뒤 서치바 활성이다.그리고 SwipeAction을 통해 부분 삭제를 가능하게 해야한다.여기까지 구현을 하고서, level5 무한스크롤 까지 끝내고 과제의 요구사항 및 선택적으로 있는 추가기능도 확인을 하면 될 것 같다디자인 수정현재 Layout 대충 잡고 기능부터 구현해서 개판이 난 상태이다, 이부분을 먼저 수습하고 가는게 좋을 듯 하다.우선 버튼의 title이 보이지 않던 문제 수정private let deleteAllButton: UIButton = {        let button = UIButton()        button.setTitle(\"전체 삭제\", for: .normal) // added        button.setTitleColor(.red, for: .normal) // added        button.backgroundColor = .white        return button    }()아주 멍청하게 titleLabel이라고 생각하고 해버렸던게 문제였다.private lazy var hStackView: UIStackView = {        let stackView = UIStackView(arrangedSubviews: [        deleteAllButton,        title,        addButton        ])        stackView.axis = .horizontal         stackView.distribution = .fillEqually // added        return stackView    }()그리고 StackView역시 아무 생각없이 영어 그대로의 의미를 생각해서 alignment property에 접근했던게 문제,구색은 완료.버튼 작동 확인을 위해 tabpublisher 사용하여 print를 사용해 콘솔에 출력을 해본다. button.tapPublisher.sink { [unowned self] _ in            print(\"삭제\")        }.store(in: &amp;cancellables)확인완료. 버튼으로써의 구색은 갖춰졌다.추가 기능 구현해당기능을 클릭하면 화면전환을 하고 searchbar를 활성시키면 된다.단순히 tabbarvc의 인스턴스를 호출하고 인덱스를 선택하게 하려 했는데 되지 않아서 검색을 했고 스택오버플로우에 나와 같은 고민을 했던 글이 있어 가져왔다. 적용해보니 바로된다.if let tabBarController = self.window!.rootViewController as? UITabBarController {                    tabBarController.selectedIndex = 0                }포인트는 rootvc가 tabbar라면 화면을 전환시키라는것이다. 또 하나 배워간다.이제 서치바를 활성 시키면 된다.어제 스크럼 중 팀원 한분이 이부분에 대해 문제를 겪고 계셨는데 왜 그런지 이해가 간다.if tabBarController.selectedViewController == MainViewController() {                    print (\"yes\")                } else {                    print(tabBarController.selectedViewController)                }우선 이렇게 출력을 했는데 현재 선택된 vc가 NavigationController라고 되어있어서SceneDelegate의 firstVC = UINavigationController(rootViewController: rootVC) 이부분을 삭제한다.이후 코드를 다음과 같이 적어주었다.if let tabBarController = self.window!.rootViewController as? UITabBarController {                tabBarController.selectedIndex = 0                let current = tabBarController.selectedViewController as? MainViewController                current?.searchView.searchBar.becomeFirstResponder()            }성공.키보드 다운 구현서치바를 탭하면 내가 입력하기 전까지 키보드가 내려가지 않는다.이부분을 좀 수졍해얄 필요를 느껴 수정해보기로 한다.bar.showsCancelButton = truebar.cancelButtonClickedPublisher.sink { [unowned self] _ in            endEditing(true)}.store(in: &amp;cancellables)단순하게캔슬버튼 활성화로 퉁.cell swipeaction을 통한 삭제전체삭제를 구현 하기 전, 먼저 swipe action으로 삭제를 하려고한다.func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {            }이녀석은 leading, trailing을 이용하여 원하는 방향에서 swipe가 가능하게 설정이 가능.이부분은 자세한 부분이 기억나지 않아 이전에 작성했던 코드를 참고해서 쓴다.작성했던 코드를 보니 우선적으로 해야할건 contextualAction을 등록하는것이다.func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {                let deleteButton = UIContextualAction(style: .normal, title: \"삭제\") { (UIContextualAction, UIView, success: @escaping (Bool) -&gt; Void)  in            let alert = UIAlertController(title: \"삭제하기\", message: \"정말 삭제하실 건가요?\", preferredStyle: .alert)                        let ok = UIAlertAction(title: \"OK\", style: .destructive, handler: { [unowned self] _ in                                wishVM.deleteSpeificData(selectedCell: wishVM.wishDocument[indexPath.row])                tableView.beginUpdates()                wishVM.wishDocument.remove(at: indexPath.row)                tableView.deleteRows(at: [indexPath], with: .fade)                tableView.endUpdates()            })                        let cancel = UIAlertAction(title: \"취소\", style: .default)                        alert.addAction(ok)            alert.addAction(cancel)            self.present(alert,animated: false)                        success(true)        }        deleteButton.backgroundColor = .red        return UISwipeActionsConfiguration(actions: [deleteButton])    }Vm작성func deleteSpeificData (selectedCell: NSManagedObject) {        do {            try context.delete(selectedCell)            try context.save()        } catch {                    }            }swipeaction 하도 안썼더니 가물가물 했다.이번에 좀 기억을 다시 해두는 편이 좋을듯하다.DB에서도 삭제가 확인 되었다.전체삭제VM에서 모델링을 하고 바로 호출을 하면 될것같다.생각해보니 한번도 전체 다 지운적이 없는듯 하여 검색을 해보고 그걸 토대로 구현한다.context에서 delete부분만 조금 다듬으면 될것같긴하다.스택오버플로우에 나와 같은 고민이 있었고 채택율이 가장 높은 글이 있어 그걸 적용해 보려한다.func deletaAllData () {        let fetchRequest: NSFetchRequest&lt;NSFetchRequestResult&gt; = NSFetchRequest(entityName: \"WishListModel\")        let deleteRequest = NSBatchDeleteRequest(fetchRequest: fetchRequest)                do {            try context.execute(deleteRequest)            try context.save()        } catch {                    }    }let request: NSFetchRequest&lt;WishListModel&gt; = WishListModel.fetchRequest() 내가 한 리퀘스트와 거의 같지만 타입이 달랐다.둘은같은걸 출력할지 몰라도 타입은 다르다.삭제는 확인 완료.지금은 버튼에 삭제만 해두었기에,코드를 좀더 보강한다. private lazy var deleteAllButton: UIButton = {        let button = UIButton()        button.setTitle(\"전체 삭제\", for: .normal)        button.setTitleColor(.red, for: .normal)        button.backgroundColor = .white        button.tapPublisher.sink { [unowned self] _ in            if let vc = childViewController as? WishlistViewController {                let alert = UIAlertController(title: \"삭제하시겠습니까?\", message: \"삭제하시면 복원은 불가능합니다.\", preferredStyle: .alert)                alert.addAction(UIAlertAction(title: \"확인\", style: .destructive, handler: { [unowned self] _ in                    vc.wishVM.deleteAllData()                    vc.wishVM.getDocumentfromCoreData()                    vc.bodyTableView.tableView.reloadData()                }))                alert.addAction(UIAlertAction(title: \"취소\", style: .default))                vc.present(alert, animated: true) }        }.store(in: &amp;cancellables)        return button    }()삭제 후 다시 request를 하여 값을 가져오고, 이때는 어차피 빈배열, 그걸 reloadData를 통해 다시 갱신.최근 본책 10개만 나오게 표출.무한스크롤 기능 구현 전에 과제를 읽어보니 최근꺼 10개만 나오게 하라고 되어있다. 그부분을 수정해 보려한다.func getDocumentfromCoreData () {                do {            try context.fetch(request).publisher                .flatMap { data in                    Publishers.Sequence(sequence: [data])}                .collect()                .map { data in                    let sorted = data.sorted { first, second in                        first.date &gt; second.date                    }                    return sorted                }                .assign(to: \\.recentDocument, on: self)                .store(in: &amp;cancellables)        } catch {                    }    }아무래도 이부분에 대해서 배열의 값을 10개까지만 하게 하면 될듯하다.현재 저기에 있는 로직은 sequence를 통해 하나씩 [data]값을 하나의 publisher로 만들고, 그걸 flatmap을 통해 하나의 publisher로 바꾼뒤, collect를 통해 하나의 배열의 형태로 전환이 되고, 그걸 다시 최신순으로 배열을 하게하는 구조이다.즉 최신순으로 배열한 값에서 다시 10개만 가져오게 하는 과정을 거치면 문제가 없을 듯 하다.do {            try context.fetch(request).publisher                .flatMap { data in                    Publishers.Sequence(sequence: [data])}                .collect()                .eraseToAnyPublisher()                .map { data in                    var sorted = data.sorted { first, second in                        first.date &gt; second.date                    }                    if sorted.count &gt; 10 {                        sorted = sorted.prefix(10)                    }                    return sorted                }                .assign(to: \\.recentDocument, on: self)                .store(in: &amp;cancellables)        } catch {                    }이렇게 했더니Cannot assign value of type 'Array&lt;Publishers.Sequence&lt;[Publishers.Sequence&lt;[RecentModel], Never&gt;.Output], Never&gt;.Output&gt;.SubSequence' (aka 'ArraySlice&lt;RecentModel&gt;') to type '[Publishers.Sequence&lt;[Publishers.Sequence&lt;[RecentModel], Never&gt;.Output], Never&gt;.Output]' (aka 'Array&lt;RecentModel&gt;')아주 장황한 에러가 난다. 에러 포인트가 뭔지 확인해보자우선 type mismatch는 확실하다.Array&lt;Publishers.Sequence&lt;[Publishers.Sequence&lt;[RecentModel], Never&gt;.Output], Never&gt;.Output&gt;.SubSequence 이게 현재 타입Publishers.Sequence&lt;[Publishers.Sequence&lt;[RecentModel], Never&gt;.Output], Never&gt;.Output]prefix를 사용한 타입.저 둘의 차이는 바로 앞에 Array가 있고 없고이다.즉 sorted.prefix(10) 에다가 Array(sorted.prefix(10))이라고 Array로 감싸주면 해결이 될 문제로 보인다.확인완료이젠 10개만 나온다."
  },
  
  {
    "title": "10주차 과제 (6)",
    "url": "/posts/10%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(6)/",
    "categories": "캠프, 10주차",
    "tags": "",
    "date": "2024-05-07 04:00:00 +0900",
    





    
    "snippet": "CollectionView에 적용.이제 데이터 넘어오는것도 확인이 되었고 구현을 해보도록 하자.우선 extension으로 관리할거니 파일을 하나 만들어주고.extension MainViewController: UICollectionViewDelegate, UICollectionViewDataSource {        func collectionSet...",
    "content": "CollectionView에 적용.이제 데이터 넘어오는것도 확인이 되었고 구현을 해보도록 하자.우선 extension으로 관리할거니 파일을 하나 만들어주고.extension MainViewController: UICollectionViewDelegate, UICollectionViewDataSource {        func collectionSetUp () {        recentView.collectionView.dataSource = self        recentView.collectionView.delegate = self    }        func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int {        wishVM.wishDocument.count    }        func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {                guard let cell = recentView.collectionView.dequeueReusableCell(withReuseIdentifier: Constants.collectionViewCellIdentifier, for: indexPath) as? RecentCollectionViewCell else { return UICollectionViewCell() }                wishVM.$wishDocument            .receive(on: DispatchQueue.main)            .map { document -&gt; RecentModel in                return document[indexPath.row]            }            .sink { model in                let image = URL(string: model.image!)                cell.imageView.kf.setImage(with: image)                cell.titleLabel.text = model.title            }.store(in: &amp;cancellables)                return cell    }}우선은 이렇게 적어준다.실행하니 보이지 않는다.역시나 Cell에도 initializer가 없었다.override init(frame: CGRect) { // added        super.init(frame: .zero)        layout()    }실행현재는 개판.지금은 검색을해서 보고나면 바로 업데이트가 되지 않는다.이부분은 추후 수정을 하도록 하고 먼저 컬렉션 뷰 부터 다시 손을 봐야겠다.우선 layout을 수정하여 cell의 크기를 지정한다.let collectionView: UICollectionView = {        let layout = UICollectionViewFlowLayout()        layout.scrollDirection = .horizontal        layout.minimumLineSpacing = 5 // added        layout.itemSize = .init(width: 220, height: 220) // added        var view = UICollectionView(frame: .zero, collectionViewLayout: layout)        view.register(RecentCollectionViewCell.self, forCellWithReuseIdentifier: Constants.collectionViewCellIdentifier)        return view    }()그리고 컬렉션 뷰 역시 클릭하면 해당 정보를 가지고 올 수 있게 해주었다.func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {                let detailVC = DetailViewController()                wishVM.$wishDocument            .map { document in                return document[indexPath.row]            }.sink { model in                let imageURL = URL(string: model.image!)                detailVC.titleView.titleLabel.text = model.title                detailVC.titleView.authorLabel.text = model.author                detailVC.imageView.imageView.kf.setImage(with: imageURL)                detailVC.imageView.priceLabel.text = model.price.stringValue                detailVC.bodyView.bodyLabel.text = model.content            }.store(in: &amp;cancellables)                present(detailVC, animated: true)    }굿.예외 해결현재 검색하고 검색결과에 있는 리스트중 하나를 터치해서 들어가면 상세페이지가 나오는데,누르고 다시 화면 복귀를 할때 업데이트가 되어야하는데 그렇지 않다.vc의 생명주기를 고려한 메서드를 실행해도 되지 않았다.즉 화면이 아예 가려지지 않아서, view가 사라지지 않아서 그런듯하다.화면전환 방식을 바꿔야한다.func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        let detailVC = DetailViewController()                // DetailVC에 전달        searchVM.$document            .map{ document in                return document[indexPath.row]            }            .sink { document in                let imageURL = URL(string: document.thumbnail)                detailVC.titleView.titleLabel.text = document.title                detailVC.titleView.authorLabel.text = document.authors[0]                detailVC.imageView.imageView.kf.setImage(with: imageURL)                detailVC.imageView.priceLabel.text = document.price.stringValue                detailVC.bodyView.bodyLabel.text = document.contents            }.store(in: &amp;cancellables)                // CoreData에 등록        searchVM.$document            .map{  document in            return document[indexPath.row]            }.sink(receiveValue: { [weak self] document in                self?.wishVM.saveDocumentToCoredata(data: document)            })            .store(in: &amp;cancellables)                detailVC.modalPresentationStyle = .fullScreen // added        present(detailVC, animated: true)    }이렇게 하면 이제 view가 완전히 사라지기에,override func viewDidDisappear(_ animated: Bool) {        super.viewDidDisappear(animated)        bind()    }이걸 사용할수 있다.이제는 처리가 잘된다.collectionview에는 적용하지 않았다.그리고 생각해보니 wishDocument가 아니라 recentDocument인데 명칭을 다르게 했다.VM역시 RecentVM인데 WishVM으로 해서 이것도 수정했다.정신이 없다.실행화면이제는 최근 본책에 바로 등록이 된다.검색후 view 탭하면 키보드 내리기.mainVC에서 tapPublisher를 하나 만들어준다.private lazy var tapPublisher: AnyPublisher&lt;Void, Never&gt; = {        let tapGesture = UITapGestureRecognizer(target: self, action: nil)        view.addGestureRecognizer(tapGesture)        return tapGesture.tapPublisher.flatMap { _ in          Just(())        }.eraseToAnyPublisher()    }()이 코드는 tip-calculator 공부하면서 알게되었다.void이므로 Just에는 아무것도 없다.그리고 observe 함수를 하나 만들어 준다.private func observe() {        tapPublisher.sink { [unowned self] _ in        view.endEditing(true)      }.store(in: &amp;cancellables)    }이러면 이제 키보드가 내려간다.모든 view에 해두니 다른게 먹지 않아서 해당기능은 폐기.그냥 1초뒤에 키보드를 내리게 했다// SearchViewprivate func observe() {        searchBar.searchTextField.textPublisher            .debounce(for: 1, scheduler: RunLoop.main) // 1초의 시간을 기다렸다가 전달.            .sink { [weak self] value in                self?.searchBarSubject.send(value)                self?.endEditing(true) // added        }.store(in: &amp;cancellables)    }WishList 구현.이제 담기 기능을 구현해야한다.디자인은 안했지만, 바로 이 초록색 버튼을 클릭했을때 담아져야한다.지금 드는 생각은 send를 통해 현재 보고있는 model을 그대로 가져와서 담기할때 그걸 다시 내보내는 구조가 되어야 되지 않을까 라는 생각이 든다.우선 detailVC에var wishSubject = PassthroughSubject&lt;Document, Never&gt;() subject를 하나 만들어준다.그리고 tableview extension에서func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        let detailVC = DetailViewController()                // DetailVC에 전달        searchVM.$document            .map{ document in                return document[indexPath.row]            }            .sink { document in                let imageURL = URL(string: document.thumbnail)                detailVC.titleView.titleLabel.text = document.title                detailVC.titleView.authorLabel.text = document.authors[0]                detailVC.imageView.imageView.kf.setImage(with: imageURL)                detailVC.imageView.priceLabel.text = document.price.stringValue                detailVC.bodyView.bodyLabel.text = document.contents                detailVC.wishSubject.send(document) // added            }.store(in: &amp;cancellables)이렇게 전달을 해주고,detailVC로 돌아가서 viewDidLoad에wishSubject.sink { value in        print(value)    }.store(in: &amp;cancellables)이걸 추가해서 제대로 전달이 되는지 확인을 해본다.출력이 되지 않았다.즉 값이 전달이 되지 않았다는 뜻이다.지금은 일어나서 다시 코드를 확인하고 있는데, 저걸 작성했던 시점에서는 part5 글작성하고 바로 part6인 이 글을 작성하고 있어서 정신줄을 놨나보다.아무래도 @published, assign 를 사용해서 우선 vm에 옮기고 그다음에 그걸 사용해서 하면 될것같다는 생각이 든다.하지만 문제 발생        searchVM.$document            .map{ document in                return [document[indexPath.row]]            }.assign(to: \\.wishDocument, on: wishVM)            .store(in: &amp;cancellables)여기와private lazy var getButton: UIButton = {        let button = UIButton ()        button.backgroundColor = .green        button.setImage(UIImage(systemName: \"bookmark.square\"), for: .normal)        button.tapPublisher.sink { [unowned self] _ in            wishVM.$wishDocument.sink { document in                print(document)            }.store(in: &amp;cancellables)        }.store(in: &amp;cancellables)        return button    }()여기의 wishVM이 서로 다르다.그게 무슨말이냐면위에 있는 wishVM의 경우 mainVC에서 만들어진 인스턴스아래에 있는 vm은 wishVC에서 만들어진 인스턴스즉 둘의 이름은 같으나 엄연히 메모리도 다른 별개의 인스턴스이다.그렇기에 아무리 호출을 해도 되지 않는다.위에 send도 마찬가지.튜터님께 여쭤보니 VM은 싱글턴을 잘 사용하지 않는다고한다.어떻게 전달해야할지 막막해진다.Publisher로 하는걸 폐기하고 한참을 고민하다가 subject중 PassthroughSubject 는 전달한 값을 들고있지않고,CurrentValueSubject는 전달한 값의 마지막값을 들고있는걸 생각했고, 바로 비교를 했다.CurrentValueSubject는 initializing이 필요하다.// cellForRowAtdetailVC.wishSub.send(document)detailVC.wishSubject.send(document)// detailVCvar wishSubject = CurrentValueSubject&lt;Document, Never&gt;(.init(authors: [], contents: \"\", price: 0, title: \"\", thumbnail: \"\", salePrice: nil))    var wishSub = PassthroughSubject&lt;Document, Never&gt;()wishSubject            .print()            .sink { document in            print(document)        }.store(in: &amp;cancellables)        wishSub        .print()        .sink { document in            print(document)        }.store(in: &amp;cancellables)결과receive subscription: (CurrentValueSubject)request unlimitedreceive value: (Document(authors: [\"조앤 K. 롤링\"], contents: \"선과 악의 대립 속에서 평범한 어린 소년이 한 사람의 영웅으로 성장해나가는 보편적인 테마를 바탕으로 빈틈없는 소설적 구성과 생생하게 살아 있는 캐릭터, 정교하게 만들어낸 환상의 세계를 접목시킨 21세기의 고전 『해리 포터와 마법사의 돌』 20주년 개정판. 해리 포터를 처음 만나는 어린 세대가 20년이 지나 성인의 눈높이에서 읽어도 어색함 없이 책을 통해 해리 포터 세계를 경험하며 기쁨을 만끽할 수 있도록 고전의 깊이로 담아냈다.    어둠의 마왕\", price: 9000, title: \"해리 포터와 마법사의 돌 1(해리포터 20주년 개정판)\", thumbnail: \"https://search1.kakaocdn.net/thumb/R120x174.q85/?fname=http%3A%2F%2Ft1.daumcdn.net%2Flbook%2Fimage%2F5134210%3Ftimestamp%3D20240426133336\", salePrice: nil))Document(authors: [\"조앤 K. 롤링\"], contents: \"선과 악의 대립 속에서 평범한 어린 소년이 한 사람의 영웅으로 성장해나가는 보편적인 테마를 바탕으로 빈틈없는 소설적 구성과 생생하게 살아 있는 캐릭터, 정교하게 만들어낸 환상의 세계를 접목시킨 21세기의 고전 『해리 포터와 마법사의 돌』 20주년 개정판. 해리 포터를 처음 만나는 어린 세대가 20년이 지나 성인의 눈높이에서 읽어도 어색함 없이 책을 통해 해리 포터 세계를 경험하며 기쁨을 만끽할 수 있도록 고전의 깊이로 담아냈다.    어둠의 마왕\", price: 9000, title: \"해리 포터와 마법사의 돌 1(해리포터 20주년 개정판)\", thumbnail: \"https://search1.kakaocdn.net/thumb/R120x174.q85/?fname=http%3A%2F%2Ft1.daumcdn.net%2Flbook%2Fimage%2F5134210%3Ftimestamp%3D20240426133336\", salePrice: nil)receive subscription: (PassthroughSubject)request unlimited둘의 데이터 전달의 차이가 발생.그래서 subject를 바꿔서 하기로 결정했다.이제 이걸 buttonview의 클래스에 있는 버튼의 tappublisher를 통해서 위와 같은 내용이 출력이 되는지 확인을 해본다.private lazy var getButton: UIButton = {        let button = UIButton ()        button.backgroundColor = .green        button.setImage(UIImage(systemName: \"bookmark.square\"), for: .normal)        button.tapPublisher.sink { [unowned self] _ in            let vc = childViewController as? DetailViewController            vc?.wishSubject.sink(receiveValue: { document in                print(document)            }).store(in: &amp;cancellables)        }.store(in: &amp;cancellables)        return button    }()다음과 같이 구현테스트를 해본다. 출력이된다.combine 개발자들은 이런상황까지 고려한걸까? 오늘도 깨달음을 하나 얻는다.세부 로직 수정//buttonviewprivate lazy var getButton: UIButton = {        let button = UIButton ()        button.backgroundColor = .green        button.setImage(UIImage(systemName: \"bookmark.square\"), for: .normal)        button.tapPublisher.sink { [unowned self] _ in            let vc = childViewController as? DetailViewController            vc?.wishSubject.sink(receiveValue: { document in                vc?.wishVM.saveDocumentToCoredata(data: document)            }).store(in: &amp;cancellables)        }.store(in: &amp;cancellables)        return button    }()//wishvmfunc saveDocumentToCoredata (data: Document) {                let newItem = WishListModel(context: context)        newItem.title = data.title        newItem.author = data.authors[0]        newItem.content = data.contents        newItem.image = data.thumbnail        newItem.price = Int64(data.price)                do {            try context.save()            print(\"담기 완료\")        } catch {                    }            }    이렇게 해주었다.담기 버튼을 클릭하니 담기 완료가 뜬다.db를 확인해보자.확인완료.coredata 가져오기.wishVM에 다음과 같이 구현 recent와 상동func getDocumentfromCoreData () {        do {            try context.fetch(request).publisher.flatMap { data in                Publishers.Sequence(sequence: [data])            }            .collect()            .assign(to: \\.wishDocument, on: self)            .store(in: &amp;cancellables)        } catch {                    }            }그리고 wishlistVC에는 다음과 같이 적는다 private func bind () {        wishVM.getDocumentfromCoreData()        wishVM.$wishDocument            .receive(on: DispatchQueue.main)            .sink { [unowned self] _ in            self.bodyTableView.tableView.reloadData()        }.store(in: &amp;cancellables)    }그리고 extension에서 wishlistVC의 tableView 메서드들 구현.성공.슬슬 AutoLayout깨진게 거슬리기 시작한다."
  },
  
  {
    "title": "10주차 과제 (5)",
    "url": "/posts/10%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(5)/",
    "categories": "캠프, 10주차",
    "tags": "",
    "date": "2024-05-06 22:00:00 +0900",
    





    
    "snippet": "상세페이지 돌아가기 버튼 구현private var closeButton: UIButton = {        var button = UIButton ()        button.backgroundColor = .gray        button.setImage(UIImage(systemName: \"x.circle\"), for: .normal)    ...",
    "content": "상세페이지 돌아가기 버튼 구현private var closeButton: UIButton = {        var button = UIButton ()        button.backgroundColor = .gray        button.setImage(UIImage(systemName: \"x.circle\"), for: .normal)        button.tapPublisher.sink { [unowned self] _ in            goToMainVC()        }.store(in: &amp;cancellables)        return button    }()공부했던 내용을 바탕으로 이렇게 적었다.tapPublisher를 통해 데이터를 전달하려는게 목적이 아닌,goToMainVC 메서드를 호출하는데 목적이 있다.error 발생.lazy를 해줌으로써 해당버튼이 이후에 작동하게 순서를 바꿔준다.그리고 goToVC 함수에는private func goToMainVC() {        childViewController?.dismiss(animated: true)    }    이렇게해서 현재 띄워져있는 VC에 대해 dismiss를 하라고 한다.childViewController 찾지 못하는데별도로 설정을 해줘야한다.extension UIResponder {        var childViewController: UIViewController? {        return next as? UIViewController ?? next?.childViewController    }    }이건 childViewController에 computed property처럼 설정을 해두었는데, next를 사용하여 그게 VC인지를 확인하고 맞으면 그대로 사용하고, 그게아니면 체이닝을 통해 vc를 찾아서 리턴을 해준다.  next 속성은 응답 체인을 형성하는 데 사용된다.      응답 체인은 이벤트가 발생했을 때 이를 처리할 객체를 찾는 과정을 말한다.이벤트가 발생하면 해당 객체에서 이벤트를 처리할 수 있는지 여부를 확인하고, 처리할 수 없는 경우 next 속성을 통해 다음 응답 객체로 이벤트를 전달한다.계속 꼬리에 꼬리를 물어 찾는다.  UIResponder?  UIResponder??      UIApplication, UIViewController, UIView 객체 모두 Responder그리고 처리되지 않은 앱의 다른부분을 전달하는 작업을 관리한다 ?          주어진 리스폰더가 일을 처리하지 않으면, 리스폰더 체인의 다음 이벤트로 해당 이벤트를 전달.정의되어있는 규칙을 사용하여 동적으로 관리 ex) 하위 view에서 상위view로 전달하거나…      이런식으로 사슬로 연결되어있는거랄까…좌측이 iOS, 우측이 macOS이다.이미지 출처https://blog.dunzo.com/swift-responder-chain-19a19fa0fadchttps://www.cocoanetics.com/2012/09/the-amazing-responder-chain/담기 화면을 위한 Wishlist VC 세팅이녀석은 탭바로 들어가기에SceneDelegate에서 초기설정을 해준다.let wishVC = WishlistViewController() // added// addedwishVC.tabBarItem = UITabBarItem(            title: \"Wish\",            image: UIImage(systemName: \"list.bullet.circle\"),            selectedImage: UIImage(systemName: \"list.bullet.rectangle.fill\"))tabbarController.viewControllers = [firstVC,wishVC] // modified 이렇게 해주면 구성끝view.backgroundColor = .green테스트를 위해 wishlist의 background를 green으로 변경.색 선정도 참….WishList VC 디자인두개의 섹션으로 구분을 하면 될 듯 하다.추가는 선택구현인데, 그냥 tabbar를 변경해주면 될것같다.class WishlistViewController: UIViewController {        private let headerView = HeaderView()    private let bodyTableView = BodyTableView()        private lazy var vStackView: UIStackView = {        var stackView = UIStackView(arrangedSubviews: [            headerView,            bodyTableView,            UIView()        ])        stackView.axis = .vertical        stackView.spacing = 20        return stackView    }()        override func viewDidLoad() {        super.viewDidLoad()        view.backgroundColor = .systemBackground              layout()    }        private func layout () {        view.addSubview(vStackView)                vStackView.snp.makeConstraints { make in            make.top.equalTo(view.snp.top).offset(100)            make.bottom.trailing.leading.equalToSuperview()        }                headerView.snp.makeConstraints { make in            make.height.equalTo(100)        }                bodyTableView.snp.makeConstraints { make in            make.height.equalTo(500)        }    }    }초기 디자인디자인 과정은 생략하겠다.CoreData 세팅우선 Coredata 모델링은 다음과 같다.물론 WishListModel의 Attributes도 같게 해두었다.AppDelegate에 설정을 해둔다.// MARK: - Coredata    lazy var persistentContainer: NSPersistentContainer = {                let container = NSPersistentContainer(name: \"CoreModel\")        container.loadPersistentStores(completionHandler: { (storeDescription, error) in            if let error = error as NSError? {                                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")            }        })        return container    }()        // MARK: - Core Data Saving support        func saveContext () {        let context = persistentContainer.viewContext        if context.hasChanges {            do {                try context.save()            } catch {                                let nserror = error as NSError                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")            }        }    }어디에 적어두면 CoreData쓸때 항상 쓰는 기능.셀 클릭시 Coredata에 저장이부분은 시도를 해본적이 없어서 과정을 좀 적어본다.검색을하고 클릭을하면 최근에 본 책에 필요한 Coredata로 값이 전달이 되어야한다.될 것 같다.우선 tableview의 cellforrowat 함수도 수정한다.func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        let detailVC = DetailViewController()                searchVM.$document        .receive(on: DispatchQueue.main)        .sink { document in // added            let imageURL = URL(string: document[indexPath.row].thumbnail)            detailVC.titleView.titleLabel.text = document[indexPath.row].title            detailVC.titleView.authorLabel.text = document[indexPath.row].authors[0]            detailVC.imageView.imageView.kf.setImage(with: imageURL)            detailVC.imageView.priceLabel.text = document[indexPath.row].price.stringValue            detailVC.bodyView.bodyLabel.text = document[indexPath.row].contents        }.store(in: &amp;cancellables)                present(detailVC, animated: true)    }기존에 있던걸 이렇게 바꾸었다 이때 assign을 통해 RecentVM에 전달이 가능할것 같아서 해본다.한번보내면 끝나는 combine 특성상 하나를 더 만들어서 RecentVM의 document로 보낸다func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        let detailVC = DetailViewController()                searchVM.$document            .receive(on: DispatchQueue.main)            .map{ document -&gt; Document in                return document[indexPath.row]            }            .sink { document in                let imageURL = URL(string: document.thumbnail)                detailVC.titleView.titleLabel.text = document.title                detailVC.titleView.authorLabel.text = document.authors[0]                detailVC.imageView.imageView.kf.setImage(with: imageURL)                detailVC.imageView.priceLabel.text = document.price.stringValue                detailVC.bodyView.bodyLabel.text = document.contents            }.store(in: &amp;cancellables)                // added        searchVM.$document            .map{  document -&gt; Document in            return document[indexPath.row]            }.assign(to: \\.wishDocument, on: recentVM.self)            .store(in: &amp;cancellables)                present(detailVC, animated: true)    }프린트를 통해 출력을 해보니receive subscription: (PublishedSubject)request unlimitedreceive value: (Document(authors: [\"조앤 K. 롤링\"], contents: \"영화 〈해리 포터〉와 〈신비한 동물사전〉 시리즈에서 비주얼 그래픽을 담당했던 스튜디오 ‘미나리마(MinaLima)’가 직접 디자인한 시리즈 ‘미나리마 에디션’이 드디어 세 번째 이야기 《해리 포터와 아즈카반의 죄수》를 선보인다. 《해리 포터와 아즈카반의 죄수: 미나리마 에디션》에서는 영화와는 다른 모습의 시리우스와 루핀, 크룩섕스와 벅빅을 만날 수 있으며, 미나리마가 오직 이 책만을 위해 만들어 낸 8가지 공작 요소를 통해 해리 포터의 마법 세계\", price: 38000, title: \"해리 포터와 아즈카반의 죄수(미나리마 에디션)\", thumbnail: \"https://search1.kakaocdn.net/thumb/R120x174.q85/?fname=http%3A%2F%2Ft1.daumcdn.net%2Flbook%2Fimage%2F6455866%3Ftimestamp%3D20240419171325\", salePrice: nil))잘 넘어가는 듯 하다.그다음 vm에서 coredata에관한 코드를 작성하다 문득 든 생각인데, 굳이 이걸 다시 assign으로 담아서 보내야 하나? 라는 생각이 들었다.그냥 클릭했을때 해당 document에 대해서 바로 coredata에 넘기면 되는것 아닌가? 라는 생각이 든다.RecentVM 작성class RecentVM {        let context = (UIApplication.shared.delegate as! AppDelegate) .persistentContainer.viewContext        func saveDocumentToCoredata (data: Document) {                let newItem = RecentModel(context: context)        newItem.title = data.title        newItem.author = data.authors[0]        newItem.content = data.contents        newItem.image = data.thumbnail        newItem.price = Int64(data.price)        newItem.date = Date().timeIntervalSince1970                do {            try context.save()        } catch {        }                }}여기는 coredata에 저장할 목적으로 다음과 같이 사용했다.date는 흔히 많이 사용하는 Date().timeIntervalSince1970를 사용했다. 이렇게 되면 Double형식으로 되는데, 이것의 숫자 값을 비교하여 최근 본순서대로 정리를 하면된다.그리고 didSelectRowAt 역시 수정을 해주었다.func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        let detailVC = DetailViewController()                searchVM.$document            .receive(on: DispatchQueue.main)            .map{ document -&gt; Document in                return document[indexPath.row]            }            .sink { document in                let imageURL = URL(string: document.thumbnail)                detailVC.titleView.titleLabel.text = document.title                detailVC.titleView.authorLabel.text = document.authors[0]                detailVC.imageView.imageView.kf.setImage(with: imageURL)                detailVC.imageView.priceLabel.text = document.price.stringValue                detailVC.bodyView.bodyLabel.text = document.contents            }.store(in: &amp;cancellables)                // modified        searchVM.$document            .map{  document -&gt; Document in            return document[indexPath.row]            }.sink(receiveValue: { [weak self] document in                self?.recentVM.saveDocumentToCoredata(data: document)            })            .store(in: &amp;cancellables)                present(detailVC, animated: true)    }실행을해서 CoreData에 들어오는지 확인을 해주면 될것같다.우선 DB위치 확인을 위해 print(FileManager.default.urls(for: .documentDirectory, in: .userDomainMask))를 적어서 호출확인완료.이젠 CoreData를 request로 호출하여 CollectionView에 띄우면 된다.    @Published var wishDocument = [RecentModel]()    private var cancellables = Set&lt;AnyCancellable&gt;()        func getDocumentfromCoreData () {                do {            try context.fetch(request).publisher                .assign(to: \\.wishDocument, on: self)                .store(in: &amp;cancellables)        } catch {                    }    }마찬가지로 예외에 대한 catch는 뒤에 하기로하고. 처음에는 이렇게 했더니 type error가 발생한다.wishDocument는 [RecentModel]의 배열인데, 리턴을 하려는건 RecentModel인 집합이 아니었기때문.그래서 operator를 사용하여 배열을 안에 넣고 리턴하게 했다.func getDocumentfromCoreData () {                do {            try context.fetch(request).publisher                .map { data in // added                    return [data]                }                .assign(to: \\.wishDocument, on: self)                .store(in: &amp;cancellables)        } catch {                    }    }VC에서 호출private func bind () {        searchVM.transform(input: SearchVM.Input(searchPublisher: searchView.valuePublisher))        searchVM.$document            .receive(on: DispatchQueue.main)            .sink { [weak self] _ in                self?.resultView.tableView.reloadData()            }.store(in: &amp;cancellables)                recentVM.$wishDocument            .print()            .receive(on: DispatchQueue.main)            .sink { [weak self] _ in                self?.recentView.collectionView.reloadData()            }.store(in: &amp;cancellables)    }이제 두개의 내용에 대해 전부 포함하는 bind 함수를 구현한다wishDocument에 print를 해둔건. 제대로 출력이 되는지에 대해 확인이 필요해서 해두었다.우선 실행해보니 coredata에 이미 테스트용 으로 해둔게 있는데 로드가 되지않은 문제를 확인했다.receive subscription: (PublishedSubject)request unlimitedreceive value: ([])생각해보니 애초에 해당 메서드를 호출하지 않았다.private func bind () {        searchVM.transform(input: SearchVM.Input(searchPublisher: searchView.valuePublisher))        searchVM.$document            .receive(on: DispatchQueue.main)            .sink { [weak self] _ in                self?.resultView.tableView.reloadData()            }.store(in: &amp;cancellables)                recentVM.getDocumentfromCoreData() // added        recentVM.$wishDocument            .receive(on: DispatchQueue.main)            .sink { [weak self] _ in                self?.recentView.collectionView.reloadData()            }.store(in: &amp;cancellables)    }출력을 확인해보니receive subscription: (PublishedSubject)request unlimitedreceive value: ([&lt;Book.RecentModel: 0x60000213f1b0&gt; (entity: RecentModel; id: 0x955587754e7d6e80 &lt;x-coredata://B14523BD-6BBF-4798-8817-D4116D7B1FEF/RecentModel/p3&gt;; data: &lt;fault&gt;)])이렇게 확인이 된다.제대로 데이터가 들어왔는지 확인을 위해 변수를 하나 만들어서 print를 해봐야겠다. private func bind () {        searchVM.transform(input: SearchVM.Input(searchPublisher: searchView.valuePublisher))        searchVM.$document            .receive(on: DispatchQueue.main)            .sink { [weak self] _ in                self?.resultView.tableView.reloadData()            }.store(in: &amp;cancellables)                recentVM.getDocumentfromCoreData()        recentVM.$wishDocument            .receive(on: DispatchQueue.main)            .sink { [weak self] data in                self?.testArray = data // 확인작업                self?.recentView.collectionView.reloadData()                print(self?.testArray[0].title) // 확인작업            }.store(in: &amp;cancellables)    }출력결과.Optional(\"해리 포터와 마법사의 돌 1(해리포터 20주년 개정판)\")데이터 들어오는게 확인이 되었다.데이터 소팅.들어오는것이 확인이 되었으니, 우리는 소팅을 해줘야한다.애초에 assign을 통해 wishDocument에 넣을때 소팅한값이 들어모면 되지않을까? 라는 생각에 VM 쪽 코드를 다듬어본다.func getDocumentfromCoreData () {                do {            try context.fetch(request).publisher                .map { data in                    return [data].sorted { first, second in // modified                        first.date &gt; second.date                    }                }                .assign(to: \\.wishDocument, on: self)                .store(in: &amp;cancellables)        } catch {                    }    }우선 이렇게 바꾸었다.역시나 확인을 위해 vc에서 테스트를 해본다.문제 발견.테스트를 하던 도중 document가 하나만 넘어오는듯하다.vm에서 print를 해보니 하나씩 리턴을 한다.func getDocumentfromCoreData () {                do {            try context.fetch(request).publisher                .map { data in                    var array = [RecentModel]()                    array.append(data)                    print(array.count)                    return array                }                .assign(to: \\.wishDocument, on: self)                .store(in: &amp;cancellables)        } catch {                    }    }이렇게 해서 프린트 한결과가111이었다.아까전에 배열이아닌 모델로 타입 미스에대한 내용이 이것이었다.나의 지식선에선 해결이 불가능해서 결국 gpt를 쓴다..flatMap { data in        Publishers.Sequence(sequence: [data])}.collect()flatMap과 collect 그리고 sequence를 사용을 했다.do {            try context.fetch(request).publisher                .flatMap { data in                    Publishers.Sequence(sequence: [data])}                .collect()                .assign(to: \\.wishDocument, on: self)                .store(in: &amp;cancellables)        } catch {                    }저건 [data]를 publisher로 만들게 된다.즉 [data] publisher가 coredata에 있는 개수만큼 생성.이후 flatmap을 통해 1개의 publisher로 통합. 그리고 collect를 사용하여 배열로 리턴.사진은 collect이건 sequencemap을 사용하면서 결과값은 항상 단일 모델이 될 수 밖에 없었다.난 계속 되는줄 알고 배열로 씌운거였는데, 애초에 xcode는 그걸 알고서 타입이 맞지않는다고 했던것이다.GPT 사용에 있어서 부정적인데, 이번에는 도움을 받긴했지만, 뭔가 검색을 하면서 한게 아니라서 그런가 썩 좋지는 않다.다시 돌아와서 collect 다음에 map을 한번더 사용하여 소팅을 해준다func getDocumentfromCoreData () {                do {            try context.fetch(request).publisher                .flatMap { data in                    Publishers.Sequence(sequence: [data])}                .collect()                .map { data in // added                    var sorted = data.sorted { first, second in                        first.date &gt; second.date                    }                    return sorted                }                .assign(to: \\.wishDocument, on: self)                .store(in: &amp;cancellables)        } catch {                    }    }이렇게되면 이제 최근에 본 순서대로 배열이 정리가 된다."
  },
  
  {
    "title": "10주차 과제 (4)",
    "url": "/posts/10%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(4)/",
    "categories": "캠프, 10주차",
    "tags": "",
    "date": "2024-05-05 05:00:00 +0900",
    





    
    "snippet": "코드 리팩토링아무생각없이 구글링을 하다가 보완할점을 발견하여 보강을 하려 한다.출처 우연히 발견한건데 이분글에는 없는게 뭘까 라는 생각이 든다.combine을 사용하면서 publisher로 선언한 변수를 그냥 계속 쓰는듯하다.나는 그러지않고 vc에서 다시 배열을 만들어서 거기에 집어넣었는데, 글을 참고하여 더 Combine스럽게 바꿔보려한다.func ...",
    "content": "코드 리팩토링아무생각없이 구글링을 하다가 보완할점을 발견하여 보강을 하려 한다.출처 우연히 발견한건데 이분글에는 없는게 뭘까 라는 생각이 든다.combine을 사용하면서 publisher로 선언한 변수를 그냥 계속 쓰는듯하다.나는 그러지않고 vc에서 다시 배열을 만들어서 거기에 집어넣었는데, 글을 참고하여 더 Combine스럽게 바꿔보려한다.func callRequest(query: String) {                NetworkManager.shared.fetchRequest(queryValue: query).sink { completion in            switch completion {            case .finished:                print(\"success\")            case .failure(let error):                print(error)            }        } receiveValue: { [weak self] documents in            self?.document = documents        }.store(in: &amp;cancellables)    }지금 receiveValue를 사용해서 처리했는데 이걸 그냥 바로 프로퍼티에 할당하는 assgin을 사용해서 고쳐본다.NetworkManager를 전부 갈아 엎는다. (거기에 있는 코드를 vm으로 이동.)그리고func transform(input: Input) {        input.searchPublisher.sink { [weak self] value in            self?.fetchRequest(queryValue: value)        }.store(in: &amp;cancellables)            }        func fetchRequest(queryValue: String) {                let urlString = \"https://dapi.kakao.com/v3/search/book?target=title\"        let headers = [\"Authorization\" : \"KakaoAK \\(Secret.apikey)\"]                var urlComponent = URLComponents(string: urlString)        urlComponent?.queryItems?.append(URLQueryItem(name: \"query\", value: queryValue))                guard let url = urlComponent?.url else {            return  // Error 리턴        }                var request = URLRequest(url: url)        request.allHTTPHeaderFields = headers        let session = URLSession(configuration: .default)        return session.dataTaskPublisher(for: request)            .map(\\.data)            .decode(type: BookModel.self, decoder: JSONDecoder())            .map(\\.documents)            .replaceError(with: [])            .assign(to: \\.document, on: self)            .store(in: &amp;cancellables)    }다음과 같이 수정.document의 프로퍼티에 넣고, 아무것도 없을땐 빈배열 리턴.그걸 transform에서 실행.//vcbookVM.$document            .receive(on: DispatchQueue.main)            .sink { [weak self] _ in                self?.resultView.tableView.reloadData()            }.store(in: &amp;cancellables)좀 더 괜찮아 졌다.정리코드 작성순서보단 코드의 흐름으로 정리한다.  before          vc에서는 vm transform 호출      vm에서 fetchRequest를 호출, searchPublisher를 통해 가져온 searchBar의 value를 쿼리에 주입.      NetworkManager를 통해 fetchRequest Method로 처리      transform의 결과로 vm의 document에 값이 저장됨.      저장된 값을 publisher를 통해 vc의 list에 다시 저장.                  publisher가 가능한 이유는 @Published 때문                    list를 사용하여 tableview에 보여짐        after          vc에서는 vm transform 호출 (상동)      vm에서 fetchRequest를 호출, searchPublisher를 통해 가져온 searchBar의 value를 쿼리에 주입. (상동)      vm 내부 fetchRequest 함수를 통해 assign을 통해 바로 document에 저장.      별도의 저장 없이 document를 사용하여 tableview에 보여짐.        우선 Sequence가 줄었다.그리고 list를 vc에서 하나 더 만들 필요가 없다. (메모리 관리가 더 좋다.)NetworkManager의 기능을 vm이 바로 관리.상세페이지 구현이제 셀을 클릭했을때 해당 페이지를 볼 상세페이지를 구현해야 한다.디자인 소질이 없으므로 과제 디자인 그대로 사용하려한다4개의 섹션으로 나누면 될듯하다.class DetailViewController: UIViewController {    private var titleView = TitleView()    private var imageView = ImageView()    private var bodyView = BodyView()    private var buttonView = ButtonView()        private lazy var vStackView: UIStackView = {        var stackView = UIStackView(arrangedSubviews: [        titleView,        imageView,        bodyView,        buttonView,        UIView()        ])        stackView.axis = .vertical        stackView.spacing = 20                return stackView    }()        override func viewDidLoad() {        super.viewDidLoad()                layout()    }        private func layout() {        view.addSubview(vStackView)                vStackView.snp.makeConstraints { make in            make.top.equalTo(view.snp.top).offset(100)            make.leading.trailing.bottom.equalToSuperview()        }                titleView.snp.makeConstraints { make in            make.height.equalTo(90)        }                imageView.snp.makeConstraints { make in            make.height.equalTo(350)        }                bodyView.snp.makeConstraints { make in            make.height.equalTo(180)        }                buttonView.snp.makeConstraints { make in            make.height.equalTo(90)        }    }    }일단은 기존과 같이 느낌만 살려둔다.여기는 사실 닫기 담기 버튼만 구현하면 되는 부분이다.위에 view관련된것을 private로 선언했는데, 생각해보니 그렇게 하면 안될것같아서 private를 다 지웠다.private를 사용하게되면 화면전환시 프로퍼티 접근이 안됨.didselectRowat 문제 해결func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {                let detailVC = DetailViewController()        let item = bookVM.document[indexPath.row]                detailVC.titleView.titleLabel.text = item.title                self.present(detailVC, animated: true)    }별에별 설정을 다해봤지만 되지않았다.설정한 내역.cell.isUserInteractionEnabled = truetableView.isUserInteractionEnabled = truetableView.allowsSelection = true마지막걸 true하고나서 발생한 에러SnapKit/ConstraintMakerRelatable.swift:85: Fatal error: Expected superview but found nil when attempting make constraint `equalToSuperview`.어디가 문제일까 고민했는데 알고보니 아까 페이지 디자인하다 말았던 거기서 에러가 발생해서 crash가 나는것같다.역시나 buttonView를 디자인 하다 만게 원인이었다.멍청하게도func layout () {        addSubview(hStackView) // 추가를 안함addsubview를 했다고 생각하고 해서 생긴 문제였다.당연히 없는데 레이아웃을 잡으려고하니 문제가 발생한것이다.레이아웃은 뒷전으로 하고 기능에 집중한다.BodyView scrollview 설정글을 하나 보고 참고했다.class BodyView: UIView {        private var scrollView: UIScrollView = {        var view = UIScrollView()        view.isScrollEnabled = true        view.showsVerticalScrollIndicator = true        return view    }()        var bodyLabel = TextLabel().makeLabel(value: \"body\")        override init(frame: CGRect) {        super.init(frame: .zero)        layout()    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        func layout () {        addSubview(scrollView)        scrollView.addSubview(bodyLabel)                scrollView.snp.makeConstraints { make in            make.top.equalToSuperview().offset(10)            make.leading.equalToSuperview().offset(10)            make.trailing.equalToSuperview().offset(-10)            make.bottom.equalToSuperview().offset(-10)        }                bodyLabel.snp.makeConstraints { make in            make.top.equalTo(scrollView.snp.top)            make.leading.equalTo(scrollView.snp.leading)            make.trailing.equalTo(scrollView.snp.trailing)            make.bottom.equalTo(scrollView.snp.bottom)            make.width.equalTo(scrollView)        }    }    }오늘은 여기까지디자인은 마지막에 다듬어보는걸로…그 다음은 Combine + Coredata를 한번 다뤄봐야겠다.MVC로 했으면 오래걸리지도 않을 과제인데 확실히 안해본걸로 다루다보니 빡세지만 그만큼 재미있는듯하다."
  },
  
  {
    "title": "10주차 과제 (3)",
    "url": "/posts/10%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(3)/",
    "categories": "캠프, 10주차",
    "tags": "",
    "date": "2024-05-05 05:00:00 +0900",
    





    
    "snippet": "이제 진짜 문제의 시작.문득 씻다가 이런생각이 들었다.VM에 대해서 생각을 좀 해보았는데,우리가 VC에 TableView관련 함수를 쓸 수 밖에 없었던 가장 큰 이유는, VC에 tableview가 있었고, 그걸 TableView 관련 protocol들을 가져왔어야 했기 때문이었다.그러다보니 자연스럽게 VC가 처리할 내용이 많아졌다.MVVM은 이런 걸 ...",
    "content": "이제 진짜 문제의 시작.문득 씻다가 이런생각이 들었다.VM에 대해서 생각을 좀 해보았는데,우리가 VC에 TableView관련 함수를 쓸 수 밖에 없었던 가장 큰 이유는, VC에 tableview가 있었고, 그걸 TableView 관련 protocol들을 가져왔어야 했기 때문이었다.그러다보니 자연스럽게 VC가 처리할 내용이 많아졌다.MVVM은 이런 걸 막기위해서 나온건 아닐까 라는 생각이 들었다. 왜냐 이전 글에서도 vc는 그냥 vm의 메서드만 호출했을 뿐이다.그렇게 본다면 TableView, CollectionView들도 그렇게 하면 되는거 아닐까? 라는 생각이 들어서 해보려고 한다.TableView SettingVM에서 해당 관련 메서드를 처리해보려 한다.관련 메서드면 Tableview의 단골 손님cellForRowAt, numberOfRowsinSection 이 두녀석이다.이걸 VM에서 핸들링이 가능한지 해보려한다.아직은 지식이 충분하지 않아 검색을 해보고 있는데 웹사이트를 보니 내 가설은 적용이 안되겠구나 라는 생각이 바로 들었다.하긴 VC가 담당할 수 밖에 없는 기능들이 있긴하니까.실제로extension BookVM: UITableViewDelegate, UITableViewDataSource {    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {    }        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {    }        func isEqual(_ object: Any?) -&gt; Bool {     }    var hash: Int {    }    var superclass: AnyClass? {       }    func `self`() -&gt; Self {       }    func perform(_ aSelector: Selector!) -&gt; Unmanaged&lt;AnyObject&gt;! {       }    func perform(_ aSelector: Selector!, with object: Any!) -&gt; Unmanaged&lt;AnyObject&gt;! {       }    func perform(_ aSelector: Selector!, with object1: Any!, with object2: Any!) -&gt; Unmanaged&lt;AnyObject&gt;! {       }    func isProxy() -&gt; Bool {       }    func isKind(of aClass: AnyClass) -&gt; Bool {       }    func isMember(of aClass: AnyClass) -&gt; Bool {       }    func conforms(to aProtocol: Protocol) -&gt; Bool {    }    func responds(to aSelector: Selector!) -&gt; Bool {       }    var description: String {       }}가설대로 해보려고 extension하자마자 무수히 많이 쏟아지는 함수들이것만 봐도 뭔가 잘못되었음을 알수있게해준다.NSObjectProtocol을 준수하라고 뜬다. Fix를 누르자마자 무더기로 쏟아진다.이걸보고 내린 나의 결론은 VC에서 해야한다라는 것이다.별도로 관리하기위해 Extension 파일을 만들어 주었고, 다음과 같이 적는다.extension ViewController: UITableViewDelegate, UITableViewDataSource {        func setUp() {        resultView.tableView.delegate = self        resultView.tableView.dataSource = self    }        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {                return 1    }        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        guard let cell = resultView.tableView.dequeueReusableCell(withIdentifier: Constants.tableViewCellIdentifier) as? ResultTableViewCell else { return UITableViewCell () }                                return cell    }}리턴을 1로 해둔 이유는, 이제 searchbar에 입력한 결과를 배열로 받아서 처리를 해야한다.지금은 그냥 밑작업.그전에 tableview cell autolayout 점검이 필요하므로 dummy data를 하나 만들어서 그것부터 좀 건드리고 해야할듯하다.let dummyData = [Document(authors: [\"나\"], contents: \"테스트\", price: 12300, title: \"테스트입니다\", thumbnail: \"\", salePrice: nil)]하나 만들어 주고내용 추가extension ViewController: UITableViewDelegate, UITableViewDataSource {        func setUp() {        resultView.tableView.delegate = self        resultView.tableView.dataSource = self        resultView.tableView.reloadData()    }        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {                return dummyData.count    }        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        guard let cell = resultView.tableView.dequeueReusableCell(withIdentifier: Constants.tableViewCellIdentifier) as? ResultTableViewCell else {            return UITableViewCell()        }                let item = dummyData[indexPath.row]                cell.titleLabel.text = item.title        cell.priceLabel.text = String(item.price)                return cell    }}코드상에 문제가 없는데 보이지가 않는다?cell의 문제로 판단 다시 cell로 가보자.override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {        super.init(style: style, reuseIdentifier: reuseIdentifier)        layout()    } 바로 이녀석이 없어서 생긴 문제였다.왜 그동안에는 저것 없이도 가능했는가? 에 대해서는 이전에는 CustomCell을 구현할때 xib파일도 같이 생성을 했기에, 거기서 Indentifier 설정이 가능했다.그리고 지금은 순수하게 CodeBase이기에 그것도 불가능.그리고, initializer가 없었기 때문이다.해당 부분을 추가해주자.출력은 잘된다.cell autolayout 문제도 우선 해결private func layout () {        addSubview(hStackView)                hStackView.snp.makeConstraints { make in            make.leading.bottom.trailing.top.equalToSuperview()        }                titleLabel.snp.makeConstraints { make in            make.leading.equalTo(hStackView.snp.leading)            make.top.equalTo(hStackView.snp.top).offset(10)            make.bottom.equalTo(hStackView.snp.bottom).offset(-10)        }                priceLabel.snp.makeConstraints { make in            make.leading.equalTo(titleLabel.snp.trailing)            make.trailing.equalTo(hStackView.snp.trailing).offset(-10)            make.top.equalTo(hStackView.snp.top).offset(10)            make.bottom.equalTo(hStackView.snp.bottom).offset(-10)        }    }wtflayout 개발한사람 진짜 칭찬해야한다.검색시 Tableview에 보이기.그전에 return type을 고쳐주었다.func fetchRequest(queryValue: String) -&gt; AnyPublisher&lt;[Document], Error&gt; { // modified                let urlString = \"https://dapi.kakao.com/v3/search/book?target=title\"        let headers = [\"Authorization\" : \"KakaoAK \\(Secret.apikey)\"]                var urlComponent = URLComponents(string: urlString)        urlComponent?.queryItems?.append(URLQueryItem(name: \"query\", value: queryValue))                guard let url = urlComponent?.url else {            return Fail(error: URLError(.badURL)).eraseToAnyPublisher() // Error 리턴        }                var request = URLRequest(url: url)        request.allHTTPHeaderFields = headers        let session = URLSession(configuration: .default)        return session.dataTaskPublisher(for: request)            .map(\\.data)            .decode(type: BookModel.self, decoder: JSONDecoder())            .map(\\.documents) // added            .eraseToAnyPublisher()    }document만 가져오게한다. 원래는 data.documents 였다면이제는 그냥 documents에 바로 접근하게 했다.이젠 console에서 출력이 되던것을 배열에 집어넣어서 handling을 해줘야한다.우선 @Published를 사용해야한다.@Published var document = [Document]() document를 바꿔주었다.그이유는 저 document가 vm에서 데이터를 받고, 다시 vc를 호출할때 값을 넘겨줄 publisher가 되기 때문이다.VC로 돌아와서 vm으로 선언한 document를 통해 sink로 데이터를 전달할건데, 그걸 받을 변수var tableViewList = [Document]()를 만들어 준다.bookVM.$document            .sink { [weak self] document in                self?.tableViewList = document            }.store(in: &amp;cancellables)resultView.tableView.reloadData()그리고 viewdidload에 다음과 같이 적는다.되어야하는데 안된다.알고보니 비동기 방식이므로 scheduler를 통해 main thread작업도 선정을 해주고 reload도 클로저 안에넣어야 했다.다시 수정하면,        bookVM.$document            .receive(on: RunLoop.main) // added            .sink { [weak self] document in                self?.tableViewList = document                self?.resultView.tableView. reloadData() // modified line            }.store(in: &amp;cancellables)굿.뭔가 공부한건 api를 사용하지 않고 combine을 사용한거라 지금 코드작성한것이 공부한것과 조금 다르긴 하지만, 그래도 조금씩 감이 온다.포인트는 publisher를 통해 어떻게 데이터를 넘길것인가 이다.셀 글씨 생략되는 디테일은 나중에 하는걸로."
  },
  
  {
    "title": "10주차 과제 (2)",
    "url": "/posts/10%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(2)/",
    "categories": "캠프, 10주차",
    "tags": "",
    "date": "2024-05-05 05:00:00 +0900",
    





    
    "snippet": "SearchBar Publisher 생성CollectionView, TableView의 Delegata, DataSource를 어떻게 해야할지 고민 하기전에,우선 SearchBar에 대한 부분은 먼저 끝내는게 좋다고 판단했다.Publisher를 하나 만들어준다.사이트를 참고하여 searchBar에 publisher를 연결하여 구현해본다.우선 textP...",
    "content": "SearchBar Publisher 생성CollectionView, TableView의 Delegata, DataSource를 어떻게 해야할지 고민 하기전에,우선 SearchBar에 대한 부분은 먼저 끝내는게 좋다고 판단했다.Publisher를 하나 만들어준다.사이트를 참고하여 searchBar에 publisher를 연결하여 구현해본다.우선 textPublisher를 사용하기 위해 extension을 하나 만들어 주고extension UITextField {    var textPublisher: AnyPublisher&lt;String, Never&gt; {        NotificationCenter.default            .publisher(for: UITextField.textDidChangeNotification, object: self)            .map { ($0.object as? UITextField)?.text  ?? \"\" }            .eraseToAnyPublisher()    }}SearchView에서 observe 함수를 하나 만들어서private func observe() {        searchBar.searchTextField.textPublisher.sink { value in            print(value)        }.store(in: &amp;cancellables)    }text값을 출력하게 해보았다.바로바로 출력이 되는걸 확인했다.이젠 이렇게 입력되는 값을 api로 넘기기 전에 실시간으로 호출을 하면 트래픽도 있고 해서 좋지 않기에입력하고 1초 뒤에 넘어가게 하는게 좋아보인다.debounce는 우리가 정한 시간뒤에 값을 넘기는게 가능하다.private func observe() {        searchBar.searchTextField.textPublisher            .debounce(for: 1, scheduler: RunLoop.main) // added            .sink { value in            print(value)        }.store(in: &amp;cancellables)    }그리고 main thread에서 작업하게 해두었다.이젠 값을 바로바로 넘기는게 아니라 유져가 입력하고 1초를 기다렸다가 넘기게 된다.이렇게 1초뒤에 입력이됨.모델링API Data에 관한 모델링은 다음과 같이 했다.struct BookModel: Codable {        let documents: [Document]    }struct Document: Codable {        let authors: String    let contents: String    let price: Int    let title: String    let thumbnail: String    let salePrice: Int        enum Codingkeys: String, CodingKey {        case salePrice = \"sale_price\"    }    }API 호출 기능 구현.private func observe() {        searchBar.searchTextField.textPublisher            .debounce(for: 1, scheduler: RunLoop.main)            .sink { [weak self] value in                self?.searchBarSubject.send(value) // added        }.store(in: &amp;cancellables)    }우선 값을 입력한걸 searchbarSubject를 통해 보낸다.여기까지 해두고 NetworkManager하나 만들어준다.우선 어떻게 값이 전달이 되어야할지 (ex: Header, Query)를 확인하기 위해 Postman을 사용하여 확인을 먼저한다.혹시나해서 title도 일종의 파라미터일까 했지만 아니다.즉 Docs에 있는 그대로, Header / Query가 둘다 필요하다는 뜻이 된다.여기서도 해보다가 알게된 두가지 방법이 있지만, 보편적인 방법을 사용하는걸로. 여기서 독특한 점이라면 urlsession에서 publisher를 사용한다는 것이다.func fetchRequest(queryValue: String) -&gt; AnyPublisher&lt;[Document], Error&gt; { }우선 이렇게 틀을 잡고 시작한다.return type은 publisher가 되게한다. 이때 나가는게 [Document]로 된다.Escaping Closure랑 비슷하게 넘어가는걸로 이해하면 될듯.그리고 내용을 적어준다.let urlString = \"https://dapi.kakao.com/v3/search/book?target=title\"let headers = [\"Authorization\" : \"KakaoAK \\(Secret.apikey)\"]        var urlComponent = URLComponents(string: urlString)urlComponent?.queryItems?.append(URLQueryItem(name: \"query\", value: queryValue))        guard let url = urlComponent?.url else {    return Fail(error: URLError(.badURL)).eraseToAnyPublisher() // Error 리턴}        var request = URLRequest(url: url)request.allHTTPHeaderFields = headerslet session = URLSession(configuration: .default)여기까지는 뭐 우리가 하던 방식대로 진행하는 부분이니 크게 문제가 없다.그다음 리턴에서 차이가 나게된다.return session.dataTaskPublisher(for: request)        .map(\\.data)        .decode(type: [Document].self, decoder: JSONDecoder())        .eraseToAnyPublisher()우선 이렇게 해두었다.받아온 data를 decoding한다.그리고 BookVM을 만들고 해당 기능을 호출할 함수를 하나 만들어주었다.private var cancellables = Set&lt;AnyCancellable&gt;()        func callRequest() {                NetworkManager.shared.fetchRequest(queryValue: \"미움받을 용기\").sink { completion in            switch completion {            case .finished:                print(\"success\")            case .failure(let error):                print(error)            }        } receiveValue: { model in            print(model.documents)        }.store(in: &amp;cancellables)    }실행하니 에러가 난다. 처음부터 documents를 다 들고와야하는건가 싶다.다시 바꿔주고, 실행하니 authors에서 typemismatch가 발생찾아보니 이녀석 string 배열이다.Model 재수정import Foundationstruct BookModel: Codable {        let documents: [Document]    }struct Document: Codable {        let authors: [String] // modified    let contents: String    let price: Int    let title: String    let thumbnail: String    let salePrice: Int? // modified        enum Codingkeys: String, CodingKey {        case salePrice = \"sale_price\"    }    }salePrice에 optional? 할인을 할 수도 있고, 안할수도있어서…아래는 NetworkManager에 대한 코드class NetworkManager {        static let shared = NetworkManager()        private var cancellables = Set&lt;AnyCancellable&gt;()        func fetchRequest(queryValue: String) -&gt; AnyPublisher&lt;BookModel, Error&gt; {                let urlString = \"https://dapi.kakao.com/v3/search/book?target=title\"        let headers = [\"Authorization\" : \"KakaoAK \\(Secret.apikey)\"]                var urlComponent = URLComponents(string: urlString)        urlComponent?.queryItems?.append(URLQueryItem(name: \"query\", value: queryValue))                guard let url = urlComponent?.url else {            return Fail(error: URLError(.badURL)).eraseToAnyPublisher() // Error 리턴        }                var request = URLRequest(url: url)        request.allHTTPHeaderFields = headers        let session = URLSession(configuration: .default)        return session.dataTaskPublisher(for: request)            .print() // 과정 확인            .map(\\.data)            .decode(type: BookModel.self, decoder: JSONDecoder())            .eraseToAnyPublisher()    }}호출 성공.중복이 뭐이리 많나 했더니/여러 군데에서 검색을 해서 가져오는가보다.SearchBar의 text 값을 vm으로 넘겨서 api처리.우선 vm으로 가서searchView에서 한 데이터가 vm까지 통신이 되는지를 확인해보는게 중요하다.//vmstruct Input {        let searchPublisher: AnyPublisher&lt;String, Never&gt;    }private var cancellables = Set&lt;AnyCancellable&gt;()    func transform(input: Input) {                input.searchPublisher.sink { [weak self] value in            self?.callRequest(query: value)        }.store(in: &amp;cancellables)        }        func callRequest(query: String) {                NetworkManager.shared.fetchRequest(queryValue: query).sink { completion in            switch completion {            case .finished:                print(\"success\")            case .failure(let error):                print(error)            }        } receiveValue: { [weak self] model in            self?.document = model.documents            print(model.documents)        }.store(in: &amp;cancellables)    }//vc override func viewDidLoad() {        super.viewDidLoad()        view.backgroundColor = .white        layout()        bookVM.transform(input: BookVM.Input(searchPublisher: searchView.valuePublisher))    }우선은 다음과 같이 구성을 했다.이렇게 하면 searchbar에서 입력한 텍스트가 vm으로 가서 transform으로 간다음, 다시 callrequest로 가서 api와 통신을 한다.즉 vc입장에선 뭐 크게 할게 없다.기존에 mvc였다면 vc에서 escaping closure나, delegate를 통해 처리한뒤 그걸 ui로 띄우는데, 아직 ui는 넘기지 못했지만,이것만으로도 엄청나게 vc입장에선 자유로워진다.확실히 기존에 하던 방식에서 새롭게 하니 오래걸리기도하고, 그렇다.그래도 나중에 뭘할때 이걸 기반으로 할 수 있을것같다.MVVM도 희미하게 보이기 시작한다."
  },
  
  {
    "title": "10주차 과제 (1)",
    "url": "/posts/10%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(1)/",
    "categories": "캠프, 10주차",
    "tags": "",
    "date": "2024-05-04 23:00:00 +0900",
    





    
    "snippet": "이번에도 과제가 주어졌다.사실 MVC로하면 길어야 이틀짜리 과제인데, 이번엔 좀 새로운 시도를 해보고자 컴바인을 공부를 하면서 mvvm도 약간 공부를 했는데,그래서 이걸 적용을 해서 과제를 해보면 아주 Best of Best 일것 같아서 이렇게 과제를 해보려 한다.물론 TableView, CollectionView 도 DataSource가 아닌 Dif...",
    "content": "이번에도 과제가 주어졌다.사실 MVC로하면 길어야 이틀짜리 과제인데, 이번엔 좀 새로운 시도를 해보고자 컴바인을 공부를 하면서 mvvm도 약간 공부를 했는데,그래서 이걸 적용을 해서 과제를 해보면 아주 Best of Best 일것 같아서 이렇게 과제를 해보려 한다.물론 TableView, CollectionView 도 DataSource가 아닌 Diffable로 해보려고한다. (가능하면?)하다가 안되면 MVC로 돌리면 되는거고.. 사실 MVC는 할만큼 했고 알만큼 아니까 MVVM을 해보는게 제일 좋긴하다.과제는 다음과 같다.Level 1 - 화면 구성예시 화면 가이드입니다. 참고하시고 요구사항을 벗어나지 않는 선에서 자유롭게 구성하시면 됩니다.레벨 1에서는 탭 바와 각 화면에 해당하는 VC 생성 및 화면 전환 연결만 구현합니다.  2개의 탭 과 3개의 화면을 가진 앱입니다.          UITabBarController 을 사용하여 2개의 탭을 구현합니다.        책 검색 화면          첫 번째 탭에 위치합니다.        책 상세 화면          사용자는 검색 결과의 리스트 아이템을 ‘탭’하여 책 상세 화면에 진입할 수 있습니다.      책 상세 화면은 모달 방식으로 등장합니다.        담은 책 리스트 화면          두번째 탭에 위치합니다.      사용자는 책 상세 화면에서 담기 를 한 책 리스트를 저장한 책 리스트 화면에서 볼 수 있습니다.      Level 2 - 책 검색 화면 구현  화면 구성          사용자는 서치바를 이용해서 책을 검색합니다.                  UISearchBar, UITextField 등을 활용                    사용자는 검색 이후 검색 결과를 리스트를 통해 볼 수 있습니다.      검색 결과 리스트는 컬렉션뷰(혹은 테이블뷰)로 구현합니다.                  FlowLayout 을 사용하셔도 되고,          컬렉션뷰을 사용하시는 경우 CompositionalLayout 을 활용하셔도 좋습니다. (Level4을 구현하신다면 시도해보셔도 좋습니다.)                      검색 기능          사용자는 서치바를 사용하여 책을 검색할 수 있습니다.      검색(입력완료)를 누르면, 검색 결과 리스트에 책 목록이 등장합니다.      검색에는 카카오 책 검색 REST API 를 이용합니다.                  Kakao Developers 검색 제품의 ** 책 검색 기능을 사용합니다.                          https://developers.kakao.com/docs/latest/ko/daum-search/dev-guide#search-book                                          Level 3 - 책 상세 보기 &amp; 담기 기능 구현1. 책 상세 화면  책 상세 화면에서는 검색 결과 응답 내용을 자세하게 보여줍니다.          title      authors      contents      thumbnail      등        담기 버튼을 탭하면          해당 책은 담은 책 목록 화면에서 볼 수 있습니다.      모달은 닫힙니다.        X 버튼을 탭 하면 모달은 닫힙니다.          X 와 담기 버튼의 너비 비율은 1:3~4 정도이면 될 것 같습니다.        (선택 구현) 책 상세 화면은 컨텐츠 양에 따라 스크롤 가능합니다.      (선택 구현) 담기 및 X 버튼은 플로팅 버튼입니다.          즉, 스크롤과 상관없이 항상 화면 위에 노출되어야합니다.        (선택 구현) 모달이 닫힌 이후, 책 검색 화면에서 […]책 담기 완료! 라는 알림창을 보여줍니다.          Delegate 패턴을 활용해봅니다.      2. 담은 책 목록 화면  담은 책 목록 화면은 두번째 탭에 위치합니다.  앱을 종료하고 다시 시작해도 담은 책 목록은 남아있어야합니다.  전체 삭제 버튼을 누르면 담았던 모든 책이 지워집니다.  스와이프 등의 방식을 통하여 담은 책 개별삭제가 가능합니다.  (선택 구현) 추가 버튼을 누르면 첫번째 탭을 보여주고, 서치바를 활성화시킵니다.          UITabBarController      First Responder      우선은 lv3까지 해보려고 한다.Level 1코드로 UIDesign 시작.StoryBoard 삭제.이때 삭제를 스토리보드 삭제말고 2가지를 더 삭제해야한다.이건 info.plist 에서 삭제를 한 모습.이건 Build Settings에서 삭제를 한 모습.1. SceneDelegate 수정.StoryBoard로 구현하기 위해 SceneDelegate에서 기초 작업을 해줘야 한다.func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {        guard let windowScene = (scene as? UIWindowScene) else { return }                let window = UIWindow(windowScene: windowScene)        let vc = ViewController()        window.rootViewController = vc        self.window = window        window.makeKeyAndVisible()            }viewDidLoad에서 backgroundColor를 blue로 해두었다.작동 확인.2. SnapKit 설치이건 뭐 계속 써야하니 설치를 하고 시작하는게 좋을듯 하다.SPM으로 설치한다.CocoaPods은 설치하면 실행파일 달라져서 패스.3. UIDesign우선 사진에 있는 내용을 크게 4개의 section으로 분리를 했다.  SearchView  RecentView  ResultView  Tabbar -&gt; tabbar로 구현 / Button X탭바뷰는 버튼으로 할지 탭바로 할지 고민이 되었으나,코드로 탭바를 구성을 해본적이 없으니 공부도 할겸 탭바는 코드로 결정1. Tabbar 구현우선 탭바를 구현 해둬야 레이아웃을 잡기 편할것 같다는 생각이 들었다.검색을 해보니참고사이트에 좋은 글이 있어서 이걸 기반으로 작성 해본다.Tabbar도 SceneDelegate에서 설정을 한다.func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {                guard let windowScene = (scene as? UIWindowScene) else { return }                let window = UIWindow(windowScene: windowScene)        let vc = ViewController()        self.window = window        window.makeKeyAndVisible()                // added        let tabbarController = UITabBarController()        let firstVC = UINavigationController(rootViewController: vc)                firstVC.tabBarItem = UITabBarItem(            title: \"Search\",            image: UIImage(systemName: \"magnifyingglass.circle\"),            selectedImage: UIImage(systemName: \"magnifyingglass.circle.fill\"))        tabbarController.viewControllers = [firstVC]        window.rootViewController = tabbarController // modifed            }이렇게 탭바를 추가한다.탭바 백그라운드가 있어야 할것 같아서tabbarController.tabBar.backgroundColor = .white 이것도 추가해둔다.2. 틀 잡기.Fok형님의 방법을 적용하여 큰틀에서의 UI구성을 해보았다.class ViewController: UIViewController {        private let searchView = SearchView()    private let recentView = RecentView()    private let resultView = ResultView()        private lazy var vStackView : UIStackView = {        let stackView = UIStackView(arrangedSubviews: [            searchView,            recentView,            resultView,            UIView()        ])                stackView.axis = .vertical        stackView.spacing = 25        return stackView    }()        override func viewDidLoad() {        super.viewDidLoad()        view.backgroundColor = .white        layout()    }        private func layout() {        view.addSubview(vStackView)                vStackView.snp.makeConstraints { make in            make.top.equalTo(view.snp.top).offset(100)            make.leading.trailing.bottom.equalToSuperview()        }                searchView.snp.makeConstraints { make in            make.height.equalTo(65)        }                recentView.snp.makeConstraints { make in            make.height.equalTo(180)        }                resultView.snp.makeConstraints { make in            make.height.equalTo(356)        }    }    }파란색쪽에 searchbar가 들어가고갈색에 CollectionView초록색에 검색결과의 TableView가 들어갈 예정navigatorbar 위치를 고려해 80에서 100으로 변경.3. SearchView 구현우선 대충 구현한다.class SearchView: UIView {        private let searchBar: UISearchBar = {        let bar = UISearchBar()        bar.placeholder = \"검색어를 입력하세요.\"        bar.autocorrectionType = .no        return bar    }()        init () {        super.init(frame: .zero)        layout()    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        private func layout() {        addSubview(searchBar)                searchBar.snp.makeConstraints { make in            make.top.equalToSuperview().offset(10)            make.bottom.equalToSuperview().offset(-10)            make.leading.equalToSuperview().offset(10)            make.trailing.equalToSuperview().offset(-10)        }    }}searchBar에 대한 값 처리는 나중에 Combine을 통해서 구현 예정4. RecentView 구현여기에 필요한건 CollectionView와 UILabel이다.그중에서도 main은 collectionviewclass TextLabel: UILabel {        func makeLabel (textValue: String) -&gt; UILabel {                let label = UILabel()        let text = NSMutableAttributedString(string: textValue, attributes: [.font: UIFont.systemFont(ofSize: 24)])        label.attributedText = text        return label            }}비슷한게 또 ResultView에서 사용이 되어서 그냥 클래스로 만들어 주었다.class RecentView: UIView {        private var textLabel = TextLabel().makeLabel(textValue: \"최근 본 책\")        init () {        super.init(frame: .zero)        layout()    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        private func layout() {        addSubview(textLabel)                textLabel.snp.makeConstraints { make in            make.top.equalToSuperview().offset(5)            make.leading.equalToSuperview().offset(20)            make.width.equalTo(100)            make.height.equalTo(50)        }    }    }이제 컬렉션뷰를 구현해보도록 한다.private var collectionView: UICollectionView = {        let layout = UICollectionViewFlowLayout()        layout.scrollDirection = .horizontal                var view = UICollectionView(frame: .zero, collectionViewLayout: layout)        return view    }()우선 이렇게만 해둔상태.그리고 label과 collectionView를 아우르는 StackView를 하나더 생성 (이게 Fok형 Style)셀을 만들고 ImageView만 넣을 생각class RecentCollectionViewCell: UICollectionViewCell {        private var imageView: UIImageView = {       let view = UIImageView()        view.contentMode = .scaleAspectFill        view.image = UIImage(systemName: \"book\")        view.tintColor = .white        view.clipsToBounds = true        return view    }()        func configure(image: UIImage) {        self.imageView.image = image        self.layout()    }        func layout() {        self.backgroundColor = .white        self.addSubview(imageView)                imageView.snp.makeConstraints { make in            make.leading.bottom.trailing.top.equalToSuperview()        }    }        override func prepareForReuse() {        super.prepareForReuse()        self.imageView.image = nil    }}그리고 cell 등록도 해준다.private var collectionView: UICollectionView = {        let layout = UICollectionViewFlowLayout()        layout.scrollDirection = .horizontal                var view = UICollectionView(frame: .zero, collectionViewLayout: layout)        view.backgroundColor = .blue        view.register(RecentCollectionViewCell.self, forCellWithReuseIdentifier: Constants.collectionViewCellIdentifier) // added        return view    }()하지만 여기서 문제가 생기는건? 바로 delegate와 datasource를 어떻게 처리할것인가이다.우선 그 고민은 나중에 다시해보는걸로..일단 Stackview를 씌우고 실행했을때 error가 발생하던건 모두 해결했다.CollectionView의 bottom이 안먹던것은 uiview를 하나더 추가하면서 해결WTFautolayout사이트를 통해 조절을 했다.private func layout() {        addSubview(vStackView)                vStackView.snp.makeConstraints { make in            make.top.bottom.leading.trailing.equalToSuperview()        }                textLabel.snp.makeConstraints { make in            make.top.equalToSuperview()            make.leading.equalTo(vStackView.snp.leading).offset(20)            make.trailing.equalTo(vStackView.snp.trailing).offset(-20)        }                collectionView.snp.makeConstraints { make in            make.top.equalTo(textLabel.snp.bottom).offset(5)            make.leading.equalTo(vStackView.snp.leading).offset(20)            make.trailing.equalTo(vStackView.snp.trailing).offset(-20)            make.bottom.equalTo(vStackView.snp.bottom).offset(-15)        }    }수정한 layout적용 완료.5. ResultView 구현여기엔 UILable, TableView가 들어오면 될것같다.Cell 구성은 다음과 같다class ResultTableViewCell: UITableViewCell {        private let titleLabel = TextLabel().makeLabel(value: \"Title\")    private let priceLabel = TextLabel().makeLabel(value: \"Price\")        private lazy var hStackView: UIStackView = {        let stackView = UIStackView(arrangedSubviews: [            titleLabel,            priceLabel        ])        stackView.axis = .horizontal        stackView.alignment = .center        return stackView    }()        override func awakeFromNib() {        super.awakeFromNib()        layout()    }        override func setSelected(_ selected: Bool, animated: Bool) {        super.setSelected(selected, animated: animated)                // Configure the view for the selected state    }        private func layout () {        addSubview(hStackView)                hStackView.snp.makeConstraints { make in            make.leading.bottom.trailing.top.equalToSuperview()        }                titleLabel.snp.makeConstraints { make in            make.leading.equalTo(hStackView.snp.leading).offset(10)            make.top.equalTo(hStackView.snp.top).offset(10)            make.bottom.equalTo(hStackView.snp.bottom).offset(-10)            make.width.equalTo(150)        }                priceLabel.snp.makeConstraints { make in            make.leading.equalTo(titleLabel.snp.trailing).offset(-25)            make.trailing.equalTo(hStackView.snp.trailing).offset(-10)            make.top.equalTo(hStackView.snp.top).offset(10)            make.bottom.equalTo(hStackView.snp.bottom).offset(-10)            make.width.equalTo(100)        }    }    }아직 sample이 없어 자세한 확인은 불가.추후에 Autolayout에 대한 값이 수정이 될듯 하다.class ResultView: UIView {        private let textLabel = TextLabel().makeLabel(textValue: \"검색 결과\")        private let tableView: UITableView = {        let tableView = UITableView()        tableView.backgroundColor = .cyan        tableView.allowsSelection = false        tableView.register(ResultTableViewCell.self, forCellReuseIdentifier: Constants.tableViewCellIdentifier)                return tableView    }()        private lazy var vStackView: UIStackView = {       let stackView = UIStackView(arrangedSubviews: [        textLabel,        tableView,       ])        stackView.axis = .vertical        stackView.spacing = 10        stackView.alignment = .center        return stackView    }()        init () {        super.init(frame: .zero)        layout()    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        private func layout() {        addSubview(vStackView)                        vStackView.snp.makeConstraints { make in            make.top.bottom.leading.trailing.equalToSuperview()        }                textLabel.snp.makeConstraints { make in            make.top.equalTo(vStackView.snp.top)            make.leading.equalTo(vStackView.snp.leading).offset(20)            make.trailing.equalTo(vStackView.snp.trailing).offset(-20)            make.bottom.equalTo(tableView.snp.top).offset(-10)        }                tableView.snp.makeConstraints { make in            make.leading.equalTo(vStackView.snp.leading).offset(20)            make.trailing.equalTo(vStackView.snp.trailing).offset(-20)            make.bottom.equalTo(vStackView.snp.bottom)        }    }        }우선 이렇게 구현을 했다.autolayout에 대한 error는 모두 해결 (Cell 제외)"
  },
  
  {
    "title": "Tip-Calculator (9)",
    "url": "/posts/Tip-Calculator-(9)/",
    "categories": "Udemy, Combine",
    "tags": "",
    "date": "2024-05-04 10:13:00 +0900",
    





    
    "snippet": "UI TestHacking with Swift에서 어떤 property를 사용할지 확인이 가능하다.파일을 하나 만들어준다.UITest를 체크를 꼭 하자.이 파일은 일종의 Constants를 관리한다.enum ScreenIdentifier {        enum ResultView: String {        case totalAmountPerPer...",
    "content": "UI TestHacking with Swift에서 어떤 property를 사용할지 확인이 가능하다.파일을 하나 만들어준다.UITest를 체크를 꼭 하자.이 파일은 일종의 Constants를 관리한다.enum ScreenIdentifier {        enum ResultView: String {        case totalAmountPerPersonValueLabel        case totalBillValueLabel        case totalTipValueLabel    }}이렇게 ResultView에 대한 identifier를 열거형을 통해 만들어준다.그리고 ResultView로 돌아가서, private let amountPersonLabel: UILabel = {        let label = UILabel()        label.textAlignment = .center        let text = NSMutableAttributedString(            string: \"$0\",            attributes: [                .font: ThemeFont.bold(ofSize: 48)            ]        )        // $ 부분만 작게        text.addAttributes([            .font: ThemeFont.bold(ofSize: 24)        ], range: NSMakeRange(0, 1))        label.attributedText = text        label.accessibilityIdentifier = ScreenIdentifier.ResultView.totalAmountPerPersonValueLabel.rawValue // added        return label    }()이렇게 Identifier를 통해 접근할수있게 해준다.나머지 tip, bill은 AmountLabel을 통해 만들어졌으므로다시 AmountLabel로 가서private let amountLabelIdentifier: String // added    private lazy var amountLabel: UILabel = {        let label = UILabel()        label.textAlignment = textAlignment        label.textColor = ThemeColor.primary        let text = NSMutableAttributedString(            string: \"$0\",            attributes: [                .font: ThemeFont.bold(ofSize: 24)            ])        text.addAttributes([            .font: ThemeFont.bold(ofSize: 16)        ], range: NSMakeRange(0, 1))        label.attributedText = text        label.accessibilityIdentifier = amountLabelIdentifier // added        return label    }()    이렇게 일종의 dependency를 만들어 주었다.그리고 뜨는 initializer 부분의 에러// custom Initializer    init(title: String, textAlignment: NSTextAlignment, amountLabelIdentifier: String) { // modified        self.title = title        self.textAlignment = textAlignment        self.amountLabelIdentifier = amountLabelIdentifier // added        super.init(frame: .zero)        layout()    }여기에도 identifier를 추가.여기에 추가하게되면 우리가 Resultview에서 AmountLabel을 사용하는 label도 그대로 init을 다시 해주면 된다.친절하다.private let totalBillView: AmountView = {       let view = AmountView(            title: \"Total Bill\",            textAlignment: .left,            amountLabelIdentifier: ScreenIdentifier.ResultView.totalBillValueLabel.rawValue) // added        return view    }()        private let totalTipView: AmountView = {       let view = AmountView(            title: \"Total Tip\",            textAlignment: .right,            amountLabelIdentifier: ScreenIdentifier.ResultView.totalTipValueLabel.rawValue) // added        return view    }()그리고 런치 테스트는 필요없으니까 쓰레기통그리고 uitests파일 역시 지난번 test처럼 내부 함수는 다 지워준다.import XCTestfinal class tip_calculatorUITests: XCTestCase {   }새로운 파일을 생성해준다 CaculatorScreen이라는 class 파일을 하나 생성을 해주었고,import XCTestclass CalculatorScreen {        private let app: XCUIApplication        init(app: XCUIApplication) {        self.app = app    }        var amountPerPersonValueLabel: XCUIElement {        return app.staticTexts[ScreenIdentifier.ResultView.totalAmountPerPersonValueLabel.rawValue]    }        var totalBillValueLabel: XCUIElement {        return app.staticTexts[ScreenIdentifier.ResultView.totalBillValueLabel.rawValue]    }        var totalTipValueLabel: XCUIElement {        return app.staticTexts[ScreenIdentifier.ResultView.totalTipValueLabel.rawValue]    }}다음과 같이 적었다.app instance를 하나 만들어 주었고 initialize를 한뒤,각각의 label을 만들어 주는데, 이때 아까전에 설정해둔 Identifier를 통해 우리가 접근을 가능하게 한다.다시 uitest로 돌아가서,final class tip_calculatorUITests: XCTestCase {        private var app: XCUIApplication!        private var screen: CalculatorScreen {        CalculatorScreen(app: app)    }       override func setUp() {        super.setUp()        app = .init()        app.launch()    }        override func tearDown() {        super.tearDown()        app = nil    }        func testResultViewDefaultValues() {        XCTAssertEqual(screen.totalAmountPerPersonValueLabel.label, \"$0\")        XCTAssertEqual(screen.totalBillValueLabel.label, \"$0\")        XCTAssertEqual(screen.totalTipValueLabel.label, \"$0\")    }}다음과 같이 작성을 해준다.그리고 테스트를 돌리니 pass그런데 저기서 value의 $0을 $1로 바꾸면 에러가 발생,왜냐 초기화면에서는 전부 $0 으로 되어있어서 같지 않기 때문.testResultViewDefaultValues의 함수는 ui의 resultview label의 초기화면 값이 설정한 값과 같은지를 테스트한다.모든 Identifier 추가.다시 ScreenIdentifier로 돌아가서,enum ScreenIdentifier {        enum LogoView: String { // added        case logoView    }        enum ResultView: String {        case totalAmountPerPersonValueLabel        case totalBillValueLabel        case totalTipValueLabel    }        enum BillInputView: String { // added        case textField            }        enum TipInputView: String { // added        case tenPercentButton        case fifteenPercentButton        case twentyPercentButton        case customTipButton    }            enum SplitInputView: String { // added        case decrementButton        case incrementButton        case quantityValueLabel    }}ui에 해당하는 것을 모두 등록을 해준다.1. Logoview Identifierinit () {        super.init(frame: .zero)        accessibilityIdentifier = ScreenIdentifier.LogoView.logoView.rawValue // added        layout()    }logoview 전체에 대한 identifier를 등록.2. BillInputView Identifierprivate lazy var textField: UITextField = {        let textField = UITextField()        textField.borderStyle = .none        textField.font = ThemeFont.demibold(ofSize: 28)        textField.keyboardType = .decimalPad        textField.setContentHuggingPriority(.defaultLow, for: .horizontal)        textField.tintColor = ThemeColor.text        textField.textColor = ThemeColor.text        textField.accessibilityIdentifier = ScreenIdentifier.BillInputView.textField.rawValue // added        // Add Toolbar        let toolBar = UIToolbar(frame: CGRect(x: 0, y: 0, width: frame.size.width, height: 36))        toolBar.barStyle = .default        toolBar.sizeToFit()        let doneButton = UIBarButtonItem(            title: \"Done\",            style: .plain,            target: self,            action: #selector(doneButtonTapped))        toolBar.items = [            UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil),            doneButton        ]        toolBar.isUserInteractionEnabled = true        textField.inputAccessoryView = toolBar        return textField    }()3. TipInputView Identifier private lazy var tenPercentTipButton: UIButton = {        let button = buildTipButton(tip: .tenPercent)        button.accessibilityIdentifier = ScreenIdentifier.TipInputView.tenPercentButton.rawValue // added        button.tapPublisher.flatMap({            Just(Tip.tenPercent)        }).assign(to: \\.value, on: tipSubject).store(in: &amp;cancellables)        return button    }()이건 하나로 대체,나머지도 button도 상동4. SplitInputView Identifierprivate lazy var incrementButton: UIButton = {        let button = buildButton(text: \"+\", corners: [.layerMaxXMinYCorner, .layerMaxXMaxYCorner])        button.accessibilityIdentifier = ScreenIdentifier.SplitInputView.incrementButton.rawValue // added        button.tapPublisher.flatMap { [unowned self] _ in            Just(splitSubject.value + 1)        }.assign(to: \\.value, on: splitSubject)            .store(in: &amp;cancellables)        return button    }()        private lazy var quantityLabel: UILabel = {        let label = LabelFactory.build(            text: \"1\",            font: ThemeFont.bold(ofSize: 20),backgroundColor: .white)        label.accessibilityIdentifier = ScreenIdentifier.SplitInputView.quantityValueLabel.rawValue // added        return label    }()QuantityLabel의 경우 우리가 보통 label.text 이런식으로 text property에 접근을 하다보니 자연스레 text를 쓰게 되는데 여기서는 label 그 자체를 해주는게 포인트.버튼은 3번과 동일.CaculatorScreen에 모든 view 추가class CalculatorScreen {        private let app: XCUIApplication        init(app: XCUIApplication) {        self.app = app    }        // LogoView    var logoView: XCUIElement {        app.otherElements[ScreenIdentifier.LogoView.logoView.rawValue]    }            // ResultView    var totalAmountPerPersonValueLabel: XCUIElement {        app.staticTexts[ScreenIdentifier.ResultView.totalAmountPerPersonValueLabel.rawValue]    }        var totalBillValueLabel: XCUIElement {        app.staticTexts[ScreenIdentifier.ResultView.totalBillValueLabel.rawValue]    }        var totalTipValueLabel: XCUIElement {        app.staticTexts[ScreenIdentifier.ResultView.totalTipValueLabel.rawValue]    }        // BillInputView    var billInputViewTextField: XCUIElement {        app.textFields[ScreenIdentifier.BillInputView.textField.rawValue]    }        // TipInputView    var tenPercentTipButton: XCUIElement {        app.buttons[ScreenIdentifier.TipInputView.tenPercentButton.rawValue]    }        var fifteenPercentTipButton: XCUIElement {        app.buttons[ScreenIdentifier.TipInputView.fifteenPercentButton.rawValue]    }        var twentyPercentTipButton: XCUIElement {        app.buttons[ScreenIdentifier.TipInputView.twentyPercentButton.rawValue]    }        var customTipButton: XCUIElement {        app.buttons[ScreenIdentifier.TipInputView.customTipButton.rawValue]    }        // customTip을 입력하려고 하면 뜨는 textField도 추가.    var customTipAlertTextField: XCUIElement {        app.textFields[ScreenIdentifier.TipInputView.customTipAlertTextField.rawValue]    }        // SplitInputView    var incrementButton: XCUIElement {        app.buttons[ScreenIdentifier.SplitInputView.incrementButton.rawValue]    }        var decrementButton: XCUIElement {        app.buttons[ScreenIdentifier.SplitInputView.decrementButton.rawValue]    }        var splitValueLabel: XCUIElement {        app.staticTexts[ScreenIdentifier.SplitInputView.quantityValueLabel.rawValue]    }        // Actions    func enterBill(amount: Double) {        billInputViewTextField.tap() // 실제 텍스트 필드를 탭한것과 같은 효과        billInputViewTextField.typeText(\"\\(amount)\\n\") // parmeter값을 입력한뒤, \\n을 하면서 키보드를 닫게함.    }        func selectTip(tip: Tip) {        switch tip {        case .tenPercent:            tenPercentTipButton.tap()        case .fifteenPercent:            fifteenPercentTipButton.tap()        case .twentyPercent:            twentyPercentTipButton.tap()        case .custom(let value):            customTipButton.tap()            XCTAssertTrue(customTipAlertTextField.waitForExistence(timeout: 1.0)) // tip alert view가 보여지기까지 기다려줌            customTipAlertTextField.typeText(\"\\(value)\\n\") // alert가 나오면 textfield에 값 입력        }            }        func selectIncrementButton(numberOfTaps: Int) {            incrementButton.tap(withNumberOfTaps: numberOfTaps, numberOfTouches: 1)        }            func selectdecrementButton(numberOfTaps: Int) {            decrementButton.tap(withNumberOfTaps: numberOfTaps, numberOfTouches: 1)        }            func doubleTapLogoView() {            logoView.tap(withNumberOfTaps: 2, numberOfTouches: 1)        }    enum Tip {        case tenPercent        case fifteenPercent        case twentyPercent        case custom(value: Int)    }        }코드로 대체코드만 봐도 크게 어려움은 없다.디테일한건 주석을 달아두었음.test에 조건을 부여조건 : $100의 bill, tip은 10%/15%/20%/, split 4/2// UItestsfunc testRegulapTip() {        // user enters a $100 bill        screen.enterBill(amount: 100)        XCTAssertEqual(screen.totalAmountPerPersonValueLabel.label, \"$100\")        XCTAssertEqual(screen.totalBillValueLabel.label, \"$100\")        XCTAssertEqual(screen.totalTipValueLabel.label, \"$0\")    }이렇게 조건을 추가.실행하니갑자기 표기법이 달라진다?$ → ₩ ??의심이 가는 부분이 있어 지역을 미국으로 변경테스트 재실행.테스트 성공.지역이 달라 표기법이 바뀐 문제였다.func testRegularTip() {    // User enters a $100 bill    screen.enterBill(amount: 100)    XCTAssertEqual(screen.totalAmountPerPersonValueLabel.label, \"$100\")    XCTAssertEqual(screen.totalBillValueLabel.label, \"$100\")    XCTAssertEqual(screen.totalTipValueLabel.label, \"$0\")      // User selects 10%    screen.selectTip(tip: .tenPercent)    XCTAssertEqual(screen.totalAmountPerPersonValueLabel.label, \"$110\")    XCTAssertEqual(screen.totalBillValueLabel.label, \"$110\")    XCTAssertEqual(screen.totalTipValueLabel.label, \"$10\")    // User selects 15%    screen.selectTip(tip: .fifteenPercent)    XCTAssertEqual(screen.totalAmountPerPersonValueLabel.label, \"$115\")    XCTAssertEqual(screen.totalBillValueLabel.label, \"$115\")    XCTAssertEqual(screen.totalTipValueLabel.label, \"$15\")    // User selects 20%    screen.selectTip(tip: .twentyPercent)    XCTAssertEqual(screen.totalAmountPerPersonValueLabel.label, \"$120\")    XCTAssertEqual(screen.totalBillValueLabel.label, \"$120\")    XCTAssertEqual(screen.totalTipValueLabel.label, \"$20\")    // User splits the bill by 4    screen.selectIncrementButton(numberOfTaps: 3)    XCTAssertEqual(screen.totalAmountPerPersonValueLabel.label, \"$30\")    XCTAssertEqual(screen.totalBillValueLabel.label, \"$120\")    XCTAssertEqual(screen.totalTipValueLabel.label, \"$20\")    // User splits the bill by 2    screen.selectDecrementButton(numberOfTaps: 2)    XCTAssertEqual(screen.totalAmountPerPersonValueLabel.label, \"$60\")    XCTAssertEqual(screen.totalBillValueLabel.label, \"$120\")    XCTAssertEqual(screen.totalTipValueLabel.label, \"$20\")  }두번째 부터 에러가 발생.뭐가 잘못되었는지 확인이 필요.우선 확실한건 로고쪽만 2번이 탭되었을때 리셋이 되어야하는데 지금 다른부분 탭을해도 리셋이 되는게 문제이다그래서 screen.selectIncrementButton(numberOfTaps: 3) 여기서 리셋이 되어버려 문제가 되는것도 있다.문제 해결 private lazy var logoviewTapPublisher: AnyPublisher&lt;Void, Never&gt; = {        let tapGesture = UITapGestureRecognizer(target: self, action: nil)        tapGesture.numberOfTapsRequired = 2        logoView.addGestureRecognizer(tapGesture) // modified        return tapGesture.tapPublisher.flatMap { _ in            Just(())        }.eraseToAnyPublisher()    }()코드를 보다가 logoview쪽에 뭔가가 문제가 있다고 판단해서 찾아보던중logoView.addGestureRecognizer 이었어야 하는데 View.addGestureRecognizer 로 해버렸다.그러니 모든 화면에서 리셋이 된것이다.이걸해결하니 모든 문제가 해결.테스트는 이런식으로 진행이됨.상당히 빠르다.이렇게 테스트를 하면서 우리가 답으로 설정해둔값과 같은지를 비교한다.CustomTip 조건 설정바로 밑에 다음과 같이 조건을 적어보자func testCustomTipAndSplitBillBy2() {    screen.enterBill(amount: 300)    screen.selectTip(tip: .custom(value: 200))    screen.selectIncrementButton(numberOfTaps: 1)    XCTAssertEqual(screen.totalBillValueLabel.label, \"$500\")    XCTAssertEqual(screen.totalTipValueLabel.label, \"$200\")    XCTAssertEqual(screen.totalAmountPerPersonValueLabel.label, \"$250\")  }$300를 입력하고 tip으로 $200 입력하고 1명을 더 추가 했을때결과값으로 우리가 위에 설정한 값이 나오면 된다.하지만 실패그냥 얼타고있다?무엇이 문제일까?customTip 과 관련된 부분을 가보니에러가 났음을 표시해주고 있다.우선 customTipAlertTextField 에 대한 identifier가 없다.// CalculatorScreen// customTip을 입력하려고 하면 뜨는 textField도 추가.    var customTipAlertTextField: XCUIElement {        app.textFields[ScreenIdentifier.TipInputView.customTipAlertTextField.rawValue]    }이렇게 적었는데 없다는게 무슨말일까? 라고 한다면.// tipinputviewprivate func handleCustomTipButton() {        let alertController: UIAlertController = {            let controller = UIAlertController(title: \"Enter Custom Tip\", message: nil, preferredStyle: .alert)            controller.addTextField { textField in                textField.placeholder = \"Make it generous!\"                textField.keyboardType = .numberPad                textField.autocorrectionType = .no            }            let cancelAction = UIAlertAction(title: \"Cancel\", style: .cancel)            let okAction = UIAlertAction(title: \"OK\", style: .default) { [weak self] _ in                guard let text = controller.textFields?.first?.text, let value = Int(text) else { return }                self?.tipSubject.send(.custom(value: value))            }            [okAction, cancelAction].forEach(controller.addAction(_:))            return controller        }()        parentViewController?.present(alertController, animated: true)    }바로 여기 textField에 identifier를 등록하지 않았기에tester가 계속 textfield에 접근하지 못해 얼타면서 timeout이 발생했던것.private func handleCustomTipButton() {        let alertController: UIAlertController = {            let controller = UIAlertController(title: \"Enter Custom Tip\", message: nil, preferredStyle: .alert)            controller.addTextField { textField in                textField.placeholder = \"Make it generous!\"                textField.keyboardType = .numberPad                textField.autocorrectionType = .no                textField.accessibilityIdentifier = ScreenIdentifier.TipInputView.customTipAlertTextField.rawValue // added            }            let cancelAction = UIAlertAction(title: \"Cancel\", style: .cancel)            let okAction = UIAlertAction(title: \"OK\", style: .default) { [weak self] _ in                guard let text = controller.textFields?.first?.text, let value = Int(text) else { return }                self?.tipSubject.send(.custom(value: value))            }            [okAction, cancelAction].forEach(controller.addAction(_:))            return controller        }()        parentViewController?.present(alertController, animated: true)    }이렇게 추가를 해주자.다시 테스트하면 성공.이제는 제대로 textField에 값을 입력한다.리셋 기능 테스트func testResetButton() {        screen.enterBill(amount: 300)        screen.selectTip(tip: .custom(value: 200))        screen.selectIncrementButton(numberOfTaps: 1)        screen.doubleTapLogoView()        XCTAssertEqual(screen.totalBillValueLabel.label, \"$0\")        XCTAssertEqual(screen.totalTipValueLabel.label, \"$0\")        XCTAssertEqual(screen.totalAmountPerPersonValueLabel.label, \"$0\")        XCTAssertEqual(screen.billInputViewTextField.label, \"\")        XCTAssertEqual(screen.splitValueLabel.label, \"1\")        XCTAssertEqual(screen.customTipButton.label, \"Custom Tip\")    }이렇게 위에 먼저 조건을 설정하고 로고뷰를 두번 탭했을대 제대로 리셋이 되는지에 대한 테스트이다.테스트해보니 잘된다끝4시간 반짜리 강의였던걸로 기억하는데 너무 신선한 충격 + 도움을 준 강의였다.Fok형 Respect"
  },
  
  {
    "title": "Tip-Calculator (8)",
    "url": "/posts/Tip-Calculator-(8)/",
    "categories": "Udemy, Combine",
    "tags": "",
    "date": "2024-05-03 23:13:00 +0900",
    





    
    "snippet": "Add image Snapshot test  Snapshot Test      간단하게 말해서 디자인 시안대로 UI를 잘 구현했는가에 대한 테스트  Snapshot Test Github여기에 들어가면 readme에 설명이 있다.이 라이브러리를 사용해서 테스트를 한다.import XCTestimport SnapshotTesting@testable imp...",
    "content": "Add image Snapshot test  Snapshot Test      간단하게 말해서 디자인 시안대로 UI를 잘 구현했는가에 대한 테스트  Snapshot Test Github여기에 들어가면 readme에 설명이 있다.이 라이브러리를 사용해서 테스트를 한다.import XCTestimport SnapshotTesting@testable import tip_calculatorfinal class tip_calculatorSnapshotTests: XCTestCase {        private var screenWidth: CGFloat {        return UIScreen.main.bounds.size.width    }        func testLogoView() {        // given        let size = CGSize(width: screenWidth, height: 48)                        // when        let view = LogoView()                // then        assertSnapshot(matching: view, as: .image(size: size), record: true)            }}record를 true하면서 Logoview에 대한 이미지가 생긴다.이제 이사진을 가지고 비교를 하게된다..그래서 record를 true하여 원본 사진을 남겨놔야한다.만약 누가 logoview의 디자인을 수정했다면? private let topLabel: UILabel = {        let label = UILabel()        let text = NSMutableAttributedString(string: \"Mr TIPs\",attributes: [.font: ThemeFont.demibold(ofSize: 16)])        text.addAttributes([.font: ThemeFont.bold(ofSize: 24)], range: NSMakeRange(3, 3)) // TIP부분 더 강조        label.attributedText = text        return label    }()Mr TIP → MR TIPs로 변경그리고 테스트를 하면?에러 발생.그 경로에 있는 이미지파일을 실행해서 비교해보면?위에 있는게 변형한것,아래있는게 오리지널디자인의 변화가 생겨서 Test Fail이 발생한다.Result View Testfunc testInitialResultView() {        // given        let size = CGSize(width: screenWidth, height: 224)        // when        let view = ResultView()                // then        assertSnapshot(matching: view, as: .image(size: size), record: true)    }이렇게 이미지를 만들어주고record를 지우고 실행.Tip Input View Testfunc testInitialTipInputView() {        // given        let size = CGSize(width: screenWidth, height: 56+56+16)        // when        let view = TipInputView()                // then        assertSnapshot(matching: view, as: .image(size: size))    }Bill Input View Testfunc testInitialBillInputView() {        // given        let size = CGSize(width: screenWidth, height: 56)        // when        let view = BillInputView()                // then        assertSnapshot(matching: view, as: .image(size: size))    }Split Input View Testfunc testInitialSplitInputView() {        // given        let size = CGSize(width: screenWidth, height: 56)        // when        let view = SplitInputView()                // then        assertSnapshot(matching: view, as: .image(size: size))    }Custom Value로 Snapshot TestStackOverFlow 참고func testResultViewWithValues() {        // given        let size = CGSize(width: screenWidth, height: 224)        let result = Result(            amountPerPerson: 100.25,            totalBill: 45,            totalTip: 60)                // when        let view = ResultView()        view.configure(result: result)                // then        assertSnapshot(matching: view, as: .image(size: size), record: true)    }이렇게 값이 입력된 view가 생성됨.BillInputView test그전에 위의 스택오버플로우 사이트에서 extension을 적용func testBillInputViewWithValues() {        // given        let size = CGSize(width: screenWidth, height: 56)        // when        let view = BillInputView()        let textField = view.allSubViewsOf(type: UITextField.self).first        textField?.text = \"500\"        // then        assertSnapshot(matching: view, as: .image(size: size))    }그리고let textField = view.allSubViewsOf(type: UITextField.self).firsttextField?.text = \"500\"여기서 Extension을 사용하는데이렇게 실제로 입력된것처럼 보인다.TipInput View Testfunc testTipInputViewWithValues() {        // given        let size = CGSize(width: screenWidth, height: 56+56+16)                // when        let view = TipInputView()        let button = view.allSubViewsOf(type: UIButton.self).first        button?.sendActions(for: .touchUpInside)        // then        assertSnapshot(matching: view, as: .image(size: size))}역시나 선택 된 것처럼 구현이 가능.SplitInputView Testfunc testSplitInputViewWithSelection() {        // given        let size = CGSize(width: screenWidth, height: 56)                // when        let view = SplitInputView()        let button = view.allSubViewsOf(type: UIButton.self).last        button?.sendActions(for: .touchUpInside)        // then        assertSnapshot(matching: view, as: .image(size: size))    }여기서 button의 first를 하게되면 - 버튼을 클릭하는데 숫자의 변화가 없기에 last를 선택하여 + 버튼이 클릭되는 이벤트가 보여지게 한다.이렇게 snapshot test를 할 수 있다.포인트는 먼저 record: true를 하고, 원본을 저장하고 이후에 ui를 재확인할때 하면 좋을듯 하다."
  },
  
  {
    "title": "Tip-Calculator (7)",
    "url": "/posts/Tip-Calculator-(7)/",
    "categories": "Udemy, Combine",
    "tags": "",
    "date": "2024-05-03 22:13:00 +0900",
    





    
    "snippet": "Unit Test 세팅import XCTestimport Combine@testable import tip_calculatorfinal class tip_calculatorTests: XCTestCase {    override func setUp() {        super.setUp()    }            override func tea...",
    "content": "Unit Test 세팅import XCTestimport Combine@testable import tip_calculatorfinal class tip_calculatorTests: XCTestCase {    override func setUp() {        super.setUp()    }            override func tearDown() {        super.tearDown()    }}test 클래스 안에 있던 모든 함수들을 다 지우고 setUp만 만든다.이떄 set치면 여러개가 나오고 첫번째 세번째가 같은 setUp인데 이때 3번째걸 해줘야한다.첫번째것은 classteardown도 마찬가지.  setUp?      기본값을 생성할때 사용          객체 인스턴스생성, db초기화, 규칙 작성 등        tearDown?      초기상태로 복원할때 사용          파일 닫기, 연결, 새로 만든 항목 제거 등      출처재생버튼같은걸 누르면테스트가 무사히 끝나면초록색으로 v가 된다는데 난 왜 안되는지 모르겠다.final class tip_calculatorTests: XCTestCase {        // Sut -&gt; System Under Test        private var sut: CalculatorVM!    private var cancellables: Set&lt;AnyCancellable&gt;!        override func setUp() {        sut = .init()        cancellables = .init()        super.setUp()    }            override func tearDown() {        super.tearDown()        sut = nil        cancellables = nil    }}setup할때 init을 해주고끝나면 nil로 바꿔준다.$100 bill, None Tip, 1명이라는 조건으로 테스트를 하는 시나리오를 만들어 보자.private let logoViewTapSubject = PassthroughSubject&lt;Void, Never&gt;()func testResultWithoutTipFor1Person() {        // given        let bill: Double = 100.0        let tip: Tip = .none        let split: Int = 1        let input = buildInput(bill: bill, tip: tip, split: split)                // when        let output = sut.transform(input: input)                // then        output.updateViewPublisher.sink { result in            XCTAssertEqual(result.amountPerPerson, 100)            XCTAssertEqual(result.totalBill, 100)            XCTAssertEqual(result.totalTip, 0)        }.store(in: &amp;cancellables)    }        private func buildInput(bill: Double, tip: Tip, split: Int) -&gt; CalculatorVM.Input {        return .init(            billPublisher: Just(bill).eraseToAnyPublisher(),            tipPublisher: Just(tip).eraseToAnyPublisher(),            splitPublisher: Just(split).eraseToAnyPublisher(),            logoViewTapPublisher: logoViewTapSubject.eraseToAnyPublisher())    }이때 위에 왜 logoViewTapSubject를 만들었냐면 우리가 사운드 테스트는 하지 않을것이라서 그렇다.given에 주어지는 조건을 만들고.transform을 통해 들어온값을 output으로 보냄output에선 publisher를 통해 처리XCTAssertEqual(result.amountPerPerson, 100) XCTAssertEqual(result.totalBill, 100)XCTAssertEqual(result.totalTip, 0)한사람이 내야할돈 100전체 돈 100팁 0이기에 위와 같이 했다.테스트 성공만약에 값을 다르게 주면?이렇게 에러가 발생한다.조건을 더 추가하여 테스트추가하려는 조건은 아래와 같다.  2명이고 팁이 없다.  2명이고 10% 팁이 있다.  4명이고 Custom Tip이 존재1. 2명이고 팁이 없는 조건func testResultWithoutTipFor2Person() {        // given        let bill: Double = 100.0        let tip: Tip = .none        let split: Int = 2        let input = buildInput(bill: bill, tip: tip, split: split)                // when        let output = sut.transform(input: input)                // then        output.updateViewPublisher.sink { result in            XCTAssertEqual(result.amountPerPerson, 50)            XCTAssertEqual(result.totalBill, 100)            XCTAssertEqual(result.totalTip, 0)        }.store(in: &amp;cancellables)    }2. 2명이고 10% 팁이 있는 조건func testResultWith10PercentTipFor2Person() {        // given        let bill: Double = 100.0        let tip: Tip = .tenPercent        let split: Int = 2        let input = buildInput(bill: bill, tip: tip, split: split)                // when        let output = sut.transform(input: input)                // then        output.updateViewPublisher.sink { result in            XCTAssertEqual(result.amountPerPerson, 55)            XCTAssertEqual(result.totalBill, 110)            XCTAssertEqual(result.totalTip, 10)        }.store(in: &amp;cancellables)    }3. 4명이고 Custom Tip이 존재하는 조건func testResultWithCustomTipFor4Person() {        // given        let bill: Double = 200.0        let tip: Tip = .custom(value: 201)        let split: Int = 4        let input = buildInput(bill: bill, tip: tip, split: split)                // when        let output = sut.transform(input: input)                // then        output.updateViewPublisher.sink { result in            XCTAssertEqual(result.amountPerPerson, 100.25)            XCTAssertEqual(result.totalBill, 401)            XCTAssertEqual(result.totalTip, 201)        }.store(in: &amp;cancellables)    }이렇게 테스트가 가능하다.이렇게 했는데 테스트가 실패한다면 로직이 잘못짜여있다는걸 의미한다.그럴땐 계산로직을 확인해봐야함.Logoview Double Tap Testfunc testSoundPlayedCalculatorResetOnLogoViewTap() {        // given        let input = buildInput(bill: 100, tip: .tenPercent, split: 2)        let output = sut.transform(input: input)        let expectation1 = XCTestExpectation(description: \"reset calculator called\")                // then        output.resetCalculatorPublisher.sink { _ in            expectation1.fulfill()        }.store(in: &amp;cancellables)                // when        logoViewTapSubject.send()        wait(for: [expectation1], timeout: 1.0)    }expectation1.fulfill()을 실행하지 않으면 에러가 발생한다.저부분은 나중에 다시 서술하도록 하는걸로.override func setUp() {        sut = .init()        cancellables = .init()        super.setUp()    }아까 init에 audio를 하지않았기에,오디오 테스트를 하기위해 init 수정목업 같은 오디오 플레이어 생성class MockAudioPlayerService: AudioPlayerService {        var expectation = XCTestExpectation(description: \"playSound is Called\")        func playSound() {        expectation.fulfill()    }}private var audioPlayerService: MockAudioPlayerService!    override func setUp() {    audioPlayerService = .init() // added    sut = .init(audioPlayerService: audioPlayerService) // modified    cancellables = .init()    super.setUp()}func testSoundPlayedCalculatorResetOnLogoViewTap() {        // given        let input = buildInput(bill: 100, tip: .tenPercent, split: 2)        let output = sut.transform(input: input)        let expectation1 = XCTestExpectation(description: \"reset calculator called\")        let expectation2 = audioPlayerService.expectation // added                // then        output.resetCalculatorPublisher.sink { _ in            expectation1.fulfill()        }.store(in: &amp;cancellables)                // when        logoViewTapSubject.send()        wait(for: [expectation1, expectation2], timeout: 1.0) // modified    }전체코드import XCTestimport Combine@testable import tip_calculatorfinal class tip_calculatorTests: XCTestCase {        // Sut -&gt; System Under Test        private var sut: CalculatorVM!    private var cancellables: Set&lt;AnyCancellable&gt;!        private var logoViewTapSubject: PassthroughSubject&lt;Void, Never&gt;!    private var audioPlayerService: MockAudioPlayerService!        override func setUp() {        audioPlayerService = .init()        sut = .init(audioPlayerService: audioPlayerService)        logoViewTapSubject = .init()        cancellables = .init()        super.setUp()    }            override func tearDown() {        super.tearDown()        sut = nil        cancellables = nil        audioPlayerService = nil        logoViewTapSubject = nil    }        func testResultWithoutTipFor1Person() {        // given        let bill: Double = 100.0        let tip: Tip = .none        let split: Int = 1        let input = buildInput(bill: bill, tip: tip, split: split)                // when        let output = sut.transform(input: input)                // then        output.updateViewPublisher.sink { result in            XCTAssertEqual(result.amountPerPerson, 100)            XCTAssertEqual(result.totalBill, 100)            XCTAssertEqual(result.totalTip, 0)        }.store(in: &amp;cancellables)    }        private func buildInput(bill: Double, tip: Tip, split: Int) -&gt; CalculatorVM.Input {        return .init(            billPublisher: Just(bill).eraseToAnyPublisher(),            tipPublisher: Just(tip).eraseToAnyPublisher(),            splitPublisher: Just(split).eraseToAnyPublisher(),            logoViewTapPublisher: logoViewTapSubject.eraseToAnyPublisher())    }        func testResultWithoutTipFor2Person() {        // given        let bill: Double = 100.0        let tip: Tip = .none        let split: Int = 2        let input = buildInput(bill: bill, tip: tip, split: split)                // when        let output = sut.transform(input: input)                // then        output.updateViewPublisher.sink { result in            XCTAssertEqual(result.amountPerPerson, 50)            XCTAssertEqual(result.totalBill, 100)            XCTAssertEqual(result.totalTip, 0)        }.store(in: &amp;cancellables)    }        func testResultWith10PercentTipFor2Person() {        // given        let bill: Double = 100.0        let tip: Tip = .tenPercent        let split: Int = 2        let input = buildInput(bill: bill, tip: tip, split: split)                // when        let output = sut.transform(input: input)                // then        output.updateViewPublisher.sink { result in            XCTAssertEqual(result.amountPerPerson, 55)            XCTAssertEqual(result.totalBill, 110)            XCTAssertEqual(result.totalTip, 10)        }.store(in: &amp;cancellables)    }        func testResultWithCustomTipFor4Person() {        // given        let bill: Double = 200.0        let tip: Tip = .custom(value: 201)        let split: Int = 4        let input = buildInput(bill: bill, tip: tip, split: split)                // when        let output = sut.transform(input: input)                // then        output.updateViewPublisher.sink { result in            XCTAssertEqual(result.amountPerPerson, 100.25)            XCTAssertEqual(result.totalBill, 401)            XCTAssertEqual(result.totalTip, 201)        }.store(in: &amp;cancellables)    }        func testSoundPlayedCalculatorResetOnLogoViewTap() {        // given        let input = buildInput(bill: 100, tip: .tenPercent, split: 2)        let output = sut.transform(input: input)        let expectation1 = XCTestExpectation(description: \"reset calculator called\")        let expectation2 = audioPlayerService.expectation                // then        output.resetCalculatorPublisher.sink { _ in            expectation1.fulfill()        }.store(in: &amp;cancellables)                // when        logoViewTapSubject.send()        wait(for: [expectation1, expectation2], timeout: 1.0)    }}class MockAudioPlayerService: AudioPlayerService {        var expectation = XCTestExpectation(description: \"playSound is Called\")        func playSound() {        expectation.fulfill()    }}"
  },
  
  {
    "title": "Tip-Calculator (6)",
    "url": "/posts/Tip-Calculator-(6)/",
    "categories": "Udemy, Combine",
    "tags": "",
    "date": "2024-05-03 17:13:00 +0900",
    





    
    "snippet": "결과를 Result View에 출력현재는 bind 함수에 콘솔로 보여주게만 되어있다.그걸 이제 result view에 출력이 되도록 한다.func configure(result: Result) {        let text = NSMutableAttributedString(            string: String(result.amountPer...",
    "content": "결과를 Result View에 출력현재는 bind 함수에 콘솔로 보여주게만 되어있다.그걸 이제 result view에 출력이 되도록 한다.func configure(result: Result) {        let text = NSMutableAttributedString(            string: String(result.amountPerPerson),            attributes: [.font: ThemeFont.bold(ofSize: 48)])        text.addAttributes([            .font: ThemeFont.bold(ofSize: 24)        ], range: NSMakeRange(0, 1))        amountPersonLabel.attributedText = text    }결과값을 폰트를 별도 적용하여 label에 적용해주는 함수를 구현TotalBillview 구현private let totalBillView: AmountView = {       let view = AmountView(            title: \"Total Bill\",            textAlignment: .left)        return view    }()    private let totalTipView: AmountView = {       let view = AmountView(            title: \"Total Tip\",            textAlignment: .left)        return view    }()다시 view를 새로 만들어 주고, 기존에private lazy var hStackView: UIStackView = {        let stackView = UIStackView(arrangedSubviews: [            AmountView(                title: \"Total Bill\",                textAlignment: .left),            UIView(), // 사이에 끼워줌.            AmountView(                title: \"Total Tip\",                textAlignment: .right)        ])        stackView.axis = .horizontal        stackView.distribution = .fillEqually        return stackView    }()hstackView에 위와 같이 만들어 뒀던것을 인스턴스를 넣어준다.private lazy var hStackView: UIStackView = {        let stackView = UIStackView(arrangedSubviews: [            totalBillView,            UIView(), // 사이에 끼워줌.            totalTipView        ])        stackView.axis = .horizontal        stackView.distribution = .fillEqually        return stackView    }()AmountView에 configure 함수 구현.func configure(text: String) {        let text = NSMutableAttributedString(string: text, attributes: [            .font: ThemeFont.bold(ofSize: 24)        ])        text.addAttributes([            .font: ThemeFont.bold(ofSize: 16)        ], range: NSMakeRange(0, 1))        amountLabel.attributedText = text    }Resultview에 적용func configure(result: Result) {        let text = NSMutableAttributedString(            string: String(result.amountPerPerson),            attributes: [.font: ThemeFont.bold(ofSize: 48)])        text.addAttributes([            .font: ThemeFont.bold(ofSize: 24)        ], range: NSMakeRange(0, 1))        amountPersonLabel.attributedText = text        totalBillView.configure(text: String(result.totalBill)) // added        totalTipView.configure(text: String(result.totalTip))   // added    }VC에 적용// bindoutput.updateViewPublisher.sink { [unowned self] result in            resultView.configure(result: result)        }.store(in: &amp;cancellables)좀 우스꽝스럽게 나왔다.수정을 해야한다.보강Double에 대해 extension을 만든다extension Double {    var currencyFormatted: String {        var isWholeNumber: Bool {            isZero ? true: !isNormal ? false: self == rounded()            }        let formatter = NumberFormatter()        formatter.numberStyle = .currency        formatter.minimumFractionDigits = isWholeNumber ? 0 : 2        return formatter.string(for: self) ?? \"\"    }}// AmountViewfunc configure(amount: Double) { // modified String -&gt; Double        let text = NSMutableAttributedString(string: amount.currencyFormatted, attributes: [ // modified            .font: ThemeFont.bold(ofSize: 24)        ])        text.addAttributes([            .font: ThemeFont.bold(ofSize: 16)        ], range: NSMakeRange(0, 1))        amountLabel.attributedText = text    }// ResultView  func configure(result: Result) {        let text = NSMutableAttributedString(            string: result.amountPerPerson.currencyFormatted, // modified            attributes: [.font: ThemeFont.bold(ofSize: 48)])        text.addAttributes([            .font: ThemeFont.bold(ofSize: 24)        ], range: NSMakeRange(0, 1))        amountPersonLabel.attributedText = text        totalBillView.configure(amount: result.totalBill) // modified        totalTipView.configure(amount: result.totalTip)   // modified    }이젠 잘된다.Tap Gesture 추가CombineCocoa를 사용한다.여기에 tap gesture가 있다.퍼블리셔 생성private lazy var viewTapPublisher: AnyPublisher&lt;Void, Never&gt; = {        let tapGesture = UITapGestureRecognizer(target: self, action: nil)        view.addGestureRecognizer(tapGesture)        return tapGesture.tapPublisher.flatMap { _ in            Just(())        }.eraseToAnyPublisher()    }()    Input이 Void?      그 이유는 우리가 탭을 할때 Int나 String 이런 값을 보내지 않을 것이라서 그렇다.그래서 just안에도 ()를 넣었음.  observe 함수 추가private func observe() {        viewTapPublisher.sink { [unowned self] value in            view.endEditing(true)        }.store(in: &amp;cancellables)    }parameter로 value가 있지만 void이므로 어차피 리턴할게 없다.제스쳐를 추가한 이유는 키보드가 올라왔을때 키보드를 내리게 하기 위함.LogoView를 탭했을 때의 이벤트 추가 private lazy var logoviewTapPublisher: AnyPublisher&lt;Void, Never&gt; = {        let tapGesture = UITapGestureRecognizer(target: self, action: nil)        tapGesture.numberOfTapsRequired = 2 // added        view.addGestureRecognizer(tapGesture)        return tapGesture.tapPublisher.flatMap { _ in            Just(())        }.eraseToAnyPublisher()    }()2번 탭했을때 해당 gestureRecognizer가 발생GestureTapPublisher를 vm에 전달.struct Input {        let billPublisher: AnyPublisher&lt;Double, Never&gt;        let tipPublisher: AnyPublisher&lt;Tip, Never&gt;        let splitPublisher: AnyPublisher&lt;Int, Never&gt;        let logoViewTapPublisher: AnyPublisher&lt;Void, Never&gt; // added    }struct Output {        let updateViewPublisher: AnyPublisher&lt;Result, Never&gt;        let resultCalculatorPublisher: AnyPublisher&lt;Void, Never&gt;    }    로고뷰에 대한 퍼블리셔를 하나 추가. vc에서 로고뷰에 대한 퍼블리셔를 void로 했기에 이것도 void로 해준다.output에도 void로 해서 하나 만들어 준다. (Reset용)// vclet input = CalculatorVM.Input(            billPublisher: billInputView.valuePublisher,            tipPublisher: tipInputView.valuePublisher,            splitPublisher: spiltInputView.valuePublisher,            logoViewTapPublisher: logoviewTapPublisher) // addedlet output = vm.transform(input: input)                output.updateViewPublisher.sink { [unowned self] result in            resultView.configure(result: result)        }.store(in: &amp;cancellables)                output.resultCalculatorPublisher.sink { _ in // added            print(\"hey, reset the form please\")        }.store(in: &amp;cancellables)            // vmfunc transform(input: Input) -&gt; Output {                let updateViewPublisher = Publishers.CombineLatest3(            input.billPublisher,            input.tipPublisher,            input.splitPublisher).flatMap { [unowned self] (bill, tip, split) in                let totalTip = getTipAmount(bill: bill, tip: tip)                let totalBill = bill + totalTip                let amountPerPerson = totalBill / Double(split)                let result = Result(                    amountPerPerson: amountPerPerson,                    totalBill: totalBill,                    totalTip: totalTip)                                return Just(result)            }.eraseToAnyPublisher()                let resultCalculatorPublisher = input.logoViewTapPublisher // added                return Output(updateViewPublisher: updateViewPublisher, resultCalculatorPublisher: resultCalculatorPublisher) // modified    }로고뷰를 탭하면hey, reset the form pleaselogoview is tapped이렇게 출력이 된다.이제는//vcprivate func observe() {        viewTapPublisher.sink { [unowned self] value in            view.endEditing(true)        }.store(in: &amp;cancellables)    }logoviewTapPublisher의 내용을 지워도 된다.bind함수에서 호출하기때문.로고뷰 탭하면 사운드 발생 이벤트 추가사운드파일을 넣어주고 새로운 스위프트 파일을 생성protocol AudioPlayerService {    func playSound()}final class DefaultAudioPlayer: AudioPlayerService {        private var player: AVAudioPlayer?            func playSound() {        let path = Bundle.main.path(forResource: \"click\", ofType: \"m4a\")!        let url = URL(fileURLWithPath: path)                do {            player = try AVAudioPlayer(contentsOf: url)            player?.play()        } catch (let error) {            print(error.localizedDescription)        }    }    }VM에서 사운드 플레이어 기능 구현 - 로고 터치시private let audioPlayerService: AudioPlayerServiceinit(audioPlayerService: AudioPlayerService = DefaultAudioPlayer()) {        self.audioPlayerService = audioPlayerService    }해당 부분을 initializing// vm// transformlet resultCalculatorPublisher = input.logoViewTapPublisher.handleEvents(receiveOutput: { [unowned self] in            audioPlayerService.playSound()        }).flatMap {            return Just($0)        }.eraseToAnyPublisher()로고탭을 하면 이벤트가 발생하고 그 이벤트로 사운드를 재생시킴, 어차피 Void로 리턴하므로 아무것도 없음.실행했지만 nil 발생스택오버플로우를 보고 시도.성공.로고 클릭시 리셋 기능 구현리셋 함수 구현//billinputviewfunc reset() {        textField.text = nil        billSubject.send(0)}// tipinputviewfunc reset () {        tipSubject.send(.none)    }// splitinputviewfunc reset () {        splitSubject.send(1)    }// vcoutput.resetCalculatorPublisher.sink { [unowned self] _ in            billInputView.reset() // added            tipInputView.reset() // added            spiltInputView.reset() // added        }.store(in: &amp;cancellables)애니메이션 구현private func bind() {                        let input = CalculatorVM.Input(            billPublisher: billInputView.valuePublisher,            tipPublisher: tipInputView.valuePublisher,            splitPublisher: spiltInputView.valuePublisher,            logoViewTapPublisher: logoviewTapPublisher)                        let output = vm.transform(input: input)                output.updateViewPublisher.sink { [unowned self] result in            resultView.configure(result: result)        }.store(in: &amp;cancellables)                output.resetCalculatorPublisher.sink { [unowned self] _ in            billInputView.reset()            tipInputView.reset()            spiltInputView.reset()                        UIView.animate(                withDuration: 0.1,                delay: 0,                usingSpringWithDamping: 5.0,                initialSpringVelocity: 0.5,                options: .curveEaseInOut) {                    self.logoView.transform = .init(scaleX: 1.5, y: 1.5)                } completion: { _ in                    UIView.animate(withDuration: 0.1) {                        self.logoView.transform = .identity                    }                }        }.store(in: &amp;cancellables)    }완성"
  },
  
  {
    "title": "Tip-Calculator (5)",
    "url": "/posts/Tip-Calculator-(5)/",
    "categories": "Udemy, Combine",
    "tags": "",
    "date": "2024-05-03 16:13:00 +0900",
    





    
    "snippet": "TipInputView publisher 생성private let tipSubject: CurrentValueSubject&lt;Tip, Never&gt; = .init(.none)var valuePublisher: AnyPublisher&lt;Tip, Never&gt; {        return tipSubject.eraseToAnyPublishe...",
    "content": "TipInputView publisher 생성private let tipSubject: CurrentValueSubject&lt;Tip, Never&gt; = .init(.none)var valuePublisher: AnyPublisher&lt;Tip, Never&gt; {        return tipSubject.eraseToAnyPublisher()    }tipSubject는 CurrentValueSubject인 이유는 값이 전달되고도 해당 값을 새로운 값이 들어오기 전까지 가지고 있게하는데에 의미가 있다.valuePublisher를 또 만든건 지난글 마지막부분쯤에 있으니 참고.Button에 Publisher 생성private lazy var tenPercentTipButton: UIButton = {        let button = buildTipButton(tip: .tenPercent)        button.tapPublisher.flatMap({ // added            Just(Tip.tenPercent)        }).assign(to: \\.value, on: tipSubject).store(in: &amp;cancellables)        return button    }()이 부분의 의미는 뭐냐, 10% 버튼을 클릭하면 Tip에서 tenpercent를 가져온다.flatmap을 사용함으로써. 여러 publisher들을 하나의 새로운 publisher로 만들어준다.해당 사진의 예시 코드enum ConvertError: Error {    case integerError} [\"1\", \"hoge\", \"2\"].publisher    .flatMap { value in        return Just(value)            .tryMap { value throws -&gt; Int in                if let integer = Int(value) {                    return integer                } else {                    throw ConvertError.integerError                }            }            .catch { _ in                Just(0)            }    }    .sink { completion in        switch completion {        case let .failure(error):            print(error)ㅁ         case .finished:            print(\"finished\")        }    } receiveValue: { value in        print(value)    } // 出力結果: 1, 0, 2, finished출처enum Tip {        case none    case tenPercent // here    case fifteenPercent    case twentyPercent    case custom(value: Int)        var stringValue: String {        switch self{        case .none:            return \"\"        case .tenPercent:            return \"10%\"  // here        case .fifteenPercent:            return \"15%\"        case .twentyPercent:            return \"20%\"        case .custom(let value):            return String(value)        }    }    }tipSubject의 value property에 tenPercent 가 들어가게 된다.나머지 버튼들도 수정을 해주고,// calculatorVCprivate func bind() {        let input = CalculatorVM.Input(            billPublisher: billInputView.valuePublisher,             tipPulbisher: tipInputView.valuePublisher, // modfied            splitPublisher: Just(5).eraseToAnyPublisher())                let output = vm.transform(input: input)            }vc에서 이부분도 수정해준다.그리고 vm에서 transform에input.tipPublisher.sink { tip in    print(\"the tip: \\(tip)\")}.store(in: &amp;cancellables)이걸 적어 보고 실행 후, 팁 버튼을 클릭하면the tip: tenPercent 라고 출력이 된다.왜 10%가 아니지? 라는 부분은 enum에 또 var로 stringvalue를 computed property로 구성을 해두었기에,print(\"the tip: \\(tip.stringValue)\")를 하게되면 퍼센티지로 출력이 된다.customtip button 기능 구현private lazy var customTipButton: UIButton = {        let button = UIButton()        button.setTitle(\"Custom Tip\", for: .normal)        button.titleLabel?.font = ThemeFont.bold(ofSize: 20)        button.backgroundColor = ThemeColor.primary        button.tintColor = .white        button.addCornerRadius(radius: 8.0)        button.tapPublisher.sink { [weak self] _ in // added            self?.handleCustomTipButton()        }.store(in: &amp;cancellables)        return button    }()private func handleCustomTipButton() {        let alertController: UIAlertController = {            let controller = UIAlertController(title: \"Enter Custom Tip\", message: nil, preferredStyle: .alert)            controller.addTextField { textField in                textField.placeholder = \"Make it generous!\"                textField.keyboardType = .numberPad                textField.autocorrectionType = .no            }            let cancelAction = UIAlertAction(title: \"Cancel\", style: .cancel)            let okAction = UIAlertAction(title: \"OK\", style: .default) { [weak self] _ in                guard let text = controller.textFields?.first?.text, let value = Int(text) else { return }                self?.tipSubject.send(.custom(value: value))            }            [okAction, cancelAction].forEach(controller.addAction(_:))            return controller        }()        parentViewController?.present(alertController, animated: true)    }extension UIResponder {        var parentViewController: UIViewController? {        return next as? UIViewController ?? next?.parentViewController    }    }code로 대체 사실 코드 보면 알기에 별다른 말이 필요 없을듯 하다.UIResponder만 신선했다.  UIResponder 클래스는 iOS 앱에서 이벤트를 처리하고 응답 체인(responder chain)을 통해 이벤트를 전달하는 데 사용되는 기본 클래스이다.      Extension은 UIResponder에 parentViewController라는 Computed Property를 추가한다. 이 속성은 옵셔널 UIViewController를 반환.parentViewController의 구현은 next 속성을 사용한다.next는 응답 체인에서 다음 응답자를 반환하는 UIResponder 속성이다. 먼저 next 응답자가 UIViewController인지 확인하고, 그렇다면 해당 UIViewController를 반환만약 next 응답자가 UIViewController가 아니라면, next?.parentViewController를 재귀적으로 호출하여 UIViewController를 찾거나 응답 체인의 끝까지 탐색  그리고 다시 VM으로 돌아가서// transforminput.tipPublisher.sink { tip in            print(\"the tip: \\(tip)\")        }.store(in: &amp;cancellables)이걸 추가해서 실행해서 custom tip을 적어보면프린트가 된다.the tip: custom(value: 25) 이런식.Handle Custom Tip Button팁버튼을 누르게되면 배경색이 변하고, custom tip에 값을 입력하면 그부분이 입력한 값으로 변하게 할것이다.우선 원상태로 돌릴 함수를 구현, 일종의 Initializerprivate func resetView() {        [tenPercentTipButton,         fifTeenPercentTipButton,         twentyPercentTipButton,         customTipButton].forEach {            $0.backgroundColor = ThemeColor.primary        }        let text = NSMutableAttributedString(string: \"Custom Tip\",                                             attributes: [.font: ThemeFont.bold(ofSize: 20)])        customTipButton.setAttributedTitle(text, for: .normal)    }resetView 함수는 모든 버튼의 색을 돌리고, custom tip 부분은 Custom tip 이라고 다시 돌아오게 한다.observe 함수 구현private func observe() {        tipSubject.sink { [unowned self] tip in            resetView()            switch tip {            case .none:                break            case .tenPercent:                tenPercentTipButton.backgroundColor = ThemeColor.secondary            case .fifteenPercent:                fifTeenPercentTipButton.backgroundColor = ThemeColor.secondary            case .twentyPercent:                twentyPercentTipButton.backgroundColor = ThemeColor.secondary            case .custom(let value):                customTipButton.backgroundColor = ThemeColor.secondary                let text = NSMutableAttributedString(                    string: \"$\\(value)\",                    attributes: [                        .font: ThemeFont.bold(ofSize: 20)                    ])                text.addAttributes([                    .font: ThemeFont.bold(ofSize: 14)                ], range: NSMakeRange(0, 1))                customTipButton.setAttributedTitle(text, for: .normal)            }        }.store(in: &amp;cancellables)    }우선 화면을 리셋 해주고나서, switch case를 통해 tip이 어떤 값인지에 따라 다르게 처리하게 한다.배경색을 바꾸는것이고 custom 만 입력한 값이 보이게 한다.그리고 이것 역시도 tipSubject를 통해 전달을 하는데, .store(in: &amp;cancellables)를 통해 subscription을 저장해두지 않으면적용이 안됨.splitview 기능 구현private let splitSubject: CurrentValueSubject&lt;Int, Never&gt; = .init(1)        var valuePublisher: AnyPublisher&lt;Int, Never&gt; {        return splitSubject.eraseToAnyPublisher()    }이번에도 역시 subject와 pulisher를 생성.//TipInputView//beforeprivate let tipSubject = CurrentValueSubject&lt;Tip, Never&gt;(.none)//afterprivate let tipSubject: CurrentValueSubject&lt;Tip, Never&gt; = .init(.none)TipInputView에 type 설정과 initializing으로 하는것으로 교체.다시 splitview로 와서private lazy var incrementButton: UIButton = {        let button = buildButton(text: \"+\", corners: [.layerMaxXMinYCorner, .layerMaxXMaxYCorner])        button.tapPublisher.flatMap { [unowned self] _ in // added            Just(splitSubject.value + 1)        }.assign(to: \\.value, on: splitSubject)            .store(in: &amp;cancellables)        return button    }()현재 splitSubject가 가지고 있는 값에서 1을 추가를 해주고 그것을 다시 splitSubject의 value 프로퍼티에 할당시켜준다.private lazy var decrementButton: UIButton = {        let button = buildButton(text: \"-\", corners: [.layerMinXMinYCorner, .layerMinXMaxYCorner])        button.tapPublisher.flatMap { [unowned self] _ in // added            Just(splitSubject.value == 1 ? 1 : splitSubject.value - 1)        }.assign(to: \\.value, on: splitSubject)            .store(in: &amp;cancellables)        return button    }()이때 decrementBtn의 경우 1이 최소값이 므로 삼항연산자를 통해 1일때는 1을 그대로 유지하고, 1이 아닐때만 -1 을 하여 그값을 splitSubject의 value프로퍼티에 넣게 해주었다.observe 함수 구현private func observe() {        splitSubject.sink { [unowned self] quantity in            quantityLabel.text = quantity.stringValue        }.store(in: &amp;cancellables)    }observe 함수를 통해 splitSubject의 value를 quantityLabel에 표시하게 한다.quantity의 type이 int이므로 extension을 통해 변환을 하게 해주었다.vm에서 작동 확인// transforminput.splitPublisher.sink { split in            print(\"the split: \\(split)\")        }.store(in: &amp;cancellables)에 이부분을 추가하여 +, - 버튼을 클릭할때마다 값이 제대로 증감하는지 확인.the split: 1the split: 2the split: 3the split: 2the split: 1// 1인 상태에서 여러번 - 클릭the split: 1the split: 1the split: 1the split: 11을 계속 눌렀을때 이벤트가 생기는걸 방지.var valuePublisher: AnyPublisher&lt;Int, Never&gt; {        return splitSubject.removeDuplicates().eraseToAnyPublisher()    }removeDuplicates는 중복상황이 생기는걸 방지하는데 지금은 split의 최소 값은 1인데 1에서 - 를 계속 누르면 1이라는 이벤트가 계속 발생하게 되는데, 이때 저 메서드를 통해 1인 상태 즉 최소값일 때 더이상 같은 이벤트가 발생하지 않게 막아주는 역할을 하게된다.Compute Result우선 vm의 transform 함수를 수정func transform(input: Input) -&gt; Output {                let updateViewPublisher = Publishers.CombineLatest3( // added            input.billPublisher,            input.tipPublisher,            input.splitPublisher).flatMap { [unowned self] (bill, tip, split) in                let totalTip = getTipAmount(bill: bill, tip: tip)                let totalBill = bill + totalTip                let amountPerPerson = totalBill / Double(split)                let result = Result(                     amountPerPerson: amountPerPerson, // modified                    totalBill: totalBill,             // modified                    totalTip: totalTip)               // modified                                return Just(result)            }.eraseToAnyPublisher()                return Output(updateViewPublisher: updateViewPublisher) // modified    }private func getTipAmount(bill: Double, tip: Tip) -&gt; Double {        switch tip{        case .none:            return 0        case .tenPercent:            return bill * 0.1        case .fifteenPercent:            return bill * 0.15        case .twentyPercent:            return bill * 0.2        case .custom(let value):            return Double(value)        }    }    CombineLatest 메서드를 통해 3개의 publisher를 묶어준다.그리고 flatMap을 통해 하나의 Publisher로 리턴을 해준다.vc로 돌아가서 bind 수정private func bind() {                        let input = CalculatorVM.Input(            billPublisher: billInputView.valuePublisher,            tipPublisher: tipInputView.valuePublisher,            splitPublisher: spiltInputView.valuePublisher)                let output = vm.transform(input: input)        output.updateViewPublisher.sink { result in // added            print(result)        }.store(in: &amp;cancellables)            }이렇게 하면 우리가 시뮬레이터를 실행하면 값에 따라 모든게 출력이 된다."
  },
  
  {
    "title": "Tip-Calculator (4)",
    "url": "/posts/Tip-Calculator-(4)/",
    "categories": "Udemy, Combine",
    "tags": "",
    "date": "2024-05-03 15:02:00 +0900",
    





    
    "snippet": "컴바인을 사용하여 Calculator ViewModel 만들기input과 output 정의우선 ViewModel을 구성할 CalculatorVM을 하나 만들어준다.import Foundationimport Combineclass CalculatorVM {        struct Input {        let billPublisher: AnyPub...",
    "content": "컴바인을 사용하여 Calculator ViewModel 만들기input과 output 정의우선 ViewModel을 구성할 CalculatorVM을 하나 만들어준다.import Foundationimport Combineclass CalculatorVM {        struct Input {        let billPublisher: AnyPublisher&lt;Double, Never&gt;        let tipPublisher: AnyPublisher&lt;Tip, Never&gt;        let splitPublisher: AnyPublisher&lt;Int, Never&gt;    }            struct Output {        let updateViewPublisher: AnyPublisher&lt;Result, Never&gt;    }}Input에는 유져가 입력할 가격(bill)과 tip이 있다.그래서 이걸 publisher를 설정을 해둔다.Publisher에는 input, output type이 Generic의 형태로 존재.bill은 소수점도 가능하기에 Double로 설정Tip은 우리가 이미 modeling을 해두었으므로 Tip타입으로 설정 해둔다.Split도 몇명으로 나눌건지에 대한 설정이므로 당연히 양수.그리고 뒤에 보면 전부 Never가 있는데,Never를 사용하게되면 failure에 대한 내용을 리턴하지 않는다.앞에는 성공했을때의 리턴 타입즉 api 에서 escaping closure를 사용했을때와 유사.struct Output {        let updateViewPublisher: AnyPublisher&lt;(Double, Double, Double)&gt;    }튜플 type으로 3개를 리턴 하는 이유?이렇게 3개의 값을 리턴하기 위해. 한번에 3개를 리턴함.이렇게 하는것 보다 새로운 struct를 만들어서 하는게 더 깔끔. (Tip처럼 새로운 모델링)간단한 메서드는 여기서 확인하면 좋을듯 하다.struct Result {        let amountPerPerson: Double    let totalBill: Double    let totalTill: Double    }struct Output {        let updateViewPublisher: AnyPublisher&lt;Result, Never&gt; // modified    }transform 함수 구현 (vm)func transform(input: Input) -&gt; Output {        let result = Result(amountPerPerson: 500, totalBill: 1000, totalTip: 50.0)            return Output(updateViewPublisher: Just(result).eraseToAnyPublisher())}Input 타입과 Output 타입은 위에 Struct로 이미 구현을 해두었다.테스트를 위해 result를 하나 만들고 Initializing을 해주었다.  eraseToAnyPublisher는 Publisher 타입을 없애고, AnyPublisher형태로 리턴한다.      지금까지의 데이터 스트림이 어떠했던 최종적인 형태의 Publisher를 리턴합니다.  bind 함수 구현 (vc) private func bind() {                let input = CalculatorVM.Input(            billPublisher: Just(10).eraseToAnyPublisher(),            tipPulbisher: Just(.tenPercent).eraseToAnyPublisher(),            splitPublisher: Just(5).eraseToAnyPublisher())                let output = vm.transform(input: input)            }input 과 output변수를 만들어 주었고. input엔 테스트를 위해 initializing을 해준다.그리고 그값을 위에 적은 transform 함수를 통해 output으로 받게 하였다.updateViewPublisher가 어디? 라고 생각한다면 위에 struct에 Output에 있다.그래서 result Type을 리턴을 하게 되는데, 거기엔 다시 적어보면let amountPerPerson: Doublelet totalBill: Doublelet totalTip: Double즉 이렇게 리턴을 한다는것.        output.updateViewPublisher.sink { result in            print(\"&gt;&gt;&gt;&gt; \\(result)\")        }.store(in: &amp;cancellables)그 이후에 이제 아웃풋의 값을 가지고.updatePublisher를 붙여서 값을 처리할것이다.updateViewPublisher가 제공한 데이터를 처리 할 수 있는 sink메서드를 통해서 지금은 콘솔에 확인하는 용도로 print를 통해 출력하게 해두고, 이 subscription은 .store(in: &amp;cancellables)을 통해 저장 한다.그리고 CalulatorVC에override func viewDidLoad() {        super.viewDidLoad()        layout()        bind() // added    }해당 함수를 트리거하는걸 잊지 말자.그러면 이상태로 출력을 하게되면?&gt;&gt;&gt;&gt; Result(amountPerPerson: 500.0, totallBill: 1000.0, totalTip: 50.0)이렇게 출력이 된다.현재는 bind에 input에 대한 내용이 있지만, 애초에 Initialize를 할때, transform함수에 있는 result가 들어가므로 input에는 그냥 dummy로 생각하는게 좋다.즉 현재 transform함수에는 input값을 처리하는 메서드가 없음.그래서 위와같은 값이 콘솔로 출력이 된다.Observe 함수 구현 (view)유져가 bill의 값을 직접 입력을 하게 되면 이 값이 ViewModel로 전달이 되어 값을 처리해야한다.하지만 지금 직접 입력쪽의 ui인 InputView의 class에는 직접적으로 전달하는 컴포넌트가 없다.이제 이부분을 핸들링할 Observe 함수 부터 구현하면서 진행을 해보도록 하겠다.BillInputView에 임포트해주기import Combineimport CombineCocoa텍스트 필드에 입력한게 적용이 되는 observe 함수 구현        private var cancellables = Set&lt;AnyCancellable&gt;()    init () {        super.init(frame: .zero)        layout()        observe() // added    }    private func observe() {        textField.textPublisher.sink { text in            print(\"text: \\(text)\")        }.store(in: &amp;cancellables)    }textField의 TextFieldPublisher 메서드를 사용해 퍼블리셔를 생성을 한다.TextField에 Publisher? 그게 별도로 존재하나? 라고 생각 할 수 있기에, 아래 그 부분에 대한 내용을 코드로 적었다.이건 실제로 Combine에 있는 내용.public extension UITextField {    /// A publisher emitting any text changes to a this text field.    var textPublisher: AnyPublisher&lt;String?, Never&gt; {        Publishers.ControlProperty(control: self, events: .defaultValueEvents, keyPath: \\.text)                  .eraseToAnyPublisher()    }    /// A publisher emitting any attributed text changes to this text field.    var attributedTextPublisher: AnyPublisher&lt;NSAttributedString?, Never&gt; {        Publishers.ControlProperty(control: self, events: .defaultValueEvents, keyPath: \\.attributedText)                  .eraseToAnyPublisher()    }    /// A publisher that emits whenever the user taps the return button and ends the editing on the text field.    var returnPublisher: AnyPublisher&lt;Void, Never&gt; {        controlEventPublisher(for: .editingDidEndOnExit)    }    /// A publisher that emits whenever the user taps the text fields and begin the editing.    var didBeginEditingPublisher: AnyPublisher&lt;Void, Never&gt; {        controlEventPublisher(for: .editingDidBegin)    }}그래서 사용이 가능.다시 정리하면 textField에 퍼블리셔를 생성하고, sink를 통해 textField에 값이 입력이 되면 콘솔로 바로 출력이 되게 보여주게 하는것이다.실행하면바로 반응이 된다.Stanby로 대기를 하다가, 유져의 입력이 들어오자마자 바로 출력을 하는 것이다.TextField의 값을 vc로 전달.// BillInputViewprivate let billSubject: PassthroughSubject&lt;Double, Never&gt;  = .init()    var valuePublisher: AnyPublisher&lt;Double, Never&gt; {    return billSubject.eraseToAnyPublisher()}billSubject를 PassthroughSubject를 사용 하였다.Type이 Doube인 이유는? 굳이 우리가 저기서 String을 할 필요가 없다.private func observe() {        textField.textPublisher.sink { [unowned self] text in // modified            billSubject.send(text?.doubleValue ?? 0) // added        }.store(in: &amp;cancellables)    }그리고 billSubject가 등장하여 text값을 전달한다.PassthroughSubject를 가지고 있으므로, Subscriber가 요청할때만 값을 전달한다.그리고 valuePublisher를 만들어 준다.  valuePublisher? 는 굳이 왜?      billSubject는 값을 받아서 방출이 가능(방출이란 데이터를 보내는 의미)그런데 valuePublisher는 값을 방출만 할 수 있다. (즉 읽기의 기능)현재 billSubject는 앞에 private을 사용함으로써 해당 뷰에서만 가능그래서 그값을 방출(전달) 하기위해 publisher를 만들어 주어 전달하게 함.    둘의 공통점은 데이터 전달 / 차이점은 데이터의 수용의 차이.이게 포인트.var valuePublisher: AnyPublisher&lt;Double, Never&gt; {        return billSubject.eraseToAnyPublisher()    }다시 VC로 돌아가서// vcprivate var cancellables = Set&lt;AnyCancellable&gt;()            override func viewDidLoad() {        super.viewDidLoad()        layout()        bind()    }        private func bind() {        let input = CalculatorVM.Input(            billPublisher: billInputView.valuePublisher, // modfied            tipPulbisher: Just(.tenPercent).eraseToAnyPublisher(),            splitPublisher: Just(5).eraseToAnyPublisher())                let output = vm.transform(input: input)            }확인용도인데 bind에 있던것이다.billInputView.valuePublisher.sink { bill in            print(\"bill: \\(bill)\")        }.store(in: &amp;cancellables)해당 부분을 위에 적고 실행하면 유져가 입력한 부분(bill)에 대한 값이 보여진다.아까의 콘솔은 view에서의 출력이었다면, 이젠 그게 vc로 전달이 되어 프린트가 된것이다.입력한게 그대로 print가 된다.물론 vm에서도 확인이 가능func transform(input: Input) -&gt; Output {        let result = Result(amountPerPerson: 500, totalBill: 1000, totalTip: 50.0)            return Output(updateViewPublisher: Just(result).eraseToAnyPublisher())}위의 부분에input.billPublisher.sink { bill in            print(\"the bill: \\(bill)\")}.store(in: &amp;cancellables)이걸 적으면 역시나 콘솔로 확인이 된다. 즉 vm에도 데이터 전달이 된다는 뜻."
  },
  
  {
    "title": "(Deep Dive) Combine 기초",
    "url": "/posts/(Deep-Dive)-Combine-%EA%B8%B0%EC%B4%88/",
    "categories": "Udemy, Deep Dive",
    "tags": "Myself",
    "date": "2024-05-02 13:00:00 +0900",
    





    
    "snippet": "컴바인에 대해 공부를 해야할 필요성을 느껴 공부를 하게 되었는데, Udemy 공부를 하면서 코드의 흐름은 파악이 되지만 정확하게 어떤 의미로 작동하는지를 확실하게 하기 위해 여기에 적는다.이전에 패캠 강의를 구매해두고 Udemy꺼만 봤는데, 이럴때 도움이 될줄은 몰랐다.내가 찾은 이미지와 내용 + 패캠강의를 mix시켜 적어보도록 한다.사용예시이런식으로...",
    "content": "컴바인에 대해 공부를 해야할 필요성을 느껴 공부를 하게 되었는데, Udemy 공부를 하면서 코드의 흐름은 파악이 되지만 정확하게 어떤 의미로 작동하는지를 확실하게 하기 위해 여기에 적는다.이전에 패캠 강의를 구매해두고 Udemy꺼만 봤는데, 이럴때 도움이 될줄은 몰랐다.내가 찾은 이미지와 내용 + 패캠강의를 mix시켜 적어보도록 한다.사용예시이런식으로 API를 처리 할 수 있다.1. Combine???2019년도에 애플이 공개한 비동기 이벤트를 처리할 수 있는 Framework우선 이미지로 보면RxSwift 보다 성능이 우월하다.3rd party library 와 framework의 차이 때문 → 약간 인텔 맥과 애플 실리콘 맥의 차이랄까성능비교는 여기서2. Components주요 Components에는 Publisher, Subscriber, Operator가 있다.  Publisher          생산자, 배출자의 개념 (value 생산)              시간이 지남에 따라 일련의 값을 전달하는데 적합한 개체      Output, Failure 두개의 값을 전달 (성공, 실패)      하나 이상의 Subscriber에게 값을 전달.        Subscriber (value를 다룸)          받는자              Publisher로 부터 값을 받음.        Operator (value와 함께 기능 수행)          가공자, 연산자의 개념              연산자는 값 변경, 값 추가, 값 제거 또는 기타 여러 작업에 대한 동작을 설명.      여러 연산자를 함께 연결하여 복잡한 처리를 수행할 수 있다.      1. Publisher정의는 아래와 같이 되어있음.public protocol Publisher&lt;Output, Failure&gt; {    /// The kind of values published by this publisher.    associatedtype Output    /// The kind of errors this publisher might publish.    ///    /// Use `Never` if this `Publisher` does not publish errors.    associatedtype Failure : Error    /// Attaches the specified subscriber to this publisher.    ///    /// Implementations of ``Publisher`` must implement this method.    ///    /// The provided implementation of ``Publisher/subscribe(_:)-4u8kn``calls this method.    ///    /// - Parameter subscriber: The subscriber to attach to this ``Publisher``, after which it can receive values.    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, Self.Failure == S.Failure, Self.Output == S.Input}기능.  데이터를 배출          구체적인 output 및 failure 타입을 정의      Subscriber가 요청한 만큼 데이터를 제공해줌. (그래서 배출의 의미)        Built in Publisher인 Just, Future가 있다.          Just : Value를 다룸      Future : Fuction을 다룸        iOS 에서는 자동으로 제공해주는 녀석들이 있음          NotificationCenter      Timer      URLSession.dataTask      2. Subscriber정의는 아래와 같이 되어있음.public protocol Subscriber&lt;Input, Failure&gt; : CustomCombineIdentifierConvertible {    /// The kind of values this subscriber receives.    associatedtype Input    /// The kind of errors this subscriber might receive.    ///    /// Use `Never` if this `Subscriber` cannot receive errors.    associatedtype Failure : Error    /// Tells the subscriber that it has successfully subscribed to the publisher and may request items.    ///    /// Use the received ``Subscription`` to request items from the publisher.    /// - Parameter subscription: A subscription that represents the connection between publisher and subscriber.    func receive(subscription: any Subscription)    /// Tells the subscriber that the publisher has produced an element.    ///    /// - Parameter input: The published element.    /// - Returns: A `Subscribers.Demand` instance indicating how many more elements the subscriber expects to receive.    func receive(_ input: Self.Input) -&gt; Subscribers.Demand    /// Tells the subscriber that the publisher has completed publishing, either normally or with an error.    ///    /// - Parameter completion: A ``Subscribers/Completion`` case indicating whether publishing completed normally or with an error.    func receive(completion: Subscribers.Completion&lt;Self.Failure&gt;)}기능.  Publisher 에게 데이터를 요청한다          Input, Failure 타입의 정의가 필요하다.                  이때 Publisher와 같은 타입이 되어야 한다!                          요청한것과 같은 데이터 타입이 되어야한다는 뜻.              Publisher의 output, Failure = Subscriber의 input, Failure                                            Publisher 구독 후, 갯수를 요청함  파이프라인을 취소할 수 있음  Built in Subscriber인  assign 과 sink 가 있다          assign 는 Publisher가 제공한 데이터를 특정 객체의 키패스에 할당                  Publisher로 부터 받은 값을 주어진 instance의 property에 할당          주어지는 값이 무조건 있어야하기 때문에 sink와는 다르게 publisher의 Failure 타입이 Never일때만 사용 가능                    sink 는 Publisher가 제공한 데이터를 받을수 있는 클로져를 제공함                  클로져에서 새로운 값이나 종료 이벤트에 대해 처리                    3. 진행되는 패턴Publisher와 Subscriber의 관계는 위의 사진도 있지만 아래 사진으로도 다시한번 보여줄게 좋을것 같다.  Subscriber가 Publisher에게 붙음  붙은걸 인지하면 Publisher가 Subsciption을 생성  Publisher가 Subscriber에게 Subsciption을 전달.  Subscriber가 Value를 요청  Publisher가 Value를 Subsciption을 통해 전달.  Value전달이 끝나면 Completion을 통해 전달이 완료되었음을 Subscriber에게 전달1. Subscription ?  Subscriber 가 Publisher가 연결됨을 나타내는 녀석          쉽게 생각하면, Publisher 가 발행한 구독 티켓      이 구독 티켓만 있으면, 데이터를 받을수 있음      이 구독 티켓이 사라지면 구독 관계도 사라짐        Cancellable protocol을 따르고 있음          Cancellable protocol의 cancel을 하게 되면 Subscriber와 Publisher 구독관계도 파기가됨.      Cancellable의 정의는 아래와 같이 되어있음.public protocol Cancellable {    /// Cancel the activity.    ///    /// When implementing ``Cancellable`` in support of a custom publisher, implement `cancel()` to request that your publisher stop calling its downstream subscribers. Combine doesn't require that the publisher stop immediately, but the `cancel()` call should take effect quickly. Canceling should also eliminate any strong references it currently holds.    ///    /// After you receive one call to `cancel()`, subsequent calls shouldn't do anything. Additionally, your implementation must be thread-safe, and it shouldn't block the caller.    ///    /// &gt; Tip: Keep in mind that your `cancel()` may execute concurrently with another call to `cancel()` --- including the scenario where an ``AnyCancellable`` is deallocating --- or to ``Subscription/request(_:)``.    func cancel()}4. Subject - Publisher  send(_:)  메소드를 이용해서 이벤트 값을 주입시킬수 있는 Publisher  기존의 비동기처리 방식에서 Combine으로 전환시 유용함  2가지 Built in 타입이 있음          PassthroughSubject                  Subcriber가 달라고 요청하면, 그때 부터 받은 값을 전달해주기만 함          전달한 값을 들고 있지 않음                    CurrentValueSubject                  Subcriber가 달라고 요청하면, 최근에 가지고 있던 값을 전달하고, 그때 부터 받은 값을 전달 함          전달한 값을 들고 있음                    5. @Published - Publisher  @Published 로 선언된 프로퍼티를 Publisher로 만들어 준다.  클래스에 한해서 사용됨 (구조체에서 사용안됨)  $ 를 이용해서 퍼블리셔에 접근할수 있음  @Published 속성은 변경되는 사항을 등록한 모든 View에 알림.  값이 변경되면 새 값을 전송하거나 게시한다.  View는 @StateObject 프로퍼티 래퍼를 사용해 이 ObservableObject와 연결될 수 있음.  ex)class Weather {    @Published var temperature: Double    init(temperature: Double) {        self.temperature = temperature    }}let weather = Weather(temperature: 20)let subscription = weather.$temperature.sink {    print (\"Temperature now: \\($0)\")}weather.temperature = 25// Temperature now: 20.0// Temperature now: 25.0 → 위에서 값이 25로 변경이 되었기에 게시를 해줌.  ObservableObject      @Published 속성값이 변경됨을 View에 알림  출처6. Operator  Publisher 에게 받은 값을 가공해서 Subscriber 에게 제공  Input, Output, Failure type 을 받는데 타입이 다를수 있음  Built in Operator가 많이 있음          map, filter, reduce, collect, combineLatest ….      7. Scheduler  Scheduler 는 언제, 어떻게 클로져를 실행할지 정해준다.  Operator 에서 Scheduler를 파라미터로 받을때가 있음          작업에 따라서, 백그라운드 혹은 메인스레드에서 작업이 실행될 수 있게 도와줌        Scheduler 가 스레드 자체는 아님1. 2가지 Scheduler Methodssubscribe(on:) 을 이용해서, publisher 가 어느 스레드에서 수행할지 결정해주는것  무거운 작업은 메인스레드가 아닌 다른 스레드에서 작업할수 있게 도와줌          예) 백그라운드 계산이 많이 필요한것      예) 파일 다운로드해야하는 경우      receive(on:) 을 이용해서 operator, subscriber 가 어느 스레드에서 수행할지 결정해주는것  UI 업데이트 필요한 데이터를 메인스레드에서 받을수 있게 도와줌          예) 서버에서 가져온 데이터를 UI 업데이트 할때      일반적인 패턴let jsonPublisher = MyJSONLoaderPublisher() // Some publisher.jsonPublisher    .subscribe(on: backgroundQueue) // background queue 에서 진행하게 설정.    .receive(on: RunLoop.main) // UI update를 위해 main thread로 이동    .sink { value in // label의 text값을 변경.\t\tlabel.text = value}UI 업데이트 시🔴 이렇게 하지말고// 가능하지만, Apple의 권고 사항이 아니다.pub.sink {    DispatchQueue.main.async {        // Do update ui    }}🟢 이렇게 하기pub.receive(on: DispatchQueue.main).sink {        // Do update ui}이미지 출처https://medium.com/harrythegreat/swift-combine-%EC%9E%85%EB%AC%B8%ED%95%98%EA%B8%B0-%EA%B0%80%EC%9D%B4%EB%93%9C-1-525ccb94af57https://www.kodeco.com/7864801-combine-getting-startedhttps://www.donnywals.com/understanding-combines-publishers-and-subscribers/https://ahmadgsufi.medium.com/mastering-the-power-of-subjects-in-combine-a-comprehensive-guide-434ece579c2ehttps://www.kodeco.com/books/combine-asynchronous-programming-with-swift/v1.0/chapters/17-schedulershttps://trycombine.com/posts/subscribe-on-receive-on/https://tanaschita.com/20221121-cheatsheet-combine-operators/"
  },
  
  {
    "title": "(Deep Dive) Combine 기초(2)",
    "url": "/posts/(Deep-Dive)-Combine-%EA%B8%B0%EC%B4%88(2)/",
    "categories": "Udemy, Deep Dive",
    "tags": "Myself",
    "date": "2024-05-02 13:00:00 +0900",
    





    
    "snippet": "코드를 통해 이해해보기. 2탄Schedulerlet arrPublisher = [1,2,3].publisherlet queue = DispatchQueue(label: \"custom\")let subscription = arrPublisher    .map { value -&gt; Int in // operator        print(\"transfo...",
    "content": "코드를 통해 이해해보기. 2탄Schedulerlet arrPublisher = [1,2,3].publisherlet queue = DispatchQueue(label: \"custom\")let subscription = arrPublisher    .map { value -&gt; Int in // operator        print(\"transform: \\(value), thread: \\(Thread.current)\")        return value    }    .sink { value in    print(\"Receive value: \\(value), thread: \\(Thread.current)\")}// transform: 1, thread: &lt;_NSMainThread: 0x600001704000&gt;{number = 1, name = main}// transform: 2, thread: &lt;_NSMainThread: 0x600001704000&gt;{number = 1, name = main}// transform: 3, thread: &lt;_NSMainThread: 0x600001704000&gt;{number = 1, name = main}// Receive value: 1, thread: &lt;_NSMainThread: 0x600001704000&gt;{number = 1, name = main}// Receive value: 2, thread: &lt;_NSMainThread: 0x600001704000&gt;{number = 1, name = main}// Receive value: 3, thread: &lt;_NSMainThread: 0x600001704000&gt;{number = 1, name = main}operator가 Heavy 한 task를 수행하지 않는 경우는 위와 같이 main에서 처리할 수도 있다.let subscription = arrPublisher    .subscribe(on: queue) // main thread가 아닌 우리가 설정한 custom thread에서의 작업을 설정.    .map { value -&gt; Int in // operator        print(\"transform: \\(value), thread: \\(Thread.current)\")        return value    }    .receive(on: DispatchQueue.main) // 작업이 완료되고 받는 작업은 main thread에서    .sink { value in    print(\"Receive value: \\(value), thread: \\(Thread.current)\")}// transform: 1, thread: &lt;NSThread: 0x600001715580&gt;{number = 6, name = (null)}// transform: 2, thread: &lt;NSThread: 0x600001715580&gt;{number = 6, name = (null)}// transform: 3, thread: &lt;NSThread: 0x600001715580&gt;{number = 6, name = (null)}// Receive value: 1, thread: &lt;_NSMainThread: 0x600001710000&gt;{number = 1, name = main}// Receive value: 2, thread: &lt;_NSMainThread: 0x600001710000&gt;{number = 1, name = main}// Receive value: 3, thread: &lt;_NSMainThread: 0x600001710000&gt;{number = 1, name = main}1번만 main thread 이다.이렇게 Scheduler를 통해 Heavy한작업은 background로 돌리면서 thread 관리가 가능하다.Operator// Transform - Maplet numPublisher = PassthroughSubject&lt;Int, Never&gt;()let subscription1 = numPublisher    .map { $0 * 2}    .sink { value in        print(\"Transformed Value: \\(value)\")    }numPublisher.send(10)numPublisher.send(20)numPublisher.send(30)// Transformed Value: 20// Transformed Value: 40// Transformed Value: 60// Filterlet stringPublisher = PassthroughSubject&lt;String, Never&gt;()let subscription2 = stringPublisher    .filter { $0.contains(\"a\") }    .sink { value in        print(\"Filtered Value: \\(value)\")    }stringPublisher.send(\"abc\")stringPublisher.send(\"Jack\")stringPublisher.send(\"Joon\")stringPublisher.send(\"Jenny\")stringPublisher.send(\"Jason\")// Filtered Value: abc// Filtered Value: Jack// Filtered Value: JasonCombineLatest2개의 publisher를 합쳐서 가장 최근의 두 publisher값을 리턴// Basic CombineLatestlet strPublisher = PassthroughSubject&lt;String, Never&gt;()let numPublisher = PassthroughSubject&lt;Int, Never&gt;()strPublisher.combineLatest(numPublisher).sink { (str, num) in    print(\"Receive: \\(str), \\(num)\")}// 위와 같은 표현Publishers.CombineLatest(strPublisher, numPublisher).sink { (str, num) in    print(\"Receive: \\(str), \\(num)\")}strPublisher.send(\"a\")strPublisher.send(\"b\")strPublisher.send(\"c\")// 여기까지만하면 아무런 값이 리턴이 되지 않음// numPublisher에는 아무런 값이 들어오지 않았기 때문이다.numPublisher.send(1) // addednumPublisher.send(2) // addednumPublisher.send(3) // added// Receive: c, 1// Receive: c, 2// Receive: c, 3이렇게 c는 고정이고 1,2,3인 이유는a,b,c 중 c가 제일 최근이고, 그다음에 1들어오면c,1이 제일 최신, 이후 2가 들어오면c,2가 최신이 되기때문.두개를 섞어서 다시 해보면strPublisher.send(\"a\")numPublisher.send(1)strPublisher.send(\"b\")numPublisher.send(2)numPublisher.send(3)strPublisher.send(\"c\")// Receive: a, 1// Receive: b, 1// Receive: b, 2// Receive: b, 3// Receive: c, 3Advanced CombineLast// Advanced CombineLatestlet usernamePublisher = PassthroughSubject&lt;String, Never&gt;()let passwordPublisher = PassthroughSubject&lt;String, Never&gt;()let validatedCredentialsSubscription = usernamePublisher.combineLatest(passwordPublisher)    .map { (username, password) -&gt; Bool in        return !username.isEmpty &amp;&amp; !password.isEmpty &amp;&amp; password.count &gt; 12    }.sink { valid in        print(\"Credential valid? : \\(valid)\")    }usernamePublisher.send(\"Harold\")passwordPublisher.send(\"weakpw\")passwordPublisher.send(\"verystrongpassword\")// Credential valid? : false// Credential valid? : trueMerge2개의 Publisher의 output type이 같을때만 가능// Mergelet publisher1 = [1, 2, 3, 4, 5].publisherlet publisher2 = [300, 400, 500].publisherlet mergePublisherSubscription = publisher1.merge(with: publisher2)    .sink { value in        print(\"Merge: subscription received value: \\(value)\")    }// 위와 같은 의미.Publishers.Merge(publisher1, publisher2).sink { value in    print(\"Merge: subscription received value: \\(value)\")}// Merge: subscription received value: 1// Merge: subscription received value: 2// Merge: subscription received value: 3// Merge: subscription received value: 4// Merge: subscription received value: 5// Merge: subscription received value: 300// Merge: subscription received value: 400// Merge: subscription received value: 500    RemoveDuplicatesvar subscriptions = Set&lt;AnyCancellable&gt;()// removeDuplicateslet words = \"hey hey there! Mr Mr?\"    .components(separatedBy: \" \") // [\"hey\", \"hey\", \"there!\", \"Mr\", \"Mr?\"]words    .removeDuplicates() // 중복값 제거 operator    .sink { value in        print(value)    }.store(in: &amp;subscriptions) // 현재 이 subscription을 위에 선언한 subscriptions에 저장.// hey// there!// Mr// Mr?    compactMapnil값은 제거let strings = [\"a\", \"1.24\", \"3\", \"def\", \"45\", \"0.23\"].publisherstrings.compactMap { Float($0) }    .sink { value in        print(value)    }.store(in: &amp;subscriptions)// 1.24// 3.0// 45.0// 0.23    ignoreOutputlet numbers = (1...10_000).publishernumbers    .ignoreOutput()    .sink (receiveCompletion: { print(\"Completed with: \\($0)\") },            receiveValue: { print($0) })    .store(in: &amp;subscriptions)// Completed with: finished첨부터 ignore 했기에 아무런 값도 넘어가지 않음.prefixlet tens = (1...10).publishertens    .prefix(2) // 앞에 n개만 받겠다.    .sink(receiveCompletion: { print (\"Completed with: \\($0)\") },          receiveValue: { print($0) })    .store(in: &amp;subscriptions)// 1// 2// Completed with: finished2개만 받았으므로 끝."
  },
  
  {
    "title": "(Deep Dive) Combine 기초(1)",
    "url": "/posts/(Deep-Dive)-Combine-%EA%B8%B0%EC%B4%88(1)/",
    "categories": "Udemy, Deep Dive",
    "tags": "Myself",
    "date": "2024-05-02 13:00:00 +0900",
    





    
    "snippet": "코드를 통해 이해해보기.Publisher &amp; Subscriberlet just = Just(1000)let subscription1 = just.sink { value in    print(\"Received Value: \\(value)\")} // Received Value: 1000 하나만 전송하고 끝.let arrayPublisher = [1...",
    "content": "코드를 통해 이해해보기.Publisher &amp; Subscriberlet just = Just(1000)let subscription1 = just.sink { value in    print(\"Received Value: \\(value)\")} // Received Value: 1000 하나만 전송하고 끝.let arrayPublisher = [1, 3, 5, 7, 9].publisherlet subscription2 = arrayPublisher.sink { value in    print(\"Received Value: \\(value)\")}// Received Value: 1// Received Value: 3// Received Value: 5// Received Value: 7// Received Value: 9// 5개 전송 다하고 끝class MyClass {    var property: Int = 0 {        didSet {            print(\"Did set property to \\(property)\")        }    }}let object = MyClass()let subscription3 = arrayPublisher.assign(to: \\.property, on: object)// assign의 경우 object에 어떤 property에 값을 할당할 것을 말함.// 여기선 object의 property에 property(arrayPublisher의 하나하나의 값)를 할당 // Did set property to 1// Did set property to 3// Did set property to 5// Did set property to 7// Did set property to 9print(\"Final Value: \\(object.property)\") // 마지막의 값 확인.// Final Value: 9Subject - Publisher// PassthroughSubjectlet relay = PassthroughSubject&lt;String, Never&gt;()let subscription1 = relay.sink { value in    print(\"Subscription1 received value: \\(value)\")}relay.send(\"Hello\")relay.send(\"World!\")// Subscription1 received value: Hello// Subscription1 received value: World!// CurrentValueSubjectlet variable = CurrentValueSubject&lt;String, Never&gt;(\"\") // 초기값 설정이 필요let subscription2 = variable.sink { value in    print(\"Subscription2 received value: \\(value)\")}variable.send(\"More text\")// Subscription2 received value:  → 비어있는건 초기값 때문// Subscription2 received value: More text다른 케이스let variable = CurrentValueSubject&lt;String, Never&gt;(\"\")variable.send(\"Initial text\") // Subscription 전에 이렇게 initialize도 가능.let subscription2 = variable.sink { value in    print(\"Subscription2 received value: \\(value)\")}variable.send(\"More text\")// Subscription2 received value: Initial text// Subscription2 received value: More textvariable.value // \"More text\" 현재 이 값을 들고있음.PassthroughSubject 에서,let publisher = [\"Here\", \"we\", \"go\"].publisher // 데이터가 주어진 상태의 publisherpublisher.subscribe(relay)// Subscription1 received value: Here// Subscription1 received value: we// Subscription1 received value: go이렇게 된다.즉 저건 아래와 같다.relay.send(\"Here\")relay.send(\"We\")relay.send(\"go\")이렇게 publisher를 통해 relay에게 [\"Here\", \"we\", \"go\"] 이 값들을 전달을 해주었다.Subscriptionlet subject = PassthroughSubject&lt;String, Never&gt;()// The print() operator prints you all lifecycle eventslet subscription = subject.sink { value in    print(\"Subscriber received value: \\(value)\")}subject.send(\"Hello\")subject.send(\"Hello again\")subject.send(\"Hello for the last time\")subject.send(completion: .finished) // 끝subject.send(\"Hello ?? :(\")// Subscriber received value: Hello// Subscriber received value: Hello again// Subscriber received value: Hello for the last timecompletion을 통해 완료되었음을 알렸으므로, subscription도 끝났으므로 아래 Hello?? 는 나오지 않는다.이걸 프린트를 통해 과정을 다시 한번 호출을 해본다.let subject = PassthroughSubject&lt;String, Never&gt;()// The print() operator prints you all lifecycle eventslet subscription = subject    .print() // added    .sink { value in    print(\"Subscriber received value: \\(value)\")}subject.send(\"Hello\")subject.send(\"Hello again\")subject.send(\"Hello for the last time\")subject.send(completion: .finished) // subscription.cancel() 이것도 같음.subject.send(\"Hello ?? :(\")// receive subscription: (PassthroughSubject)         → 관계 형성// request unlimited                                  → 무제한 요청// receive value: (Hello)                             → Hello를 받음// Subscriber received value: Hello                   → Subscriber에게 Hello 전달// receive value: (Hello again)                       → 상동 // Subscriber received value: Hello again             → 상동// receive value: (Hello for the last time)           → 상동// Subscriber received value: Hello for the last time → 상동 // receive finished                                   → Subscriber가 모든 데이터를 받았음을 알림. (그 밑에 있는건 전달하지 않음.)이런식의 sequence를 보면 이해가 더 잘된다.@Publishedfinal class SomeViewModel {    @Published var name: String = \"Jack\" // Publisher 와 같은 의미로 사용    var age: Int = 20}final class Label {    var text: String = \"\"}let label = Label()let vm = SomeViewModel()print(\"text: \\(label.text)\")vm.$name.assign(to: \\.text, on: label) // @Published 를통해 label의 text property에 name 프로퍼티 전달.print(\"text: \\(label.text)\")// text: // text: Jackvm.name = \"Jason\" // print(\"text: \\(label.text)\")// text: Jason이걸 사용해서 값이 변할때마다 UIComponent에 변화를 줄 수 있다.ex) UILabel.text 를 변경.URLSessionTask에서의 Publisherstruct SomeDecodable: Decodable { }URLSession.shared.dataTaskPublisher(for: URL(string: \"https://www.google.com\")!) // publisher    .map { data, response in        return data    }    .decode(type: SomeDecodable.self, decoder: JSONDecoder())이런 형태를 가진다.Notifications에서의 Publisherlet center = NotificationCenter.default // center 생성let noti = Notification.Name(\"MyNoti\") // Notification 생성let notiPublisher = center.publisher(for: noti, object: nil) // publisher 생성let subscription = notiPublisher.sink { _ in // Noti를 받으면 프린트문 호출    print(\"Noti Received\")}center.post(name: noti, object: nil) // Noti에 보내본다, 실제로 호출을 하는지KeyPath binding to NSObject instances의 Publisherlet ageLabel = UILabel()print(\"text: \\(ageLabel.text)\")Just(28)    .map { \"Age is \\($0)\"}    .assign(to: \\.text, on: ageLabel)print(\"text: \\(ageLabel.text)\")Timer에서의 Publisher// autoconnect 를 이용하면 subscribe 되면 바로 시작함let timerPublisher = Timer    .publish(every: 1, on: .main, in: .common)    .autoconnect()let subscription2 = timerPublisher.sink { time in    print(\"timne \\(time)\")}// time: 2024-05-02 12:56:42 +0000// time: 2024-05-02 12:56:43 +0000// time: 2024-05-02 12:56:44 +0000// time: 2024-05-02 12:56:45 +0000// time: 2024-05-02 12:56:46 +0000다만 이상태로는 무한대로 시간을 출력하므로 5초뒤에 끊어주는 메서드가 필요.DispatchQueue.main.asyncAfter(deadline: .now() + 5) {    subscription2.cancel()}"
  },
  
  {
    "title": "Tip-Calculator (3)",
    "url": "/posts/Tip-Calculator-(3)/",
    "categories": "Udemy, Combine",
    "tags": "",
    "date": "2024-05-01 09:13:00 +0900",
    





    
    "snippet": "Input View 디자인HeaderView라는 클래스를 하나 만들어 주고 시작한다.class HeaderView: UIView {        init() {        super.init(frame: .zero)    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:...",
    "content": "Input View 디자인HeaderView라는 클래스를 하나 만들어 주고 시작한다.class HeaderView: UIView {        init() {        super.init(frame: .zero)    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        private func layout() {        backgroundColor = .red    }    }그리고 TextField를 감쌀 View도 하나 만들어준다.private let textFieldContainerView: UIView = {        let view = UIView()        view.backgroundColor = .white                return view    }()extension에 코너를 둥글게할 기능도 새로 추가해준다func addCornerRadius(radius: CGFloat) {        layer.masksToBounds = false        layer.cornerRadius = radius    }  setContentHuggingPriority      뷰 내에서 Label의 높이가 조정되어 제약을 만족시키고자 할 때 setContentHuggingPriority() 메서드를 사용한다.          높이가 고정될 Label의 우선순위를 .defaultHight, 높이가 조정될 Label의 우선순위를 .defaultLow로 설정해준다      출처private lazy var textField: UITextField = {        let textField = UITextField()        textField.borderStyle = .none        textField.font = ThemeFont.demibold(ofSize: 28)        textField.keyboardType = .decimalPad        textField.setContentHuggingPriority(.defaultLow, for: .horizontal)        textField.tintColor = ThemeColor.text        textField.textColor = ThemeColor.text        // Add Toolbar        let toolBar = UIToolbar(frame: CGRect(x: 0, y: 0, width: frame.size.width, height: 36))        toolBar.barStyle = .default        toolBar.sizeToFit()        let doneButton = UIBarButtonItem(            title: \"Done\",            style: .plain,            target: self,            action: #selector(doneButtonTapped))        toolBar.items = [            UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil),            doneButton        ]        toolBar.isUserInteractionEnabled = true        textField.inputAccessoryView = toolBar        return textField    }()이렇게 하면 키보드 위에 Toolbar가 생성이 되고 done버튼이 있다.이걸 누르게 되면 키보드가 내려간다.HeaderView 디자인class HeaderView: UIView {        private let topLabel: UILabel = {        LabelFactory.build(text: nil, font: ThemeFont.bold(ofSize: 18))    }()        private let bottomLabel: UILabel = {        LabelFactory.build(text: nil, font: ThemeFont.regular(ofSize: 16))    }()        private let topSpacerView = UIView()    private let bottomSpacerView = UIView()        private lazy var stackView: UIStackView = {        let stackView = UIStackView(arrangedSubviews: [            topSpacerView,            topLabel,            bottomLabel,            bottomSpacerView        ])        stackView.axis = .vertical        stackView.alignment = . leading        stackView.spacing = -4        return stackView    }()        init() {        super.init(frame: .zero)        layout()    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        private func layout() {        addSubview(stackView)                stackView.snp.makeConstraints { make in            make.edges.equalToSuperview()        }                topSpacerView.snp.makeConstraints { make in            make.height.equalTo(bottomSpacerView)        }    }        func configure(topText: String, bottomText: String) {        topLabel.text = topText        bottomLabel.text = bottomText    }    }코드로 대체 딱히 적을게 없다.InputView 디자인팁 버튼을 디자인을 하는데 그전에 enum 을 통해 어떤 케이스로 될지 디자인을 해둔다.enum Tip {        case none    case tenPercent    case fifteenPercent    case twentyPercent    case custom(value: Int)        var stringValue: String {        switch self{        case .none:            return \"\"        case .tenPercent:            return \"10%\"        case .fifteenPercent:            return \"15%\"        case .twentyPercent:            return \"20%\"        case .custom(let value):            return String(value)        }    }    }그리고 Default 버튼 디자인을 해준다private func buildTipButton(tip: Tip) -&gt; UIButton{        let button = UIButton(type: .custom)        button.backgroundColor = ThemeColor.primary        button.tintColor = .white        button.addCornerRadius(radius: 8.0)        let text = NSMutableAttributedString(            string: tip.stringValue,            attributes: [                .font: ThemeFont.bold(ofSize: 20)            ])        text.addAttributes([            .font: ThemeFont.demibold(ofSize: 14)        ], range: NSMakeRange(2, 1))        button.setAttributedTitle(text, for: .normal)        return button    }이렇게 enum과 버튼 디자인을 해두면private lazy var tenPercentTipButton: UIButton = {        let button = buildTipButton(tip: .tenPercent)        return button    }()이렇게 그냥 사용만 해주면 된다.그리고 스택뷰 생성private lazy var buttonHStackView: UIStackView = {        let stackView = UIStackView(arrangedSubviews: [        tenPercentTipButton,        fifTeenPercentTipButton,        twentyPercentTipButton        ])        stackView.distribution = .fillEqually        stackView.spacing = 16        stackView.axis = .horizontal        return stackView    }()하지만 그 아래에 들어갈 customTipButton의 경우 위와 같은 스타일이 아니므로 별도로 디자인을 해줘야한다.private lazy var customTipButton: UIButton = {        let button = UIButton()        button.setTitle(\"Custom Tip\", for: .normal)        button.titleLabel?.font = ThemeFont.bold(ofSize: 20)        button.backgroundColor = ThemeColor.primary        button.tintColor = .white        button.addCornerRadius(radius: 8.0)        return button    }()그리고 버튼 3개를 합친 스택뷰와 새로만든 customTipButton을 감쌀 VerticalStackview 생성.그리고 오토레이아웃도 잡아주면 끝.splitview 디자인특정 모서리만 둥글게 해주는 기능을 extension에 추가func addRoundedCorners(corners: CACornerMask, radius: CGFloat) {        layer.cornerRadius = radius        layer.maskedCorners = [corners] // 특정 모서리만 둥글게    }완성"
  },
  
  {
    "title": "Tip-Calculator (2)",
    "url": "/posts/Tip-Calculator-(2)/",
    "categories": "Udemy, Combine",
    "tags": "",
    "date": "2024-05-01 09:13:00 +0900",
    





    
    "snippet": "Warning 해결현재 실행을 하게되면Unable to simultaneously satisfy constraints.\tProbably at least one of the constraints in the following list is one you don't want. \tTry this: \t\t(1) look at each constraint and...",
    "content": "Warning 해결현재 실행을 하게되면Unable to simultaneously satisfy constraints.\tProbably at least one of the constraints in the following list is one you don't want. \tTry this: \t\t(1) look at each constraint and try to figure out which you don't expect; \t\t(2) find the code that added the unwanted constraint or constraints and fix it. 이런식으로 Auto Layout에 대한 워닝이 발생한다.에러가 발생하는 이유는 Vertical StackView 때문인데여기안에 UIView를 하나 더 추가를 해줘야한다.설명이 이해가 안가서 나중에 다시 알아봐야할거같다.이렇게 UIView하나가 새로 생기면서 해결이 되긴 했다.폰트 적용 틀 만들어두기.지원버전은 사이트참고struct ThemeFont {    // AvenirNext    static func regular(ofSize size: CGFloat) -&gt; UIFont {        return UIFont(name: \"AvenirNext-Regular\", size: size) ?? .systemFont(ofSize: size)    }        static func bold(ofSize size: CGFloat) -&gt; UIFont {        return UIFont(name: \"AvenirNext-Bold\", size: size) ?? .systemFont(ofSize: size)    }        static func demibold(ofSize size: CGFloat) -&gt; UIFont {        return UIFont(name: \"AvenirNext-Demibold\", size: size) ?? .systemFont(ofSize: size)    }}LogoView 디자인이건 완성된 코드하나도 될 것 같다.이렇게 디자인 할 생각을 하지 못했는데 새로운 강의를 들으면서 제대로 배웠다.구현할 View를 먼저 클래스 파일로 만들고 거기서 디자인을 한다.이게 포인트다.class LogoView: UIView {        private let imageView: UIImageView = {        let view = UIImageView(image: .init(named: \"icCalculatorBW\"))        view.contentMode = .scaleAspectFit                return view    }()        private let topLabel: UILabel = {        let label = UILabel()        let text = NSMutableAttributedString(string: \"Mr TIP\",attributes: [.font: ThemeFont.demibold(ofSize: 16)])        text.addAttributes([.font: ThemeFont.bold(ofSize: 24)], range: NSMakeRange(3, 3)) // TIP부분 더 강조        label.attributedText = text        return label    }()        private let bottomLabel: UILabel = {        LabelFactory.build(            text: \"Calculator\",            font: ThemeFont.demibold(ofSize: 20),            textAlignment: .left)    }()        private lazy var vStackView: UIStackView = {        let view = UIStackView(arrangedSubviews: [        topLabel,        bottomLabel        ])        view.axis = .vertical        view.spacing = -4        return view    }()        private lazy var hStackView: UIStackView = {        let view = UIStackView(arrangedSubviews: [            imageView,            vStackView        ])        view.axis = .horizontal        view.spacing = 8        view.alignment = .center        return view    }()        init () {        super.init(frame: .zero)        layout()    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }            private func layout() {        addSubview(hStackView)        hStackView.snp.makeConstraints { make in            make.top.bottom.equalToSuperview()            make.centerX.equalToSuperview()        }                imageView.snp.makeConstraints { make in            make.height.equalTo(imageView.snp.width)        }    }        }// LabelFactorystruct LabelFactory {    // 기본적인 틀을 구조화    static func build(          text: String?,        font: UIFont,        backgroundColor: UIColor = .clear,        textColor: UIColor = ThemeColor.text,        textAlignment: NSTextAlignment = .center) -&gt; UILabel {            let label = UILabel()            label.text = text            label.font = font            label.backgroundColor = backgroundColor            label.textColor = textColor            label.textAlignment = textAlignment            return label    }}완성.ResultView 추가위와 상동다만 하나 알아두면 좋을 것은private lazy var hStackView: UIStackView = {        let stackView = UIStackView(arrangedSubviews: [        AmountView(),        UIView(), // 사이에 끼워줌.        AmountView()        ])        stackView.axis = .horizontal        stackView.distribution = .fillEqually        return stackView    }()이렇게 가운데에 UIView 를 끼워주고 3분할을 정확하게 해주었다는 것.또 하나 배웠다.shadow효과를 위한 extension 생성extension UIView {        func addShadow(offset: CGSize, color: UIColor, radius: CGFloat, opacity: Float) {        layer.cornerRadius = radius        layer.masksToBounds = false        layer.shadowOffset = offset        layer.shadowColor = color.cgColor        layer.shadowRadius = radius        layer.shadowOpacity = opacity        let backgroundCGColor = backgroundColor?.cgColor        backgroundColor = nil        layer.backgroundColor = backgroundCGColor    }}가운데 선과 아래 View 사이 패딩 추가private func buildSpacerView(height: CGFloat) -&gt; UIView {        let view = UIView()        view.heightAnchor.constraint(equalToConstant: height).isActive = true        return view    }이렇게 하나 만들어주고horizontalLineView,buildSpacerView(height: 0),hStackView높이 0짜리를 하나 사이에 끼워 넣어주면서 패딩이 자연스럽게 된다.완성AmountView 디자인class AmountView: UIView {        private let title: String    private let textAlignment: NSTextAlignment        private lazy var titleLabel: UILabel = {        LabelFactory.build(            text: title,            font: ThemeFont.regular(ofSize: 18),            textColor: ThemeColor.text,            textAlignment: textAlignment)    }()        private lazy var amountLabel: UILabel = {        let label = UILabel()        label.textAlignment = textAlignment        label.textColor = ThemeColor.primary        let text = NSMutableAttributedString(            string: \"$0\",            attributes: [                .font: ThemeFont.bold(ofSize: 24)            ])        text.addAttributes([            .font: ThemeFont.bold(ofSize: 16)        ], range: NSMakeRange(0, 1))        label.attributedText = text        return label    }()        private lazy var stackView: UIStackView = {        let stackView = UIStackView(arrangedSubviews: [        titleLabel,        amountLabel        ])        stackView.axis = .vertical        return stackView    }()        // custom Initializer    init(title: String, textAlignment: NSTextAlignment) {        self.title = title        self.textAlignment = textAlignment        super.init(frame: .zero)        layout()    }//    //    override init(frame: CGRect) {//        super.init(frame: frame)//        layout()//    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        private func layout() {        addSubview(stackView)        stackView.snp.makeConstraints { make in            make.edges.equalToSuperview()        }    }    }처음에 AmountView를 같은걸 해놔서 똑같은 뷰가 두개가 되어있었는데,이것을 Custom Initializer를 통해 text와 문자 배열을 하게 설정을 한다.    // custom Initializer    init(title: String, textAlignment: NSTextAlignment) {        self.title = title        self.textAlignment = textAlignment        super.init(frame: .zero)        layout()    }    // origin initializer -&gt; Don't use this method        override init(frame: CGRect) {        super.init(frame: frame)        layout()    }// resultview의 일부private lazy var hStackView: UIStackView = {        let stackView = UIStackView(arrangedSubviews: [            AmountView( // modified                title: \"Total Bill\",                textAlignment: .left),            UIView(), // 사이에 끼워줌.            AmountView( // modified                title: \"Total Tip\",                textAlignment: .right)        ])        stackView.axis = .horizontal        stackView.distribution = .fillEqually        return stackView    }()뭔가 Code로 UIdesign 하는것에 신세계를 경험하게 된다.너무 길어지니 파트2는 여기까지"
  },
  
  {
    "title": "Tip-Calculator (1)",
    "url": "/posts/Tip-Calculator-(1)/",
    "categories": "Udemy, Combine",
    "tags": "",
    "date": "2024-04-30 15:13:00 +0900",
    





    
    "snippet": "이제는 Combine, RxSwift에 대한 이야기도 나와서 슬슬 준비를 해야겠다는 생각이 들어 글을 써본다.시작Test를 체크를 해준다.  Test 체크를 하는 이유?      소스 코드에서 특정 모듈, 클래스가 개발자가 의도한 대로 정확하게 작동하는지 테스트를 한다.  라이브러리 추가SPM을 통해 설치를 해주자.3개의 Target에 설치를 다 하는...",
    "content": "이제는 Combine, RxSwift에 대한 이야기도 나와서 슬슬 준비를 해야겠다는 생각이 들어 글을 써본다.시작Test를 체크를 해준다.  Test 체크를 하는 이유?      소스 코드에서 특정 모듈, 클래스가 개발자가 의도한 대로 정확하게 작동하는지 테스트를 한다.  라이브러리 추가SPM을 통해 설치를 해주자.3개의 Target에 설치를 다 하는데,  project target (combinecocoa, snapkit)  test target (combinecocoa, snapkit test)  uitest target (combinecocoa)처음에 라이브러리를 추가를 해주면 2,3 번째에서는 간단하게이렇게 추가가 가능.그리고 2번에서 추가할때주의! 테스트로 할것.Root VC 설정 (promatically)스토리보드를 지워준다.그리고 네모로 표시한부분도 삭제 해준다.이대로 실행하면 Crash가 발생한다.SceneDelegate에서 설정을 해줘야한다.안쓰는 메서드에 대해 다 지워주고 (첫번째 빼고는 다 삭제)class SceneDelegate: UIResponder, UIWindowSceneDelegate {    var window: UIWindow?    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {                                guard let _ = (scene as? UIWindowScene) else { return }    }}이제 여기서 root VC를 설정해준다.guard let windowScene = (scene as? UIWindowScene) else { return }                let window = UIWindow(windowScene: windowScene)        let vc = ViewController()        window.rootViewController = vc        self.window = window        window.makeKeyAndVisible()그래도 안된다면?이걸 확인해보자.코드로 UI 디자인  전반적으로 큰틀에서 어떻게 이루어질지 각각의 View를 만들어서 배치를 해주고 그다음에 세부 디자인을 하는 매커니즘으로 간다.private let logoView = LogoView()private let resultView = ResultView()private let billInputView = BillInputView()private let tipInputView = TipInputView()private let spiltInputView = SplitInputView()    private lazy var vStackView: UIStackView = {    let stackView = UIStackView(arrangedSubviews: [        logoView,        resultView,        billInputView,        tipInputView,        spiltInputView        ])        stackView.axis = .vertical        stackView.spacing = 36        return stackView}()여러 View를 만들어주고 그걸 전체로 감싸는 StackView도 만들어준다. 중심축을 수직으로 해주고, 간격을 36으로 해주었다.그리고 snapkit을 사용하여 autolayout 설정을 해주었다. private func layout() {                     vStackView.snp.makeConstraints { make in            make.leading.equalTo(view.snp.leadingMargin).offset(16)            make.trailing.equalTo(view.snp.trailingMargin).offset(-16)            make.bottom.equalTo(view.snp.bottomMargin).offset(-16)            make.top.equalTo(view.snp.margins).offset(16)                    }    }하지만 실행하면 에러가 발생한다.view.addSubview(vStackView)이게 빠졌기 때문.Build Settings 재 수정현재 SafeArea쪽도 그렇고 위와 아래쪽이 예전 폰으로 보이는듯한 느낌이 들어서 우리가 보는것 처럼 확대를 해보려 한다.이부분을 아까 잘못지워서 생긴 문제였다.해결.색상 설정Config 디렉토리를 만들어 주었다.UIColor(hexString:) 메서드를 사용하기위해 extension으로 기능을 구현해준다. StackOverFlow참고extension UIColor {    convenience init(hexString: String) {        let hex = hexString.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)        var int = UInt64()        Scanner(string: hex).scanHexInt64(&amp;int)        let a, r, g, b: UInt64        switch hex.count {        case 3: // RGB (12-bit)            (a, r, g, b) = (255, (int &gt;&gt; 8) * 17, (int &gt;&gt; 4 &amp; 0xF) * 17, (int &amp; 0xF) * 17)        case 6: // RGB (24-bit)            (a, r, g, b) = (255, int &gt;&gt; 16, int &gt;&gt; 8 &amp; 0xFF, int &amp; 0xFF)        case 8: // ARGB (32-bit)            (a, r, g, b) = (int &gt;&gt; 24, int &gt;&gt; 16 &amp; 0xFF, int &gt;&gt; 8 &amp; 0xFF, int &amp; 0xFF)        default:            (a, r, g, b) = (255, 0, 0, 0)        }        self.init(red: CGFloat(r) / 255, green: CGFloat(g) / 255, blue: CGFloat(b) / 255, alpha: CGFloat(a) / 255)    }}오늘은 여기까지"
  },
  
  {
    "title": "킥보드 프로젝트 후기",
    "url": "/posts/%ED%82%A5%EB%B3%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%ED%9B%84%EA%B8%B0/",
    "categories": "캠프, 프로젝트2",
    "tags": "",
    "date": "2024-04-29 23:00:00 +0900",
    





    
    "snippet": "일주일간의 팀프로젝트가 끝났다. 개인후기는 지난번 글에 적었고, 튜터님의 리뷰를 여기에 적어본다.후기.1. 장점  상용되어 있는 서비스처럼 퀄리티적인 측면을 많이 신경쓴 것으로 보임  화면이 엄청 많아서 앱이 풍성해 보였음  리드미 구성을 잘 해두었음.2. 보완할 점 및 수정내용1. 싱글톤 패턴  단순히 활용하고 끝이 아니라, 어떤 장점이 있는지 단점...",
    "content": "일주일간의 팀프로젝트가 끝났다. 개인후기는 지난번 글에 적었고, 튜터님의 리뷰를 여기에 적어본다.후기.1. 장점  상용되어 있는 서비스처럼 퀄리티적인 측면을 많이 신경쓴 것으로 보임  화면이 엄청 많아서 앱이 풍성해 보였음  리드미 구성을 잘 해두었음.2. 보완할 점 및 수정내용1. 싱글톤 패턴  단순히 활용하고 끝이 아니라, 어떤 장점이 있는지 단점이 있는지 꼭 알아보고 이해하고 있기!!!  싱글톤 패턴이란?      특정 용도로 객체를 하나만 생성하여, 공용으로 사용하고 싶을 때 사용하는 디자인 패턴    장점          한번만 생성하면 되므로 메모리 낭비를 방지      전역 Instance로 다른 클래스와 공유가 쉽다.      공통된 객체를 여러개 생성해서 사용하는 상황이 많이 발생할때 사용        단점          싱글톤 패턴이 너무 많은 일을 하거나, 너무나 많은 데이터를 공유 시킬 경우, 다른 클래스간의 결합도가 높아져 개방-폐쇄 원칙을 위배.                  수정과 테스트가 어려워짐.          의존성이 생김                      예시 출처    class Singleton { static let shared = Singleton()     var x = 0     private init() { }}Hello.shared.x = 123print(Hello.shared.x) // 123        개방-폐쇄 원칙?      개방-폐쇄 원칙(OCP, Open-Closed Principle)은 ‘소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다’는 프로그래밍 원칙이다. 출처: 위키  출처 : https://babbab2.tistory.com/66여기서 연습을 해보면 좋을듯.2. 컨벤션  컨벤션을 러프하게 잡다보면 문제가 생길 수 있음 &gt; 잘 챙기기!우리조에서 발생했던 문제점  VC의 Identifier 규칙 부재로 인한 문제발생          ex) SigninVC / signinVC / SignInVC                  Identifer의 대소문자를 사람마다 다르게 써서 merge후 해당 화면전환시 Exception 발생.          SigninVC를 사용하기로 최종 결정.                      VC 생성시, 정확한 명칭의 부재          ex) MapViewController가 아닌 MapVC로 생성.                  refactor → rename을 통해 이름 일괄적으로 변경                    3. Static으로 Cell 관리  셀 아이덴티파이어를 스태틱하게 설정해두는 것 시도해보기      이전까지 이렇게 했는데 왜 이번에는 까먹었는지 모르겠다.  struct Constants {        static let counponCell = \"CouponCollectionViewCell\"    static let guideCell = \"guideList\"    static let guideTableCell = \"GuideTableViewCell\"    static let ProfileTableCell = \"ProfileTableViewCell\"    static let profileList = \"ProfileList\"        }// Tableview CellforRowAt의 한부분guard let cell = GuideTable.dequeueReusableCell(withIdentifier: Constants.guideCell, for: indexPath) as? GuideTableViewCell else { return UITableViewCell () }수정완료.4. Cell Function  셀에서 자체 펑션으로 데이터/모델이 들어왔을 때 바꾸는 동작들이 실행되는 위치를 조정해보기      cellForRowAt 메서드에 cell을 하나하나 정의하는게 아닌 CustomCell Class에서 미리 정의 하고 시작.  // Custom cell classfunc configure(cellModel: ProfileModel) {        iconImageView.image = UIImage(named: cellModel.iconName)        titleLabel.text = cellModel.title    }// cellForRowAtfunc tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        guard let cell = tableView.dequeueReusableCell(withIdentifier: Constants.profileList, for: indexPath) as? ProfileTableViewCell else {            return UITableViewCell ()                    }                let item = dummyData[indexPath.row]                cell.configure(cellModel: item) // modified                return cell    }수정완료.KPT🐾  Keep 우리가 잘한 것 → 지속해야 할 부분  매일 2번의 데일리 스크럼을 통해 서로의 진행 상황을 트래킹 함  업무 진행 대시보드를 활용하여 개발 순서와 진행을 관리함  팀원들 간의 협력을 중요시하며 서로 진행을 도움  기본적으로 서로를 존중하는 의식이 바탕이 되어 즐거운 마음으로 프로젝트에 임할 수 있었음.⚠️  Problem 팀에서 발생한 문제와 → 해결방법  문제점          코드 컨벤션 : 러프하게 잡은 코드 컨벤션 때문에 변수명의 통일 등 통합 시간을 추가로 소요했다      카카오맵 Docs와 SDK간 메서드 불일치 등의 이슈로 맵 선정 과정에서 어려움을 겪음.      화면전환시 데이터 전달, back 버튼 유무 등 시행착오가 다수 발생        해결방안          코드 컨벤션의 문서화      의사결정 과정을 거쳐 구현 방식 변경 결정 (KakaoMap SDK 에서 Apple MapKit로 변경)  맵 자체는 Apple MapKit으로 구현하였으며, 위치 검색 기능 사용을 위한 KakaoMap REST API 사용      생명주기, 화면전환 방식 변경을 통해 최적화된 화면전환 방식을 설정.   화면전환은 전체적인 통일감을 위해 NavigationController를 사용한 화면전환을 일괄적으로 사용.   생명 주기의 경우 어느 시점에서 메소드가 필요한지 확인 후 적절한 위치에 사용하는 방식으로 해결.  데이터 저장의 경우, 필요에 따라 UserDefault, Coredata, Singleton Pattern을 사용하여 해결.      💪 Try (+ Feel) 다음 프로젝트를 위해 해야할 노력 및 느낀점  Try  프로젝트의 리팩토링 및 기능 개선 계획을 세웠다  팀원이 바뀌어도 지금 팀 분위기를 유지하려고 노력  Feel  일주일의 팀 프로젝트였지만 내용, 화면구성, 그리고 다양한 기능 구현 등 지난 키오스크와 비교했을때는 난이도는 확실히 달랐습니다. 하지만 이런 어려운 난이도에도 불구하고 할 수 있었던 가장 큰 이유는 팀원끼리 서로 할 수 있다는 자신감과 서로에 대한 신뢰감이라고 생각합니다. 저번에도 그랬고 이번에도 너무 좋은 팀원분들을 만나서 재미있게 했던 한 주였습니다.위의 소감은 팀원분을 제외한 내꺼만 적는다."
  },
  
  {
    "title": "킥보드 프로젝트 7일차",
    "url": "/posts/%ED%82%A5%EB%B3%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-7%EC%9D%BC%EC%B0%A8/",
    "categories": "캠프, 프로젝트2",
    "tags": "",
    "date": "2024-04-28 05:00:00 +0900",
    





    
    "snippet": "최종점검이것저것 테스트를하며 혹시나 생각하지 못했던 예외상황이 없는지 확인을 해보았다.아니나 다를까 예외 상황은 발생했다.1. 반납할때 코어데이터에 등록이 되지않았던 문제 수정테스트를 하다가 뭔가 이상해서 보니 반납할때 킥보드의 위치가 그냥 싱글턴 배열에먼 저장이 되고 코어데이터에는 저장이 되지 않는 문제를 확인했다.우선 반납할때 핀의 시리얼 번호를 ...",
    "content": "최종점검이것저것 테스트를하며 혹시나 생각하지 못했던 예외상황이 없는지 확인을 해보았다.아니나 다를까 예외 상황은 발생했다.1. 반납할때 코어데이터에 등록이 되지않았던 문제 수정테스트를 하다가 뭔가 이상해서 보니 반납할때 킥보드의 위치가 그냥 싱글턴 배열에먼 저장이 되고 코어데이터에는 저장이 되지 않는 문제를 확인했다.우선 반납할때 핀의 시리얼 번호를 사용을 해야겠다고 생각을 했다.그래서 Predicate를 사용했다.이때 로직은 괜찮은데 자꾸 에러가 발생했는데 알고보니let predicate = NSPredicate(format: \"id == %@\", slicedSerial)현재는 slicedSerial로 되어있지만 이전에는 serial로 해버렸다.저기에 있는 serial은 title을 그대로 받아오기에 기기번호:  라는 문자열이 같이 넘어오게된다.무튼 문제점을 수정하여 코어데이터에 반여이 되게 수정을 했다. @IBAction func returnScooterBtn(_ sender: UIButton) {        DispatchQueue.global().async {            if CLLocationManager.locationServicesEnabled() {                self.locationManager.requestWhenInUseAuthorization()                let currentLocation = self.locationManager.location                                let serial = self.serialNumber                let slicedSerial = String(serial.suffix(10))                self.addMark(coordinate: CLLocationCoordinate2D(latitude: currentLocation?.coordinate.latitude ?? 37.503702192, longitude: currentLocation?.coordinate.longitude ?? 127.025313873406), serial: slicedSerial)                //self.makingDummy()                self.locations.append(currentLocation!.coordinate)                                do { //new                    let predicate = NSPredicate(format: \"id == %@\", slicedSerial)                    self.request.predicate = predicate                    request.predicate = predicate                    SavedPinSingleton.shared.array.removeAll()                    SavedPinSingleton.shared.array = try self.context.fetch(requestForPredicate)                                        if SavedPinSingleton.shared.array.count != 0 {                                                let filteredObject = SavedPinSingleton.shared.array[0]                        filteredObject.setValue((currentLocation?.coordinate.longitude ?? 37.503702192), forKey: \"x\")                        filteredObject.setValue((currentLocation?.coordinate.latitude ?? 37.503702192), forKey: \"y\")                                                do {                            try self.context.save()                        } catch {                            let alert = UIAlertController(title: \"에러 발생\", message: \"데이터 저장 중 오류가 발생했습니다.\", preferredStyle: .alert)                            alert.addAction(UIAlertAction(title: \"확인\", style: .default))                            self.present(alert, animated: true)                        }                    }                                                        } catch {                    let alert = UIAlertController(title: \"에러 발생\", message: \"데이터 저장 중 오류가 발생했습니다.\", preferredStyle: .alert)                    alert.addAction(UIAlertAction(title: \"확인\", style: .default))                    self.present(alert, animated: true)                }                self.getDummy()                self.makingDummy()            }                    }        isUsed = false        setbuttonHidden(isStatus: isUsed)                let alert = UIAlertController(title: \"반납완료\", message: \"킥보드 반납이 완료되었습니다.\\n안녕히 가세요.\", preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"확인\", style: .default))        self.present(alert, animated: true)        let distance = calculateTripDistance()        let finTime = dateFormatter.string(from: Date())        RecordSingleton.shared.array.append(RecordModel(distance: distance, time: finTime))        locations.removeAll() // 거리 계산후 배열 초기화.            }2. 반납하고 다른 탭을 갔다가 다시 지도로 넘어왔을때 반납한 스쿠더만 보이던 문제 해결테스트를 다시 하던중 해당 문제를 발견하고 급하게 핫픽스를 하였다.request를 같은걸 사용하기에 발생한 문제였다.그래서 predicate 전용 리퀘스트를 만들어 주었다.let requestForPredicate: NSFetchRequest&lt;PinData&gt; = PinData.fetchRequest()let predicate = NSPredicate(format: \"id == %@\", slicedSerial)requestForPredicate.predicate = predicate문제 해결.물론 이것외에도 일주일간 여러 예외상황이 있었고, 최대한 해결을 했지만 기억이 나지않아서 여기까지 글을 작성하도록 하겠다.일주일간 짧은 프로젝트였지만 팀원들과 많은걸 이루어내었기에 후회없는 프로젝트였다.개인 후기.이번에는 저번과 다르게 모두 처음 뵙는 분들과 함께 했지만, 지난 팀프로젝트와 마찬가지로, 뭔가 프로젝트 자체가 엄청 재미있게 될것같다고 생각이 들었는데, 역시나 팀분위기가 쳐지는것 없이 너무 재미있게 했다.그러다보니 나도 더 열심히 해서 팀원들의 기대에 부응을 하려고 노력을 하다보니, 제발 그만 좀 하라고 할정도로 열심히한 것 같다.지난번에 지도를 아주 잠깐 썼지만, 이번에 지도를 제대로 쓰면서 어떻게 써야할지 좋은 공부가 되었다.물론 시간때문에 더 구현하고 싶었지만 못했던것도 있다.이부분은 나중에 팀원분들의 동의를 얻어 개조를 하려고 한다. 물론 지난번 키오스크도 아직 개조를 못한상태…아마 이 모든 과정이 끝나고 개조를 하지 않을까 싶기도 하다.일주일 누구한테는 길었고, 누구한테는 짧았을 시간인데, 적어도 나에겐 너무나 짧았다. 그만큼 너무 재미있어서 시간가는줄 몰랐던것 같다.아직도 공부할게 많지만, 이번 프로젝트에서 너무 좋은 에너지를 받았기에 그걸 바탕으로 더 열심히 해야겠다는 생각도 든다.생각나는 후기는 여기까지 추가로 더 쓰도록 하겠다."
  },
  
  {
    "title": "킥보드 프로젝트 6일차",
    "url": "/posts/%ED%82%A5%EB%B3%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-6%EC%9D%BC%EC%B0%A8/",
    "categories": "캠프, 프로젝트2",
    "tags": "",
    "date": "2024-04-27 05:00:00 +0900",
    





    
    "snippet": "관리자 페이지 구현.사실 이번 프로젝트에서 킥보드 등록 기능이 있는데 지금까지 구현한걸로 보았을때,너무 유져입장에서 만든 것 같아, 관리자 입장에서도 만들어 본다.우선 admin 계정일때만 새로 만든 Manage tabbar가 나오게 한다.import UIKitclass TabbarViewController: UITabBarController {   ...",
    "content": "관리자 페이지 구현.사실 이번 프로젝트에서 킥보드 등록 기능이 있는데 지금까지 구현한걸로 보았을때,너무 유져입장에서 만든 것 같아, 관리자 입장에서도 만들어 본다.우선 admin 계정일때만 새로 만든 Manage tabbar가 나오게 한다.import UIKitclass TabbarViewController: UITabBarController {        var myID = \"\"        override func viewDidLoad() {        super.viewDidLoad()                self.selectedIndex = 0        self.navigationController?.isNavigationBarHidden = true                self.tabBar.backgroundColor = .white // new                if myID != \"admin\" { // new            self.viewControllers?.remove(at: 3)        }    }}3번째 인덱스(Tabbar도 0부터 시작)를 삭제 하면 아이디가 admin이 아닌경우엔 킥보드 관리를 할 수 없다.킥보드 등록, 삭제 기능 구현새로운 VC를 하나 만들어주었다. 그리고 여기서는 간단하게 TableView로 작업을 하려고한다.그래서 CustomCell을 만들어주었다. 해당 부분은 pass1. 핀 모델링 및 싱글턴 패턴 사용.struct PinModel {    var x: Double    var y: Double    var id: String}class SavedPinSingleton {        static let shared = SavedPinSingleton()        var array: [PinModel] = [PinModel]()    private init () {}    }좌표값과 시리얼 번호만 있으면 될것같아서 구현을 해두었다.2. TableView 관련 기능 설정.extension ScooterManageViewController: UITableViewDelegate, UITableViewDataSource {    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {        SavedPinSingleton.shared.array.count    }        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        guard let cell = tableView.dequeueReusableCell(withIdentifier: \"manageCell\", for: indexPath) as? ScooterManageTableViewCell else {            return UITableViewCell() }                cell.serialLabel.text = \"\\(indexPath.row + 1)호기 Serial Number: \\(SavedPinSingleton.shared.array[indexPath.row].id ?? \"1A2B3C4D5E\")\"        cell.delteBtn.tag = indexPath.row        cell.delteBtn.addTarget(self, action: #selector(deleteEvent), for: .touchUpInside)        cell.selectionStyle = .none                return cell    }        @objc func deleteEvent(sender: UIButton) {                let alert = UIAlertController(title: \"삭제하시겠습니까?\", message: \"삭제를 하시면 등록된 킥보드 정보가 삭제가 됩니다.\\n해당 정보는 되돌릴 수 없습니다.\", preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"취소\", style: .default))        alert.addAction(UIAlertAction(title: \"확인\", style: .destructive, handler: { _ in            SavedPinSingleton.shared.array.remove(at: sender.tag)            self.tableView.reloadData()        }))                self.present(alert, animated: true)    }    }우선 테이블뷰에는 CustomCell에 관련된걸 넣어주었고. 삭제 버튼에 대한 Event를 selector를 사용하여 처리를 해주었다.테이블 뷰는 하도 많이 써서그런가 별 감흥이 없다.3. 기기 추가 기능 구현@IBAction func addPinData(_ sender: UIButton) {                let alert = UIAlertController(title: \"킥보드를 추가합니다.\", message: \"아래에 정보를 입력해주세요.\", preferredStyle: .alert)        alert.addTextField { textField in            textField.placeholder = \"10자리의 Code를 입력해주세요\"        }        alert.addTextField { textField in            textField.placeholder = \"경도: ex) -122.030189\"        }        alert.addTextField { textField in            textField.placeholder = \"위도: ex) 37.331676\"        }                alert.addAction(UIAlertAction(title: \"확인\", style: .default, handler: { _ in            if let serial = alert.textFields?[0].text, let lon = Double((alert.textFields?[1].text)!), let lat = Double((alert.textFields?[2].text)!) {                if serial.count != 10 {                    let alert = UIAlertController(title: \"에러 발생\", message: \"Serial Number는 반드시 10자리로 입력해 주세요.\", preferredStyle: .alert)                    alert.addAction(UIAlertAction(title: \"확인\", style: .default))                    self.present(alert, animated: true)                } else {                    SavedPinSingleton.shared.array.append(newItem)                                        self.tableView.reloadData()                }            } else {                let alert = UIAlertController(title: \"에러 발생\", message: \"Field에 값을 입력해 주세요.\", preferredStyle: .alert)                alert.addAction(UIAlertAction(title: \"확인\", style: .default))                self.present(alert, animated: true)            }        }))        alert.addAction(UIAlertAction(title: \"취소\", style: .cancel))        self.present(alert, animated: true)    }이렇게 배열에 값을 추가하였다.킥보드 데이터 Coredata로 이관.지금은 앱을 켤때마다 계속 다르게 생성이 된다. 배열이기때문.이젠 CoreData를 사용할때가 된거 같아 이부분을 구현한다.1. 컨테이너 생성우선 컨테이너를 만들어 준다// AppDelegatelazy var persistentContainer: NSPersistentContainer = {    let container = NSPersistentContainer(name: \"PinModel\")        container.loadPersistentStores(completionHandler: { (storeDescription, error) in            if let error = error as NSError? {                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")            }        })        return container    }()    // MARK: - Core Data Saving supportfunc saveContext () {    let context = persistentContainer.viewContext        if context.hasChanges {            do {                try context.save()            } catch {                let nserror = error as NSError                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")            }        }    }Appdelegate에 복붙만 하면되기에 패스 물론 이름은 설정해줘야한다.2. Entity, Attribute 설정설명은 사진으로 대체기존 PinModel을 옮긴것이라고 보면 된다.3. CoordGenerator 수정let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext        func makingDummyArray() {                for _ in 0 ... 9 {            let newItem = PinData(context: context)            newItem.id = serialGenerator()            newItem.x = lonlatGenerator().0            newItem.y = lonlatGenerator().1            do {                try context.save()            } catch {            }        }        }기존에 배열에 추가하고 리턴하던 부분을 수정한다.  배열저장 → Coredata로 저장만 바뀜.4. MapVC 관련 내용 수정무분별한 생성을 막기위해서, 다 지웠을때만 생성하게 해두려고한다.func makingDummy() {        for i in SavedPinSingleton.shared.array.indices {            let coordinate = CLLocationCoordinate2D(latitude: SavedPinSingleton.shared.array[i].y, longitude: SavedPinSingleton.shared.array[i].x)            let serial = SavedPinSingleton.shared.array[i].id ?? \"1A2B3C4D5E\"            addMark(coordinate: coordinate, serial: serial)        }    }    func getDummy() {        do {            SavedPinSingleton.shared.array = try context.fetch(request)        } catch {            let alert = UIAlertController(title: \"에러 발생\", message: \"데이터를 로드 하던 중 오류가 발생했습니다.\", preferredStyle: .alert)            alert.addAction(UIAlertAction(title: \"확인\", style: .default))            self.present(alert, animated: true)        }    }func refreshPinData () {        mapView.removeAnnotations(mapView.annotations)        makingDummy()    }싱글턴 배턴을 사용한 배열에 coredata의 값을 불러오는 함수, 그리고 그걸 바탕으로 pin을 지도에 표시하게 하는 함수를 구현해두었다.그리고 혹시 몰라서 핀을 재생성 하게 하기 위해 refresh기능도 구현해 주었다.5. ManageVC 수정여기는 그냥 핀만 추가해주면 되기에,@IBAction func addPinData(_ sender: UIButton) {                let alert = UIAlertController(title: \"킥보드를 추가합니다.\", message: \"아래에 정보를 입력해주세요.\", preferredStyle: .alert)        alert.addTextField { textField in            textField.placeholder = \"10자리의 Code를 입력해주세요\"        }        alert.addTextField { textField in            textField.placeholder = \"경도: ex) -122.030189\"        }        alert.addTextField { textField in            textField.placeholder = \"위도: ex) 37.331676\"        }                alert.addAction(UIAlertAction(title: \"확인\", style: .default, handler: { _ in                                    if let serial = alert.textFields?[0].text, let lon = Double((alert.textFields?[1].text)!), let lat = Double((alert.textFields?[2].text)!) {                if serial.count != 10 {                    let alert = UIAlertController(title: \"에러 발생\", message: \"Serial Number는 반드시 10자리로 입력해 주세요.\", preferredStyle: .alert)                    alert.addAction(UIAlertAction(title: \"확인\", style: .default))                    self.present(alert, animated: true)                } else {                    let newItem = PinData(context: self.context) // new                    newItem.id = serial // new                    newItem.x = lon // new                    newItem.y = lat // new                    SavedPinSingleton.shared.array.append(newItem)                                        // new                    do {                        try self.context.save()                    } catch {                        let alert = UIAlertController(title: \"에러 발생\", message: \"데이터 추가 중 오류가 발생했습니다.\", preferredStyle: .alert)                        alert.addAction(UIAlertAction(title: \"확인\", style: .default))                        self.present(alert, animated: true)                    }                                        self.tableView.reloadData()                }            } else {                let alert = UIAlertController(title: \"에러 발생\", message: \"Field에 값을 입력해 주세요.\", preferredStyle: .alert)                alert.addAction(UIAlertAction(title: \"확인\", style: .default))                self.present(alert, animated: true)            }                                            }))        alert.addAction(UIAlertAction(title: \"취소\", style: .cancel))        self.present(alert, animated: true)    }핀 추가쪽만 설정해 주었다.완료사진은 패스."
  },
  
  {
    "title": "킥보드 프로젝트 5일차",
    "url": "/posts/%ED%82%A5%EB%B3%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-5%EC%9D%BC%EC%B0%A8/",
    "categories": "캠프, 프로젝트2",
    "tags": "",
    "date": "2024-04-26 05:00:00 +0900",
    





    
    "snippet": "Test용 Dummy Data생성기능 구현도 막바지 언제까지 계속 버튼으로 테스트용 핀버튼 눌러가며 할수는 없기에DummyData를 만들어본다.시뮬레이터를 쓸때 움직이는걸 확인하려면 어쩔수없이 기준을 Apple로 해야하기에Apple의 위도, 경도를 기반으로 만들어 본다.우선 간단한 모델링을 해주었다.import Foundationstruct PinMo...",
    "content": "Test용 Dummy Data생성기능 구현도 막바지 언제까지 계속 버튼으로 테스트용 핀버튼 눌러가며 할수는 없기에DummyData를 만들어본다.시뮬레이터를 쓸때 움직이는걸 확인하려면 어쩔수없이 기준을 Apple로 해야하기에Apple의 위도, 경도를 기반으로 만들어 본다.우선 간단한 모델링을 해주었다.import Foundationstruct PinModel {        var x: Double    var y: Double    var id: String}x,y,id 이렇게 3개를 했다.우선 id값은 처음에 int로 숫자만 하려다가. 그냥 알파벳숫자 모두가 섞인 값이 더 나을것이라고 판단하였다.10자리로 값을 무작위로 추출하게 고차함수를 이용하고,검색해보니 1km의 위도, 경도 값이 있어서 처음에는 1km로 했다가 생각보다 범위가 너무 넓어서 250m로 줄였다.class CoordGenerator {        func makingDummyArray() -&gt; [PinModel] {        var list = [PinModel]()                for _ in 0 ... 20 {            let model = PinModel(x: lonlatGenerator().0, y: lonlatGenerator().1, id: serialGenerator())            list.append(model)        }                return list    }        // 10자리의 랜덤한 SerialNumber를 만들어줌    func serialGenerator() -&gt; String {        let letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"        let madeString = String((0 ..&lt; 10).map{ _ in letters.randomElement()! })        return madeString    }        func lonlatGenerator() -&gt; (Double, Double) {                // 시뮬레이터 기반 Apple 지역 위도,경도        let defaultLon = -122.030189        let defaultLat = 37.331676        // 위도,경도를 250m 환산했을때의 값        let lonKm = 0.002825        let latKm = 0.002275                // 애플의 위도,경도를 기준으로 +,- 1km 범위의 랜덤 값을 추출        let x = Double.random(in: (defaultLon - lonKm ... defaultLon + lonKm))        let y = Double.random(in: (defaultLat - latKm ... defaultLat + latKm))                return (x, y)    }   }그리고 해당 기능을 사용할 mapvc로 가서func makingDummy() {        for i in dummyArray.indices {            let coordinate = CLLocationCoordinate2D(latitude: dummyArray[i].y, longitude: dummyArray[i].x)            addMark(coordinate: coordinate, serial: dummyArray[i].id)        }}이렇게 구현을 했다. 이때 addMark 함수는 좌표값만 parameter로 받았는데, serial값도 부여하기 위해 변경해줬다.func addMark(coordinate: CLLocationCoordinate2D, serial: String) {                let pin = MKPointAnnotation()        let address = CLGeocoder.init()        address.reverseGeocodeLocation(CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude)) { (placemarks, error) in            var placeMark: CLPlacemark!            placeMark = placemarks?[0]                        guard let address = placeMark else { return }                        pin.title = \"기기번호: \\(serial)\" // modified            pin.subtitle = \"현재위치: \\(address.thoroughfare ?? \"Apple Store\")\"                        pin.coordinate = coordinate            self.mapView.addAnnotation(pin)        }    }예외처리도 하였지만 너무 한게 많아서 기억이 나질 않는다.정보 view 생성이건 키오스크에서 내가 구현했던걸 그대로 가져왔다.그래서 자세한 설명은 패스.거의 그대로 내가 썼던걸 사용했고,단지 UITapGestureRecognizer 를 통해 호출하게 하였다."
  },
  
  {
    "title": "킥보드 프로젝트 4일차",
    "url": "/posts/%ED%82%A5%EB%B3%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-4%EC%9D%BC%EC%B0%A8/",
    "categories": "캠프, 프로젝트2",
    "tags": "",
    "date": "2024-04-25 05:00:00 +0900",
    





    
    "snippet": "프로젝트 4일차다.점점 눈으로 보이기 시작한다.어제에 이어, Annotation Pin관련 기능을 구현하는게 가장 중요하므로. 오늘은 이부분을 구현하면 될것같다.AnnotationView의 경우, 우리가 주변에 있는 킥보드를 클릭했을때 간단한 정보 + 대여버튼이 있으면 좋을 것 같아서, 구현하려한다.자료를 찾던 중 유튜브에 너무 코드 흐름이 잘 되어있...",
    "content": "프로젝트 4일차다.점점 눈으로 보이기 시작한다.어제에 이어, Annotation Pin관련 기능을 구현하는게 가장 중요하므로. 오늘은 이부분을 구현하면 될것같다.AnnotationView의 경우, 우리가 주변에 있는 킥보드를 클릭했을때 간단한 정보 + 대여버튼이 있으면 좋을 것 같아서, 구현하려한다.자료를 찾던 중 유튜브에 너무 코드 흐름이 잘 되어있어서, 이걸 기반으로 하나하나 작성해가면서 그 과정을 적어 보려 한다.Custom Annotation Pin, View 구현우선 Annotation Pin은 지금은 그냥 일반적인 pin이다.이걸 킥보드의 이미지로 보여주면 더 좋을 것 같아서 수정하기로 결정.// MARK: - AnnotationViewextension MapViewController: MKMapViewDelegate {        // AnnotaionView 생성    func mapView(_ mapView: MKMapView, viewFor annotation: any MKAnnotation) -&gt; MKAnnotationView? {        guard !(annotation is MKUserLocation) else {            return nil        }                var annotationView = mapView.dequeueReusableAnnotationView(withIdentifier: \"customPin\")                if annotationView == nil {            // view 생성                        annotationView = MKAnnotationView(annotation: annotation, reuseIdentifier: \"customPin\")            annotationView?.canShowCallout = true                        let btn = UIButton(type: .infoLight)            annotationView?.rightCalloutAccessoryView = btn            let click = UITapGestureRecognizer(target: self, action: #selector(showbtn))            annotationView?.addGestureRecognizer(click)            let btnClick = UITapGestureRecognizer(target: self, action: #selector(showView))            btn.addGestureRecognizer(btnClick)                                } else {            annotationView?.annotation = annotation        }                // pin image 조절 및 등록        let pinImage = UIImage(named: \"scooterPin\")        let size = CGSize(width: 40, height: 40)        UIGraphicsBeginImageContext(size)        pinImage!.draw(in: CGRect(x: 0, y: 0, width: size.width, height: size.height))        let resizedImage = UIGraphicsGetImageFromCurrentImageContext()                annotationView?.image = resizedImage                return annotationView    }    }지도에 스쿠터모양의 pin이 생긴다.기능구현에 집중을 하다보니 결국 과정보단 결과를 기준으로 글을 작성하게 되었다.위의 코드를 프로젝트 완료가 된 시점에서 리뷰를 하며 적는다우선 CustomCell 처럼 이것도 역시 커스텀이 가능하지만, 위의 영상대로 이렇게도 나름 원하는대로 조정이 가능하기에 선택을 하게 되었다.  MKAnnotationView 란?      Annotation Object를 비주얼적으로 보여준다.  만드는 방법은 아주 다양하다, 위에서 언급한대로 별도의 Class를 사용하여 조금 더 디테일하게 만들 수도 있다.아마 다음에 지도를 또 사용하게 된다면 사용할것같다.다시 돌아와서, UIGestureRecognizer를 사용하여, 클릭을 할때 Event가 발생하게 하였다.우선 마커들을 클릭했을때 정보를 표현하고 싶었기에, annotationView?.canShowCallout = true로 설정하였다.그러면 예전 키오스크에서는 마커를 클릭해도 간단하게 확대가되고, 밑에 subtitle이 보였던것으로 기억하는데, 이제는 클릭을 하면 말풍선 같은게 생기면서 좀더 마커에 정보를 담을 수 있게한다.Pin 추가 기능생각해보니 핀에대한 언급이 없어서 여기에 적기로한다. (이부분은 사실 5일차에 디테일하게 구현한 내용.)4일차에는 핀만 추가 되어있었다.// pin 추가.    func addMark(coordinate: CLLocationCoordinate2D, serial: String) {                let pin = MKPointAnnotation()        let address = CLGeocoder.init()        address.reverseGeocodeLocation(CLLocation(latitude: coordinate.latitude, longitude: coordinate.longitude)) { (placemarks, error) in            var placeMark: CLPlacemark!            placeMark = placemarks?[0]                        guard let address = placeMark else { return }                        pin.title = \"기기번호: \\(serial)\"            pin.subtitle = \"현재위치: \\(address.thoroughfare ?? \"Apple Store\")\"                        pin.coordinate = coordinate            self.mapView.addAnnotation(pin)        }            }핀을 구현하는것 자체는 키오스크에서 썼던 방식과 크게 차이는 없다. 다만 가장 큰 차이라면 Subtitle에 들어가는 내용이 좌표를 기반으로한 현재 위치를 보여주는 것이다.  다만 주의사항이 있다면, 1분안에 많은 request가 발생할경우 지도에 핀이 보이지 않는다.현재 좌표를 기반으로 주소를 호출하는 메서드인 reverseGeocodeLocation을 사용한다. 그리고 Completion Handler를 사용하는 이유는, 이것도 일종의 Apple의 REST API를 호출하는 개념이기 때문.성공하면 Address정보가 나오게 된다. 주소를 길게 표현을 하는게 좋을까 하다가, 그냥 마지막 주소 예를 들면 한국이면 ~~로 이런식으로 표현을 하는게 좋을 것같아 이렇게 구현했다.우선 시뮬레이터에서 일본, 미국으로 테스트했을때 둘의 지역표기가 달라서 thothoroughfare 단위를 사용했다.그리고 pin의 좌표도 설정해주고, 지도에 핀을 박게 하였다.pin 선택시 이벤트 구현1. 선택시 거리를 기준으로 구현. func mapView(_ mapView: MKMapView, didSelect annotation: any MKAnnotation) {                let pin = annotation        let currentLocation = mapView.userLocation.location                guard let distance = currentLocation?.distance(from: CLLocation(latitude: pin.coordinate.latitude, longitude: pin.coordinate.longitude)) else {            fatalError(\"Can't get distance from Pin\")        }                if distance &gt; 100.0 {            rentButton.isHidden = true            let alert = UIAlertController(title: \"구역 외 킥보드 접근\", message: \"100m 를 넘어선 킥보드는 이용이 불가합니다.\", preferredStyle: .alert)            alert.addAction(UIAlertAction(title: \"확인\", style: .default))            self.present(alert, animated: true)        }    }저때 거리는 123미터였다.구현완료.하지만 기본적으로는 보이게는 해야하기에 대여버튼을 눌렀을때 해당 로직이 구현이 되어야한다.2. 대여 시 pin 삭제.처음에는 무수히 많은 핀들중 어떻게 내가 선택한 핀만 확인할 수 있을까 고민을 했지만, 나의 배움의 부족으로 아이디어가 떠오르지 않았다.그러다가 스택오버플로우에서 내가 원하는 걸 찾았다.바로 didSelect Method를 활용하는것이다.보자마자 아차 싶었고, 바로 적용을 했다.var selectedAnnotation: MKPointAnnotation? func mapView(_ mapView: MKMapView, didSelect view: MKAnnotationView) {        self.selectedAnnotation = view.annotation as? MKPointAnnotation    }func completedRent(didSelect annotation: any MKAnnotation) {        let pin = annotation        mapView.removeAnnotation(pin)    }구현 완료.3. 주행기록 Data 저장.실제 주행거리는 아니지만 좌표로 계산해서 이런 기능만 보여주려고 만들었다.물론 일정한 시간마다 거리계산용 배열에 좌표값을 계속 추가해준다면, 실제 이동한 거리 구현도 가능하다.하지만 튜터님께 여쭤본 결과 지금 프로젝트 단계에서는 이정도 구현도 충분하다고 하셨기에, 여기서 멈춘다.var locations: [CLLocationCoordinate2D] = [] // 거리 계산용 배열// 거리계산 함수.    func calculateTripDistance() {                var total: Double = 0.0        for i in 0..&lt;locations.count - 1 {            let start = locations[i]            let end = locations[i + 1]            let distance = getDistance(from: start, to: end)            total += distance        }           }        func getDistance(from: CLLocationCoordinate2D, to: CLLocationCoordinate2D) -&gt; CLLocationDistance {        let from = CLLocation(latitude: from.latitude, longitude: from.longitude)        let to = CLLocation(latitude: to.latitude, longitude: to.longitude)        return from.distance(from: to)    }// 대여시@IBAction func didTapRentButton(_ sender: Any) {        let rentProcessAlert = UIAlertController(title: \"대여 진행\", message: \"해당 킥보드를 이용하시겠습니까?\", preferredStyle: .alert)                let rent = UIAlertAction(title: \"대여하기\", style: .default) { _ in            self.completedRent(didSelect: self.selectedAnnotation!)                        if let coordinate = self.selectedAnnotation?.coordinate { // new                self.locations.append(coordinate)            }                        DispatchQueue.main.async {                                self.isUsed = true                self.setbuttonHidden(isStatus: self.isUsed)            }        }                let cancel = UIAlertAction(title: \"취소\", style: .cancel)                rentProcessAlert.addAction(cancel)        rentProcessAlert.addAction(rent)        present(rentProcessAlert, animated: true, completion: nil)                            }// 반납시@IBAction func returnScooterBtn(_ sender: UIButton) {        DispatchQueue.global().async { [weak self] in            if CLLocationManager.locationServicesEnabled() {                self?.locationManager.requestWhenInUseAuthorization()                let currentLocation = self?.locationManager.location                                self?.addMark(coordinate: CLLocationCoordinate2D(latitude: currentLocation?.coordinate.latitude ?? 37.503702192, longitude: currentLocation?.coordinate.longitude ?? 127.025313873406))                self?.locations.append(currentLocation!.coordinate)            }                    }        isUsed = false        setbuttonHidden(isStatus: isUsed)                let alert = UIAlertController(title: \"반납완료\", message: \"킥보드 반납이 완료되었습니다.\\n안녕히 가세요.\", preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"확인\", style: .default))        self.present(alert, animated: true)        let distance = calculateTripDistance()        let finTime = Date.now        RecordSingleton.shared.array.append(RecordModel(distance: distance, time: finTime))    }            대여시 거리계산용 배열에 좌표를 추가하고, 반납시 좌표를 추가하여, 그 둘의 값을 계산하는 시퀀스로 이루어 진다고 생각하면 된다.위에도 적었지만 이걸 일정한 간격마다 계속 추가하고 함수를 계속 사용하여 Dispatchqueue를 사용하여 해당 내용을 어떤 View에 추가를 한다면,실시간 이동거리를 계산 할 수도 있다.이부분은 프로젝트 개조할때 해보는걸로…4. 반납시 기록을 저장할 배열을 싱글턴으로 구현위에 이미 마지막에 추가하는게 적혀있지만 그래도 사용하게된 이유를 적어보자면, 우선 싱글턴으로 구현을 해서 지도와, 마이페이지의 주행거리 쪽을 눌러서 확인할때 데이터를 굳이 왔다갔다 하는게 의미가 있나 싶어서 싱글턴을 사용하면 좋겠다 싶어 바로 구현을 했다.키오스크때 사용을 해서 그런가, 바로 구현을 했다.import Foundationclass RecordSingleton {        static let shared = RecordSingleton()        var array: [RecordModel] = [RecordModel]()        private init () {}    }5. 추가 대여 방지 로직 구현.사실 이건 Boolean을 통해 대여하기 버튼을 보이지 않는 형식으로 단순하게 했다.var isUsed: Bool = falseisUsed라는 값을 통해 유져가 사용중인지? 아닌지를 판단하고 그에따라 버튼을 보여줄지 말지를 결정하게 했다.사실 추가대여 방지는 사용할때 바로 버튼을 다 보이지않게 숨기고, 그다음에 사용을 다하게 되면 보여주는 방식이 더 좋았지만현재 기능 테스트에서는 단순히 버튼만 보여주고 말고만 하게 하였다.// 대여의 상태를 보고 버튼을 숨기거나 보여줌    func setbuttonHidden(isStatus: Bool) {                if !isStatus {  // false 대여를 하지 않은 상태            rentButton.isHidden = true // true인 이유는 평상시에도 숨기다가 킥보드를 클릭했을때 보여주게 하기위함.            returnButton.isHidden = true        } else { // 대여를 한 상태라면            rentButton.isHidden = true            returnButton.isHidden = false        }    }확인 완료."
  },
  
  {
    "title": "킥보드 프로젝트 3일차",
    "url": "/posts/%ED%82%A5%EB%B3%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-3%EC%9D%BC%EC%B0%A8/",
    "categories": "캠프, 프로젝트2",
    "tags": "",
    "date": "2024-04-24 18:00:00 +0900",
    





    
    "snippet": "프로젝트 3일차 각 팀원분들이 올려준걸 머지를 어떻게 하는지 알려주고나니 슬슬 틀이 잡혀지는게 보인다.약간의 추가기능 느낌이지만, 이부분은 어떻게 보면 나름 필수 기능이라고 생각해서 이부분에 대해 작성을 해보려 한다.현재위치에서 가장 가까운 Marker와의 거리를 구하는 로직 구현.let pins = mapView.annotationslet curre...",
    "content": "프로젝트 3일차 각 팀원분들이 올려준걸 머지를 어떻게 하는지 알려주고나니 슬슬 틀이 잡혀지는게 보인다.약간의 추가기능 느낌이지만, 이부분은 어떻게 보면 나름 필수 기능이라고 생각해서 이부분에 대해 작성을 해보려 한다.현재위치에서 가장 가까운 Marker와의 거리를 구하는 로직 구현.let pins = mapView.annotationslet currentLocation = mapView.userLocation.location        print(pins.count)우선 다음과 같이 했다.그리고 Annotation을 추가할때마다 몇개가 출력이 되는지 확인을 하기위해 print를 사용하여 개수를 확인했다.아무것도 없는데 개수가 1이 뜨는것으로 보아.현재 유져의 위치를 알려주는것도 annotation으로 포함을 하는것 같다.작성된 코드를 확인해 보아도 Annotation 추가에 관한 내용는 테스트로 둔 Addpin 버튼밖에 없다.코드를 좀 더 구현했다. pins.forEach { pin in            if let distance = currentLocation?.distance(from: CLLocation(latitude: pin.coordinate.latitude, longitude: pin.coordinate.longitude)) {                array.append(distance)                print(array)                print(\"=====\")                print(array.min() ?? 0)            }        }이렇게 하고 최소값을 찍으려하니 문제를 알았다.[0.0, 511.98378656402537]=====0.0[0.0, 511.98378656402537, 113.42895215161697]=====0.0[0.0, 511.98378656402537, 113.42895215161697, 540.4131619778344]=====0.0이게 출력한 결과중 일부인데, 현위치도 마커로 인식하기때문에 무조건 최소값은 0이 찍히는게 당연했다.그래서 배열을 오름차순 정렬을 하게 한뒤에 첫번째 인덱스의 값을 가져오게 했다. @IBAction func getDistance(_ sender: UIButton) {                let pins = mapView.annotations        let currentLocation = mapView.userLocation.location                var array: [Double] = [Double]()                pins.forEach { pin in            if let distance = currentLocation?.distance(from: CLLocation(latitude: pin.coordinate.latitude, longitude: pin.coordinate.longitude)) {                array.append(distance)            }        }        array.sort(by: &lt;)        print(array[1])    }    완료.TabBar 연결.프로젝를 진행하면서 처음에 TabbarVC가 있었는데, 그게 어느순간 사라진것알았다.TabbarViewController를 하나 만들어주고, Items(Tabbar VC를 생성하면 자연스럽게 추가되는 VC)를 전부 지워주고탭바로 연결하려고 하는 VC를 Link하듯 컨트롤을 누르고 드래그 해주면 된다.그리 어렵지는 않다. 그리고 초기화면과 기타 설정을 해주기 위해 TabbarVC Class도 만들어 준다.그리고 팀원분이 만드신 회원가입페이지에서 TabbarVC로 화면전환을 시킨다.// SingupVCif let tabVC = self.storyboard?.instantiateViewController(withIdentifier: \"tapVC\") as? TabbarViewController {                self.navigationController?.pushViewController(tabVC, animated: true)            } else {                print(\"NextViewController를 인스턴스화할 수 없습니다.\")            }// Tabbar Controllerimport UIKitclass TabbarViewController: UITabBarController {    override func viewDidLoad() {        super.viewDidLoad()        self.selectedIndex = 0        self.navigationController?.isNavigationBarHidden = true    }}처음에 선택되는건 지도로 하기위해 인덱스를 0으로 설정하고,NavigationBar Button을 보이지 않게 하기위해 hidden을 설정한다.이렇게 되면 회원가입을하면 TabbarVC로 가게 되고 TabbarVC중 item index가 0인건 지도이므로 바로 지도화면을 보이게 된다.오늘은 내 기능보다 팀원분들을 도와준게 더 많았기에 여기서 마무리"
  },
  
  {
    "title": "킥보드 프로젝트 2일차",
    "url": "/posts/%ED%82%A5%EB%B3%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-2%EC%9D%BC%EC%B0%A8/",
    "categories": "캠프, 프로젝트2",
    "tags": "",
    "date": "2024-04-23 18:00:00 +0900",
    





    
    "snippet": "Kakao Map API V2를 사용하려 했으나,Docs대로 구현 하던 중 메서드가 먹히지 않아 searchBar에 대한 부분만 해보려 한다.우선 검색을 했을때 해당 주소의 지역의 값을 가져오게 하려고 한다.searchBar 기능 구현extension ViewController: UISearchBarDelegate {        func search...",
    "content": "Kakao Map API V2를 사용하려 했으나,Docs대로 구현 하던 중 메서드가 먹히지 않아 searchBar에 대한 부분만 해보려 한다.우선 검색을 했을때 해당 주소의 지역의 값을 가져오게 하려고 한다.searchBar 기능 구현extension ViewController: UISearchBarDelegate {        func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {        searchBar.text = \"\"    }        func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {        searchBar.endEditing(true)    }        func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {        print(searchBar.text)    }}우선은 기본 틀만 잡아둔다.KakaoMap REST API 호출Docs에 알려주는대로 구현하면 될것 같다.우선 헤더와 파라미터를 다르게 사용하기에 Alamofire을 사용해야 할 것으로 보인다.func fetchRequest(textString: String) {        let url = \"https://dapi.kakao.com/v2/local/search/address.json\"        let header: HTTPHeaders = [\"Authorization\" : \"KakaoAK {API KEY}\"]        let parameter = [\"query\" : textString]                AF.request(url, method: .get, parameters: parameter, headers: header).responseDecodable(of: MapModel.self) { response in            print(response)        }            }Decoding Error가 떠서 확인했는데 알고보니 Authorization 관련 Error였다.엄한부분 파고들었던게 잘못이었다.우선 모델링은 좌표값만 가져오려고 하기에 다음과 같이 구성을 하였다.struct MapModel: Decodable {        let documents: [Document] }struct Document: Decodable {        let addressName: String    let x: String    let y: String        enum CodingKeys: String, CodingKey {                case addressName = \"address_name\"        case x        case y            }    }이제 코드를 더 작성해서 넘기도록 하겠다.func fetchRequest(textString: String, completion: @escaping (Result&lt;MapModel, Error&gt;) -&gt; Void) {        let url = \"https://dapi.kakao.com/v2/local/search/address.json\"        let header: HTTPHeaders = [\"Authorization\" : \"KakaoAK API Key\"]        let parameter = [\"query\" : textString]                AF.request(url, method: .get, parameters: parameter, headers: header).responseDecodable(of: MapModel.self) { response in            switch response.result {            case .success(let data):                completion(.success(data))            case .failure(let error):                completion(.failure(error))            }        }            }func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {        if let text = searchBar.text {            mapManager.fetchRequest(textString: text) { result in                switch result {                case .success(let data):                    print(data)                case .failure(let error):                    print(error)                }            }                    }            }출력은 잘된다.다만 코엑스 이렇게 검색하는게 아니라, 진짜 찐 주소를 입력해야 가져오는 아주 큰 단점이 존재한다.호출된 좌표값으로 지역 이동.documents의 배열에 어차피 첫번쨰로 가기에 일단은 인덱스를 0으로 해두었다. 해당 부분은 추가로 수정 예정func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {        if let text = searchBar.text {            mapManager.fetchRequest(textString: text) { result in                switch result {                case .success(let data):                    if let lat = Double(data.documents[0].y), let lon = Double(data.documents[0].x) {                        DispatchQueue.main.async {                            let region = MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: lat, longitude: lon), span: MKCoordinateSpan(latitudeDelta: 0.01, longitudeDelta: 0.01))                            self.mapView.setRegion(region, animated: true)                        }                                            }                case .failure(let error):                    print(error)                }            }                    }            }    완료.괜히 카카오 지도 쓰려다가 고생은 했지만, 손해본건 아니어서 좋은 경험이었다.갑자기 AlamoFire를 쓰지않고도 구현해보는 연습이 필요해서 추가로 글을 작성한다FetchRequest 재구현 (Without AlamoFire)AF를 쓰지않고도 할 수 있을것 같아서 찾아보다가 사이트를 한번 봤는데, 생각보다 별거 없어서 구현해보려한다.func fetchRequestWithSession(textString: String, completion: @escaping (Result&lt;MapModel, Error&gt;) -&gt; Void) {                let urlString = \"https://dapi.kakao.com/v2/local/search/address.json\"        let header: HTTPHeaders = [\"Authorization\" : \"KakaoAK API Key\"]        if let url = URL(string: urlString) {                        var urlComponent = URLComponents(string: urlString)            urlComponent?.queryItems = [URLQueryItem(name: \"query\", value: textString)]                        var request = URLRequest(url: url)            request.httpMethod = \"GET\"            request.headers = header                        let urlSession = URLSession(configuration: .default)                        let task = urlSession.dataTask(with: url) { (data, response, error) in                if let e = error {                    completion(.failure(e))                }                                if let safeData = data {                    let decodedData = self.decodingJson(data: safeData)                    completion(.success(decodedData!))                }            }            task.resume()        }            }        func decodingJson (data: Data) -&gt; MapModel? {                let decoder = JSONDecoder()        do {            let decodedData = try decoder.decode(MapModel.self, from: data)            let documents = decodedData.documents            let address = documents[0].addressName            let x = documents[0].x            let y = documents[0].y                        var list: MapModel = MapModel(documents: [Document(addressName: address, x: x, y: y)])                        return list                    } catch {            print(error)                        return nil        }            }디코딩에러 아무래도, 또 Auth 에러로 보인다.즉 설정한 헤더가 제대로 먹지 않았다고 생각이 든다.문제점 확인let task = urlSession.dataTask(with: url) 이부분이 문제였다.with 부분에 url이 아닌 request로 들어가야 했던 문제였다.헤더는 ` request.setValue(“KakaoAK API_Key”, forHTTPHeaderField: “Authorization”)` 이부분이 맞았다.이제는 파라미터에 관한 에러가 뜬다.혹시나 해서 request에서 query를 넣는 메소드가 있어서 해보았다.request.url?.append(queryItems: [URLQueryItem(name: \"query\", value: \"전북 삼성동 100\")])실행해보니 출력이 된다.이제 이해했다.그런데 왜 urlcomponent에서는 안되는지 좀 생각을 해봐야겠다.뭐가 놓친게 있는듯하다.urlcomponent의 url로 넘기니 해결이 되었다.component 사용class NetworkManager {        func makeStringKoreanEncoded(_ string: String) -&gt; String {        return string.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? string    }        func fetchRequestWithSession(completion: @escaping (Result&lt;MapModel, Error&gt;) -&gt; Void) {                        let urlString = \"https://dapi.kakao.com/v2/local/search/address.json\"            if let url = URL(string: urlString) {                                var urlComponent = URLComponents(string: urlString)                urlComponent?.queryItems = [URLQueryItem(name: \"query\", value: \"전북 삼성동 100\")]                                let urlforrequest = urlComponent?.url                                var request = URLRequest(url: urlforrequest!)                request.httpMethod = \"GET\"                request.setValue(\"KakaoAK API_KEY\", forHTTPHeaderField: \"Authorization\")                let urlSession = URLSession(configuration: .default)                                let task = urlSession.dataTask(with: request) { (data, response, error) in                    if let e = error {                        completion(.failure(e))                    }                                        if let safeData = data {                        if let decodedData = String(data: safeData, encoding: .utf8) {                            print(decodedData)                            let decod = self.decodingJson(data: safeData)                            completion(.success(decod!))                                                    } else {                            print(\"decoding fail\")                        }                    }                }                task.resume()            }                    }                func decodingJson (data: Data) -&gt; MapModel? {                        let decoder = JSONDecoder()            do {                let decodedData = try decoder.decode(MapModel.self, from: data)                let documents = decodedData.documents                let address = documents[0].addressName                let x = documents[0].x                let y = documents[0].y                                let list: MapModel = MapModel(documents: [Document(addressName: address, x: x, y: y)])                                return list                            } catch {                print(error)                                return nil            }                    }    }component 미사용import Foundationclass NetworkManager {        func makeStringKoreanEncoded(_ string: String) -&gt; String {        return string.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? string    }        func fetchRequestWithSession(completion: @escaping (Result&lt;MapModel, Error&gt;) -&gt; Void) {                        let urlString = \"https://dapi.kakao.com/v2/local/search/address.json\"            if let url = URL(string: urlString) {                                var request = URLRequest(url: urlforrequest!)                request.httpMethod = \"GET\"                request.url?.append(queryItems: [URLQueryItem(name: \"query\", value: \"전북 삼성동 100\")])                request.setValue(\"KakaoAK API_KEY\", forHTTPHeaderField: \"Authorization\")                                let urlSession = URLSession(configuration: .default)                                let task = urlSession.dataTask(with: request) { (data, response, error) in                    if let e = error {                        completion(.failure(e))                    }                                        if let safeData = data {                        if let decodedData = String(data: safeData, encoding: .utf8) {                            print(decodedData)                            let decod = self.decodingJson(data: safeData)                            completion(.success(decod!))                                                    } else {                            print(\"decoding fail\")                        }                    }                }                task.resume()            }                    }                func decodingJson (data: Data) -&gt; MapModel? {                        let decoder = JSONDecoder()            do {                let decodedData = try decoder.decode(MapModel.self, from: data)                let documents = decodedData.documents                let address = documents[0].addressName                let x = documents[0].x                let y = documents[0].y                                let list: MapModel = MapModel(documents: [Document(addressName: address, x: x, y: y)])                                return list                            } catch {                print(error)                                return nil            }                    }    }끝."
  },
  
  {
    "title": "킥보드 프로젝트 1일차",
    "url": "/posts/%ED%82%A5%EB%B3%B4%EB%93%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-1%EC%9D%BC%EC%B0%A8/",
    "categories": "캠프, 프로젝트2",
    "tags": "",
    "date": "2024-04-22 18:00:00 +0900",
    





    
    "snippet": "일주일간 새로운 팀프로젝트가 시작된다.이번엔 좀 더 다양한 기능을 사용할 수 있게된 프로젝트이다.이번에 내가 기본기능에서 담당하는건, 반납 기능이다.반납을할때 pin을 꽂으면 될 듯 하다.그리고 대여값에 있던 내용을 지워주면 되기에 해당기능은 얼추 진행이 되었을 때 연결하면 될 듯하다.테스트용 지도 구현.우선 빈프로젝트에 해당 기능을 구현해서 테스트를...",
    "content": "일주일간 새로운 팀프로젝트가 시작된다.이번엔 좀 더 다양한 기능을 사용할 수 있게된 프로젝트이다.이번에 내가 기본기능에서 담당하는건, 반납 기능이다.반납을할때 pin을 꽂으면 될 듯 하다.그리고 대여값에 있던 내용을 지워주면 되기에 해당기능은 얼추 진행이 되었을 때 연결하면 될 듯하다.테스트용 지도 구현.우선 빈프로젝트에 해당 기능을 구현해서 테스트를 하는게 바람직해 보인다.우선 MkMapView를 UI에 그렸고,import UIKitimport MapKitimport CoreLocationclass ViewController: UIViewController, MKMapViewDelegate {        @IBOutlet weak var mapView: MKMapView!        let locationManager = CLLocationManager()            override func viewDidLoad() {        super.viewDidLoad()                locationManager.delegate = self        locationManager.requestWhenInUseAuthorization()        locationManager.requestLocation()                mapView.delegate = self        mapView.showsUserLocation = true                }    @IBAction func returnBoardBtn(_ sender: UIButton) {    }    }extension ViewController: CLLocationManagerDelegate {     func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {        if let location = locations.last {            locationManager.startUpdatingLocation()            let lat = location.coordinate.latitude            let lon = location.coordinate.longitude                    }    }        func locationManager(_ manager: CLLocationManager, didFailWithError error: any Error) {        let alert = UIAlertController(title: \"에러발생\", message: \"로드중 \\(error.localizedDescription) 가 발생했습니다.\", preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"확인\", style: .default))        self.present(alert, animated: true)    }    }우선은 다음과 같이 뼈대를 작성했다.문제 해결실행을 했을때 현재는 문제가 발생한다.현재 위치를 받아오는 과정에서 생긴 문제이다.현재 위치를 유져의 동의 없이 이루어진듯 하다.실제로 어플을 실행했을때 notice가 없었다.이부분이 빠져서 생긴 문제 같다.수정해주었다.requestLocation() 호출 시, 현위치를 다시 가져오게 하는 기능을 구현했다.func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {        if let location = locations.last {                        locationManager.startUpdatingLocation()            let lat = location.coordinate.latitude            let lon = location.coordinate.longitude            let region = MKCoordinateRegion(center: CLLocationCoordinate2D(latitude: lat, longitude: lon), span: MKCoordinateSpan(latitudeDelta: 0.05, longitudeDelta: 0.05))                        mapView.setRegion(region, animated: true)            mapView.showsUserLocation = true        }    }위치를 업데이트 한뒤, 위도, 경도 값을 region에 저장하고 그것을 mapView에 띄우는 매커니즘으로 가게된다.일단 시뮬레이터에 지정해둔 Location에 위치하는것까지는 구현이 되었으나.다른 기능을 Test를 하려고하니 Error가 발생한다.did fail with error: Error Domain=kCLErrorDomain Code=0 \"(null)\"이제는 좌표값을 가져오는 기능을 구현해봐야 한다.사이트를 참고 하여 위치를 가져왔다.if CLLocationManager.locationServicesEnabled() {                self?.locationManager.requestWhenInUseAuthorization()                let currentLocation = self?.locationManager.location                print(currentLocation)            }이떄 main thread에서는 실행하면 안된다는 error가 뜨므로,global로 바꿔주면 @IBAction func returnBoardBtn(_ sender: UIButton) {        DispatchQueue.global().async { [weak self] in            if CLLocationManager.locationServicesEnabled() {                self?.locationManager.requestWhenInUseAuthorization()                let currentLocation = self?.locationManager.location                print(currentLocation)            }                    }            }버튼을 클릭했을때 그 위치에 핀을 꽂게 구현@IBAction func returnBoardBtn(_ sender: UIButton) {        DispatchQueue.global().async { [weak self] in            if CLLocationManager.locationServicesEnabled() {                self?.locationManager.requestWhenInUseAuthorization()                let currentLocation = self?.locationManager.location                                self?.addMark(coordinate: CLLocationCoordinate2D(latitude: currentLocation?.coordinate.latitude ?? 37.503702192, longitude: currentLocation?.coordinate.longitude ?? 127.025313873406))            }                    }            }        func addMark(coordinate: CLLocationCoordinate2D) {        let pin = MKPointAnnotation()        pin.coordinate = coordinate        mapView.addAnnotation(pin)    }끝.나중에 coredata가 연결되면, 그때 등록을 하면 될 것 같다."
  },
  
  {
    "title": "Create Model (2)",
    "url": "/posts/Create-Model-(2)/",
    "categories": "Udemy, CoreML",
    "tags": "",
    "date": "2024-04-20 15:13:00 +0900",
    





    
    "snippet": "playground를 통한 자연어 처리 Model 생성우선 Dataset을 하나 가져온다.내용은 다음과 같다.여기서 playground로 만들어 주자.import Cocoaimport CreateMLlet data = try MLDataTable(contentsOf: URL(fileURLWithPath: \"\"))Dataset을 가져오는 작업을 한다.위...",
    "content": "playground를 통한 자연어 처리 Model 생성우선 Dataset을 하나 가져온다.내용은 다음과 같다.여기서 playground로 만들어 주자.import Cocoaimport CreateMLlet data = try MLDataTable(contentsOf: URL(fileURLWithPath: \"\"))Dataset을 가져오는 작업을 한다.위의 path에 경로를 넣어주자.실행해보니 path도 잘 연결된것으로 나온다.이젠 Train / Test Data를 만들어볼것이다.let(traningData, testingData) = data.randomSplit(by: 0.8, seed: 5)let sentimentClassifier = try MLTextClassifier(trainingData: traningData, textColumn: \"text\", labelColumn: \"class\")전에 언급했던 8:2의 비율로 나누고, seed는 일종의 난수로 시드에 따라 랜덤으로 8:2로 맞춰준다.여기 textColumn과 labelColumn은이렇게 된다.// beforeimport Cocoaimport CreateMLlet data = try MLDataTable(contentsOf: URL(fileURLWithPath: \"/Users/dongik/Documents/Workspace/twitter-sanders-apple3.csv\"))let(traningData, testingData) = data.randomSplit(by: 0.8, seed: 5)//let sentimentClassifier = try MLTextClassifier(trainingData: traningData, textColumn: \"text\", labelColumn: \"class\")let evaluationMetrics = sentimentClassifier.evaluation(on: testingData, textColumn: \"text\", labelColumn: \"class\")let evatuationAccuracy = (1.0 - evaluationMetrics.classificationError) * 100실행하니 다음과 같다.이제 모델을 저장해보자.let metadata = MLModelMetadata(author: \"Harold Song\", shortDescription: \"A model trained to classify sentiment on Tweets\", version: \"1.0\")try sentimentClassifier.write(to: URL(fileURLWithPath: \"/Users/dongik/Documents/Workspace/TweetSentimentClassifer.mlmodel\"), metadata: metadata)model에 대한 정보를 적고. 실행하면 모델이 생긴다.Test Modelpredict를 통해 테스트를 해보자부정적인 글을 썼더니 결과로 Neg가 나온다.import Cocoaimport CreateMLlet data = try MLDataTable(contentsOf: URL(fileURLWithPath: \"/Users/dongik/Documents/Workspace/twitter-sanders-apple3.csv\"))let(traningData, testingData) = data.randomSplit(by: 0.8, seed: 5)let sentimentClassifier = try MLTextClassifier(trainingData: traningData, textColumn: \"text\", labelColumn: \"class\")let evaluationMetrics = sentimentClassifier.evaluation(on: testingData, textColumn: \"text\", labelColumn: \"class\")let evatuationAccuracy = (1.0 - evaluationMetrics.classificationError) * 100let metadata = MLModelMetadata(author: \"Harold Song\", shortDescription: \"A model trained to classify sentiment on Tweets\", version: \"1.0\")try sentimentClassifier.write(to: URL(fileURLWithPath: \"/Users/dongik/Documents/Workspace/TweetSentimentClassifer.mlmodel\"), metadata: metadata)try sentimentClassifier.prediction(from: \"@Apple is a terrible company!\") // Negtry sentimentClassifier.prediction(from: \"I just found the best restaurant ever, and it's @DuckandWaffle\") // Postry sentimentClassifier.prediction(from: \"I think @CocaCola ads are just ok.\") // NeutralXcode에 Framework 추가하기.Drag &amp; Drop으로 만든 모델을 가져와서 클릭해보니, 내가 Metadata로 입력한 값들이 그대로 들어가 있는걸 알 수 있다.그리고 Twitter Api를 사용하기위해 Site를 접속해보자.그리고 개발자 계정을 만들어 두자.swift에 관한 내용은 여기를 참고.그리고 해당 내용 깃클론으로 가져온다.그리고 우리가 만든 프로젝트에 드래그를 해준다.그리고 프로젝트 바로 하위로 드래그 해준다.xcodeproj 파일을 드래그 해준 이유는 아래 사진으로 모두 설명이 된다.이렇게 프로젝트의 하위 내용도 그대로 사용이 가능해진다.이젠 해당 프레임워크를 사용해야하니 추가를 해보자.위의 사진처럼 추가를 해주면 된다.확인은 위와 같이 해준다.그리고 빌드테스트로 확인을 해주면 프레임워크 추가 끝.혹시나 빌드 테스트를 하면서 버전에 관한 에러가 뜬다면?이렇게 Minimum Deployments Version을 수정해주면된다.Twitter Framework 사용swifter = Swifter(consumerKey: TWITTER_CONSUMER_KEY, consumerSecret: TWITTER_CONSUMER_SECRET) 이걸 복사해서입력하고 consumer key, consumer secret을 입력해주자.API Key 관리.API키는 민감한 정보이므로, 이런 내용들이 Github에 올라가는 일을 방지해야한다. 물론 Git Guardian으로 메일이 와서 경고를 해주기도하지만, 애초에 해당 내용을 방지하는게 좋다.이렇게 새로운 PropertyList파일을 하나 만들어준다.그리고 여기에 담아주는데, 이때 .plist 파일을 .gitignore에 적어서 해당 파일을 업로드 하지 못하게 하면 된다.글한번 읽어보는 것도 추천.검색하는 기능을 구현.swifter의 searchTweet Method를 사용하는데, parameter가 많다.parameter에 대한 정보는.Docs를 참고. swifter.searchTweet(using: \"@Apple\") { (result, metadata) in            print(result)        } failure: { error in            print(error)        }검색에 관련된 메서드를 다음과 같이 적어주었다.우선 실행해서 어떻게 나오는지를 확인해\\보자.SwifterError(message: \"HTTP Status 401: Unauthorized, Response: {\\\"errors\\\":[{\\\"code\\\":32,\\\"message\\\":\\\"Could not authenticate you.\\\"}]}\"우선 Auth Error가 발생했기에, api key를 다시한번 확인해본다.Key를 Regenerate하여 입력하니SwifterError(message: \"HTTP Status 403: Forbidden, Response: {\\\"errors\\\":[{\\\"message\\\":\\\"You currently have access to a subset of Twitter API v2 endpoints and limited v1.1 endpoints (e.g. media post, oauth) only. If you need access to this endpoint, you may need a different access level. You can learn more here:다른 에러가 발생한다.아무래도 api 유료화에 대한 정책이라 더이상 진행이 불가능 해보인다…그냥 추가로 흐름에 대해서만 적도록 한다.모델 적용.let sentimentClassifier = TweetSentimentClassifer() model을 instance화 하고,predict 메서드를 사용한다.let prediction = try! sentimentClassifier.prediction(text: \"@Apple is a terribe company\")        print(prediction.label)이렇게 예측 값을 출력을 할 수 있다.그리고 여러값을 배열에 저장해서 예측을 할때는var tweets = [TweetSentimentClassiferInput]()                        for i in 0 ..&lt; 100 {                if let tweet = result[i][\"full_text\"].string {                    let tweetForClassfication = TweetSentimentClassiferInput(text: tweet)                    tweets.append(tweetForClassfication)                }            }                        do {                let predictions = try self.sentimentClassifier.predictions(inputs: tweets)                for pred in predictions {                    print(pred.label)                }            } catch {                print(error)            }이런식으로 여러 값을 저장할때 type이 중요한데, 우리가 만든 모델에 input 메서드를 통해 string값을 저장을 한다.이때 tweetForClassfication의 datatype은 TweetSentimentClassiferInput 이다.그러므로 var tweets = [TweetSentimentClassiferInput]() 배열도 이렇게 만드는 것이다.그리고 predict를 사용할때 어러 배열값이 들어갈때는이렇게 한번씩 option으로 확인을 해주는게 중요하다.이번 챕터는 여기까지.."
  },
  
  {
    "title": "Create Model (1)",
    "url": "/posts/Create-Model-(1)/",
    "categories": "Udemy, CoreML",
    "tags": "",
    "date": "2024-04-19 15:13:00 +0900",
    





    
    "snippet": "CreateML이제는 모델을 직접 만드는 과정이다.Docs 참고.학습을 위한 DataSet을 만들고 이미지 가져오기.이전에 파이썬으로 모델을 만드는것과 동일하게, Directory의 이름이 곧 Label이 된다.TrainingData라는 Directory를 만들고 거기에 새롭게 Dog라는 디렉토리를 만든다.Dataset이 많을 수록 더 정확도가 올라간...",
    "content": "CreateML이제는 모델을 직접 만드는 과정이다.Docs 참고.학습을 위한 DataSet을 만들고 이미지 가져오기.이전에 파이썬으로 모델을 만드는것과 동일하게, Directory의 이름이 곧 Label이 된다.TrainingData라는 Directory를 만들고 거기에 새롭게 Dog라는 디렉토리를 만든다.Dataset이 많을 수록 더 정확도가 올라간다.그리고 학습시킨 이미지를 테스트할 TestingData라는 폴더를 만들고 그 하위에 똑같이 Dog를 만든다.이때 중요한건, 학습과, 테스트의 Image는 달라야 한다.그래야 더 객관적으로 정확도를 판단할 수 있기 때문이다.강의에선 구글의 이미지를 가지고 오는데 이럴땐 Kaggle에서 데이터셋을 찾으면 더 편하다.캐글 오래간만에 들어가네, 이전에 프로젝트하면서 견종 인식 딥러닝 모델 정확도 올린다고 2주를 고생했던 기억이 떠오른다.사진은 모델링 하면서 했던 과정중의 하나를 가져와봤다.과거의 나와 조우.CreateML로도 할 수 있어서 나중에 한번 이걸로 아이디어를 만들어볼까? 생각을 해본다.다시 본론으로 돌아가서.이미지를 저장하게 되면 이미지의 확장자, 사이즈가 중요해진다.하지만 Createml은 그런 걱정에서 해방시켜준다.즉 JPEG, PNG같은 이미지 표준 형식을 사용하는 한 아무런 문제가 없다.ImageSet을 Train/Test로 분류하기.우리가 직접 이미지를 저장하고 폴더를 분류 하지않는 이상.ImageSet을 구하게 되면 label로만 나눠져있는 경우가 많다.강의와 다르게 Kaggle에서 구한 ImageSet은 90종의 동물 label이 있고, 이미지의 개수는 총 5400장이 있다.이것을 하나하나 Train/Test로 나눈다는건 멍청한 짓이다.Train/Test 이미지를 나눌때 비율은 8:2가 이상적이라고 한다.하지만 이렇게 분류하고서 끝이나는게 아니고, 원래는 Validation이라고 하여 학습을하고 그걸 통해 Test가 된 모델을 검증해야 하기에 Validation용 이미지를 또 별도로 분류를 하곤 한다.하지만 지금은 뭐 굳이 그렇게 까지 할 필요는 없기에… split만 하는걸로 하려고한다.우선 Python을 사용해야하고, split-folders라는 라이브러리가 필요하다.pip install split-folders위에 pip했을때 reject된 이유는 2.7버전이 더이상 업뎃이나 이런 유지보수를 안하기 때문.그래고 pip3 -V를 한 이유는 version check를 해야 vscode에서 python interpreter를 해당 버전에 맞추기 때문이다.설치가 끝났으니 해당 라이브러리를 사용한다.vscode에서 F1을 눌러 인터프리터를 설정을 다시 해준다. (그래야 설치한 라이브러리가 적용이된다.)vscode로 바로 터미널로 해당 파일 실행을 하면 이렇게 분류가 된다.import splitfolderssplitfolders.ratio(\"animals\", output=\"output\", seed=1337, ratio=(.8, .2))이때 주의할점은 디렉토리의 구조가 파이썬파일과 animals라는 상위 폴더와 같이있고, animals를 들어갔을때 label 폴더가 있어야 한다는 점이다.이런식.그러면 위의 사진과 같이 output이라는 새로운 디렉토리가 생성되었고 train/val로 나뉘어진걸 알 수 있다.그래서 위에는 TrainingData라는 디렉토리를 만들고 그다음에 Dog를 만들었지만, 더 많은 종류의 학습을 위해 새롭게 구성했다.train / val 의 디렉토리로 나누어졌다.CreateML을 통해 머신러닝모델 만들기.이전과 CreateML을 사용하는 방식이 바뀌었다.Xcode → ToolBar → Open Developer Tools → Create ML → Choose New Document → Choose an Image Classification → Give it the Training and Testing Data이렇게 된다.그리고 Training and Testing Data에 디렉토리를 추가해준다.Iteration은 반복 횟수를 의미한다.우선 아무런 Augumentations를 하지않고 학습을 시작해본다.이런식으로 진행과정이 보인다.1차 결과antelope가 0퍼센트의 정답률을 보인다.사실 이럴땐 이미지를 더 보강해줘야 하긴하지만, 지금은 그냥 테스트니까 넘어가자…우선 trainmore를 통해 35회의 반복 횟수를 더 주기로 했다.이렇게 결과가 나오면 어떤 부분이 제일 학습하면서 혼란스러워 했는지 알 수 있는데,영양과 사슴을 헷갈려했다.위에도 언급했지만 이건 영양과 사슴에 대해 이미지를 더 많이 주고 학습시키는것 밖에는 답이 없다.일단 모델만드는것에 포커스를 두고 패스하자.get을 누르면 해당 모델을 저장 할 수 있다.정확도를 올리는 Article이 애플 개발자 문서에 있으니 참고해도 좋을 듯 하다."
  },
  
  {
    "title": "6주차 과제 제출 Form 작성",
    "url": "/posts/6%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-%EC%A0%9C%EC%B6%9C-%EC%9E%91%EC%84%B1/",
    "categories": "캠프, 6주차",
    "tags": "",
    "date": "2024-04-19 04:00:00 +0900",
    





    
    "snippet": "iOS 숙련 개인과제 Form 작성.  기술질문: 앱 화면의 콘텐츠를 표시하는 로직과 관리를 담당하는 객체가 무엇인지 아는 대로 설명해주세요. [검색]          화면 위의 콘텐츠를 관리하기 위한 사각형 영역 객체를 UIVIew라고 정의한다.      즉 사용자에게 보일 UILabel, UIButton과 같은 화면 구성요소들을 모두 UIView라...",
    "content": "iOS 숙련 개인과제 Form 작성.  기술질문: 앱 화면의 콘텐츠를 표시하는 로직과 관리를 담당하는 객체가 무엇인지 아는 대로 설명해주세요. [검색]          화면 위의 콘텐츠를 관리하기 위한 사각형 영역 객체를 UIVIew라고 정의한다.      즉 사용자에게 보일 UILabel, UIButton과 같은 화면 구성요소들을 모두 UIView라고 하지만 이러한 객체들을 관리하기 위한 객체가 UIViewController이다.        기술질문: URLSession에 대해서 아는대로 설명해주세요. [Docs]          URLsession 클래스와 관련 클래스는 URLsession에서 데이터를 다운로드하고 URLs로 표시된 엔드포인트로 데이터를 업로드하기 위한 API를 제공한다.      또한 앱이 실행되지 않거나 iOS에서 앱이 일시 중단된 상태에서 이 API를 사용하여 백그라운드 다운로드를 수행할 수 있다.        어느 레벨까지 구현에 성공하셨나요?          Lv.5        어려웠던 점이 있다면 말씀해주세요.          기능구현에 있어서는 딱히 어려웠던 건 없다. 강의를 보지않고 먼저 5까지 구현을 다하고 나의 코드 전개와 튜터님이 알려주시는 코드전개가 어떤 차이가 있는 지 비교하면서 보았다.      어려웠다기 보다는 공부를 하면 좋을 것 같다고 생각한건, GCD이다.그리고 제출당일 CoredataManager를 해당 클래스로 코어데이터 관련 로직을 하려고 했으나, do catch의 예외가 들어가야하기에 그걸 어떻게 VC로 넘겨야할지에 대한 고민을 하다가 제출을 못할것 같아서 우선은 save쪽만 구현을 하고 제출을 하게 되었다. 너무 늦게 해당 아이디어가 생각이 나버렸던게 좀 아쉽다.        기술질문: 앱의 콘텐츠나 데이터 자체를 내부 저장/보관하는 특별한 객체로는 무엇이 있는지 아는 대로 설명해주세요.[검색&amp;요약]          I. UserDefaults                  UserDefaults는 간단한 Key-Value 데이터를 저장하는데 사용한다                    II. KeyChain                  iOS 앱에서 사용자의 비밀번호, 토큰, 인증서, 민감한 데이터와 같은 보안 관련 정보를 저장하는데 사용한다.                    III. CoreData                  iOS 앱에서 데이터를 관리하고 영구적으로 저장하는데 사용한다.          데이터 모델링을 할 수 있다                    IV. FileManager                  앱 내부 또는 외부 파일 시스템에 데이터를 저장할 수 있다.                      기술질문: 이번 챕터에서 학습을 하며 알게된 기술, 지식을 정리해보세요.          데이터를 받아오는 클래스에서 VC로 전달을 할때, 항상 Protocol을 사용하다가 이번에 챌린지반 수업을 진행하면서 Escaping Closure를 사용하여 전달하시는 모습을 보고, 여러 튜터님께 어느 방법이 더 효율정인지를 여쭤 보았고, 이런 단일 타입을 전달할때는 Escaping Closure로 전달하는게 더 좋다고 하셨기에, 공부도 하고 챌린지반 리마인드도 할겸 pull to refresh 부분에 해당기능을 구현 하였다.      Escaping Closure의 경우, 함수가 종료되었을때 작동을 한다. 일반적인 Non-escaping Closure의경우 함수의 실행이 종료 되기 전에 실행되는 클로저로 차이가 명확하다.      그리고 클로저안에 전달할 parameter로 Result라는 열거형을 사용했는데, 성공했을때, 실패했을때 두개의 case를 가지고 있다.      성공할경우엔 우리가 전달하고자하는 DataType이 들어가고, 실패했을때는 error를 전달하게 한다.        과제를 작성한 Github Repository 주소를 기입해주세요.          https://github.com/Haroldfromk/WishListRepo        기술질문: CoreData의 각 Entity, Attribute, Relationship의 역할을 아는 대로 설명해주세요. [나의지식]          Database에서 Entity는 Table의 역할을 하고, Attribute는 Field의 역할을 한다.RelationShip은 각 Entity 간의 관계를 설정할때 사용하는데, ParentRelationShip / ChildRelationShip으로 나뉜다      "
  },
  
  {
    "title": "WhatFlower (2)",
    "url": "/posts/WhatFlower-(2)/",
    "categories": "Udemy, CoreML",
    "tags": "",
    "date": "2024-04-18 01:13:00 +0900",
    





    
    "snippet": "기본 코드 구성.class ViewController: UIViewController {    @IBOutlet weak var imageView: UIImageView!        let imagePicker = UIImagePickerController()        override func viewDidLoad() {        super....",
    "content": "기본 코드 구성.class ViewController: UIViewController {    @IBOutlet weak var imageView: UIImageView!        let imagePicker = UIImagePickerController()        override func viewDidLoad() {        super.viewDidLoad()                imagePicker.delegate = self        imagePicker.sourceType = .camera        imagePicker.allowsEditing = true            }    @IBAction func cameraTapped(_ sender: UIBarButtonItem) {        present(imagePicker, animated: true)                imagePicker.dismiss(animated: true)    }    }extension ViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate {        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {                    let userPickedImage = info[UIImagePickerController.InfoKey.editedImage] as? UIImage                imageView.image = userPickedImage    }}SeeFood와 동일한 구조로 기본 코드를 구성한다.차이점이라면 allowsEditing이 true로 되었고, 그에따라 userPickedImage 역시 editedImage가 되었다는 것.info.plist file 수정카메라 접근 권한 허용을 유져에게 물어봐야 하기에 해당부분을 구현한다.CoreML, Vision 사용하여 기능 구현.어제 SeeFood와 했던 것 그대로 작성한다.고고우선 내 기억과 이해를 바탕으로 먼저 작성해본다.// 나func detect (image: CIImage) {                var coremlModel = try! VNCoreMLModel(for: FlowerClassifier().model)    var request = VNCoreMLRequest(model: coremlModel) { (request, error) in        print(request)    }            var handler = VNImageRequestHandler(ciImage: image)                do {            try handler.perform([request])        } catch {            print(error)        }    }  // 강의func detect (image: CIImage) {                    guard let coremlModel = try? VNCoreMLModel(for: FlowerClassifier().model) else {            fatalError(\"Import model failed\")        }        let request = VNCoreMLRequest(model: coremlModel) { (request, error) in            print(request)        }                var handler = VNImageRequestHandler(ciImage: image)                do {            try handler.perform([request])        } catch {            print(error)        }    }// request 수정.let request = VNCoreMLRequest(model: coremlModel) { (request, error) in            let result = request.results?.first as? VNClassificationObservation                        self.navigationItem.title = result?.identifier        }실행하여 테스트.102 종류의 꽃을 분류한다고하니 확인해보자.애플 개발자 계정은 무료일땐 3개가 최대이다. (실제 폰에서 테스트할때)결과의 첫번째 문자를 대문자로 바꾸기.현재 결과를 보면 전부 소문자로 나온다.앞에 대문자를 만들어 주자.self.navigationItem.title = result?.identifier.capitalized뒤에 capitalized 만 넣어주면 해결.특정 Library 설치Alamofire 와 swiftyJson을 설치한다.위키피디아 api를 사용.Docs 참고.API에 대한 간략한 정보는 여기에.let wikipediaURl = \"https://en.wikipedia.org/w/api.php\"  let parameters : [String:String] = [  \"format\" : \"json\",  \"action\" : \"query\",  \"prop\" : \"extracts\",  \"exintro\" : \"\",  \"explaintext\" : \"\",  \"titles\" : flowerName,  “indexpageids” : \"\",  \"redirects\" : \"1\",   ]위의 정보를 바탕으로 api 호출 url을 만들어본다.그럼 다음과 같다https://en.wikipedia.org/w/api.php?format=json&amp;action=query&amp;prop=extracts&amp;exintro=&amp;explaintext=&amp;titles=flowerName&amp;indexpageids=&amp;redirects=1저기서 flowerName 부분에 label에 있는 꽃의 이름을 입력하면이렇게 json 정보를 얻을 수 있다Alamofire(Old version) 사용하여 JSON 가져오기.  func requestInfo(flowerName: String) {          let parameters : [String:String] = [          \"format\" : \"json\",          \"action\" : \"query\",          \"prop\" : \"extracts\",          \"exintro\" : \"\",          \"explaintext\" : \"\",          \"titles\" : flowerName,          \"indexpageids\" : \"\",          \"redirects\" : \"1\",          ]                Alamofire.request(wikipediaURl, method: .get, parameters: parameters).responseJSON { (response) in            if response.result.isSuccess {                print(\"Got\")                print(response)            }        }            }parameters라는 배열을 통해 위에처럼 주소로 다 안적고 심플하게 할 수 있다.강의상 Alamofire를 구버전으로 설치했기에 그걸로 했다.특히 어려워할부분은 없다.특이한건 responseJSON을 사용했다는것.그러다보니 데이터 타입이 다르다.기존에 우리가 아는 개념으로 적용했을땐 decoding 하고 어떤 Model이 DataType이었는데, 그런식으로 적용한 코드가 아니다.기능테스트화면과 콘솔에 출력되는 결과이다.swiftyJSON 사용let flowerJSON: JSON = JSON(response.result.value!)let pageid = flowerJSON[\"query\"][\"pageids\"][0].stringValuelet flowerDescription = flowerJSON[\"query\"][\"pages\"][pageid][\"extract\"].stringValue                self.label.text = flowerDescriptionSDWebImage 사용하기.위키에서 제공하는 이미지를 사용하기위해 파라미터를 수정let parameters : [String:String] = [          \"format\" : \"json\",          \"action\" : \"query\",          \"prop\" : \"extracts|pageimages\", // modified          \"exintro\" : \"\",          \"explaintext\" : \"\",          \"titles\" : flowerName,          \"indexpageids\" : \"\",          \"redirects\" : \"1\",          \"pithumbsize\" : \"500\"          ]let flowerImageURL = flowerJSON[\"query\"][\"pages\"][pageid][\"thumbnail\"][\"source\"].stringValue                self.imageView.sd_setImage(with: URL(string: flowerImageURL))이미지에 주소에 대한 파라미터를 바꾸니 경로가 나온다.작동 완료."
  },
  
  {
    "title": "WhatFlower (1)",
    "url": "/posts/WhatFlower-(1)/",
    "categories": "Udemy, CoreML",
    "tags": "",
    "date": "2024-04-17 14:13:00 +0900",
    





    
    "snippet": "PIP 설치확인  PIP?      파이썬으로 작성된 패키지 라이브러리를 관리해주는 시스템  우선 설치되어있는지 확인하기위해 Terminal에서 버전체크를 해보자맥에서는 기본적으로 python이 설치가 되어있다.하지만 python -V를 하니 인식이 안되어서 환경변수를 확인해볼까 하다가. brew install python을 사용해서 파이썬 재설치를 ...",
    "content": "PIP 설치확인  PIP?      파이썬으로 작성된 패키지 라이브러리를 관리해주는 시스템  우선 설치되어있는지 확인하기위해 Terminal에서 버전체크를 해보자맥에서는 기본적으로 python이 설치가 되어있다.하지만 python -V를 하니 인식이 안되어서 환경변수를 확인해볼까 하다가. brew install python을 사용해서 파이썬 재설치를 하기로 결정pip를 통해 가상환경 설치인스톨을 하려 하니 문제가 발생.사이트를 참고하여 값을 변경해주었다.pip3 install virtualenv 를 통해 설치 완료.생각보다 이것저것 검색하다가 시간을 날린것같다.가상환경 설정cd ~ // Home Directorymkdir Environments // Environments Directory 생성virtualenv --python=/usr/bin/python2.7 python27 // 강의 내용과 다름.virtualenv --python=/usr/bin/python2.7 python27 이부분이 강의와 다르기에 별도로 적는다.사이트를 통해 python2.7 수동 설치.virtualenv py2.7-env로 생성 하지만 버전이 3.12.3 이다.에러 코드에 대해 검색해보니 pip install --upgrade pip를 사용하여 버전업을 하라고 해서 버전업을 하고virtualenv 버전도 지정을 해주었다.pip install virtualenv==20.15.1python -m virtualenv venv 를 실행하니2.7버전으로 뭔가 만들어진 스멜이다. 확인해보자.다시 순서 정리cd ~ // Home Directorymkdir Environments // Environments Directory 생성python -m virtualenv venv // 2.7 버전으로 가상환경 생성source venv/bin/activate // 파이썬 버전 적용.python --version // 버전확인deactivate // 버전 해제coremltools 설치coremltools 설치pip install -U coremltools설치중 에러 발생사이트 참고하여python3 -m ensurepip --default-pippython3 -m pip install --upgrade pip setuptools wheel진행하니 에러코드가 달라졌다.파이썬 3.12 최신버전에 대한 문제도 있어 3.11로 새로 설치한다.다운그레이드하고 해보니 일단 설치는 된것같다.힘들었다..py file에 import를 해봤으나 실패…Defaulting to user installation because normal site-packages is not writeable어느순간 바뀌어버린 에러메세지.파이썬에대한 환경변수가 문제인건가 생각이 들기 시작한다.현재 설치된 파이썬의 경로를 찾아보기 시작한다.❯ where python/Library/Frameworks/Python.framework/Versions/2.7/bin/python/usr/local/bin/python❯ where python3/usr/bin/python3python 디폴트가 2.7로 되어있다. 우선 이녀석을 3.12버전만 아닌 다른 녀석으로 설치를 해줘야할 듯 하다.현재 라이브러리 들어가서 확인 해본결과 2.7하나만 있다.brew list를 확인해보니 3.10, 3.11 버전은 설치가 되어있다.파이썬 공식사이트를 통해 설치를 해보기로 했다.버전은 3.11.9python3 명령어를 치고 import coremltools를 하니 먹힌다.어느부분에서 인식이 된건지 모호하다.터미널을 4개나 켜면서 확인을 해야했던 작업.터미널 진짜 사용해보면 재미있는데…..python 3.9 버전에서 coremltools import 확인.vscode에서 python3 version을 3.9로 체인지.이건 조만간 맥미니로 테스트를 하면서 과정을 다시 적어보도록 하겠다.python 코드 작성새로운 폴더를 하나 만들고 model과 관련된 파일들을 넣어준다.그리고 파이썬을 사용하여 swift에서 사용할 수 있는 모델로 바꾸기 위한 작업을 시작해보겠다.file명은 convert-script.py로 해두었다.간만에 머신러닝, 딥러닝 모델을 접하니 설렌다. 딥하게 아는건 아니지만 그래도 찍먹을 해보아서 그럴까? 설렌다.관련 Docs는 여기를 참고.caffe model내용은 여기를 참고.자세한정보는여기import coremltoolscaffe_model = ('oxford102.caffemodel', 'deploy.prototxt')labels = 'flower-labels.txt'coreml_model = coremltools.converters.caffe.convert(    caffe_model,    class_labels=labels,    image_input_names='data')coreml_model.save('FlowerClassifier.mlmodel')  parameter 정보 (convert)          첫번째 : model의 경로 (String)                  현재는 python file과 같은 경로이기에 파일명을 그대로 쓰면됨.          caffe_model(모델, 모델정보txt) → 같은 디렉토리일때.                    두번째 : class_label (String)                  모든 클래스들이 명명된 문서의 파일경로.          여기선 클래스들은 꽃의 이름들.                                                                세번째 : image_input_names (String              [String])                                                                    문제 발생. 현재 버전에서는 converter에 caffe_model를 다루지 않음…..실제로 실행할땐 python3 convert-script.py를 사용하면 될 것이다.기껏 설치했더니 현재는 지원하지 않는 버전.개빡.하긴 이미 vscode에서 작성하면서 미리 인지를 해두긴 했음.그래서 강제로 버전 다운그레이드.재부팅을 해서 그런가 아까 설치한 python3.11.9 버전이 디폴트가 되었다.pip3 install coremltools 재시도pip3 install coremltools==4.0 버전 다운그레이드 설치완료.Vscode python interpreter 다시 교체.인터프리터가 같은버전으로 2개가 있는데이렇게 확인해주면 된다.그랬더니 다시 coremltools 인식.다시 터미널에서 해당 파일 파이썬으로 돌려보면.에러발생.찾아보니 4.0 버전도 안됨.3.4에서 된다는 글을 보아서 다운그레이드 재시도.하지만 현재 파이썬 버전에서는 불가능.다시 가상환경에서 2.7 버전의 파이썬을 재호출.coremltools 3.4 버전 설치.그리고 가상환경에서 2.7의 파이썬에서convert-script.py 파일이 있는 디렉토리로 이동다시 재호출드디어 성공.사양이 좋아서 그런가. model생성이 1분도 안걸렸다.역시 가끔은 낮에 하는 것 보다 밤에하는게 잘된다.그동안의 여정을 정리.coremltools 설치 이후.  우선 coremltools가 현재 어떤 파이썬의 버전을 지원하는지 체크를 하지않고 무작정 설치하려다 호환성 문제로 설치가 안됨.          그걸 깨닫는시점이 너무 오래걸림.        문제점 인지하고 파이썬 버전을 downgrade          3.12 -&gt; 3.11        coremltools 설치 성공.  코드 작성중 coremltools가 caffe model을 지원하지 않는다는것을 인지.  Coremltools Downgrade (4.0)  4.0에서도 안됨. 코드내부의 문제가 아닌 coremltools의 호환성 문제.  다운그레이드 재시도 (3.4)  현재 파이썬 버전에서는 안됨.  이전에 만들어둔 가상환경이 2.7버전인걸 확인.  해당가상환경 로드 후 pip install coremltools==3.4로 특정 버전으로 설치 시도.  설치 성공후 VScode에서 해보려고 했으나, 할필요가 없음을 깨달음          terminal에서 가상환경으로 2.7을 불러두고 convert-script.py 실행하면됨.        해당 파일 실행.  성공.몇시간동안 노력의 결과.확실한건. 가상환경으로 파이썬 구버전을 잘 쟁여둬야겠다는 생각이 든다.언제 또 쓸지 모르니까."
  },
  
  {
    "title": "SeeFood",
    "url": "/posts/SeeFood/",
    "categories": "Udemy, CoreML",
    "tags": "",
    "date": "2024-04-17 13:13:00 +0900",
    





    
    "snippet": "CoreML  머신러닝 모델을 iOS 프로젝트에 사용가능하게 해준다.          머신러닝 모델을 로드할 수 있다.      훈련한 모델들이 예측할 수 있도록 만들 수 있다.      애플 개발자 사이트 참고!우리가 사용할 수 있는 ML모델들이 있다.아래는 Flow에 대한 간단한 사진 from Udemy.프로젝트 내부에 ML Model 추가.개발자...",
    "content": "CoreML  머신러닝 모델을 iOS 프로젝트에 사용가능하게 해준다.          머신러닝 모델을 로드할 수 있다.      훈련한 모델들이 예측할 수 있도록 만들 수 있다.      애플 개발자 사이트 참고!우리가 사용할 수 있는 ML모델들이 있다.아래는 Flow에 대한 간단한 사진 from Udemy.프로젝트 내부에 ML Model 추가.개발자사이트에 가보면 Apple이 올려둔 여러 Model들이 존재하는데 다운 받아 사용 하면 된다.그리고 다운받은 모델을 프로젝트로 드래그 하면 끝.참고로 Model들은 용량이 꽤 많이 나가는 편이다.VC 작성우선 import를 해주는데 CoreML만 하는것이아닌, Vision도 해준다.Vision의 경우, 이미지를 더 쉽게 처리하고 많은 코드를 작성하지 않아도 CoreML과 작업할 수 있도록 해준다.import CoreMLimport Vision1. ImagePicker 사용.extension ViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate {        }해당 기능을 사용하기위해 extension으로 뺐다.그리고 다음과 같이 코드를 ViewDidLoad에 적는다.imagePicker.delegate = selfimagePicker.sourceType = .cameraimagePicker.allowsEditing = false의미는 picker 프로토콜에 대한 위임자 설정과, picker를 어떤 타입으로 쓸지 (camera, photolibrary, savedPhotosAlbum), 그리고 이미지를 사용 후 수정을 허용할지에 대한 내용이다.  참고사항      imagePicker.sourceType에서 camera를 제외한 나머지 기능 (photolibrary, savedPhotosAlbum)은 Deprecate 예정          해당 기능을 사용하려면 imagepicker 대신 phpicker를 사용하자.      2. 선택한 이미지를 ML Model에 전달.didFinishPickingMediaWithInfo 메서드를 사용한다.이미지 선택이 끝나고 수행하기 위한 메서드. func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {                let userPickedImage = info[UIImagePickerController.InfoKey.originalImage]            }유져가 선택한 이미지 원본을 가져오기 위해 다음과 같이 적었다.기존에는 UIImagePickerControllerOriginalImage로 작성을 했으나,현재는 UIImagePickerController.InfoKey.originalImage로 바뀌었다는 점 참고하도록 하자.imageView.image = userPickedImage를 사용하여 적용하니 Type에 대한 Error가 발생한다.if let userPickedImage = info[UIImagePickerController.InfoKey.originalImage] as? UIImage {            imageView.image = userPickedImage        }DownCasting을 해주는데 이때 optional Binding을 하여 nil을 방지해주자.extension ViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate {        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {                if let userPickedImage = info[UIImagePickerController.InfoKey.originalImage] as? UIImage {            imageView.image = userPickedImage        }                imagePicker.dismiss(animated: true)    }      }실행해보자.카메라를 눌러보니 보이진 않고 다음과 같은 Warning이 발생한다.2. info.Plist 수정우리가 카메라를 사용할때 알람이 뜨면서 카메라를 허용하는 그 내용을 만들것이다.값을 추가해주고.다음과 같이 적어주었다.value는 자유롭게!시뮬레이터에서는 카메라가 없어서 실제 iPhone에 빌드하여 테스트를 진행했다.오늘의 키보드를 찍은건데. 너무 대충 찍긴 했다.무튼 작동하면 다음과 같이 뜬다.현재 시뮬레이터에서 작동을 하지않는건 시뮬레이터에 카메라가 없어서 그런것같다.찾아보니 카메라 기능은 실제 iphone으로 해야하는것같다.Model 사용해보기.1. Image → CIImage로 변환하기  CIImage란?      코어 이미지 필터에 의해 처리되거나 생성되는 이미지의 표현 (from Docs)  이렇게 사전적정의로 하니 뭔가 크게 받아들여지지는 않는다.  특별한 유형의 이미지로 Vision &amp; CoreML Framework를 사용할 수 있도록 한다.let ciImage = CIImage(image: userPickedImage) 이렇게 ciImage에 대한 Instance는 아주 간단히 설정이 가능.2. Model을 사용하여 이미지를 감지하는 함수 구현 func detect(image: CIImage) {                guard let model = try? VNCoreMLModel(for: Inceptionv3().model) else {            fatalError(\"Loading CoreML Model Failed.\")        }    }우선 다음과 같이 model을 객체화 하였다.이제는 예외에 대한 부분도 생각해야하기에 if let / guard let을 사용하여 옵셔널 바인딩을 확실하게 해주자.VNCoreMLModel은 Vision에서 온 메서드이고 이미지 분석 요청을 수행할 수 있게 해준다.이후 API 사용하듯이 request로 요청하여 작성을 하게 된다. (API에서 task작성하는 느낌과 비슷.)그리고 해당 요청을 다룰 handler를 만들어 준다.그리고 실패할수있기에 do~catch문을 사용한다.perform에 갑자기 배열? 이라고 생각 할 수있는데. perform에 대해 읽어보면 parameter가 저렇다.func detect(image: CIImage) {                guard let model = try? VNCoreMLModel(for: Inceptionv3().model) else {            fatalError(\"Loading CoreML Model Failed.\")        }                let request = VNCoreMLRequest(model: model) { (request, error) in            guard let results = request.results as? [VNClassificationObservation] else {                fatalError(\"Model Failed to process Image\")            }            print(results)        }                let handler = VNImageRequestHandler(ciImage: image)                do {            try handler.perform([request])        } catch {            print(error)        }    }실행을 해서 사진을 찍어 테스트를 해보자.사진을 사용하면[&lt;VNClassificationObservation: 0x302271800&gt; 544438A7-B5CC-43EF-A821-AE7A9DFFE458 VNCoreMLRequestRevision1 confidence=0.754823 \"computer keyboard, keypad\", &lt;VNClassificationObservation: 0x302210980&gt; 47C13DE4-854B-415F-AD3F-C529CA97409A VNCoreMLRequestRevision1 confidence=0.168424 \"space bar\", &lt;VNClassificationObservation: 0x302274500&gt; 9DB696BD-738D-412B-BDD5-6ED4AFBBB745 VNCoreMLRequestRevision1 confidence=0.045331 \"notebook, notebook computer\", &lt;VNClassificationObservation: 0x302204200&gt; A538D26B-D16D-4F0C-B947-0FBD36AB1C0F VNCoreMLRequestRevision1 confidence=0.013825 \"typewriter keyboard\", &lt;VNClassificationObservation: 0x302270a80&gt; 8E6F5208-D937-42CF-9129-1F032EEDFDA4 VNCoreMLRequestRevision1 confidence=0.006530 \"laptop, laptop computer\",엄청 많은 내용이 나오는데 신뢰도 순으로 나온다.confidence=0.754823 \"computer keyboard, keypad\" 여기를 참고하여 보면.현재 가장 신뢰도가 높은 값은 computer keyboard, keypad라고 나온다.신뢰도는 약 75%로 나오고있다.지금까지의 Sequence 정리여태까지의 흐름을 한번 정리를 해본다면.전체 흐름.  우선 사진을 찍고 사진데이터를 userPickedImage에 저장 (Type: UIImage)  userPickedImage 데이터를 CIimage Type으로 변환 (Type: CIImage)  detect 메서드로 변환된 이미지 데이터를 전달.Detect 메서드 흐름  VNCoreMLModel 메서드를 사용하여 우리가 사용하려는 Model을 객체화.          VNCoreMLModel(for: 사용하고자 하는 모델의 class를 가져와서 그안의 model값을 사용.)        VNCoreMLRequest 메서드를 사용하여 request 호출 내용 구현          model / completionHandler 두개의 파라미터가 사용이 되며, completionHandler 부분은 API 사용하듯, Closure형태로 전환하여 구현.              completionHandler는 (request, error) 두가지 형태로 나뉜다 (parameter는 본인 마음)                  성공: request의 결과를 강의에선 다운 캐스팅을 해서 as? [VNClassificationObservation] 로 특정.                          하지만 현재는 requests.results의 타입을 확인하면 [Any]? → [VNObservation]? 로 바뀌었음.              그래도 다운캐스팅을 해줘야하는게, 아래 사진을 보면알겠지만 여기에 identifier가 있다.                                              실패: 지금은 print(error) 로 간단하게 리턴                      VNImageRequestHandler 메서드를 사용하여 handler를 구현 (API 관점에서보면 task)          이떄 Parameter로 ciImage를 사용.        do~catch 를 사용하여 handler에게 request를 수행하라고 지시.          이떄 Parameter는 배열이다. ([VNRequest])      Hotdog / Not Hotdog 구현테스트를 통해 우리가 가져온 모델이 나름 괜찮게 결과값을 보여주는 것을 확인했다.이젠 result를 콘솔에 출력하는것이 아닌, 핫도그인지 아닌지를 구분하게 만들어보자.result의 closure 부분으로 돌아가서// beforeprint(results)// afterif let firstResult = results.first {                if firstResult.identifier.contains(\"hotdog\") {                    self.navigationItem.title = \"Hotdog!!\"                } else {                    self.navigationItem.title = \"Not Hotdog!!\"                }            }결과값의 첫번째, 즉 신뢰도가 가장 높은 값을 가져와서, identifier에 핫도그가 있는지 없는지를 구분하게 하면된다.그리고 해당 결과를 navigationItem의 Title로 표시할것이다.그러면 이제 핫도그 이미지를 하나 창에 띄워서 테스트를 해보면 결과를 알 수 있다.이럴줄 알았음 그냥 영상을 올릴걸 그랬다.위에 핫도그라고 잘 나온다."
  },
  
  {
    "title": "InAppPurchase",
    "url": "/posts/InApp/",
    "categories": "Udemy, Todoey",
    "tags": "",
    "date": "2024-04-16 18:13:00 +0900",
    





    
    "snippet": "In App 결제가장 효과적인 방법은 유져에게 80%정도의 기능을 무료로 제공하고 나머지 20%기능을 유료전환시에 사용 할 수있게 하는 것이다. (광고제거, 프리미엄버전)  조건          애플 개발자 프로그램 필요.      연간 99달러씩 연회비가 필요.      실제 iPhone이 있어야 테스트가 가능.                  시뮬레...",
    "content": "In App 결제가장 효과적인 방법은 유져에게 80%정도의 기능을 무료로 제공하고 나머지 20%기능을 유료전환시에 사용 할 수있게 하는 것이다. (광고제거, 프리미엄버전)  조건          애플 개발자 프로그램 필요.      연간 99달러씩 연회비가 필요.      실제 iPhone이 있어야 테스트가 가능.                  시뮬레이터와 다르다.                    애플 개발자 계정 필요.      Apple Developer Program 접속"
  },
  
  {
    "title": "Todoey (11)",
    "url": "/posts/Todoey-(11)/",
    "categories": "Udemy, Todoey",
    "tags": "",
    "date": "2024-04-16 15:13:00 +0900",
    





    
    "snippet": "UINavigation Bar 수정하기1. Navigation Bar Title 크기 키우기Navigation Bar의 Title 이 좀 작다고 느껴진다면 이 부분을 체크를 하면 좀 더 크게 볼 수 있다.beforeafterTitle이 훨씬 더 커졌다.2. Navigation Bar Color 변경 하기.Category의 색에 맞게 Nav Bar의 색...",
    "content": "UINavigation Bar 수정하기1. Navigation Bar Title 크기 키우기Navigation Bar의 Title 이 좀 작다고 느껴진다면 이 부분을 체크를 하면 좀 더 크게 볼 수 있다.beforeafterTitle이 훨씬 더 커졌다.2. Navigation Bar Color 변경 하기.Category의 색에 맞게 Nav Bar의 색상을 변경하려고 한다.// Viewdidloadif let colorHex = selectedCategory?.color {                        guard let navBar = navigationController?.navigationBar else { fatalError(\"Navigation Controller does not exist.\")}                        navigationController?.navigationBar.barTintColor = UIColor(hexString: colorHex)        }이렇게 작성을 해준다.실행하니 에러가 발생한다.Fatal error: Navigation Controller does not exist.존재하지 않는다는것.그렇다면 이유는 하나.NavigationController의 속성이 업데이트 되기 전에 ViewDidLoad가 호출된다.에러가 발생한 시점에서 NavigationController에 대한 내용은 아무것도 없었다.이렇땐 VC의 생명주기를 고려하여 호출을 해야한다. override func viewWillAppear(_ animated: Bool) {        if let colorHex = selectedCategory?.color {                        guard let navBar = navigationController?.navigationBar else { fatalError(\"Navigation Controller does not exist.\")}                        navigationController?.navigationBar.barTintColor = UIColor(hexString: colorHex)        }    }ViewWillAppear를 사용해주었다.3. 기타 디자인// CategoryVCoverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {                let cell = super.tableView(tableView, cellForRowAt: indexPath)                if let category = categories?[indexPath.row] {            cell.selectionStyle = .none                        guard let categoryColor = UIColor(hexString: category.color) else {fatalError()}            cell.textLabel?.text = categories?[indexPath.row].name ?? \"No Categories added Yet\"            cell.backgroundColor = categoryColor            cell.textLabel?.textColor = ContrastColorOf(categoryColor, returnFlat: true)        }        return cell    }// TodoListVCoverride func viewWillAppear(_ animated: Bool) {        if let colorHex = selectedCategory?.color {                        title = selectedCategory?.name                        guard let navBar = navigationController?.navigationBar else { fatalError(\"Navigation Controller does not exist.\")}                        if let navBarColor = UIColor(hexString: colorHex) {                navBar.barTintColor = navBarColor                navBar.tintColor = ContrastColorOf(navBarColor, returnFlat: true)                navBar.largeTitleTextAttributes = [NSAttributedString.Key.foregroundColor:                ContrastColorOf(navBarColor, returnFlat: true)]                searchBar.barTintColor = navBarColor            }                 }    }    버전의 문제도 일부 있을듯한데 NavBar에대한 색이 변경이 되지 않았다. 해당문제는 나중에 다시 해결해보는걸로."
  },
  
  {
    "title": "Todoey (10)",
    "url": "/posts/Todoey-(10)/",
    "categories": "Udemy, Todoey",
    "tags": "",
    "date": "2024-04-16 09:13:00 +0900",
    





    
    "snippet": "Cell에 Color추가하기카멜레온사이트를 이용하여 Library를 가져온다.pod install을 통해 library 설치 완료.  참고      해당 library는 현재 나와있는대로 설치를 하면 이전 버전의 swift로 작성된것이라 에러가 많이 뜬다.pod ‘ChameleonFramework/Swift’, :git =&gt; ‘https://gi...",
    "content": "Cell에 Color추가하기카멜레온사이트를 이용하여 Library를 가져온다.pod install을 통해 library 설치 완료.  참고      해당 library는 현재 나와있는대로 설치를 하면 이전 버전의 swift로 작성된것이라 에러가 많이 뜬다.pod ‘ChameleonFramework/Swift’, :git =&gt; ‘https://github.com/wowansm/Chameleon’, :branch =&gt; ‘swift5’          이걸로 설치하도록 하자.      import ChameleonFrameworkoverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {                let cell = super.tableView(tableView, cellForRowAt: indexPath)                cell.textLabel?.text = categories?[indexPath.row].name ?? \"No Categories added Yet\"        cell.backgroundColor = UIColor.randomFlat() // new                return cell    }색상이 아주 잘 나온다.특이점이라면, 위의 코드를 보면 알겠지만 랜덤으로 색상이 결정된다. 즉 실행할때마다 임의의 색상이 나온다는것.Cell 색상 고정하기.print(UIColor.randomFlat().hexValue()) 를 사용하면 셀 색깔에 대한 hex값을 얻을 수 있다.이걸 이용해서 색상을 저장하여 사용 하면 될것같다.class Category: Object {        @objc dynamic var name: String = \"\"    @objc dynamic var color: String = \"\" // new    let items = List&lt;Item&gt;()     }@IBAction func buttonPressed(_ sender: UIBarButtonItem) {                var textField = UITextField()                let alert = UIAlertController(title: \"Add New Todoey Item\", message: \"\", preferredStyle: .alert)                let action = UIAlertAction(title: \"Add Item\", style: .default) { (action) in                        let newCategory = Category()            newCategory.name = textField.text!            newCategory.color = UIColor.randomFlat().hexValue() // new                        self.save(category: newCategory)                    }                alert.addTextField { (alertTextField) in            alertTextField.placeholder = \"Add a new Category\"            textField = alertTextField        }                alert.addAction(action)                present(alert, animated: true, completion: nil)                tableView.reloadData()            }override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {                let cell = super.tableView(tableView, cellForRowAt: indexPath)                cell.textLabel?.text = categories?[indexPath.row].name ?? \"No Categories added Yet\"        cell.backgroundColor = UIColor(hexString: realm.objects(Category.self)[indexPath.row].color) // new        print(UIColor.randomFlat().hexValue())                return cell    }    우선 나는 이렇게 했는데// 나cell.backgroundColor = UIColor(hexString: realm.objects(Category.self)[indexPath.row].color)// 강의cell.backgroundColor = UIColor(hexString: categories?[indexPath.row].color ?? \"1D98F6\")이렇게 했다.Gradient Flow Cell 만들기.override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {                let cell = super.tableView(tableView, cellForRowAt: indexPath)                if let item = todoItems?[indexPath.row] {            cell.textLabel?.text = item.title                        if let color = FlatSkyBlue().darken(byPercentage:                                                CGFloat(indexPath.row / todoItems!.count)) {                                cell.backgroundColor = color                            }                                    cell.accessoryType = item.done ? .checkmark : .none        } else {            cell.textLabel?.text = \"No Items Added\"        }                return cell    }Library의 darken을 이용하여 그라데이션 효과를 주려고 한다.CGFloat(indexPath.row / todoItems!.count) 아래로 내려갈수록 색을 더 진하게 한다는 의미.그런데 실행해보니 변화가 없다?print(indexPath.row / todoItems!.count) 를 찍어보니 0 이 나와버린다.왜냐면 나눌때 int기준으로 나누고 CGFloat으로 타입이 변환되기때문이다.print안에 두 값은 Int이기에 해당 값을 CGFloat으로 타입변환을 해주고 나면 원하는 값이 나오게 된다.override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {                let cell = super.tableView(tableView, cellForRowAt: indexPath)                if let item = todoItems?[indexPath.row] {            cell.textLabel?.text = item.title                        if let color = FlatSkyBlue().darken(byPercentage:                                                CGFloat(CGFloat(indexPath.row) / CGFloat(todoItems!.count))) {                                cell.backgroundColor = color                            }                        cell.accessoryType = item.done ? .checkmark : .none        } else {            cell.textLabel?.text = \"No Items Added\"        }                return cell    }그라데이션 효과는 이제 구현이 되었다.하지만 가장 마지막의 셀의 경우 너무 어두워서 점점 black과 가까워진다.이말은 cell의 text가 보이지않게된다는것.유져입장에서는 이부분 또한 하나의 컴플레인으로 작용할 수 있는 요소이기에 해당부분을 수정해보도록 하자.Readme의 ConstrastColor를 사용하여 text의 색을 주었다.cell.textLabel?.textColor = ContrastColorOf(color, returnFlat: true)Category의 색을 넘겨받아 TodoListTable에 반영하기if let color = UIColor(hexString: selectedCategory!.color)?.darken(byPercentage:                                                CGFloat(CGFloat(indexPath.row) / CGFloat(todoItems!.count))) { // modified                                cell.backgroundColor = color                cell.textLabel?.textColor = ContrastColorOf(color, returnFlat: true)            }"
  },
  
  {
    "title": "Todoey (9)",
    "url": "/posts/Todoey-(9)/",
    "categories": "Udemy, Todoey",
    "tags": "",
    "date": "2024-04-16 08:13:00 +0900",
    





    
    "snippet": "SuperClass로 추가 기능 관리.지금껏 Readme파일의 내용을 가져와서 우리의 코드에 맞게 수정하는 작업을 했다.그렇게 하지말고, 새로운 Class하나 만들어서, VC가 해당 Class를 상속하게 해서 관리를 해보도록 하자.1. 새로운 파일 생성 및 내부 코드 수정지금 Category, TodoList VC 모두 UITableViewContro...",
    "content": "SuperClass로 추가 기능 관리.지금껏 Readme파일의 내용을 가져와서 우리의 코드에 맞게 수정하는 작업을 했다.그렇게 하지말고, 새로운 Class하나 만들어서, VC가 해당 Class를 상속하게 해서 관리를 해보도록 하자.1. 새로운 파일 생성 및 내부 코드 수정지금 Category, TodoList VC 모두 UITableViewController 이므로 새로운 파일도 UITableViewController로 만들어준다.그리고 파일명은 SwipeTableViewController 이렇게 해주었다.이제 이파일이 SuperClass가 될 것이다.이제 CategoryVC에 작성했던 extension의 내용을 전부 SwipeTableVC로 옮겨준다.import UIKitimport SwipeCellKitclass SwipeTableViewController: UITableViewController, SwipeTableViewCellDelegate {    override func viewDidLoad() {        super.viewDidLoad()    }    func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath, for orientation: SwipeActionsOrientation) -&gt; [SwipeAction]? {                guard orientation == .right else { return nil }                let deleteAction = SwipeAction(style: .destructive, title: \"Delete\") { action, indexPath in                        if let currentCategory = self.categories?[indexPath.row] {                do {                    try self.realm.write {                        self.realm.delete(currentCategory)                    }                } catch {                    print(\"Error \\(error.localizedDescription)\")                }            }                    }                // customize the action appearance        deleteAction.image = UIImage(named: \"delete-icon\")                return [deleteAction]    }        func tableView(_ tableView: UITableView, editActionsOptionsForRowAt indexPath: IndexPath, for orientation: SwipeActionsOrientation) -&gt; SwipeOptions {        var options = SwipeOptions()        options.expansionStyle = .destructive        return options    }}하지만 이제 문제가 생긴다.바로 여기부분이다.아무래도 그대로 cut &amp; paste를 하다보니 생긴 문제이기도 하고, SwipeTableVC의 경우 SuperClass이기에, 하위 Class에 대한 내용을 알 필요가 없기도 하다.  무슨말이냐면, Category, TodoListVC가 SwipeTableVC를 상속을 받기에, SwipeTableVC 안에는 그 내용이 담길 필요도, 이유도 없다는것.2. Category VC 수정class CategoryViewController: UITableViewController 현재 CategoryVC는 UITableViewController를 상속 받고 있다.이제 이 상속을 지우고, SwipeTableViewController로 대신 상속받게 할것이다.import SwipeCellKit을 지우자마자 발생하는 에러.SwipeTableVC에 TableView Datasource Methods 구현이 필요해졌다.다시 SwipeTableVC로 돌아가서 TableView Datasource Methods 부분을 구현해보자.3. SwipeTableVC TableView Datasource Methods 구현.override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        let cell = tableView.dequeueReusableCell(withIdentifier: \"CategoryCell\") as! SwipeTableViewCell                cell.textLabel?.text = categories?[indexPath.row].name ?? \"No Categories added Yet\"        cell.delegate = self                return cell    }우선은 CategoryVC의 cellForRowAt 함수내 cell을 담당하던 코드를 넣어주자.SwipeTableVC가 SuperClass의 성격을 가지므로, let cell = tableView.dequeueReusableCell(withIdentifier: \"CategoryCell\")의 부분에서 identifier의 문자열을 좀 더 General하게 해주는것이 좋기에 \"CategoryCell\"→\"Cell\"로 고쳐주자.그리고 StoryBoard의 Cell의 Identifier도 모두 고쳐주자.cell.textLabel?.text = categories?[indexPath.row].name ?? \"No Categories added Yet\" 이 부분 역시현재 CategoryCell 특정이기에 지워버리자.4. CategoryVC에서 cell 상속.// beforelet cell = tableView.dequeueReusableCell(withIdentifier: \"CategoryCell\") as! SwipeTableViewCell// afterlet cell = super.tableView(tableView, cellForRowAt: indexPath)super를 통해 SwipeTableVC의 cellForRowAt의 cell을 그대로 사용한다.실행하니 드래그는 되는데, 실제로 삭제를 하려고하니 에러가 발생했다.*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'Invalid update: invalid number of rows in section 0. The number of rows contained in an existing section after the update (2) must be equal to the number of rows contained in that section before the update (2), plus or minus the number of rows inserted or deleted from that section (0 inserted, 1 deleted) and plus or minus the number of rows moved into or out of that section (0 moved in, 0 moved out).생각보다 에러가 꽤나 길다.그전에 SwipeTableVC에 delete에 관한 메서드를 주석을 달았기 때문이다.5. 삭제 함수 구현하기이제 SwipeTableVC에 함수를 구현해보자func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath, for orientation: SwipeActionsOrientation) -&gt; [SwipeAction]? {                guard orientation == .right else { return nil }                let deleteAction = SwipeAction(style: .destructive, title: \"Delete\") { action, indexPath in                        self.updateModel(at: indexPath) // new        }                // customize the action appearance        deleteAction.image = UIImage(named: \"delete-icon\")                return [deleteAction]    }    func updateModel(at indexPath: IndexPath) { // new    // Update our data Model.}현재 데이터를 갱신해주는 함수를 구현했다.CategoryVC로 돌아와서,// MARK: - Delete Data From Swipe    override func updateModel(at indexPath: IndexPath) {}updateModel을 재정의 (override) 해서 사용할 것이다.  왜 갑자기 override를 하는지?      CategoryVC 와 SwipeTableVC는 상속 관게이다.          SwipeTableVC에서 updateModel 함수를 구현 해뒀으니.상속받는 CategoryVC는 동일한 이름, parameter의 함수를 사용하기 위해선 재정의를 해야하는것.              ViewDidload도 override인 이유는 UIViewController를 상속받았기에 가능.            여기에 아까 삭제에 관해 주석쳤던 부분을 넣어주자.// MARK: - Delete Data From Swipeoverride func updateModel(at indexPath: IndexPath) {        if let currentCategory = self.categories?[indexPath.row] {            do {                try self.realm.write {                    self.realm.delete(currentCategory)                }            } catch {                print(\"Error \\(error.localizedDescription)\")            }        }    }그럼 여기서 누구나 가질 수 있는 궁금증  SwipeTableVC의 updateModel에 내가 기능을 구현한 건 사용을 할 수 없다?      정답은 X만약 override을 하여 해당 함수 자체를 재정의 했지만, 상속받는 함수의 기능도 사용을 하고 싶다면?          super.updateModel 이렇게 적으면 된다 (현재 함수를 예시로)      이해를 돕기위해 아래 예시를 하나 만든다.// SwipeTableVCfunc updateModel(at indexPath: IndexPath) {        print(\"Status Updated\") // new    }// CategoryVCoverride func updateModel(at indexPath: IndexPath) {                super.updateModel(at: indexPath) // new                if let currentCategory = self.categories?[indexPath.row] {            do {                try self.realm.write {                    self.realm.delete(currentCategory)                }            } catch {                print(\"Error \\(error.localizedDescription)\")            }        }    }super를 사용함으로써 갖는 의미는 내가 이 함수를 상속 받았지만 내가 기능을 다시 정하지만, 상속받는 기능도 사용하겠다! 는 의미.super를 사용하지 않으면 나는 함수를 상속 받으면서 기능은 내가 다시 정하겠다 는 의미.실행해보자.굿.그러면 또 갑자기 이런 생각이 들수도 있다.아까 4번에서는// beforelet cell = tableView.dequeueReusableCell(withIdentifier: \"CategoryCell\") as! SwipeTableViewCell// afterlet cell = super.tableView(tableView, cellForRowAt: indexPath)  위에는 super를 썼는데 함수처럼 쓰인게 아니라 변수안에 들어갔네요?      tableView의 함수가    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {       let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\") as! SwipeTableViewCell       cell.delegate = self            return cell   }        마지막에 cell을 리턴하기에 가능 했던것.          즉 after에서 나는(CategoryVC) cell을 재정의해서 쓰는것이 아니라, 셀은 그냥 상속받는거 쓸게. 의 의미.      끝."
  },
  
  {
    "title": "Todoey (8)",
    "url": "/posts/Todoey-(8)/",
    "categories": "Udemy, Todoey",
    "tags": "",
    "date": "2024-04-15 14:13:00 +0900",
    





    
    "snippet": "Query 작성하기.지금 Query에 해당하는 부분은 SearchBar에 대한 부분 밖에 없다.그 부분의 내용을 고쳐보도록 하자.todoItems = todoItems?.filter(&lt;#T##predicateFormat: String##String#&gt;, &lt;#T##args: Any...##Any#&gt;) 에서 필터를 사용한 것을 다시 ...",
    "content": "Query 작성하기.지금 Query에 해당하는 부분은 SearchBar에 대한 부분 밖에 없다.그 부분의 내용을 고쳐보도록 하자.todoItems = todoItems?.filter(&lt;#T##predicateFormat: String##String#&gt;, &lt;#T##args: Any...##Any#&gt;) 에서 필터를 사용한 것을 다시 todoitems에 담는다.predicateFormat에는 NSpredicateFormat과 동일하게 작성한다.  즉, \"title CONTAINS[cd] %@\" 이 부분이 그대로 들어간다는 뜻todoItems = todoItems?.filter(\"title CONTAINS[cd] %@\", searchBar.text!) 이렇게 된다.NSpredicate사용했을때와 비교하면 let predicate = NSPredicate(format: \"title CONTAINS[cd] %@\", searchBar.text!)내용은 같다.하지만 이전에는 필터링한 결과를 가지고 소팅을 했다면 이번엔 바로 소팅 메서드를 연결할 수 있다.todoItems = todoItems?.filter(\"title CONTAINS[cd] %@\", searchBar.text!).sorted(byKeyPath: \"title\", ascending: true)이전에 길었던 코드가 한줄로 해결이 되는 매직이 발생했다.1. 날짜를 기준으로 소팅해보기@objc dynamic var dateCreated: Date? 생성newItem.dateCreated = Date() 도 추가.error: 'try!' expression unexpectedly raised an error: Error Domain=io.realm Code=10 \"Migration is required due to the following errors:- Property 'Item.dateCreated' has been added.\" UserInfo={Error Name=SchemaMismatch, NSLocalizedDescription=Migration is required due to the following errors:- Property 'Item.dateCreated' has been added., Error Code=10}다음과 같은 에러가 뜬다.현재 DB에는 dateCreated라는 속성이 없기에 발생한 문제!즉 에러에서 말하는 그대로 Migration이 필요하다는 것이다.2. Migration 하기앱을 삭제하자!즉 새로운 Realm파일로 시작하는 의미.새로 생긴걸 알 수 있다.값을 추가하니 date가 잘 나오는걸 알 수 있다.Swipe하여 삭제기능 구현CocoaPod의 라이브러리를 사용할것이다.사이트에 정보가 나와있다.예시를 바탕으로 코드 수정// sample    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\") as! SwipeTableViewCell        cell.delegate = self        return cell    }// modifiedoverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {                let cell = tableView.dequeueReusableCell(withIdentifier: \"CategoryCell\") as! SwipeTableViewCell                cell.textLabel?.text = categories?[indexPath.row].name ?? \"No Categories added Yet\"        cell.delegate = self                return cell    }1. extension을 사용하여 코드 확장extension CategoryViewController: SwipeTableViewCellDelegate {    func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath, for orientation: SwipeActionsOrientation) -&gt; [SwipeAction]? {        guard orientation == .right else { return nil } // swipe 방향        let deleteAction = SwipeAction(style: .destructive, title: \"Delete\") { action, indexPath in            // handle action by updating model with deletion        }        // customize the action appearance        deleteAction.image = UIImage(named: \"delete\")        return [deleteAction]    }    }안의 함수는 현재 readme에 있는 코드내용.이제 안의 함수부를 수정 할 예정이다.이미지는 사이트의 이미지를 사용했다.실행했더니 App Crash가 발생했다.Could not cast value of type 'UITableViewCell' (0x1ec2f2b10) to 'SwipeCellKit.SwipeTableViewCell' (0x101eeeda0).UITableViewCell을 SwipeCellKit.SwipeTableViewCell로 캐스팅을 할 수 없다고 나왔다.여기에 Class가 UITableViewCell로 default가 잡혀있는데,이부분을 바꿔주어야한다.이렇게 바꿔준다. 모듈도 꼭 확인해보고 체크해두자.확인해보니 현재 사이즈가 맞지않는다.조절을 해야할것같다.tableView.rowHeight = 85.0 각 셀의 높이를 85으로 주었다.사진은 업로드 하지않았지만 꽤 괜찮다.삭제를 하는 코드를 넣어보자.우선 내 기억대로 해보았는데 에러가 발생했다.do {    self.realm.delete(currentCategory)                        } catch {            print(\"Error \\(error.localizedDescription)\")            }Exception Error가 발생했다.내용은 다음과 같다.*** Terminating app due to uncaught exception 'RLMException', reason: 'Can only add, remove, or create objects in a Realm in a write transaction - call beginWriteTransaction on an RLMRealm instance first.'이전에 작성한걸 보았다.do {    try realm.write {                    item.done = !item.done                    }    } catch {            print(\"Error Saving New Items, \\(error.localizedDescription)\")            }realm.write를 빼먹었다.분명히 기억에 try도 썼는데 어디갔나 했다.잘 기억해두자.if let currentCategory = self.categories?[indexPath.row] {                do {                    try self.realm.write {                        self.realm.delete(currentCategory)                    }                } catch {                    print(\"Error \\(error.localizedDescription)\")                }                tableView.reloadData() // new            }           reloadData를 안하니 에러가 발생했다.문제를 바로 확인하고 추가하니 작동이 잘 된다.기능 추가func tableView(_ tableView: UITableView, editActionsOptionsForRowAt indexPath: IndexPath, for orientation: SwipeActionsOrientation) -&gt; SwipeOptions {        var options = SwipeOptions()        options.expansionStyle = .destructive        return options    }Readme에 있는 부분을 가져와서 추가했다.완료."
  },
  
  {
    "title": "Todoey (7)",
    "url": "/posts/Todoey-(7)/",
    "categories": "Udemy, Todoey",
    "tags": "",
    "date": "2024-04-15 13:13:00 +0900",
    





    
    "snippet": "TodoList VC이제 TodoList VC도 CategoryVC와 같이 수정을 해보도록 하자.context는 이제 안쓰니 지워버리자.1. loadItems 수정기존에 Parameter로 있던 request부분을 전부 날려버리자.그리고 itemArray에 itemArray = selectedCategory?.items.sorted(byKeyPath:...",
    "content": "TodoList VC이제 TodoList VC도 CategoryVC와 같이 수정을 해보도록 하자.context는 이제 안쓰니 지워버리자.1. loadItems 수정기존에 Parameter로 있던 request부분을 전부 날려버리자.그리고 itemArray에 itemArray = selectedCategory?.items.sorted(byKeyPath: \"title\", ascending: true) 이렇게 Realm을 활용하는 코드로 바꿔준다.위의 내용은 request.sortDescriptors = [NSSortDescriptor(key: \"title\", ascending: true)] 이부분과 동일하다고 보면된다.title이라는 field를 기준으로 내림차순을 한다는것.다시 itemArray로 돌아가서// beforevar itemArray = [Item]()// aftervar itemArray: Results&lt;Item&gt;?2. Optional Bindingoverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {                let cell = tableView.dequeueReusableCell(withIdentifier: \"ToDoItemCell\", for: indexPath)                if let item = todoItems?[indexPath.row] {            cell.textLabel?.text = item.title                        cell.accessoryType = item.done ? .checkmark : .none        } else {            cell.textLabel?.text = \"No Items Added\"        }                return cell    }override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {                return todoItems?.count ?? 1    }    3. SaveItems 구현selectedCategory가 nil이 아니라면~if let currentCategory = self.selectedCategory {                do {                    try self.realm.write{                        let newItem = Item()                        newItem.title = textField.text!                        currentCategory.items.append(newItem)                    }                } catch {                    print(\"Error Saving New Items, \\(error.localizedDescription)\")                }                            }currentCategory에 item을 담아주면서 relationship과 매칭결과. 연결이 잘되었다.그리고 load할때 title로 sorting을 하게 해두었기에,이렇게 정렬된 모습으로 볼 수 있다.CRUD중 Update 구현Save 메커니즘과 유사하기에 크게 차이점은 없다.didSelectRowAt의 함수에서 수정할수있게 구현 할것이다.선택한 아이템이 존재한다면?해당 셀을 터치했을때 완료에대한 내용이 수정이되게 간단하게 바꾸었다.if let item = todoItems?[indexPath.row] {            do {                try realm.write {                    item.done = !item.done                }            } catch {                print(\"Error Saving New Items, \\(error.localizedDescription)\")            }                    }실행했을때 true면 checkmark가 뜨게 될것이다.실시간으로 변하는것도 확인 완료.CRUD중 Delete 구현이번엔 셀을 클릭했을때 삭제하게 만들어 보자.if let item = todoItems?[indexPath.row] {            do {                try realm.write {                    realm.delete(item)                    //item.done = !item.done                }            } catch {                print(\"Error Saving New Items, \\(error.localizedDescription)\")            }                    }delete에 해당 item을 해주면된다.크게 어려운부분은 없다.구현 완료."
  },
  
  {
    "title": "Todoey (6)",
    "url": "/posts/Todoey-(6)/",
    "categories": "Udemy, Todoey",
    "tags": "",
    "date": "2024-04-15 10:13:00 +0900",
    





    
    "snippet": "Realm 사용해보기.사이트참고1. AppDelegate 수정하기import RealmSwift// didFinishLaunchingWithOptionsdo {    let realm = try Realm()    } catch {            print(\"Error initializing new Realm, \\(error)\")    }2. 파...",
    "content": "Realm 사용해보기.사이트참고1. AppDelegate 수정하기import RealmSwift// didFinishLaunchingWithOptionsdo {    let realm = try Realm()    } catch {            print(\"Error initializing new Realm, \\(error)\")    }2. 파일 생성import Foundationimport RealmSwiftclass Data: Object {    }파일을 생성하고 Object를 상속하게 하자. Object는 Object is a class used to define Realm model objects.Realm을 설치하면서 추가되었다.그리고 변수를 만들때 dynamic을 붙여준다.아무래도 Realm을 사용할때 쓰는듯 하다.  Dynamic Dispatch를 사용하라는 의미인데, 앱이 실행되는 동안 Dynamic으로 설정한 변수들을 모니터 한다.      사용자가 name을 변경 할 경우, 앱이 실행되는동안 Realm이 데이터베이스에서 변경 사항을 동적으로 업데이트 하게된다.  @objc를 쓰지않았지만 빌드 후 에러가 발생하지 않았다.AppDelegate로 돌아가서,let data = Data()        data.name = \"Harold\"        data.age = 10이렇게 작성을 해보았다.그리고do {            let realm = try Realm()            try realm.write {                realm.add(data)            }        } catch {            print(\"Error initializing new Realm, \\(error)\")        }이렇게 하고 실행하니 바로 Exception Error가 발생했다 Data에 관한 내용이었고, @objc를 적지않아 발생한 문제다.즉 위에 Objc를 쓰지만 에러가 발생하지 않았다는 건 그냥 빌드했을때이고, 실제로 실행할때는 에러가 발생하므로, 꼭 objc를 적어주자.지금은 실행해도 CoreData와 Realm이 같이 공존하고 있다.3. Realm 파일의 위치 확인해보기print(Realm.Configuration.defaultConfiguration.fileURL) 를 적어보자.실행하면 console에 해당 위치가 출력이된다.  AppStore에 RealmBrowser가 있으니 설치를 해주자.      encryption key가 필요하다고해서 Realm Studio를 설치했다.  그리고 Command+Shift+G를 눌러 해당 경로를 복붙하면 이동이 훨씬 편해진다.확인결과등록이 되었다.두개가 되어있는건 두번실행했기 때문.CRUD 중 Create 구현이전에 Data작성이 확인이 되었으니, 다시 해당부분을 지워주자do {            let realm = try Realm()        } catch {            print(\"Error initializing new Realm, \\(error)\")        }이렇게만 다시 남겨두도록 한다.1. 파일 생성기존 Data.swift는 지우고 Item, Category 이렇게 두개의 파일을 만들어준다.CoreData의 Entity와 동일하다고 생각하자.기존에는 CoreData의 하나의 큰 Container에 여러 Entity가 있었지만Realm으로 오면서 AppDelegate에 Realm이라는 Container를 만들고, Entity는 Swift 파일로 관리한다고 생각하면 된다.import Foundationimport RealmSwiftclass Item: Object {        @objc dynamic var title: String = \"\"    @objc dynamic var done: Bool = false    }이렇게 만들어줬더니 갑자기?중복된 선언이라고 한다. 이게 무슨소리지? 라고 생각할 수 있지만.이전에 CoreData하면서 만들어두었던 Entity때문이다.Entity는 만들면서 자연스럽게 NSObject의 class파일을 생성하게된다.Codegen에 Class Definition으로 해두었기 때문.이젠 CoreData를 놓아주도록 하자.2. Relationship 연결하기.기존에 CoreData로 Relationship을 연결했는데 이제는 Realm에도 연결을 해보도록 하자.class Category: Object {        @objc dynamic var name: String = \"\"    let items = List&lt;Item&gt;()    }class Item: Object {        @objc dynamic var title: String = \"\"    @objc dynamic var done: Bool = false    var parentCategory = LinkingObjects(fromType: Category.self, property: \"items\")    }Type은 카테고리타입 그 자체를 사용하기에 self가 들어갔다.2. VC 수정먼저 CategoryVC에 Realm을 인스턴스화 한다.let newCategory = Category() // modifiedfunc saveCategories(category: Category) {                do {            try realm.write { // modified                realm.add(category)            }        } catch {            print(error.localizedDescription)        }        tableView.reloadData()    }에러가 있는 부분을 모두 주석처리하고 add가 잘되는지 확인을 해보도록 하자저장이 잘 되는걸 알 수 있다.CRUD 중 Read 구현func loadCategories () {                categories = realm.objects(Category.self)                                tableView.reloadData()    }categories를 다음과 같이 작성한다.작성하고 나니 Type Error가 난다.var categories = [Category]() 이기 때문.Result 역시 Realm에서 제공하는데, categories를 realm에 맞게 타입변형을 해주면 된다.var categories: Results&lt;Category&gt;!우선은 Force Unwrapping을 하는걸로.그러면 이제 self.categories.append(newCategory)여기 부분에서 에러가 난다.그전에는 categories가 Category라는 배열이었는데, 배열이 아니기 때문.그냥 지워주면된다.  Q: 그러면 기존에는 배열에 값을 저장하고 Load할때 배열에 값을 넣어 그 배열에 대한 값을 출력했는데 어떻게 하나?      A: auto-updating Container라는것을 우리는 주목해야한다.  실행하니 아까 적었던게 그대로 나온다.Simple해졌다.1. Optional Bindingvar categories: Results&lt;Category&gt;?!에서 ?로 바꿔주고 Optional 타입으로 한뒤에,관련되어있는 부분을 병합연산자 ?? 를 사용하여 nil일때 Default Value를 만들어 준다.cell.textLabel?.text = categories?[indexPath.row].name ?? \"No Categories added Yet\"return categories?.count ?? 1ViewDidload에서 loadCategory 트리거를 잠시 주석으로 바꾸고 실행하자.즉 아무것도 없는 nil상태로 출력을 해보면예외처리도 잘 되었다."
  },
  
  {
    "title": "(Deep Dive) Keywords",
    "url": "/posts/(Deep-Dive)-Keywords/",
    "categories": "Udemy, Deep Dive",
    "tags": "Myself",
    "date": "2024-04-14 13:00:00 +0900",
    





    
    "snippet": "가끔 여러 사이트를 보며 참고를 할때 변수 앞에 lazy가 붙는 경우가 종종 있다.이왕 하는거 keyword에 대한 부분을 좀 정리를 해보려고 한다.Strong, weak에 대한 부분은 ARC에서 적었으므로 pass하도록 한다.1. lazyLiteral 의미 그대로 받아들이는게 좋다고 생각한다. 요근래 swift의 keyword를 좀 보고있다보면 이런...",
    "content": "가끔 여러 사이트를 보며 참고를 할때 변수 앞에 lazy가 붙는 경우가 종종 있다.이왕 하는거 keyword에 대한 부분을 좀 정리를 해보려고 한다.Strong, weak에 대한 부분은 ARC에서 적었으므로 pass하도록 한다.1. lazyLiteral 의미 그대로 받아들이는게 좋다고 생각한다. 요근래 swift의 keyword를 좀 보고있다보면 이런 Literal로 그냥 받아들이면 이해가 가는 단어들이 꽤 있는듯 하다.다시 돌아가서,  lazy의 가장 큰 특징은      선언한 프로퍼티가 처음 사용되기 전까지는 메모리에 올라가지 않는다! 는 점이다.  그래서 우리가 lazy를 사용할때의 예를 보면Container, 아니면 Code로 작성하는 UIComponent들도 lazy를 사용한다.이렇게 프로퍼티가 처음부터 메모리에 올라가는것이 아닌, 사용이 될때 메모리가 올라가기에메모리를 효율적으로 사용할 수 있다. 는 장점이 생긴다.Stackoverflow에도 한 유져가 질문했고 추천수가 많은 대답이 있는데, 한번 읽어보면 좋다. 짧은글이기에 시간도 얼마 안걸린다.var와 비교var computedValue = {        var a = 7        var b = 8        return a + b    }메모리에 할당이 되어있는걸 볼 수 있다.이번엔 앞에 lazy를 붙이고 하나더 만들어 보겠다. lazy var lazyComputedValue = {        var a = 7        var b = 8        return a + b    }lazy var로 선언한 lazyComputedValue는 nil이라 아직 할당이 되어 있지 않는다.그럼 viewDidLoad에 print를 하면 어떻게 되는지 알아보자.print(computedValue())print(lazyComputedValue())메모리에 할당이 되었다.이렇게 메모리에 상주시키지 않고 만들어 뒀다가 필요할때 쓰는것이 바로 lazy 라고 보면 될것같다.그래서 container의 경우도 AppDelegate에 적었지만, 메모리에 할당시키지 않다가, 유져가 CoreData 파일을 만들면서 연결을 시키면 그때 부터 메모리에 할동하고 작동하게 하는것도 이런 이유이다.2. finalOverride가 필요 없을 때 즉 상속이 필요 없을때 final을 사용한다.이게 진짜 끝이야 라는 느낌으로 보면 좋지않을까 싶다.class Person1 {    final var name: String = \"\"    final func speak() {        print(\"Say Ho!\")    }}final class Student: Person {    override var name: String {        set {            super.name = newValue        }        get {            return \"Student\"        }    }}class normalPerson: Student {    }Student Class가 Person을 상속 받았으나! name앞에 final로 선언이 되었기에, 위의 함수를 swift그대로 적게되면 Error가 발생한다.그리고 normalPerson이라는 class가 Student class를 상속 받으려고 했지만, Student는 final class이기에 상속이 되지 않는다.이렇게 뭔가 상속을 할때, 해당 함수, 변수등이 상속시 하위 클래스에서 사용하지 못하게 할때 final을 사용한다.3. self우리가 무의식적으로 자주 사용하는? self이다.클로저에서도 사용이되고, delegate를 사용할때는 필수요소이다.그럼 우리는 self에 대해서 자세히 알고 쓰는걸까? 아니면 그냥 빌드하니 error가 뜨면서 self를 입력하라고해서, 그냥 하라는대로 하는걸까?모든 인스턴스는 암시적으로 생성된 self 프로퍼티를 갖는다.  자기 자신을 나타내는 프로퍼티.      인스턴스를 더 명확히 지칭하고 싶을때 사용한다.인스턴수 변수인지, 지역변수인지? 확인할때  @escaping Closure에서도 사용을 하게되는데 이때는 강한 참조를 피하기 위해 사용한다."
  },
  
  {
    "title": "챌린지반 과제 FeedBack",
    "url": "/posts/%EC%B1%8C%EB%A6%B0%EC%A7%80%EB%B0%98-%EA%B3%BC%EC%A0%9C-FeedBack/",
    "categories": "캠프, 챌린지반 과제",
    "tags": "",
    "date": "2024-04-12 23:00:00 +0900",
    





    
    "snippet": "FeedBack 내용내용은 아래와 같다.  iOS 미니멈 버전 요구사항을 맞춰주세요  컨밴션을 맞춰주세요  사용하지 않는 함수는 삭제해주세요.  DispatchGroup 적용해보기.  Model에 CodingKey 적용하여 카멜형식으로 수정해주세요.  수정이 되지 않는 변수는 let으로 변경해주세요.  GitModel 다시 생성하는 부분을 수정해주세요...",
    "content": "FeedBack 내용내용은 아래와 같다.  iOS 미니멈 버전 요구사항을 맞춰주세요  컨밴션을 맞춰주세요  사용하지 않는 함수는 삭제해주세요.  DispatchGroup 적용해보기.  Model에 CodingKey 적용하여 카멜형식으로 수정해주세요.  수정이 되지 않는 변수는 let으로 변경해주세요.  GitModel 다시 생성하는 부분을 수정해주세요.  gitList는 Array 형식이 아니여도 좋을거 같아요.1. iOS 미니멈 버전 요구사항을 맞춰주세요코드를 제출하고 어제 챌린지반 강의 수강하면서 아차 싶었던 부분이다.미니멈 버전의 요구사항은 15였다.버전을 바꾸니 다음과 같은 에러가 발생했다.Compiling for iOS 15.0, but module 'Alamofire' has a minimum deployment target of iOS 17.0Alamofire의 버전을 현재 ios의 최신버전으로 사용하면서 생긴 문제로 생각한다.Clear!2. 컨벤션을 맞춰주세요이건 내가 너무 코드작성에만 신경을 써서 놓친 부분같다.우선 나머지 먼저 진행하는걸로.3. 사용하지 않는 함수는 삭제해주세요.이걸 튜터님이랑 같이 코드를 보면서 알게되었다.왜 만들었나 싶다. 뭔가 페이징처리하면서 이것저것 시도하면서 생긴게 아닐까라는 생각이 든다.과제제출한지 10일이 지난 시점이라 기억이 정확하게 나지 않는다.해당 코드를 지우면서 이것도 Clear!override func viewDidAppear(_ animated: Bool) {            }4. DispatchGroup 적용해보기.func loadPage () {        isLoadingPage = true // 로드가 되는동안에는 true로 하여 브레이크를 준다 dispatchQueue 실행 전에 더 내려서 발생하는 함수 재호출 방지        DispatchQueue.main.async { // 섹션 1을 로딩            self.tableView.reloadSections(IndexSet(integer: 1), with: .none)        }        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { // 1초뒤 실행, 무분별한 로딩을 방지            self.addPage()        }    }여기에 DispatchQueue가 두번 들어갔는데 이부분에 대해서 DispatchGroup을 사용해야한다.5. Model에 CodingKey 적용하여 카멜형식으로 수정해주세요.이것역시 튜터님 강의를 보면서 아차싶었던 부분이다.바로 적용해보도록 하자.// Beforestruct GitModel : Codable {        var login : String     var name : String     var avatar_url : String // CamelCase 규칙 어김    var location : String     var followers : Int     var following : Int     }struct GitRepoModel: Codable {        var name: String     var html_url: String // CamelCase 규칙 어김    var language: String? }바로 url부분에서 CamelCase를 사용하지 못했다.그냥 JSON과 똑같은 변수명으로 하면서 놓쳐버린 아주 어이없는Case이다.// Afterstruct GitModel: Codable {        var login : String // id    var name : String // 이름    var avatarUrl : String // profile image url    var location : String // 지역    var followers : Int // 팔로워 수    var following : Int // 팔로잉 수        // new!    enum CodingKeys: String, CodingKey {                case login        case name        case avatarUrl = \"avatar_url\" // avatar_url로 실제 Json과 같은 변수명을 사용.        case location        case followers        case following            }}struct GitRepoModel: Codable {        var name: String // repo이름    var htmlUrl: String // url주소    var language: String? // repo사용된 언어        enum CodingKeys: String, CodingKey {                case name        case htmlUrl = \"html_url\"        case language            }    }해당부분도 수정완료.url부분의 변수명이 바뀌면서 관련에러는 그에 맞게 이름만 다시 조정해주면 해결이 된다.Clear!6. 수정이 되지 않는 변수는 let으로 변경해주세요.struct Constants {        static var identifier = \"RepoCell\"    static var cellName = \"RepoTableViewCell\"    static var secondCellName = \"LoadingCell\"    }너무 어이가 없던 부분이다. let을 써야할 부분에 왜 var를 썼는지 이해가 안간다.var -&gt; let으로 바꿔주면 끝Clear!7. GitModel 다시 생성하는 부분을 수정해주세요.항상 배열로 넘기다보니 익숙함에 빠져서 어이없는 실수를 한 부분이다.실제로 이번과제인 WishList에서도 똑같이 하고있었다.사실 하면서 왜 내가 [0] 의 인덱스 값을 가져와서 하는거지? 라는 의문을 품었는데 그냥 찰나였다.반성하자.단일 Data 개념이라 그냥 Model자체로 넘기면 되는 거였는데, 뭔가 내가 잘못 적으면서 어찌저찌 하다가 안에 배열로 감싸면서 넘겼던 기억이 어렴풋이 있다.// beforefunc sendData (data: [GitModel])// afterfunc sendData (data: GitModel?)프로토콜 내부 전달하던 DataType도 배열을 빼고 GitModel로 넘기게 했다.func fetchRequest () {                AF.request(url, method: .get, headers: header).responseDecodable(of: GitModel.self        ) { response in                        switch response.result {            case .success(let data) :                do {                    let profileList = GitModel(login: data.login, name: data.name, avatarUrl:  data.avatarUrl, location: data.location, followers: data.followers, following: data.following)                                        self.delegate?.sendData(data: profileList)                }            case .failure(let error) :                print(error.localizedDescription)            }        }    }profileList가 [GitModel] 이었던것을 GitModel로 바꿔주었다.8. gitList는 Array 형식이 아니여도 좋을거 같아요.7번의 내용과 연결되는 부분이다.// Beforevar gitList: [GitModel] = [GitModel]()// After이렇게 바꿔주었다.  옵셔널인 이유는?      Data를 받지 못하면 nil이 되니까.    삭제한 이유는?      sendData에서 옵셔널 바인딩을 할 것이라서.  func sendData(data: GitModel?) {                if let gitList = data {                        DispatchQueue.main.async {                                self.profileImageView.kf.setImage(with: URL(string: gitList.avatarUrl)) // kingfisher를 사용하여 image url을 적용                self.idLabel.text = \"User ID : \\(gitList.login)\"                self.nameLabel.text = \"Name : \\(gitList.name)\"                self.regionLabel.text = \"Location : \\(gitList.location)\"                self.followerLabel.text = \"Follower : \\(String(gitList.followers))\"                self.followingLabel.text = \"Following : \\(String(gitList.following))\"                            }        }     }기존에 있던 gitList를 옵셔널 바인딩에서 사용할 변수이름으로 바꿔 주었다.그러다보니 기존에 있던 self부분을 다 지워주었다.Clear!4번이 가장 큰 산이다. 더 공부를 하고 추가로 수정하도록 하겠다."
  },
  
  {
    "title": "GCD (1)",
    "url": "/posts/GCD-(1)/",
    "categories": "Concurrency",
    "tags": "Git",
    "date": "2024-04-12 14:25:00 +0900",
    





    
    "snippet": "근래 Concurrency에 관심이 많이 생겨서 이것저것 자료를 찾다가, 강의라도 있으면 좋겠다는 생각이었는데, 구글링을 하다 발견하여 바로 결제를 해버렸다.GCD Series의 글들은 강의를 들으면서 내가 새로 알게된, 그리고 기존에 알고있지만 표현하지 못했던 부분을 정리 하고자 한다.출처",
    "content": "근래 Concurrency에 관심이 많이 생겨서 이것저것 자료를 찾다가, 강의라도 있으면 좋겠다는 생각이었는데, 구글링을 하다 발견하여 바로 결제를 해버렸다.GCD Series의 글들은 강의를 들으면서 내가 새로 알게된, 그리고 기존에 알고있지만 표현하지 못했던 부분을 정리 하고자 한다.출처"
  },
  
  {
    "title": "Todoey (5)",
    "url": "/posts/Todoey-(5)/",
    "categories": "Udemy, Todoey",
    "tags": "",
    "date": "2024-04-11 05:53:00 +0900",
    





    
    "snippet": "DB인식 문제 해결하기.강의를 수강하기 전, Relationship을 하면서 DB에 입력은 되지만 TableView에 보이지 않는 현상이 생겼다.이부분을 먼저 해결하고 다시 공부를 시작하도록 하겠다.// wrongoverride func numberOfSections(in tableView: UITableView) -&gt; Int {        r...",
    "content": "DB인식 문제 해결하기.강의를 수강하기 전, Relationship을 하면서 DB에 입력은 되지만 TableView에 보이지 않는 현상이 생겼다.이부분을 먼저 해결하고 다시 공부를 시작하도록 하겠다.// wrongoverride func numberOfSections(in tableView: UITableView) -&gt; Int {        return categories.count    }// correct    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {                return categories.count    }뭐가 잘못되었나 하나하나 확인하다가 어이없는 실수를 한걸 봤다.segue로 화면 전환우선 StoryBoard에 Segue가 있는지를 확인하고 작성하자세그가 잘 있고 Identifier도 확실하게 체크해두자.override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        performSegue(withIdentifier: \"goToItems\", sender: self)    }    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {        let destinationVC = segue.destination as! TodoListViewController                if let indexPath = tableView.indexPathForSelectedRow {             destinationVC.selectedCategory = categories[indexPath.row]        }    }Didset이란?  프로퍼티의 값이 변경된 직후에 호출되는 옵저버  기존에 저장되어 있던 값이 매개상수 형태로 전달된다.  프로퍼티 값이 변경된 후에 처리해야할 구문이 있다면 이 값을 이용해서 처리하면 된다.  시스템에서 기본적으로 oldValue라는 상수명 제공  새로 할당된 값이 필요할 때에는 프로퍼티 자체를 그냥 참조하면 된다.  새로운 값은 이미 프로퍼티에 저장되어 있는 상태이기 때문이다.var selectedCategory : Category? {        didSet {            loadItems()        } }let newItem = Item(context: self.context)            newItem.title = textField.text!            newItem.done = false            newItem.parentCategory = self.selectedCategory // new             하지만 이렇게 해줘도 현재 category아무거나 클릭해도 똑같은 값이 나오게 된다.왜냐하면 request에 어떠한 Query도 없기 때문이다.즉 어떠한 카테고리를 눌러도 동일한 request를 호출한다는 것.현재 TableView와 관련된 배열은 itemArray이다.loadItems에 가게되면,func loadItems (with request : NSFetchRequest&lt;Item&gt; = Item.fetchRequest()) {                do {            itemArray = try context.fetch(request)        } catch {            print(\"Error fetching data from context \\(error)\")        }                tableView.reloadData()    }Item에 모든 값을 request로하여 가져온다.Predicate를 이용한 쿼리문 작성우리는 이제 특정한 조건을 나타내는 쿼리문을 작성해야 한다.let predicate = NSPredicate(format: \"parentCategory.name MATCHES %@\", selectedCategory?.name ?? \"\")  format: 정규식이 들어가서 parentCategory의 이름과 %@에 일치하는 카테코리를 가져온다.selectedCategory 우리가 선택한 카테고리의 이름      즉, 여러 카테고리중, 우리가 선택한 카테고리와 일치하는 값을 가져오는 쿼리  그후 request에 request.predicate = predicate 쿼리문을 요청한다.parameter추가그리고 이제 load할때 쿼리문도 같이 넣어주어야 그 쿼리문에 맞는 값에 대해 로드를 하게된다.func loadItems (with request : NSFetchRequest&lt;Item&gt; = Item.fetchRequest(), predicate: NSPredicate) {현재 검색을 하면 오름차순 정렬만 되기에, SearchBar를 구현한 함수부에도 수정을 좀 해준다.func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {                let request : NSFetchRequest&lt;Item&gt; = Item.fetchRequest()                let predicate = NSPredicate(format: \"title CONTAINS[cd] %@\", searchBar.text!) // modified                request.sortDescriptors = [NSSortDescriptor(key: \"title\", ascending: true)]        loadItems(with: request, predicate: predicate) // modified            }쿼리와 일치하는 request를 요청한다.그리고 다시 loadItems로 가서,let compoundPredicate = NSCompoundPredicate(andPredicateWithSubpredicates: [categoryPredicate, predicate])        request.predicate = compoundPredicate하나더 만들어 준다.NSCompoundPredicate는 말그대로 여러 predicate를 가지고 있는 모음이라고 생각하면 된다.andPredicateWithSubpredicates는 배열안에 predicate가 들어가기에 저렇게 배열안에 담아주는 것이다.함수 수정으로인한 에러 해결loadItems에 parameter가 request하나 였지만, 이제는 predicate가 추가되었기에 그에 맞게 loadItems을 트리거하는 부분도 고쳐주어야 한다.하지만 그전에 일반적으로 우리가 쿼리가 해당하지 않는 부분을 load 할 수도 있기에func loadItems (with request : NSFetchRequest&lt;Item&gt; = Item.fetchRequest(), predicate: NSPredicate? = nil)이렇게 default Value로 nil을 주면, 일반적으로 DB에서 가져올때는 쿼리문 없이 가져오게 된다.if let additionalPredicate = predicate {            request.predicate = NSCompoundPredicate(andPredicateWithSubpredicates: [categoryPredicate, additionalPredicate])        } else {            request.predicate = categoryPredicate        }아까 작성했던 부분을 Optional Binding을 사용하여 고쳐주었다.작동해보면 이제는 검색도 잘 되는걸 알 수 있다."
  },
  
  {
    "title": "7주차 과제 (7)",
    "url": "/posts/7%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(7)/",
    "categories": "캠프, 7주차",
    "tags": "",
    "date": "2024-04-11 04:00:00 +0900",
    





    
    "snippet": "기존에는 API에서 값을 전달할때 Protocol을 사용하여 VC로 값을 넘겼는데,여러튜터님들에게 여쭤보며 Insight를 구해보니, 단일 메서드일때는 클로저가 더 좋다는 말씀도 있고, 두개 다 할줄 알아야 한다고 하셨기에, 그 부분만 좀 구현을 해보려 한다.잘 쓰지않아서 생소하기에 처음부터 하나하나 좀 파헤쳐가면서 기능을 구현하려고한다Escaping...",
    "content": "기존에는 API에서 값을 전달할때 Protocol을 사용하여 VC로 값을 넘겼는데,여러튜터님들에게 여쭤보며 Insight를 구해보니, 단일 메서드일때는 클로저가 더 좋다는 말씀도 있고, 두개 다 할줄 알아야 한다고 하셨기에, 그 부분만 좀 구현을 해보려 한다.잘 쓰지않아서 생소하기에 처음부터 하나하나 좀 파헤쳐가면서 기능을 구현하려고한다Escaping Closure를 사용한 통신1. 기본틀 작성func fetchRequestWithClosure(completion: @escaping() -&gt; Void) {            }기본틀은 다음과 같다. 완료되었을때 Escaping Clousre를 사용하여 데이터를 넘긴다는 의미.2. Escaping Closure?API호출 함수가 종료되면 종료 직후 그 값을 전달하기 위해서 escaping closure를 사용한다.현재 API를 통해 결과값을 가져와야하므로Escaping Clousre안에 어떤 값이 들어와햐하는지 생각을 해보자.우리는 Result를 사용할 것이다.Result는 들어가보면이런식으로 된다.성공했을때, 실패했을때 나눠서 작성하면된다.Failure일때는 Error를 사용하면되고,Success일때는 우리가 원하는 데이터 타입을 넘겨주면 된다.프로토콜로 생각한다면 어떤 값을 넘길지에대한 부분이 바로 successs에 들어간다고 생각하면 되겠다.func fetchRequestWithClosure(completion: @escaping(Result&lt;DataModel, Error&gt;) -&gt; Void) {     //                                            -------------------------    }이렇게 된다.url사용은 생략하겠다.이번에는 독특하게 httpMethod도 포함시켜서 작성 해보았다.func fetchRequestWithClosure(completion: @escaping(Result&lt;DataModel, Error&gt;) -&gt; Void) {                let pageNumber = (1...100).randomElement() ?? 1                if let url = URL(string: \"https://dummyjson.com/products/\\(pageNumber)\") {                        var request = URLRequest(url: url)            request.httpMethod = \"GET\"                        let task = URLSession.shared.dataTask(with: request) { (data, response ,error) in                                if let error {                    completion(.failure(error))                    return                }                                if let safeData = data {                    if let decodedData = self.decodingJson(data: safeData) {                        completion(.success(decodedData))                        return                    }                }            }            task.resume()        } else {                    }            }VC에서 해당 메서드 호출dataManager.fetchRequestWithClosure { result in            switch result {            case .success(let data) :                print(\"OK\")            case .failure(let error) :                print(\"Fail\")            }        }출력했을때 OK 확인.self.dataManager.fetchRequestWithClosure { result in                switch result {                case .success(let data) :                    self.list = data                    DispatchQueue.main.async {                        let price = self.numberFormatter.string(from: Double(self.list.price) * (100.00 - self.list.discountPercentage) / 100 as NSNumber)                        self.titleLabel.text = self.list.title                        self.bodyLabel.text = self.list.description                        self.priceLabel.text = \"\\(self.numberFormatter.string(from: self.list.price as NSNumber) ?? \"0\") $\"                        self.discountedLabel.text = \"할인 적용: \\(price ?? \"0\")$\"                        self.setPageCount()                        self.makingImageView.makingImage(list: self.list, scrollView: self.imageScrollView)                        self.scrollViewDidScroll(self.imageScrollView)                                            }                case .failure(let error) :                    let alert = self.alertManager.makingAlert(title: \"에러 발생\", body: \"데이터를 로드 하던 중 \\(error)가 발생했습니다.\")                    self.present(alert, animated: true)                }            }작동확인 완료.warning 수정기존에extension UIImageView {    func load(url: URL) {        DispatchQueue.global().async { [weak self] in            if let data = try? Data(contentsOf: url) {                if let image = UIImage(data: data) {                    DispatchQueue.main.async {                        self?.image = image                    }                }            }        }    }}Thread Performance Checker: Thread running at User-initiated quality-of-service class waiting on a lower QoS thread running at Default quality-of-service class. Investigate ways to avoid priority inversionsPID: 16569, TID: 604505첨에 URL주소를 바로 쓰는거라 사용을 한것이었는데 이런 Warning이 나올줄은 몰랐다.여기서 나는 warning이 너무 거슬려서 수정thread에서 우선순위 역전에 관한 내용이다.무튼 해당 문제를 해결하기위해ImageView관련 extension을 지웠다.그리고 아래 코드를 적용하려 했다.let url = URL(string: \"\")let data = try Data(contentsOf: url!)uiImageView.image = UIImage(data: data)하지만 위의 url,data 부분에서 해당 명령은 URLSession단에서 행하라는 swift의 message를 보고사이트를 참고하여 수정했다.해결완료.func makingImage (list: DataModel, scrollView: UIScrollView) {        for i in 0 ..&lt; list.images.count - 1 {            let imageView = UIImageView()            guard let url = URL(string: list.images[i]) else { return }            URLSession.shared.dataTask(with: url) {                (data, response, error) in                if let error {                    print(error)                }                guard let imageData = data else { return }                DispatchQueue.main.async {                    imageView.image = UIImage(data: imageData)                }            }.resume()            let xPos = scrollView.frame.width * CGFloat(i)            imageView.frame = CGRect(x: xPos, y: 0, width: scrollView.bounds.width, height: scrollView.bounds.height)                        scrollView.addSubview(imageView)            scrollView.contentSize.width = imageView.frame.width * CGFloat(i + 1)                    }    }여러 튜터님과 대화를 해보았는데,extension UIImageView {    func load(url: URL) {        DispatchQueue.global(qos: .background).async { [weak self] in            if let data = try? Data(contentsOf: url) {                if let image = UIImage(data: data) {                    DispatchQueue.main.async {                        self?.image = image                    }                }            }        }    }}qos를 Background로 더 뒤로 보내니 에러가 뜨지 않았다.Thread 심오한녀석이다."
  },
  
  {
    "title": "7주차 과제 (6)",
    "url": "/posts/7%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(6)/",
    "categories": "캠프, 7주차",
    "tags": "",
    "date": "2024-04-11 04:00:00 +0900",
    





    
    "snippet": "중복처리곰곰히 생각을 해보다가 똑같은 페이지를 로드했을때 담게되면 중복값이 그대로 DB에 들어갈것같아중복이라는 예외처리를 해보려 한다.현재는 이렇게 중복된 값이 들어가게 된다.1~100 까지는 너무나 광범위하니 1~5로 조정하여 테스트를 진행한다. do {                     savedList = try context.fetch(req...",
    "content": "중복처리곰곰히 생각을 해보다가 똑같은 페이지를 로드했을때 담게되면 중복값이 그대로 DB에 들어갈것같아중복이라는 예외처리를 해보려 한다.현재는 이렇게 중복된 값이 들어가게 된다.1~100 까지는 너무나 광범위하니 1~5로 조정하여 테스트를 진행한다. do {                     savedList = try context.fetch(request)                    } catch {            let alert = alertManager.makingAlert(title: \"에러 발생\", body: \"데이터를 로드 하던 중 오류가 발생했습니다.\")            self.present(alert, animated: true)        }우선 데이터를 로드한다.if savedList.filter({$0.id == list[0].id}).count == 1if문에 다음과 같이 적었다.DB의 값을 savedList에 저장을 하고, fetchRequest에서 가져온 값의 id와 비교를 하는 것이다.이때 count가 1이 된다는것은, 저장되어있는 값과 현재 불러온 값이 일치하는게 하나 존재한다는 뜻이다.@IBAction func saveListBtn(_ sender: UIButton) {        // new        do {                        savedList = try context.fetch(request)                    } catch {            let alert = alertManager.makingAlert(title: \"에러 발생\", body: \"데이터를 로드 하던 중 오류가 발생했습니다.\")            self.present(alert, animated: true)        }                if savedList.filter({$0.id == list[0].id}).count == 1 { // new                        let alert = alertManager.makingAlert(title: \"중복된 값이 존재합니다\", body: \"이미 해당 정보가 위시리스트에 저장되어있습니다.\")            self.present(alert, animated: true)                    } else {                        let newItem = Lists(context: self.context)            newItem.id = Int64(list[0].id)            newItem.title = list[0].title            newItem.price = Int64(list[0].price)            newItem.discountPercentage = list[0].discountPercentage                        do            {                try context.save()                            } catch {                let alert = alertManager.makingAlert(title: \"에러발생\", body: \"\\(error.localizedDescription)가 발생했습니다.\")                self.present(alert, animated: true)                            }                    }                savedList.removeAll()        dataManager.fetchRequest()        }이렇게 좀 더 디테일하게 구분을 해주었다.이렇게 미리 1~5 페이지 값을 다 담아 두었다.이렇게 alert가 뜨고, db에도 더이상 값이 들어가지 않는다.AlertManager 생성기존에 계속 무의미하게 let alert = UIAlertController~ 이렇게 무의미하게 계속 생성하는것 같아서함수로 구현해주었다.class AlertManager {        func makingAlert (title: String, body: String) -&gt; UIAlertController {        let alert = UIAlertController(title: title, message: body, preferredStyle: .alert)        alert.addAction(UIAlertAction(title: \"확인\", style: .default))                return alert    }}title과 본문내용인 body를 parameter로 받게 하였다.위에 예외처리를 하면서 테스트를 해본결과 작동이 잘 되는것을 확인했다.id순으로 정렬하여 보여주기.현재는 등록된 순으로 tableview에 보여지게 된다.이걸 id순으로 정렬하여 보여지게 하자.현재는 뒤죽박죽이다.tableVC.savedList = savedList.sorted(by: {$0.id &lt; $1.id})클로저를 사용하여 정렬한다.완료.삭제할때 꼬이지않고 DB에서 잘 지워지는것도 확인했다.기능 업그레이드.생각해보니 현재 ImageView를 사용했는데, 지난번 프로젝트때처럼 여러 이미지들에 대해 가로로 스크롤 해셔 보여주는것도 좋을 것 같아서 해당부분을 더 발전시켜보려한다.참고사이트이전에 팀원분을 도와주면서 해당 기능에 대한 매커니즘은 파악한 상태여서 내 코드에 맞게 조정을 하면 될듯하다.그리고 할인 전, 후 가격을 같이 보여주면 좋을 것 같다고해서 그 부분도 더 보강 해보려한다.지난 프로젝트의 아이디어가 생각나서 imageview에서 scrollview로 바꾸었다.func addImage() {                for i in 0 ..&lt; list[0].images.count - 1 {            let imageView = UIImageView()            let xPos = imageScrollView.frame.width * CGFloat(i)            imageView.frame = CGRect(x: xPos, y: 0, width: imageScrollView.bounds.width, height: imageScrollView.bounds.height)            imageView.load(url: URL(string: list[0].images[i])!)            imageScrollView.addSubview(imageView)            imageScrollView.contentSize.width = imageView.frame.width * CGFloat(i + 1)        }            }안에서 이미지뷰가 새로 갱신이 되는 스타일이다.이전에는 viewDidload에 해당 함수를 넣었겠지만 이번엔 다르다.api통신 이후 값이 들어오므로 DispatchQueue.main.async {                let price = self.numberFormatter.string(from: Double(self.list[0].price) * (100.00 - self.list[0].discountPercentage) / 100 as NSNumber)                self.titleLabel.text = self.list[0].title                self.bodyLabel.text = self.list[0].description                self.priceLabel.text = \"\\(self.numberFormatter.string(from: self.list[0].price as NSNumber) ?? \"0\") $\"                self.discountedLabel.text = \"할인 적용: \\(price ?? \"0\")$\"                self.addImage() // new            }여기에 넣어준다.우선 잘되는걸 확인했다.하지만 내가 직접 스크롤을 하지 않는 이상 보이지 않기에 PageControl도 추가해준다.extension ViewController: UIScrollViewDelegate {        func setPageCount () { // page의 카운트를 정해줌.        imagePageControl.numberOfPages = list[0].images.count - 1    }        private func setPageControlSelectedPage(currentPage:Int) { // 현재 페이지를 보여줌        imagePageControl.currentPage = currentPage      }        func scrollViewDidScroll(_ imageScrollView: UIScrollView) {        let value = imageScrollView.contentOffset.x/imageScrollView.frame.size.width        setPageControlSelectedPage(currentPage: Int(round(value)))    }    }참고사이트와 코드전개는 동일.이때 주의해야할 점이라면 현재 scrollView가 2개이기에 delegate를 사용할때 매칭을 잘 해줘야한다.scrollView / imageScrollView 두개가 있는데scrollView로 하게되면 pull to refresh할때 scrollViewDidScroll 메서드가 트리거된다."
  },
  
  {
    "title": "7주차 과제 (5)",
    "url": "/posts/7%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(5)/",
    "categories": "캠프, 7주차",
    "tags": "",
    "date": "2024-04-11 02:00:00 +0900",
    





    
    "snippet": "Lv.5Lv5. 당겨서 새로고침 구현  위시 리스트의 “다른 상품 보기”를 업그레이드 해봅니다.  스크롤을 내려 당기면, Refresh Indicator를 노출시킵니다.  데이터를 불러오는동안 잠시, Indicator를 고정시킵니다.  반드시 사용할 것 : UIRefreshControlPull to Refresh를 구현하는 내용이다.이전 챌린지 과제에...",
    "content": "Lv.5Lv5. 당겨서 새로고침 구현  위시 리스트의 “다른 상품 보기”를 업그레이드 해봅니다.  스크롤을 내려 당기면, Refresh Indicator를 노출시킵니다.  데이터를 불러오는동안 잠시, Indicator를 고정시킵니다.  반드시 사용할 것 : UIRefreshControlPull to Refresh를 구현하는 내용이다.이전 챌린지 과제에 있었기에 어려운건 없을듯하다.좀 다른 점이라면, 이전에는 TableView에서 Pull to Refresh였다면,이번엔 화면자체에서 pull to refresh를 하는것이다.참고사이트를 보니 별거 없어보인다.scrollView를 하나 만들어 주었고.실제로 refresh를 별도로 생성할때는 작동이 뭔가 안되는것 같았다.그래서 scrollView에 refreshControl프로퍼티가 있어서 그것을 이용하기로 했다.// viewdidloadscrollView.refreshControl = UIRefreshControl()scrollView.refreshControl?.addTarget(self, action: #selector(reloadJson), for: .valueChanged)    @objc func reloadJson() {            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {        self.dataManager.fetchRequest()    }        }이렇게 해주었다.하지만 로드 이후에도 계속 인디게이터가 돌아가는걸 알 수있다.문제해결@objc func reloadJson() {                DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {            self.dataManager.fetchRequest()            self.scrollView.refreshControl?.endRefreshing() // new        }            }refreshing을 종료해주는 메서드가 없어서 생긴 문제다.완료.2초 너무 긴거같아서 1초로 바꾼다."
  },
  
  {
    "title": "7주차 과제 (4)",
    "url": "/posts/7%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(4)/",
    "categories": "캠프, 7주차",
    "tags": "",
    "date": "2024-04-11 01:00:00 +0900",
    





    
    "snippet": "Lv.4Lv4. 위시 리스트 삭제  아래 방법 중 1가지를 택해 구현합니다.          목록을 스와이프하여 삭제 버튼을 노출하고 터치하면 삭제 - UITableView의 기능      목록 Cell에 삭제 UIButton을 구성      길게 눌러 Alert를 띄우기        반드시 사용할 것 : UITableView or UIButton예외...",
    "content": "Lv.4Lv4. 위시 리스트 삭제  아래 방법 중 1가지를 택해 구현합니다.          목록을 스와이프하여 삭제 버튼을 노출하고 터치하면 삭제 - UITableView의 기능      목록 Cell에 삭제 UIButton을 구성      길게 눌러 Alert를 띄우기        반드시 사용할 것 : UITableView or UIButton예외 처리.Lv.4 기능은 ContextualAction을 사용 해서 구현을 할 생각이다.즉 Swipe해서 삭제를 처리 할 예정.그전에 이전에 피드백에서도 단순히 print말고 좀 더 유져에게 보여주면 좋을 것 같다는 피드백을 들었기에예외처리를 좀 더 해보려 한다.1. 각 Button의 예외처리@IBAction func saveListBtn(_ sender: UIButton) {                    let newItem = Lists(context: self.context)                newItem.id = Int64(list[0].id)        newItem.title = list[0].title        newItem.price = Int64(list[0].price)        newItem.discountPercentage = list[0].discountPercentage                do            {               try context.save()                            } catch {                print(error.localizedDescription)            }    }현재는 이렇게 되어있다.단순히 콘솔로 에러코드가 출력되는 부분에 대해서 alert를 이용해서 하려고한다.@IBAction func saveListBtn(_ sender: UIButton) {                        let newItem = Lists(context: self.context)                newItem.id = Int64(list[0].id)        newItem.title = list[0].title        newItem.price = Int64(list[0].price)        newItem.discountPercentage = list[0].discountPercentage                do        {            try context.save()                    } catch {            let alert = UIAlertController(title: \"에러 발생\", message: \"\\(error.localizedDescription)가 발생했습니다.\", preferredStyle: .alert)            alert.addAction(UIAlertAction(title: \"확인\", style: .default))            self.present(alert, animated: true)        }    }이렇게 해주었다.showDBBtn에 대한 Action도 동일하게 해주었다.2. DataLoad에서의 예외처리기존에 난수를 만들때 배열을 썼는데 불필요한 메모리를 만드는 것같아 코드를 한줄로 줄인다.func fetchRequest() {                let pageNumber = (1...100).randomElement() ?? 1 // modified                let url = \"https://dummyjson.com/products/\\(pageNumber)\"                if let url = URL(string: url) {             let urlSession = URLSession(configuration: .default)                        let task = urlSession.dataTask(with: url) { (data,response,error) in                                if error != nil {                    self.delegate?.sendList(data: [])                    return                }                                if let safeData = data {                    let decodedData = self.decodingJson(data: safeData)                    self.delegate?.sendList(data: decodedData)                }            }                        task.resume()        }    }현재 에러가 발생하게 되면 아무것도 없는 빈 배열을 delegate를 통해 전달하게 해두었다.그래서 에러가 발생했을 경우를 생각하여 아래 isEmpty로 조건을 만들어 alert를 구현하여 유져에게 인폼을 주도록 했다. func sendList(data: [DataModel]) {                if !data.isEmpty { // new            list = data                        DispatchQueue.main.async {                let price = self.numberFormatter.string(from: Double(self.list[0].price) * (100.00 - self.list[0].discountPercentage) as NSNumber)                self.imageView.load(url: URL(string: self.list[0].thumbnail)!)                self.titleLabel.text = self.list[0].title                self.bodyLabel.text = self.list[0].description                self.priceLabel.text = \"\\(price ?? \"0\")$\"            }        } else {            let alert = UIAlertController(title: \"에러 발생\", message: \"데이터 로드중 문제가 발생했습니다.\", preferredStyle: .alert)            alert.addAction(UIAlertAction(title: \"확인\", style: .default))            self.present(alert, animated: true)        }    }fetch request에 pagenumber를 0으로 줘서 예외 발생 처리를 테스트 해보자.실제로 page가 0일때는{\"message\": \"Product with id '0' not found\"}이렇게 출력이된다. 즉 데이터가 없으므로 빈배열을 리턴하게 된다.결과.다음 버튼을 눌러도 똑같다.예외처리가 잘 되었다.Lv.41. 삭제기능 구현위에 언급한대로 UIContextualAction을 사용해 swipe하면서 해당 내용을 지우는 것이다.override func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {                let deleteBtn = UIContextualAction(style: .normal, title: \"Delete\") { (UIContextualAction, UIView, success: @escaping (Bool) -&gt; Void) in                        let alert = UIAlertController(title: \"삭제하기\", message: \"정말 삭제하시나요?.\", preferredStyle: .alert)                        let ok = UIAlertAction(title: \"OK\", style: .destructive, handler: { _ in                  self.savedList.remove(at: indexPath.row)                tableView.beginUpdates()                tableView.deleteRows(at: [indexPath], with: .fade)                tableView.endUpdates()                            })                        let cancel = UIAlertAction(title: \"Cancel\", style: .cancel)                        alert.addAction(ok)            alert.addAction(cancel)            self.present(alert,animated: false)                        success(true)        }        deleteBtn.backgroundColor = .red        return UISwipeActionsConfiguration(actions: [deleteBtn])    }일단 테이블뷰에 삭제되는 기능은 구현이 되었다2. Context를 이용하여 삭제 구현.override func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {                let deleteBtn = UIContextualAction(style: .normal, title: \"Delete\") { (UIContextualAction, UIView, success: @escaping (Bool) -&gt; Void) in                        let alert = UIAlertController(title: \"삭제하기\", message: \"정말 삭제하시나요?.\", preferredStyle: .alert)                        let ok = UIAlertAction(title: \"OK\", style: .destructive, handler: { _ in                                self.context.delete(self.savedList[indexPath.row]) // new                self.savedList.remove(at: indexPath.row)                tableView.beginUpdates()                tableView.deleteRows(at: [indexPath], with: .fade)                tableView.endUpdates()                self.appDelegate.saveContext() // new            })                        let cancel = UIAlertAction(title: \"Cancel\", style: .cancel)                        alert.addAction(ok)            alert.addAction(cancel)            self.present(alert,animated: false)                        success(true)        }        deleteBtn.backgroundColor = .red        return UISwipeActionsConfiguration(actions: [deleteBtn])    }해당 위치의 값을 delete로 삭제해준다.이대 saveContext()를 하지않으면 삭제된게 DB에 반영이 되지 않으므로 반드시 작성해준다.그게 아니면do {    try self.context.save()    } catch {        print(error)    }이걸 사용해도 된다.요지는 DB의 값이 변동이 되었을때 save를 해줘야 한다는것.saveContext에는func saveContext () {        let context = persistentContainer.viewContext        if context.hasChanges {            do {                try context.save()            } catch {                // Replace this implementation with code to handle the error appropriately.                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.                let nserror = error as NSError                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")            }        }    }값이 변화하면 save를 하게 되어있다.Lv.4 끝"
  },
  
  {
    "title": "7주차 과제 (3)",
    "url": "/posts/7%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(3)/",
    "categories": "캠프, 7주차",
    "tags": "",
    "date": "2024-04-10 15:00:00 +0900",
    





    
    "snippet": "CoreData 사용하기이번 과제에서는 CoreData를 사용하는것이 있기에 그부분을 구현하려한다.이미 DataModel라는 API로 부터 가져오는 똑같은 이름이 있으니LocalModel로 만들어 주었다.Entities 가 TableAttributes 가 Field라고 보면 된다.이렇게 만들어 주었다.사용전 AppDelegate에 다음과 같이 내용을 ...",
    "content": "CoreData 사용하기이번 과제에서는 CoreData를 사용하는것이 있기에 그부분을 구현하려한다.이미 DataModel라는 API로 부터 가져오는 똑같은 이름이 있으니LocalModel로 만들어 주었다.Entities 가 TableAttributes 가 Field라고 보면 된다.이렇게 만들어 주었다.사용전 AppDelegate에 다음과 같이 내용을 적어주자.import CoreData// MARK: - Core Data stack    lazy var persistentContainer: NSPersistentContainer = {        /*         The persistent container for the application. This implementation         creates and returns a container, having loaded the store for the         application to it. This property is optional since there are legitimate         error conditions that could cause the creation of the store to fail.        */        let container = NSPersistentContainer(name: \"LocalModel\")        container.loadPersistentStores(completionHandler: { (storeDescription, error) in            if let error = error as NSError? {                // Replace this implementation with code to handle the error appropriately.                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.                                 /*                 Typical reasons for an error here include:                 * The parent directory does not exist, cannot be created, or disallows writing.                 * The persistent store is not accessible, due to permissions or data protection when the device is locked.                 * The device is out of space.                 * The store could not be migrated to the current model version.                 Check the error message to determine what the actual problem was.                 */                fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")            }        })        return container    }()    // MARK: - Core Data Saving support    func saveContext () {        let context = persistentContainer.viewContext        if context.hasChanges {            do {                try context.save()            } catch {                // Replace this implementation with code to handle the error appropriately.                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.                let nserror = error as NSError                fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")            }        }    }그리고 Container와 소통할 Context를 적어준다.let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContext앞으로 CRUD에 관한 모든것들은 Context를 통해서 이루어지게될것이다.그리고 버튼을 눌렀을때 CoreData에 들어가야 하기에 다음과 같이 구현해준다.1. Create 구현.CRUD중 첫번째인 C를 구현한다.값을 그냥 DB에 추가를 하면 되는 부분이다.@IBAction func saveListBtn(_ sender: UIButton) {                    let newItem = Lists(context: self.context)                newItem.id = Int64(list[0].id)        newItem.title = list[0].title        newItem.price = Int64(list[0].price)        newItem.discountPercentage = list[0].discountPercentage                do            {               try context.save()                            } catch {                print(error.localizedDescription)            }    }2. Read 구현두번째인 R을 구현한다.1. TableVC 생성해당 부분은 TableView에 보여져야 하므로, 새로운 VC를 만들어야한다.디자인과는 무관하므로 TableViewController 통으로 된걸 만들었다.@IBAction func showDBBtn(_ sender: UIButton) {                if let tableVC = self.storyboard?.instantiateViewController(identifier: Constansts.tableVC) as? DBTableViewController {                        self.present(tableVC, animated: true)        }    }그리고 다음과 같이 구현했다.이렇게하면 화면전환은 문제없이 된다.2. TableVC 내용 구성class DBTableViewController: UITableViewController {        var savedList: [Lists] = [Lists]()        override func viewDidLoad() {        super.viewDidLoad()         }        override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {                return savedList.count    }            override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        guard let cell = tableView.dequeueReusableCell(withIdentifier: Constansts.cellIdentifier) else {            return UITableViewCell()        }                cell.textLabel?.text = \"\\(savedList[indexPath.row].id)\\(savedList[indexPath.row].title ?? \"None\")\"                return cell    }}이렇게 구성을 해두었다.context가 VC에 있기에 거기서 로드를 하여 배열에 저장 후, property를 통해 직접 전달로 하면서 넘기면 될 듯 하다.3. Context 작성@IBAction func showDBBtn(_ sender: UIButton) {                let request : NSFetchRequest&lt;Lists&gt; = Lists.fetchRequest()                do {            savedList = try context.fetch(request)        } catch {            print(error.localizedDescription)        }                        if let tableVC = self.storyboard?.instantiateViewController(identifier: Constansts.tableVC) as? DBTableViewController {                        tableVC.savedList = savedList                        self.present(tableVC, animated: true)        }            }request를 이용한다.작성하는 방식은 3가지가 존재한다let request = NSFetchRequest&lt;Entity&gt;(entityName: \"Entity\")let request: NSFetchRequest&lt;Entity&gt; = Entity.fetchRequest()let request = Entity.fetchRequest()  직접 생성          NSFetchRequest를 직접 생성하고 엔터티의 이름을 지정하여 검색 요청을 정의      entityName 매개변수에는 검색할 엔터티의 이름을 String으로 전달엔터티 이름을 하드 코딩하는 방식으로 해당 방법은 지양        자동 생성          Core Data에서 자동으로 생성한 Swift 클래스의 fetchRequest() 메서드를 사용하는 방식      엔터티 이름 하드 코딩할 필요없이 검색 요청 정의 가능      NSFetchRequest라는 정확한 타입 정보를 가지고 있음        자동 생성 단축형          2번의 방법과 동일하며, 타입 정보를 생략, 코드의 가독성을 높인 간결한 방식이다.      엔터티 타입을 정확하게 추론한다.      참고사이트그리고 가격부분을 좀 다듬어 주었다.override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {                guard let cell = tableView.dequeueReusableCell(withIdentifier: Constansts.cellIdentifier) else {            return UITableViewCell()        }                let price = Double(savedList[indexPath.row].price) * (100.00 - savedList[indexPath.row].discountPercentage)        cell.textLabel?.text = \"[\\(savedList[indexPath.row].id)] \\(savedList[indexPath.row].title ?? \"None\") - \\(numberFormatter.string(from: price as NSNumber) ?? \"0\")$\"        return cell    }잘나온다.좀 짤리는 부분이 있어서 폰트 사이즈를 조정해준다.cell.textLabel?.font = UIFont.systemFont(ofSize: 15)Lv.3 까지 끝."
  },
  
  {
    "title": "7주차 과제 (2)",
    "url": "/posts/7%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(2)/",
    "categories": "캠프, 7주차",
    "tags": "",
    "date": "2024-04-10 15:00:00 +0900",
    





    
    "snippet": "API로 부터 값 가져오기.어떤 값이 필요로할지 조건을 보고 다음과 같이 모델링을 해두었다.struct DataModel {        let id: Int    let title: String    let description: String    let price: Int    let discountPercentage: Double    let t...",
    "content": "API로 부터 값 가져오기.어떤 값이 필요로할지 조건을 보고 다음과 같이 모델링을 해두었다.struct DataModel {        let id: Int    let title: String    let description: String    let price: Int    let discountPercentage: Double    let thumbnail: String    }image의 경우 url이기에 아무래도 3rd Party Library를 사용해야 할 것 같다. func fetchRequest() {                var pageNumber: Int = 1                let url = \"https://dummyjson.com/products/\\(pageNumber)\"                if let url = URL(string: url) {             let urlSession = URLSession(configuration: .default)                        let task = urlSession.dataTask(with: url) { (data,response,error) in                                if error != nil {                    print(error?.localizedDescription)                    return                }                                if let safeData = data {                    print(safeData)                }            }                        task.resume()        }    }우선 다음과 같이 적었다첨에 왜 결과값이 안보이나 했는데 task.resume()을 빼먹었다.출력결과 537bytes가 나온다.즉 Decoding을 해야한다는 뜻이다.Decoder 함수 구현func decodingJson (data: Data) -&gt; [DataModel]? {                let decoder = JSONDecoder()        do {            let decodedData = try decoder.decode(DataModel.self, from: data)            let id = decodedData.id            let title = decodedData.title            let description = decodedData.description            let price = decodedData.price            let discountPercentage = decodedData.discountPercentage            let thumnail = decodedData.thumbnail                        var list: [DataModel] = [DataModel(id: id, title: title, description: description, price: price, discountPercentage: discountPercentage, thumbnail: thumnail)]                      return list                    } catch {            print(error)                        return []        }                }그리고 해당부분을 확인하기 위해 우선 프린트로 대체했다if let safeData = data {                    let decodedData = self.decodingJson(data: safeData)                    print(decodedData)                }출력해보니 잘 나온다.UI에 값 구현하기.잘나오는 것을 확인했으니 이제 값을 전달하기 위해 Delegate를 사용하여 전달한다.인터넷 찾아보니 cocoapod을 안해도 url로 이미지를 가져올수있어서 그걸 사용하기로 했다.extension ViewController: SendData {    func sendList(data: [DataModel]) {        list = data                DispatchQueue.main.async {            self.imageView.load(url: URL(string: self.list[0].thumbnail)!)            self.titleLabel.text = self.list[0].title            self.bodyLabel.text = self.list[0].description            self.priceLabel.text = self.numberFormatter.string(from: Double(self.list[0].price) * self.list[0].discountPercentage as NSNumber)        }    }   }extension UIImageView {    func load(url: URL) {        DispatchQueue.global().async { [weak self] in            if let data = try? Data(contentsOf: url) {                if let image = UIImage(data: data) {                    DispatchQueue.main.async {                        self?.image = image                    }                }            }        }    }}실행하면?우선 api로 값을 UI에 띄우는것 까지는 구현이 되었다.다음글에서는 CoreData를 활용하여 위시리스트를 담아보도록 하겠다."
  },
  
  {
    "title": "7주차 과제 (1)",
    "url": "/posts/7%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(1)/",
    "categories": "캠프, 7주차",
    "tags": "",
    "date": "2024-04-09 20:00:00 +0900",
    





    
    "snippet": "이번에도 약 2주의 시간이 주어지며,WishList App을 만드는것이다.강의에 간단하게 만드는 내용이 있던걸로 아는데, 그걸 보지않고 여태껏 배워 온 내용으로 먼저 만들고 이후에 보려고 한다.최소 구현해야하는 단계는 아래와 같다.Lv1. 데이터 모델링하기  API로 받아올 데이터 객체를 만듭니다.          아래 API 정보 토글에서 받아올 수...",
    "content": "이번에도 약 2주의 시간이 주어지며,WishList App을 만드는것이다.강의에 간단하게 만드는 내용이 있던걸로 아는데, 그걸 보지않고 여태껏 배워 온 내용으로 먼저 만들고 이후에 보려고 한다.최소 구현해야하는 단계는 아래와 같다.Lv1. 데이터 모델링하기  API로 받아올 데이터 객체를 만듭니다.          아래 API 정보 토글에서 받아올 수 있는 데이터를 확인하고, 필요한 데이터를 모델링합니다.              데이터 예시          struct RemoteProduct: Decodable {  \tlet id: Int  \t// 다음 데이터  \t// 다음 데이터  \t// 다음 데이터  }                            Dummy API 정보        [GET] https://dummyjson.com/products/{ID}                  ID의 범위: 1 ~ 100                      Response JSON              {      \"id\": 1,      \"title\": \"iPhone 9\",      \"description\": \"An apple mobile which is nothing like apple\",      \"price\": 549,      \"discountPercentage\": 12.96,      \"rating\": 4.69,      \"stock\": 94,      \"brand\": \"Apple\",      \"category\": \"smartphones\",      \"thumbnail\": \"https://i.dummyjson.com/data/products/1/thumbnail.jpg\",      \"images\": [          \"https://i.dummyjson.com/data/products/1/1.jpg\",          \"https://i.dummyjson.com/data/products/1/2.jpg\",          \"https://i.dummyjson.com/data/products/1/3.jpg\",          \"https://i.dummyjson.com/data/products/1/4.jpg\",          \"https://i.dummyjson.com/data/products/1/thumbnail.jpg\"      ]  }                                            API로 받아온 데이터에 맞게 CoreData 데이터를 모델링합니다.  잠깐!          왜 네트워크 통신으로 받아온 데이터와 내부 저장소인 CoreData 데이터를 각각 모델링 해줘야하죠?                  API로 받아온 데이터와 CoreData 데이터 엔티티를 별도로 모델링하면 앱 내에서 우려사항을 명확하게 분리하는 데 도움이 됩니다.          우려사항이라고 한다면?                          API로 받아온 데이터는 특히 API가 변경되거나 업데이트되는 경우 핵심 데이터 모델의 구조와 항상 완벽하게 일치하지 않을 수 있답니다!                                API로 받아온 데이터를 별도로 모델링하면 받아온 데이터 형식을 빠르게 반영하도록 설계할 수 있으므로 CoreData 엔티티에 매핑할 때 처리가 더 쉬워집니다.                    Lv2. 위시 리스트 메인 페이지  디자인 및 화면 구성은 반드시 예시대로 하지 않아도 됩니다.  다른 상품 보기 버튼 구현          버튼을 누르면 랜덤한 “id”를 생성하고 해당 id에 따라 다른 상품을 보여줍니다.      [GET] https://dummyjson.com/products/{ID}        아래 JSON Dummy API를 활용해, 상품 정보를 노출합니다.          반드시 보여줘야할 상품 데이터                  썸네일 이미지(thumbnail)          상품명(title)          상품 설명(description)          가격(price)                          가격의 경우, 1000단위로 콤마(,) 처리합니다.                                          반드시 사용할 것 : URLSession, UIImage, UILabel              Dummy API 정보        [GET] https://dummyjson.com/products/{ID}                  ID의 범위: 1 ~ 100                      Response JSON              {      \"id\": 1,      \"title\": \"iPhone 9\",      \"description\": \"An apple mobile which is nothing like apple\",      \"price\": 549,      \"discountPercentage\": 12.96,      \"rating\": 4.69,      \"stock\": 94,      \"brand\": \"Apple\",      \"category\": \"smartphones\",      \"thumbnail\": \"https://i.dummyjson.com/data/products/1/thumbnail.jpg\",      \"images\": [          \"https://i.dummyjson.com/data/products/1/1.jpg\",          \"https://i.dummyjson.com/data/products/1/2.jpg\",          \"https://i.dummyjson.com/data/products/1/3.jpg\",          \"https://i.dummyjson.com/data/products/1/4.jpg\",          \"https://i.dummyjson.com/data/products/1/thumbnail.jpg\"      ]  }                                          Lv3. 위시 리스트 보기 페이지  위시 리스트 담기 버튼 구현          버튼을 누르면 현재 보여주고 있는 상품의 정보를 CoreData에 저장      반드시 사용할 것 : Core Data, UIButton        위시 리스트 보기 페이지 구현          “위시 리스트 보기” 버튼을 누르면 위시 리스트 담기 버튼을 눌렀을 때 CoreData에 저장한 데이터 노출      상품 아이템들 사이에 회색 라인을 추가해서 구분해주세요.      반드시 보여줘야할 상품 데이터(ex: [1] iPhone 9 - 549$)                  상품의 아이디(id)          상품명(title)          가격(price)                    반드시 사용할 것 : UIViewController, TableView      Mindmap 작성우선은 머리속에 생각나는대로 적어봤다.LV.1 시작우선 DataModel을 하나 만들어준다.이건 API에서 가져올 데이터를 가져올때 사용할것이다.LV.3에 보면 반드시 보여야할 상품데이터에 id, title, price가 있다.즉 이 값들은 무조건 DataModel에 들어있어햐 한다는 뜻이다.JSON 데이터 확인.우선 API에 요청을 했을때 어떤 값을 가지고 오는지를 확인해보자이런식으로 값을 가져오는데, 제일 아래 보면 total이 100개가 끝이다.그렇다는건 1~100 까지의 값을 난수로 설정하여 얻어서 페이지에 입력하면 될듯하다.즉 https://dummyjson.com/products/\\(pageNumber) 이런 느낌?pageNumber라는 변수는 나중에 별도로 설정하고 하면 될 것 같다.과제의 흐름을 보아선 그래도 이전 과제는 1~3까지는 과제의 흐름을 따라 할 수 있었지만 이번에는 안될것같다.찐으로 시작하는건 다음글에서부터"
  },
  
  {
    "title": "7주차 (1)",
    "url": "/posts/%EB%B3%B8%EC%BA%A0%ED%94%84-7%EC%A3%BC%EC%B0%A8-(1)/",
    "categories": "캠프, 7주차",
    "tags": "",
    "date": "2024-04-09 18:00:00 +0900",
    





    
    "snippet": "심화내용 시작이다.첫날은 가볍게 시작하고 싶었는데, 하필이면 관심을 요근래 가지던 메모리 구조라서공부도할겸 이것저것 여러 자료를 찾아서 정리를 해보려한다.Swift Memory StructureCode 영역  Code 영역은 프로그램의 실행 코드가 저장되는 공간입니다.  컴파일된 소스 코드와 프로그램의 명령어들이 저장되어 있습니다.  이 영역은 읽기 ...",
    "content": "심화내용 시작이다.첫날은 가볍게 시작하고 싶었는데, 하필이면 관심을 요근래 가지던 메모리 구조라서공부도할겸 이것저것 여러 자료를 찾아서 정리를 해보려한다.Swift Memory StructureCode 영역  Code 영역은 프로그램의 실행 코드가 저장되는 공간입니다.  컴파일된 소스 코드와 프로그램의 명령어들이 저장되어 있습니다.  이 영역은 읽기 전용(Read-Only)이며, 프로그램이 실행되면서 수정되지 않습니다.Data 영역  Data 영역은 전역 변수(global variables)와 정적 변수(static variables), 상수(constants)가 저장되는 곳입니다.  프로그램 시작 시 할당되고 프로그램이 종료될 때까지 유지됩니다.Stack 영역  소스코드가 컴파일러에 의해 기계어로 변환되는 시점(컴파일 타임)에 크기가 결정됩니다.  Stack 영역은 함수 호출과 관련된 정보를 저장하는 데 사용됩니다.  함수가 호출될 때마다 해당 함수의 로컬 변수(local variables), 함수 매개변수(parameters), 반환 주소(return address) 그리고 함수 호출에 필요한 기타 정보가 스택에 저장됩니다.  함수가 실행을 마치면 해당 함수와 관련된 데이터가 스택에서 제거됩니다.  스택은 후입선출(Last-In-First-Out, LIFO) 구조를 가지고 있습니다.  값타입(value Type)이 저장되는 영역Heap 영역  Heap 영역은 프로그램 실행 중(런타임) 동적으로 할당된 데이터가 저장되는 곳입니다.  힙은 런타임 중에 메모리 할당이 필요한 경우 사용되며, 개발자가 직접 제어할 수 있습니다.  힙에 저장된 데이터는 직접적으로 포인터를 통해 접근(참조)됩니다.  힙은 스택과 달리 메모리의 자유 공간을 사용하여 데이터를 저장하므로, 크기나 수명에 대한 동적인 요구에 대응할 수 있습니다.  참조타입(reference Type)이 저장되는 영역Swift의 ARCSwift는 ARC를 사용하여 Heap 영역의 객체 메모리를 자동으로 관리합니다.  ARC : Automatic Reference Counting의 약자ARC는 Heap 영역의 객체에 대한 Strong Reference(강한 참조) count를 추적하고,객체가 더 이상 필요하지 않을 때 (참조 count가 없을 때) 해당 객체에 대한 메모리를 자동으로 해제하는방식으로 메모리를 관리합니다.Strong Reference (강한 참조)기본적으로 Swift에서 변수나 상수는 Strong Reference(강한 참조)를 합니다.객체에 대한 Strong Reference(강한 참조) count가 증가되어 있다면, 해당 객체는 메모리에 유지됩니다.class Person {    var name: String    init(name: String) {        self.name = name    }}var person1: Person? = Person(name: \"Alice\") // strong 참조var person2 = person1 // 또 다른 strong 참조// person1이 nil이 되더라도 person2가 여전히 strong 참조를 가지고 있으므로 객체는 메모리에 유지됨person1 = nilCircular References (순환 참조)ARC 작동 방식의 특성상 두 객체가 서로를 강하게 참조하는 경우, 순환참조가 발생합니다.두 객체 모두 더이상 사용되지 않더라도 두 객체가 서로를 강하게 참조하는 경우, Strong Reference count가 감소하지 않아, 메모리에서 해제되지 못하고 메모리가 누수되는 문제가 발생합니다.이러한 문제를 해결하기 위해, 약한 참조(weak reference)와 미소유 참조(unowned reference) 같은 다른 참조 유형을 사용할 수 있습니다.class Person {    var name: String    var pet: Pet? // Person이 소유하는 Pet    init(name: String) {        self.name = name    }}class Pet {    var species: String    var owner: Person? // Pet을 소유하는 Person    init(species: String) {        self.species = species    }}var person: Person? = Person(name: \"Alice\") // Person 클래스의 인스턴스를 생성var pet: Pet? = Pet(species: \"Dog\") // Pet 클래스의 인스턴스를 생성person?.pet = pet // Person 클래스의 pet에 Pet 인스턴스를 할당pet?.owner = person // Pet 클래스의 owner에 Person 인스턴스를 할당Weak Reference (약한 참조)약한 참조는 Strong Reference(강한 참조)와는 달리 객체의 참조 count 증가시키지 않습니다.객체의 생명 주기에 영향을 주지 않으면서 참조를 유지할 수 있습니다.class Person {    var name: String    weak var friend: Person? // 약한 참조    init(name: String) {        self.name = name    }}var person1: Person? = Person(name: \"Alice\")var person2: Person? = Person(name: \"Bob\")person1?.friend = person2person2?.friend = person1// person1이 메모리에서 해제됨, 그에 따라 person1과 연결된 모든 객체의 참조 카운트가 감소됨person1 = nilUnowned Reference (미소유 참조)미소유 참조는 약한 참조와 유사하지만, optional 값이 아니라, nil로 설정될 수 없습니다.만일 참조하는 객체가 이미 메모리에서 해제된 상태에서 접근하려 하면 runtime error가 발생되며,사용 시점에 객체가 이미 해제되지 않았다고 확신할 수 있는 경우에 사용하여야 합니다.class Country {    var name: String    var capital: City!    init(name: String, capitalName: String) {        self.name = name        self.capital = City(name: capitalName, country: self)    }}class City {    var name: String    unowned var country: Country // 미소유 참조    init(name: String, country: Country) {        self.name = name        self.country = country    }}여기까지가 강의의 내용.실제로 해보기.사이트를 참고하여 코드를 작성하면서 정리를 해보려 한다.Reference Type의 특징class MyClass {    var myInt: Int = 8    deinit {        print(\"this is now deallocated from memory\")    }}MyClass라는 테스트용 클래스를 하나 만들어 주었고,ViewDidload에 다음과 같이 적어주었다.var first: MyClass? = MyClass()var second = firstvar third = first        print(first?.myInt)first?.myInt = 2print(second?.myInt)print(third?.myInt)출력하면 결과는 다음과 같이 나온다.Optional(8) // firstOptional(2) // secondOptional(2) // thirdfirst에서는 myInt가 기존 클래스 값 그대로 8을 유지 했으나.그다음 바로 first의 myInt를 2로 바꾸면서second와 third는 first와 같은 메모리 영역을 참조하고 있기에 값이 바뀌면서 같이 값이 바뀌어 버렸다.breakpoint를 찍어서 확인을 해보면first, second, third 모두 같은 메모리 영역을 사용함을 볼 수 있다.그리고 그 메모리 영역은 MyClass이다.1. nil을 주었을때 변화var first: MyClass? = MyClass()var second = firstvar third = firstfirst = nil // newprint(first)print(second?.myInt)print(third?.myInt)실행을 해보면first는 역시 nil이 되었지만.나머지 second, third는 8을 유지하고 있다.저 메모리 값은MyClass와 같다.first가 nil이 되면서 참조가 first는 메모리에서 해제 되었지만.second, third는 강한 참조이기에 MyClass 메모리에 링크 되어있는걸 볼 수 있다.이게 바로 강한 참조의 가장 큰 문제이다.내가 어떤 변수나 클래스를 더이상 사용하지 않더라도 이렇게 메모리에 남아 누수를 일으킬 수 있다는 것이다.2. 모두 nil을 준다면?메모리에 할당되어있던게 사리진걸 볼 수 있다.순환 참조서로가 서로를 강하게 참조할때 발생.class Person {    var job: Job?        deinit{        print(\"Deallocating Person\")    }}class Job {    var person: Person?        deinit{        print(\"Deallocating Job\")    }}이번엔 위와 같이 클래스를 작성해준다.그리고 ViewDidload에 다음과 같이 작성해주자var joe: Person? = Person()var dev: Job? = Job()        joe?.job = devdev?.person = joe서로가 서로를 참조하는 매커니즘이다.역시 실행을 해보자.서로가 서로를 참조하기에 계속 생성이 된다.그리고 메모리 누수가 발생하는걸 알 수 있다.무한루프 발생.그리고 하나를 nil로 주어도var joe: Person? = Person()var dev: Job? = Job()        joe?.job = devdev?.person = joe        joe = nil //new이렇게 이미 무한 루프에 빠진 dev는 계속 챗바퀴처럼 돌게된다.해결방안1. 약한 참조 (weak)변수 선언 앞에 weak을 붙여 약한 참조로 하는것이다.class Person {    weak var job: Job? //new        deinit{        print(\"Deallocating Person\")    }}class Job {    weak var person: Person?        deinit{        print(\"Deallocating Job\")    }}실행.무한루프가 사라졌다.그리고 joe에 nil을 줘도 아무런 콘솔에 뜨던게 없었는데 약한참조를 하면서 nil을 하니 Person 클래스가 메모리에서 사라진걸 확인 할 수 있다.2. 미소유 참조 (Unowned)약한 참조와 달리 자신이 참조하는 인스턴스가 항상 메모리에 존재할 것이라는 전제를 기반으로한다.  즉 해당 인스턴스가 nil이 아닐것이라는 확신을 가지고 미소유 참조를 사용.      메모리에 해제된 인스턴스에 접근하려하면 런타임 에러가 발생하며 강제종료 된다.  다음과 같이 클래스를 구성하였다.class Person2 {    let name: String        var card: CreditCard?        init(name: String) {        self.name = name    }        deinit { print(\"\\(name) is deinitialized\")}    }class CreditCard {        let number: Int    unowned let owner: Person        init(number: Int, owner: Person) {        self.number = number        self.owner = owner    }        deinit {        print(\"Card \\(number) is deinitailized\")    }}viewDidLoad에 다음과 같이 해주었다.var harold: Person2? = Person2(name: \"harold\")                if let person2: Person2 = harold {            person2.card = CreditCard(number: 1, owner: person2)        }"
  },
  
  {
    "title": "프로젝트 보강계획",
    "url": "/posts/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%B3%B4%EA%B0%95%EA%B3%84%ED%9A%8D/",
    "categories": "캠프, 프로젝트1",
    "tags": "",
    "date": "2024-04-09 11:00:00 +0900",
    





    
    "snippet": "프로젝트가 끝이났다.전반적으로 꽤나 만족스러운 프로젝트였다.이후 내 나름대로의 하고싶은 기능 구현을 위해 프로젝트를 진행했던 팀원분들의 동의를 얻어 나홀로, 해당 프로젝트를 조금 더 발전시키려 한다.물론 디자인은 제외.  판매자 시점의 화면 구현          지금은 유져의 입장에서 만들어진 화면이다. 그렇기에 판매자 시점의 화면이 존재하지 않는다....",
    "content": "프로젝트가 끝이났다.전반적으로 꽤나 만족스러운 프로젝트였다.이후 내 나름대로의 하고싶은 기능 구현을 위해 프로젝트를 진행했던 팀원분들의 동의를 얻어 나홀로, 해당 프로젝트를 조금 더 발전시키려 한다.물론 디자인은 제외.  판매자 시점의 화면 구현          지금은 유져의 입장에서 만들어진 화면이다. 그렇기에 판매자 시점의 화면이 존재하지 않는다.      해당기능을 구현하게되면 지금 있는 마이페이지도 상당수 코드가 바뀔것으로 예상한다.        문의하기를 판매자 실시간 소통방식으로 전환          현재는 alert에 textfield가 추가된 아주 심플한 방식이지만, 문의하기를 누르면 판매자와의 채팅화면이 나오게 해보려 한다. 디자인은 패스        유져가 주문하게되면 판매자에게 전달이가게 구현          해당기능이 어떻게 하면 좋을까 고민을 하게 만드는 기능이다. 다른기능들은 어떻게 진행해야할지 머리속에 존재하지만 해당내용은 현재 뭔가 희미한 느낌이다.              현재 대안은 타이머를 주어 reload를 지속적으로 하게 한다는 것이다.      지금 당장 머리속에 떠오른 아이디어는 이 세가지가 끝이다.중간중간에 틈이 날때마다 해당 기능을 구현하면서의 과정을 적어보려한다."
  },
  
  {
    "title": "프로젝트 KPT",
    "url": "/posts/KPT/",
    "categories": "캠프, 프로젝트1",
    "tags": "",
    "date": "2024-04-08 17:00:00 +0900",
    





    
    "snippet": "KPTKeep : 이번 프로젝트에서 진행한 과정 중 다음 프로젝트에서도 유지했으면 하는 부분.Communication : 팀원들 간의 소통에 어려움 없이, 커뮤니케이션이 진행되었다.Wish List : 각자 자신이 하고 싶은 파트를 맡아서 진행하여 더욱 책임감을 가지고 각자의 파트를 완수하였다.No Trouble : 개인이 바라는 기능에 대한 강한 의...",
    "content": "KPTKeep : 이번 프로젝트에서 진행한 과정 중 다음 프로젝트에서도 유지했으면 하는 부분.Communication : 팀원들 간의 소통에 어려움 없이, 커뮤니케이션이 진행되었다.Wish List : 각자 자신이 하고 싶은 파트를 맡아서 진행하여 더욱 책임감을 가지고 각자의 파트를 완수하였다.No Trouble : 개인이 바라는 기능에 대한 강한 의견 제안보다, 팀 전체 프로젝트 목표를 달성하는 방향을 추구하며 트러블 없이 프로젝트를 완수하였다.Problem문제점 : 이번 프로젝트에서 발생한 문제점을 객관적으로 판단해결 방안 : 해당 문제점을 해결할 수 있는 현실적인 방안 제시다양한 접근 방식에 대한 인지문제점 : 같은 결과를 내기위해 여러가지 구현 방법이 있을 텐데, 다른 방법을 찾아내기 위한 키워드를 알아내기 어려웠다.해결방안 : 결국에는 공부를 통해서 다양한 키워드를 알 수 있도록 해야 함을 느꼈다.Git 협업문제점 : 깃허브를 통한 협업 시 코드컨벤션을 자세하게 작성하지 않아 충돌되는 문제가 발생했다.해결방안 : 기획 단계에서 구체적인 코드컨벤션을 작성하고 프로젝트를 시작해야 한다.Try : 다음 프로젝트를 위해 해야 할 노력Feel : 이번 프로젝트를 통해 느낀 점프로젝트를 진행하며, 나름 디테일하게 생각하고 많은 부분을 앱에 담으려고 노력하고 생각했음에도 불구하고, 다른 팀들의 발표를 보니, 버튼의 색상을 설정하거나, 제품군 안에 한 단계 더 세분화 된 seg를 넣거나, 제품의 색상을 선택하게 하는 등의 놓친 부분이 꽤 많았음을 깨달았다. 다음 프로젝트를 할 때는 좀 더 세세하게 챙겨야겠다는 생각을 했다.충분히 유져 입장에서 생각을 했다고 하였지만, 결과론적으로 다른 조의 프로젝트와 비교했을 때, 조금은 내실이 부족했다 라는 생각이 든다. 화면 구성이나 기능적인 측면에서 좀 더 유져의 입장에서 생각을 해야겠다 라고 반성을 하게 된다.기획 단계에서 지금보다 더 상세한 UI 구성이 필요하고, 가능하다면 협업툴(피그마)을 사용한 협업을 경험해보면 좋을 것 같다.FeedbackFrom Tutor좋다고 하셨던 점 : Kiosk주제에서 Tabbar나 지도 같은 여러 기능구현에 대한 시도가 좋았다.아쉬운 점 : 코드로 ui 구현하다보니 Autolayout 설정에 대한 내용이 너무 반복되었음.상속이나 프로토콜 방식으로 하면 좋을것 같다.권고 : Compositional Layout이 어렵다 안해본 사람들은 앞으로 프로젝트때 사용을 할수 있으니미리 연습을 해둘 것.Bymyself다른조의 발표를 보기전까지 이정도 기능구현이면 잘했다고 생각했다. 물론 지금도 그렇게 생각을 한다.하지만 제품선택의 디테일이 다른조에 비해 조금은 부족했다 라는 생각을 다른조의 발표를 보며 느꼈다.우리작품의 경우는 해당 품목을 단순히 담고 개수 조절에서 끝났다면, 우리와 비슷한 주제를 다룬 다른 조는 제품의 색깔을 선택하게하여 좀 더 넓은 선택지를 유져에게 제공 해주었다.아직도 부족한게 많다라는것을 생각한다.더 유져의 관점에서 생각을 해봐야 할것같다.그리고 다른조에서 JSON을 사용하여 제품 정보를 가져왔다.우리의 경우 DataManager를 통해 미리 배열에 담아 보여지게 끔 했는데 JSON을 사용할것이라고 생각지도 못했다.이부분은 좋은 가르침이 되었다."
  },
  
  {
    "title": "프로젝트 5일차",
    "url": "/posts/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-5%EC%9D%BC%EC%B0%A8/",
    "categories": "캠프, 프로젝트1",
    "tags": "",
    "date": "2024-04-05 11:00:00 +0900",
    





    
    "snippet": "5일차다 처음에는 백지였던 그림이 시간을 지나 점점 뚜렷하게 보이기 시작한다.이젠 크게 중요하진 않으나 있으면 좋을 기능을 구현하려한다.신상표시우선 Model에 신상인지 아닌지를 판별할 Bool Type의 변수를 하나 만든다.struct AppleProduct {        let image: UIImage?    let name: String   ...",
    "content": "5일차다 처음에는 백지였던 그림이 시간을 지나 점점 뚜렷하게 보이기 시작한다.이젠 크게 중요하진 않으나 있으면 좋을 기능을 구현하려한다.신상표시우선 Model에 신상인지 아닌지를 판별할 Bool Type의 변수를 하나 만든다.struct AppleProduct {        let image: UIImage?    let name: String    let price: Int    let category: String    var value: Int     var isNew: Bool // new    }CollectionView내에 새로운 label을 만들었다.코드로 작성된 디자인이기에 그에 맞춰 작성했다.그리고 컬렉션 뷰에 적용해야하므로 다음과 같이 extension으로 기능을 확장해준다.해당 코드는 저번의 ToDoList에서 가져왔다.extension UIView {    func blink() {        self.alpha = 0.7;        UIView.animate(withDuration: 0.5, //Time duration you want,                       delay: 0.0,                       options: [.curveEaseInOut, .autoreverse, .repeat],                       animations: { [weak self] in self?.alpha = 0.0 },                       completion: { [weak self] _ in self?.alpha = 1.0 })    }        func stopBlink() {        layer.removeAllAnimations()        alpha = 1    }}그리고 신상품에 대해서 true로 해주고 컬렉션뷰 셀을 담당하는 코드로 가서func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: Constants.contentName, for: indexPath) as! ProductCell        let product = filteredProducts[indexPath.item]        cell.configure(with: product)        //new        if product.isNew {            cell.newLabel.isHidden = false            cell.newLabel.blink()        } else {            cell.newLabel.isHidden = true        }                return cell    }다음과 같이 설정을 해준다.이렇게 실행하면 처음에는 보여지나 두번째에서는 이펙트 없이 Label만 나오게된다.VC의 생명주기를 이용하여override func viewWillAppear(_ animated: Bool) {        mainCollectionView.reloadData()    }로드를 새로 해준다.완료.하지만 문제점은 셀의 크기는 같지만, 이미지 사이즈가 각각 다르기에 이미지가 Label을 가리는 경우가 생긴다.이부분은 이미지 조절이 필요할듯하다.지도 구현.뭔가 더 특색있게 하는게 낫지 않을까 싶어 지도를 구현한다.코드로 VC를 구현하려다 AutoLayout이 말썽을 일으켜 StoryBoard 로 대체한다.CallCenterVC에 아래와 같이 함수를 하나 만들어준다.func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        if indexPath.row == 0 {            if let mapVC = self.storyboard?.instantiateViewController(identifier: Constants.mapVC) as? MapViewController {                                self.present(mapVC, animated: true)            }        }    }첫번째가 매장찾기이므로 첫번째 해당하는것만 화면전환을 했다.import UIKitimport MapKit // newimport CoreData // newclass MapViewController: UIViewController {    @IBOutlet weak var mapView: MKMapView!        @IBOutlet weak var branchLabel: UILabel!        let coordinates = CLLocationCoordinate2D(        latitude: 37.503702192, longitude: 127.025313873406    )        override func viewDidLoad() {        super.viewDidLoad()        mapView.setRegion(MKCoordinateRegion(center: coordinates, span: MKCoordinateSpan(latitudeDelta: 0.1, longitudeDelta: 0.1)), animated: false)                addBranch()        branchLabel.numberOfLines = 0        branchLabel.text = \"Fine Apple Store 강남점 \\n주소: 서울특별시 강남구 강남대로 🍍🍍🍍\"    }        func addBranch () {        let pin = MKPointAnnotation()        pin.title = \"🍍 Fine Apple Store 강남점\"        pin.subtitle = \"본점\"        pin.coordinate = coordinates        mapView.addAnnotation(pin)    }    }지도를 구현하기 위해선 MapKit은 필수로 불러와야한다.현위치를 사용하지 않기 때문에, GPS값을 가져오는것이 아닌 좌표를 입력하여 위치를 지정하므로 CoreData까지 가져온다.그리과 좌표를 설정해주고.setRegion을 통해 지도에서 어느위치를 보여질지 정하고, MKCoordinateSpan 값이 클수록 지도의 축척이 커진다.(더 넓게 보인다는 의미)가까운 위치를 보여주기위해 0.1씩 주었다.그리고 핀을 추가해주기 위해 addBranch라는 함수를 만들어 주었다.확인 완료.이제 추가할 기능이 뭐가 있나 싶다."
  },
  
  {
    "title": "프로젝트 4일차",
    "url": "/posts/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-4%EC%9D%BC%EC%B0%A8/",
    "categories": "캠프, 프로젝트1",
    "tags": "",
    "date": "2024-04-04 11:00:00 +0900",
    





    
    "snippet": "4일차가 시작이 되었다.이전에 SearchBar를 구현했었기에 오늘은 먼저 해당 기능을 구현하려고 한다.SearchBar 기능구현Component 등록은 생략.의식의 흐름대로 기능을 구현해본다.1. 취소시 text 해제func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {        search...",
    "content": "4일차가 시작이 되었다.이전에 SearchBar를 구현했었기에 오늘은 먼저 해당 기능을 구현하려고 한다.SearchBar 기능구현Component 등록은 생략.의식의 흐름대로 기능을 구현해본다.1. 취소시 text 해제func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {        searchBar.text = \"\"    }완료.2. 엔터를 쳤을때 검색 결과 나타내기func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {    if let input = searchBar.text {        filteredProducts = dataManager.products.filter{$0.name.contains(input)}        mainCollectionView.reloadData()    }        }컬렉션뷰가 가져오는 배열이 filteredProducts이기에 입력값을 포함하는 데이터들을 거기에 담아 보여주게 했다.3. 검색내용을 지웠을때 화면을 첫 세그로func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {        if searchBar.text?.count == 0 {            productSegment.selectedSegmentIndex = 0            filteredProducts = dataManager.products.filter { $0.category == \"맥북\" }            mainCollectionView.reloadData()        }    }입력을 지웠을때 세그와 배열을 초기화 해주었다.세그만 0으로 해서는 안되는 문제였다.4. 기능 발전2번의 내용을 지우고 아래와 같이 발전시켰다.extension ViewController: UISearchBarDelegate {        // 입력 취소시    func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {        searchBar.text = \"\"    }        // 활성화된 키보드에서 검색을 눌렀을때 키보드 사라짐.    func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {        searchBar.endEditing(true)    }        // 검색어의 변화가 있을때    func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {        // 지웠을때        if searchBar.text?.count == 0 {            productSegment.selectedSegmentIndex = 0 // 인덱스 mac으로 되돌리기            filteredProducts = dataManager.products.filter { $0.category == \"맥북\" }            mainCollectionView.reloadData()                    // 타이핑 하고 있을때        } else {            filteredProducts = dataManager.products.filter{$0.name.contains(searchText)}            mainCollectionView.reloadData()        }    }    }테스트테스트 하면서 더 보완을 해야하긴 할것같다.문제(?) 발견Tab Bar를 통해 UI를 구성하면서 VC에서 MyPageVC로의 데이터 전달을 시도하였으나 아무리 시도해도 되지 않았다.그러다 튜터님께 해당문제에 대해 조언을 구하기 위해 여쭤 봤다.새로운 대책 제시튜터님께서 현재 SelectedList가 이렇게 많이 쓰이는것이라면, 싱글톤을 쓰는게 좋다고 하셨다.새로운 깨우침을 얻었다.해당 기능을 구현 해보려한다.싱글톤 방식 채택싱글톤은 추후에 따로 정리하도록 하겠다.처음에는 AppleProduct에 그냥 할까 하다가. 그러면 데이터 입력에 대한 코드가 전부 꼬이기에새롭게 구성했다.class ListManager {        static let shared = ListManager()        var list: [AppleProduct] = []        private init () {}}그리고 selectedList와 관련되어있던 내용을 전부 ListManager.shared.list로 바꿔주었다.하나 더!// MARK: - 장바구니 선택    @IBAction func openCart(_ sender: UIButton) {        let modalVC = self.modalViewController        modalVC.delegate = self               // 사이드 메뉴 뷰 컨트롤러를 자식으로 추가하고 뷰 계층 구조에 추가.        self.addChild(modalVC)        self.view.addSubview(modalVC.view)                let menuWidth = self.view.frame.width // 가로는 현재 화면과 동일하게        let menuHeight = self.view.frame.height * 0.3 // 높이만 30%로 설정                // 사이드 메뉴의 시작 위치를 화면 아래로 설정.        modalVC.view.frame = CGRect(x: 0, y: view.frame.height, width: menuWidth, height: menuHeight)                // 어두운 배경 뷰를 보이게 한다.        self.dimmingView?.isHidden = false        self.dimmingView?.alpha = 0.6                UIView.animate(withDuration: 0.3, animations: {            // 사이드 메뉴를 화면에 표시.            modalVC.view.frame = CGRect(x: 0, y: self.view.frame.height - menuHeight, width: menuWidth, height: menuHeight)            // 어두운 배경 뷰의 투명도를 조절.            self.dimmingView?.alpha = 0.5        })            }장바구니 선택할때 delegate를 통해 전달하던것을 지웠다 이제는 상관없기 때문이다.작동 테스트 완료.이젠 프로토콜 사용했던것들도 전부 날려버리자.그래도 나름 데이터 전송 연습했으니 만족."
  },
  
  {
    "title": "프로젝트 3일차",
    "url": "/posts/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-3%EC%9D%BC%EC%B0%A8/",
    "categories": "캠프, 프로젝트1",
    "tags": "",
    "date": "2024-04-03 11:00:00 +0900",
    





    
    "snippet": "3일차가 시작되었다. 머지 문제가 해결이 되어 새로 프로젝트를 클론하여 시작한다.내가 맡은 기능은 장바구니 기능이다.장바구니 버튼을 클릭했을때 사이드 바처럼 새로운 뷰가 나오게 하는것이다.한번 시작해보도록 하겠다.ModalViewController로 새로운 파일을 하나 만들어 주었고,TableView와 관련된 내용을 전부 옮겨둔 상태이다.우선 해당부분...",
    "content": "3일차가 시작되었다. 머지 문제가 해결이 되어 새로 프로젝트를 클론하여 시작한다.내가 맡은 기능은 장바구니 기능이다.장바구니 버튼을 클릭했을때 사이드 바처럼 새로운 뷰가 나오게 하는것이다.한번 시작해보도록 하겠다.ModalViewController로 새로운 파일을 하나 만들어 주었고,TableView와 관련된 내용을 전부 옮겨둔 상태이다.우선 해당부분에 대한 레이아웃은 후순위로 미루고 SideView처럼 보이게 하는것이 목표이다.1. 클릭시 화면 나타내기.var modalViewController = ModalViewController() // 새로 보여줄 VCvar dimmingView: UIView? // 어둡게 할 배경새로만든 VC와, 그걸 view로 보여줄 객체를 생성해준다.현재 새로만든 VC엔 작동확인을 위해 배경을 검게 해두었다.그리고 다음과 같이 구현했다.@IBAction func openCart(_ sender: UIButton) {                let modalVC = self.modalViewController                // 사이드 메뉴 뷰 컨트롤러를 자식으로 추가하고 뷰 계층 구조에 추가.        self.addChild(modalVC)        self.view.addSubview(modalVC.view)                let menuWidth = self.view.frame.width // 가로는 현재 화면과 동일하게        let menuHeight = self.view.frame.height * 0.3 // 높이만 30%로 설정                // 사이드 메뉴의 시작 위치를 화면 아래로 설정.        modalVC.view.frame = CGRect(x: 0, y: view.frame.height, width: menuWidth, height: menuHeight)                // 어두운 배경 뷰를 보이게 한다.        self.dimmingView?.isHidden = false        self.dimmingView?.alpha = 0                UIView.animate(withDuration: 0.3, animations: {            // 사이드 메뉴를 화면에 표시.            modalVC.view.frame = CGRect(x: 0, y: self.view.frame.height - menuHeight, width: menuWidth, height: menuHeight)            // 어두운 배경 뷰의 투명도를 조절.            self.dimmingView?.alpha = 0.5        })            }버튼을 누르면 아래에서 위로 올라오게 구현은 해두었다.2. 탭했을때 화면 사라지게 구현.현재 화면은 올라오지만 내려가지 않는 상황이다.그리고 어두운 배경인 dimmingView역시 나오지 않는다.dimmingView에 대한 코드를 작성해준다.private func addDimmingView() {                dimmingView = UIView(frame: self.view.bounds)        dimmingView?.backgroundColor = UIColor.black.withAlphaComponent(0.5)        dimmingView?.isHidden = true        view.addSubview(dimmingView!)        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(handleDimmingViewTap))        dimmingView?.addGestureRecognizer(tapGesture)            }    @objc private func handleDimmingViewTap() {    let modalVC = self.modalViewController            UIView.animate(withDuration: 0.3, animations: {            modalVC.view.frame = CGRect(x: 0, y: self.view.frame.height, width: self.view.frame.width, height: self.view.frame.height)            self.dimmingView?.alpha = 0        }) { (finished) in            modalVC.view.removeFromSuperview()            modalVC.removeFromParent()            self.dimmingView?.isHidden = true        }    }그리고 ViewDidload에 adddimmingView를 호출해주자.기능 구현 완료.3. ModalVC에 데이터 전달.가장큰 문제가 남았다.modalVC.selectedList.removeAll()modalVC.selectedList = selectedList이렇게 리스트를 한번 초기화 하고 다시 담아서 전달 하였다.전달이 되는걸 확인했다.4. ModalVC에서 VC로 데이터 전달새로운 뷰에서 값을 전달했을때 값이 변경되어야 하므로 프로토콜을 사용해서 전달하기로 했다.protocol sendList {    func sendData (dataList: [AppleProduct])}를 만들어 주고값이 변화할때마다 델리게이트를 통해 전달하게 했다.@objc func minusValue(sender: UIButton) {        var currentValue = selectedList[sender.tag].value        if let cell = tableView.cellForRow(at: IndexPath(row: sender.tag, section: 0)) as? PriceCell {            if currentValue != 1 {                currentValue -= 1                selectedList[sender.tag].value = currentValue                cell.valueLabel.text = String(currentValue)                self.delegate?.sendData(dataList: selectedList) // new                getData()            } else {                currentValue = 1            }        }            }    @objc func plusValue(sender: UIButton) {        var currentValue = selectedList[sender.tag].value                if let cell = tableView.cellForRow(at: IndexPath(row: sender.tag, section: 0)) as? PriceCell {            currentValue += 1            selectedList[sender.tag].value = currentValue            cell.valueLabel.text = String(currentValue)            self.delegate?.sendData(dataList: selectedList) // new            getData()        }    }    @objc func deleteValue(sender: UIButton) {        selectedList.remove(at: sender.tag)        tableView.reloadData()        self.delegate?.sendData(dataList: selectedList) // new        getData()    }값이 잘 전달되는걸 확인했다.5. 셀 갱신 문제 해결위와 같이 한번 장바구니를 확인하고 뭔가 리스트에 변경이 생겼을때추가한 셀이 보이지 않는 것을 확인했다.처음에는 어디가 문제일까 고민을하다가viewdidload에 프린트를 했는데,한번실행되고 더이상 출력이 되지않는다는걸 알았다.객체화를 해서 실행할때마다 계속 viewdidload가 트리거 되는줄 알았다.그래서 뷰컨트롤러의 생명주기를 참고하여 개선하였다.아래가 바로 생명주기.새로 viewWillAppear에서 시작하므로 해당 메서드를 다음과 같이 새로 작성해주었다.override func viewWillAppear(_ animated: Bool) {        tableView.reloadData()        getData()    }확인 완료.아무리 테스트 용이지만 역시 디자인 소질은 없는듯 하다.6. 추가시 장바구니에 개수 표시 구현하기현재는 그냥 클릭만하면 어떠한 알림 없이 장바구니에 담기게 된다.유저로 하여금 추가했을때 인지하게끔 구현해보자.레이블을 하나 만들어 주었다. 아주 작게!그리고 다음과 같이 함수를 적었다.func setLabel () {                if selectedList.count == 0 {            notiLabel.isHidden = true        } else {            notiLabel.text = String(selectedList.map{$0.value}.reduce(0, +))            notiLabel.isHidden = false        }    }아이템의 변동에 따라 이벤트가 나와야 하므로.override func viewDidLoad() {        super.viewDidLoad()                setupCollectionView()        productSegment.selectedSegmentIndex = 0        segmentValueChanged(productSegment)                numberFormatter.numberStyle = .decimal                // label 디자인        notiLabel.backgroundColor = .red         notiLabel.textColor = .white         notiLabel.layer.masksToBounds = true         notiLabel.layer.cornerRadius = notiLabel.frame.width/2                 addDimmingView()        setLabel() // new    }@objc private func handleDimmingViewTap() {        let modalVC = self.modalViewController                UIView.animate(withDuration: 0.3, animations: {            modalVC.view.frame = CGRect(x: 0, y: self.view.frame.height, width: self.view.frame.width, height: self.view.frame.height)            self.dimmingView?.alpha = 0        }) { (finished) in            modalVC.view.removeFromSuperview()            modalVC.removeFromParent()            self.dimmingView?.isHidden = true            self.setLabel() // new        }            }func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {        selectedList.append(filteredProducts[indexPath.item])                if selectedList.map({$0.name}).filter({$0 == filteredProducts[indexPath.item].name}).count == 2 {            let alert = UIAlertController(title: \"중복 선택 확인\", message: \"중복으로 선택 되었습니다.\", preferredStyle: .alert)            alert.addAction(UIAlertAction(title: \"확인\", style: .cancel))            selectedList.removeLast()                       self.present(alert, animated: true)        }        setLabel() // new    }이렇게 총 3군데에 해당 함수를 적용하게 했다.구현완료."
  },
  
  {
    "title": "프로젝트 2일차",
    "url": "/posts/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-2%EC%9D%BC%EC%B0%A8/",
    "categories": "캠프, 프로젝트1",
    "tags": "",
    "date": "2024-04-02 17:00:00 +0900",
    





    
    "snippet": "이글을 작성할때는 merge 문제가 이미 해결이 되었던 부분이라 사진이 많이 없어서 회상하는 식으로 작성한다.Merge 문제 확인우선 Merge가 안된다고 하여 해당 문제를 해결하려고 한다.역시나 Conflict가 발생했다.문제는 프로젝트 파일이 실행조차 안되었다..xcodeproj 파일을 우클릭 하여 패키지 내용보기를 한다.project.pbxpro...",
    "content": "이글을 작성할때는 merge 문제가 이미 해결이 되었던 부분이라 사진이 많이 없어서 회상하는 식으로 작성한다.Merge 문제 확인우선 Merge가 안된다고 하여 해당 문제를 해결하려고 한다.역시나 Conflict가 발생했다.문제는 프로젝트 파일이 실행조차 안되었다..xcodeproj 파일을 우클릭 하여 패키지 내용보기를 한다.project.pbxproj 파일을 열어 «&lt; Head == »&gt; 부분을 지운다.그리고 프로젝트가 실행이 되는지 확인해본다.프로젝트 파일이 충돌이 발생하는 이유는위치에 새로운 디렉토리가 생기는 즉 내부의 파일이 변동이 되어서 프로젝트 파일을 구성해주는 값이 변화가 생김으로 인한 충돌이다.위의 파일이 바로 그런것을 코드로 구성해주는 파일이다.여기를 구성해주는 파일이라고 보면 될듯하다.무튼 해당 문제를 해결하고 머지하여 다시 repository에 올려두었다.Storyboard역시 내용이 바뀌면 Conflict가 발생하는데, 이부분이 좀 까다로운듯하다.컬렉션 뷰에서 값이 선택되었을때 테이블뷰에 나타내기.컬렉션뷰를 담당하시는 팀원분이 코드를 올려주셨던걸 내려 받아 머징 테스트를 하면서, 본의아니게 해당 기능을 구현 할 수 있게 되었다.처음에는 단순히 이렇게 구현했다.func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {    selectedList.append(filteredProducts[indexPath.item])    tableView.reloadData()    getData()  }기능구현은 잘 되었다.하지만 위의 코드에 대해 예외처리를 하지 않고 단순하게 코드를 작성했다는 것을 알았다.예외처리해당 코드의 예외란 두번 클릭을 하게되면 아래와 같이 똑같은것이 두번 선택이 된다는 것이다.처음에는 수량을 올릴까 하다가 그냥 중복된것이 선택 되었다고 alert를 주는게 좋을 것 같아서 alert를 추가했다.func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {                selectedList.append(filteredProducts[indexPath.item])                if selectedList.map({$0.name}).filter({$0 == filteredProducts[indexPath.item].name}).count == 2 {            let alert = UIAlertController(title: \"중복 선택 확인\", message: \"중복으로 선택 되었습니다.\", preferredStyle: .alert)            alert.addAction(UIAlertAction(title: \"확인\", style: .cancel))            selectedList.removeLast()                        self.present(alert, animated: true)        }        tableView.reloadData()        getData()    }    고차함수를 사용하여, 똑같은 제품명이 2개가 되었을때 즉, 중복된 값이 추가가 되었을때, UIAlertController 객체를 생성하여 경고를 주게하고, 처음에 값을 추가하게 코드가 진행이 되었으므로 중복된 값은 배열의 마지막에 위치함으로 마지막값을 제거하게 하였다.실행 화면은 다음과 같다.숫자 1000단위 씩 끊기.현재 위의 사진에는 이미 처리가 되어있다.어제 해결했는데 깜빡하고 적질 못했다.let numberFormatter = NumberFormatter()override func viewDidLoad() {        super.viewDidLoad()                numberFormatter.numberStyle = .decimal}priceLabel.text = \"\\(numberFormatter.string(from: totalPrice as NSNumber) ?? \"0\") 원\"countLabel.text = \"\\(String(totalCount)) 개\"사용한 코드만 따로 빼두었다.우선 dateFormatter와 비슷하게 숫자도 포맷을 줄수있는 NumberFormatter 객체를 하나 만들고 앱을 시작하자마자 단위를 정하게viewDidload에 decimal을 쓴다고 정해두자.그리고 내가 단위로 쓸 label에 위와 같이 표현을 하면 된다.4000000원 이 아니라 4,000,000원으로 표시된걸 알수 있다."
  },
  
  {
    "title": "챌린지반 과제 (5)",
    "url": "/posts/%EC%B1%8C%EB%A6%B0%EC%A7%80%EB%B0%98-%EA%B3%BC%EC%A0%9C-(5)/",
    "categories": "캠프, 챌린지반 과제",
    "tags": "",
    "date": "2024-04-02 02:00:00 +0900",
    





    
    "snippet": "Token 적용해보기.검색을 하다가 Header를 통해 Token을 적용할 수 있다고 하여 해보려고 한다.되는지 안되는지는 페이징 테스트 여러번 해보면 될것같다.깃 공식사이트에 헤더를 사용하라고 되어있긴한데 어떻게 적용할지 몰라서 검색을 많이 했다.그러다 사이트 를 발견하고 이렇게 헤더를 그냥 쓰면 되겠구나 해서 해보려 한다.let headers: H...",
    "content": "Token 적용해보기.검색을 하다가 Header를 통해 Token을 적용할 수 있다고 하여 해보려고 한다.되는지 안되는지는 페이징 테스트 여러번 해보면 될것같다.깃 공식사이트에 헤더를 사용하라고 되어있긴한데 어떻게 적용할지 몰라서 검색을 많이 했다.그러다 사이트 를 발견하고 이렇게 헤더를 그냥 쓰면 되겠구나 해서 해보려 한다.let headers: HTTPHeaders = [\"Authorization\": \"Bearer Token\"] 하나 만들어 준다.저기 토큰은 각자 알아서.        AF.request(url, method: .get, headers: headers)이런식으로 뒤에 헤더만 더 넣어준다.동작테스트우선은 잘 나온다.헤더가 잘 되는지 토큰값을 변경하고 테스트를 해본다.바로 에러가난다.다시 토큰값을 원복시키고 실행 하니 잘 된다.즉 헤더가 제대로 먹힌다는 것이다.endpage 일때 페이징 멈추기func addPage () {        let currentCount = repoList.count        if hasNext {            currentPage += 1            gitManager.fetchRequestAppleRepo(page: currentPage, hasNext: hasNext)            isLoadingPage = false                        if currentCount &gt; 290 { // 전체 로딩개수가 기준을 넘어가면 false                hasNext = false            }        }    }현재는 290개 일때 멈추게 되어있다.이건 repository의 개수를 알기에 강제로 세팅이 가능했다.func addPage () {        let currentCount = repoList.count        if isHasNext {            currentPage += 1            gitManager.fetchRequestAppleRepo(page: currentPage, hasNext: isHasNext)            isLoadingPage = false                        if currentCount &gt; 290 { // 전체 로딩개수가 기준을 넘어가면 false                isHasNext = false            }        }    }이젠 알아서 boolean값을 바꾸게 한번 해보자.if !decodedData.isEmpty {                        do {                            for data in decodedData {                                let list = GitRepoModel(name: data.name, html_url: data.html_url, language: data.language)                                self.repoLists.append(list)                            }                            self.delegate?.sendRepo(data: self.repoLists)                        }                    } else {                                            }우선 값을 받아올때 더이상 페이지를 가져오지않는 페이지에 도달했을때의 조건을 주기위해 isEmpty를 사용했다.protocol SendProfile {    func sendData (data: [GitModel])    func sendRepo (data: [GitRepoModel])    func sendNext (hasNext: Bool)}그리고 프로토콜에 하나 더 전달하기위해 sendNext를 사용했다.func fetchRequestAppleRepo (page: Int, hasNext: Bool) {                if hasNext {            let appleURL = \"https://api.github.com/users/apple/repos?page=\"                        AF.request(appleURL+String(page), method: .get, headers: header).responseDecodable(of: [GitRepoModel].self            ) { response in                switch response.result {                case .success(let decodedData) :                    if !decodedData.isEmpty {                        do {                            for data in decodedData {                                let list = GitRepoModel(name: data.name, html_url: data.html_url, language: data.language)                                self.repoLists.append(list)                            }                            self.delegate?.sendRepo(data: self.repoLists)                            self.delegate?.sendNext(hasNext: true)                        }                    } else {                        self.delegate?.sendNext(hasNext: false)                    }                case .failure(let error) :                    print(error.localizedDescription)                }            }        }    }그리고 다음과 같이 delegate를 통해 전달하게 하고,func sendNext(hasNext: Bool) {        isHasNext = hasNext    }위와 같은 함수를 통해 받게하였다.하지만 문제는 한번더 내려줬을때 빈배열을 확인하고 더이상 로드를 하지않게 하는것이라서 근본적인 문제 해결은 아니었다.func fetchRequestAppleRepo (page: Int, hasNext: Bool) {                if hasNext {            let appleURL = \"https://api.github.com/users/apple/repos?page=\"                        AF.request(appleURL+String(page), method: .get, headers: header).responseDecodable(of: [GitRepoModel].self            ) { response in                switch response.result {                case .success(let decodedData) :                    if !decodedData.isEmpty {                        if decodedData.count == 30 {                            do {                                for data in decodedData {                                    let list = GitRepoModel(name: data.name, html_url: data.html_url, language: data.language)                                    self.repoLists.append(list)                                }                                self.delegate?.sendRepo(data: self.repoLists)                                self.delegate?.sendNext(hasNext: true)                            }                        } else {                            do { // 30개가 아닐때                                for data in decodedData {                                    let list = GitRepoModel(name: data.name, html_url: data.html_url, language: data.language)                                    self.repoLists.append(list)                                }                                self.delegate?.sendRepo(data: self.repoLists)                                self.delegate?.sendNext(hasNext: false)                            }                        }                    } else {                        self.delegate?.sendNext(hasNext: false)                    }                case .failure(let error) :                    print(error.localizedDescription)                }            }        }    }그래서 한페이지 당 30개의 값을 가져오기에, 마지막이 30개가 아닐때로 한번더 세분화를 해주었다.더이상 로드를 하지 않게 되었다.해결"
  },
  
  {
    "title": "프로젝트 1일차",
    "url": "/posts/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-1%EC%9D%BC%EC%B0%A8/",
    "categories": "캠프, 프로젝트1",
    "tags": "",
    "date": "2024-04-01 20:10:00 +0900",
    





    
    "snippet": "프로젝트가 시작되었다.내가 담당하는건 TableView이다.CollectionView에서 이미지를 선택하는 이벤트가 발생했을때, 처리를 하는게 내가 할 역할이다.코드는 아래와 같다.중간중간 기능을 구현하면서 작성하지 않아서 코드내 주석으로 대신한다.import UIKitclass ViewController: UIViewController {      ...",
    "content": "프로젝트가 시작되었다.내가 담당하는건 TableView이다.CollectionView에서 이미지를 선택하는 이벤트가 발생했을때, 처리를 하는게 내가 할 역할이다.코드는 아래와 같다.중간중간 기능을 구현하면서 작성하지 않아서 코드내 주석으로 대신한다.import UIKitclass ViewController: UIViewController {            @IBOutlet weak var tableView: UITableView!        @IBOutlet weak var countLabel: UILabel!        @IBOutlet weak var priceLabel: UILabel!        var selectedList: [AppleProduct] = [AppleProduct]()            var totalCount = 0    var totalPrice = 0            override func viewDidLoad() {        super.viewDidLoad()                tableView.rowHeight = 75        tableView.delegate = self        tableView.dataSource = self        tableView.register(UINib(nibName: Constants.cellName, bundle: nil), forCellReuseIdentifier: Constants.cellName)                tableView.reloadData()    }        func getData() { // 전체 값, 개수를 적용.                totalCount = selectedList.map{$0.value}.reduce(0, +)        totalPrice = selectedList.map{Int($0.value * $0.price)}.reduce(0, +)                priceLabel.text = \"\\(String(totalPrice)) 원\"        countLabel.text = \"\\(String(totalCount)) 개\"    }    }extension ViewController: UITableViewDelegate, UITableViewDataSource {        func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {                return selectedList.count    }        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {                let currentLocation = indexPath.row                guard let cell = tableView.dequeueReusableCell(withIdentifier: Constants.cellName, for: indexPath) as? PriceCell else { return UITableViewCell()        }                cell.selectionStyle = .none // 선택 안되게        cell.titleLabel.text = selectedList[currentLocation].name        cell.itemImage.image = selectedList[currentLocation].image        cell.priceLabel.text = String(selectedList[currentLocation].price)        cell.valueLabel.text = String(selectedList[currentLocation].value)                // Tag를 부여        cell.minusBtn.tag = currentLocation        cell.plusBtn.tag = currentLocation        cell.deleteBtn.tag = currentLocation                cell.minusBtn.addTarget(self, action: #selector(minusValue), for: .touchUpInside)        cell.plusBtn.addTarget(self, action: #selector(plusValue), for: .touchUpInside)        cell.deleteBtn.addTarget(self, action: #selector(deleteValue), for: .touchUpInside)                return cell    }        @objc func minusValue(sender: UIButton) {        var currentValue = selectedList[sender.tag].value        if let cell = tableView.cellForRow(at: IndexPath(row: sender.tag, section: 0)) as? PriceCell {            if currentValue != 1 { // 1 아래로 떨어지면 안되므로                currentValue -= 1                selectedList[sender.tag].value = currentValue                cell.valueLabel.text = String(currentValue)                getData()            } else {                currentValue = 1 //1 을 유지            }        }            }        @objc func plusValue(sender: UIButton) {        var currentValue = selectedList[sender.tag].value                if let cell = tableView.cellForRow(at: IndexPath(row: sender.tag, section: 0)) as? PriceCell {                        currentValue += 1            selectedList[sender.tag].value = currentValue            cell.valueLabel.text = String(currentValue)                        getData()        }    }        @objc func deleteValue(sender: UIButton) {            selectedList.remove(at: sender.tag)        tableView.reloadData()        getData()            }}기술 면접 후기현재 내가 알고 있는 지식에 2뎁스 정도 더 생각해서 확장시켜서 생각해두면 좋다고 하셨다.그리고 대답을할때 간결하게 하자.간결하게 하려고하는데 머리속에있는걸 그대로 이야기 하다보니 길어진듯하다."
  },
  
  {
    "title": "챌린지반 과제 (4)",
    "url": "/posts/%EC%B1%8C%EB%A6%B0%EC%A7%80%EB%B0%98-%EA%B3%BC%EC%A0%9C-(4)/",
    "categories": "캠프, 챌린지반 과제",
    "tags": "",
    "date": "2024-04-01 08:50:00 +0900",
    





    
    "snippet": "계속 해보려고한다.저번에 스크롤을 내릴때 페이지를 1증가하게 하여 값을 가져오게 하려고 했는데 한번에 페이지수가 급증을 하는것 같아 스크롤을 내릴때 로딩페이지를 만들어 api 트래픽도 관리를 하는게 좋아보인다.로딩 셀 만들기.CustomCell을 하나 더 만들어주고 LoadingCell이라고 이름을 짓는다.여기엔 UIActivityIndicatorVi...",
    "content": "계속 해보려고한다.저번에 스크롤을 내릴때 페이지를 1증가하게 하여 값을 가져오게 하려고 했는데 한번에 페이지수가 급증을 하는것 같아 스크롤을 내릴때 로딩페이지를 만들어 api 트래픽도 관리를 하는게 좋아보인다.로딩 셀 만들기.CustomCell을 하나 더 만들어주고 LoadingCell이라고 이름을 짓는다.여기엔 UIActivityIndicatorView라고 하여, pull to refresh처럼 로딩액션이 뜨게 한다.사이트 참고 하여 만들어 본다.func numberOfSections(in tableView: UITableView) -&gt; Int {        return 2    }로딩셀을 표시하기위해 섹션을 하나 더만들어 주고,func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {                if section == 0 {                        return repoList.count                    } else if section == 1 {                        return 1        }                return 0    }일단은 섹션이값이 0일땐 repository값을 가져오게 하였다.func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        if indexPath.section == 0 {                        guard let cell = tableView.dequeueReusableCell(withIdentifier: Constants.identifier, for: indexPath) as? RepoTableViewCell else { return UITableViewCell() }                        cell.repoLabel.text = repoList[indexPath.row].name            cell.languageLabel.text = repoList[indexPath.row].language            cell.selectionStyle = .none            print(indexPath)            return cell        } else {            guard let cell = tableView.dequeueReusableCell(withIdentifier: Constants.secondCellName, for: indexPath) as? LoadingCell else {                return UITableViewCell()            }            cell.start()            print(indexPath)                        return cell        }    }그리고 새로 추가한 셀을 section값이 0일때 1일때 구분하여 1일때는 로딩화면이 나오는 셀을 나오게 한다.실행화면로딩시 값 가져오기.여러 참고 사이트를 보다보니 처음에는 어떻게 해야할지 뭔가 감이 안섰는데, 오늘은 감이 좀 오기 시작하는 듯 하다.어제 테스트를 바탕으로 무지성으로 1씩 증가를 하면 안되겠다라는 생각이 든다.저 로딩화면은 DispatchQueue.main.aysncAffer를 통해 약간의 시간적인 딜레이를 주면 될것같고,내가 해당 페이지를 가져올지 안가져올 지는 boolean값을 주어 로딩할지 안할지에 대해서 정하면 될듯하다.var isLoadingPage: Bool = false 하나 만들어 주었다.페이지를 로딩 할지 안할지 이다.함수도 수정해준다.func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {                if section == 0 {                        return repoList.count                    } else if section == 1 &amp;&amp; isLoadingPage { //new                        return 1        }                return 0    }그리고 스크롤을 내릴때 true로 일단 해보았다.func scrollViewDidScroll(_ scrollView: UIScrollView) {        let offsetY = scrollView.contentOffset.y        let contentHeight = scrollView.contentSize.height        let height = scrollView.frame.height                // 스크롤이 테이블 뷰 Offset의 끝에 가게 되면 다음 페이지를 호출        if offsetY &gt; (contentHeight - height) {            isLoadingPage = true        }    }작동하지 않았다. 이상태에서는 섹션이 하나 더 추가되지 않는다.하나 더 만들어 주기위해 함수를 하나 더 만들어 준다.func loadPage () {        isLoadingPage = true                // Section 1을 reload하여 로딩 셀을 보여줌 (페이징 진행 중인 것을 확인할 수 있도록)        DispatchQueue.main.async {            self.tableView.reloadSections(IndexSet(integer: 1), with: .none)        }                // 페이징 메소드 호출        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {            print(\"loaded\")        }    }로딩셀이 나오는 걸 확인했다.loaded 자리에 값을 가져오는 함수 구현이제 저 출력한 자리에 값을 가져오게하는 함수를 구현하면 된다.func addPage () {                currentPage += 1        gitManager.fetchRequestAppleRepo(page: currentPage)        isLoadingPage = false            }addPage라는 함수를 만들고 호출될떄마다 1씩 증가하게 하였다.작동해보니 잘된다.하지만 마지막페이지에 대한 인식이 없기에 마지막일땐 더이상 안가져오게 해야하는 기능을 구현해야 할듯 하다.물론 지금도 마지막엔 값을 가져오지 않긴 하지만 무의미한 api 접속을 방지 하려 한다.전체 갯수를 알때 더이상 로드 방지func addPage () {           let currentCount = repoList.count                if hasNext {            currentPage += 1            gitManager.fetchRequestAppleRepo(page: currentPage, hasNext: hasNext)            isLoadingPage = false            if currentCount &gt; 290 {            hasNext = false        }        }    }hasNext 변수를 하나 만들고 290개가 넘어갔을때 false를 주어 더이상 로드를 못하게 하였다.우선 기본 구성은 다 한듯하고 다음글에서는 token을 적용하는걸 적어봐야겠다.시간 리미트가 너무 빡세서 테스트가 어렵다."
  },
  
  {
    "title": "챌린지반 과제 (3)",
    "url": "/posts/%EC%B1%8C%EB%A6%B0%EC%A7%80%EB%B0%98-%EA%B3%BC%EC%A0%9C-(3)/",
    "categories": "캠프, 챌린지반 과제",
    "tags": "",
    "date": "2024-03-31 09:50:00 +0900",
    





    
    "snippet": "StoryBoard 파일 제거StoryBoard 파일 제거.네모로 표시한부분 삭제.      Targets→Info        Info.plist  SceneDelegate.swift 파일에 다음과 같이 추가.func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options con...",
    "content": "StoryBoard 파일 제거StoryBoard 파일 제거.네모로 표시한부분 삭제.      Targets→Info        Info.plist  SceneDelegate.swift 파일에 다음과 같이 추가.func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {        guard let windowScene = (scene as? UIWindowScene) else { return }                window = UIWindow(frame: UIScreen.main.bounds)                window?.windowScene = windowScene                window?.rootViewController = ViewController()                window?.makeKeyAndVisible()    }cell language 표시다시 비교하던중 language가 없어서 추가한다.struct GitRepoModel: Codable {        var name: String // repo이름    var html_url: String // url주소    var language: String? // repo사용된 언어 New!}func fetchRequestRepo () {        AF.request(url+\"/repos\", method: .get).responseDecodable(of: [GitRepoModel].self        ) { response in                        self.repoLists.removeAll()            switch response.result {            case .success(let decodedData) :                do {                    for data in decodedData {                        let list = GitRepoModel(name: data.name, html_url: data.html_url, language: data.language)                        self.repoLists.append(list)                    }                    self.delegate?.sendRepo(data: self.repoLists)                }            case .failure(let error) :                print(error.localizedDescription)            }        }    }label이 하나 더 필요하게 되어 CustomCell을 만들었다.class RepoTableViewCell: UITableViewCell {        @IBOutlet weak var repoLabel: UILabel!        @IBOutlet weak var languageLabel: UILabel!        override func awakeFromNib() {        super.awakeFromNib()        // Initialization code    }    override func setSelected(_ selected: Bool, animated: Bool) {        super.setSelected(selected, animated: animated)        // Configure the view for the selected state    }    }디자인은 생략.Apple Repository 추가로 가져오기.func fetchRequestAppleRepo () {                let appleURL = \"https://api.github.com/users/apple\"                AF.request(appleURL+\"/repos\", method: .get).responseDecodable(of: [GitRepoModel].self        ) { response in            switch response.result {            case .success(let decodedData) :                do {                    for data in decodedData {                        let list = GitRepoModel(name: data.name, html_url: data.html_url, language: data.language)                        self.repoLists.append(list)                    }                    self.delegate?.sendRepo(data: self.repoLists)                }            case .failure(let error) :                print(error.localizedDescription)            }        }    }함수만 하나 더 만들어주었다.테스트 해보니 잘된다.TableView Paging페이징기능은 우리가 아는 1, 2, 3, 4 이런식으로 게시판의 페이지 개념이 아니라,셀이 몇개 되었을때 추가적으로 로딩하여 더 많은 셀을 보여주는 그런 기능이다.생각보다 자료도 많이 없어서 하나하나 step by step으로 적어보려고 한다.순서는 그냥 내방식대로 한다.1. 스크롤 내렸을때 제대로 작동하는지 확인참고여러 자료를 참고하지만 왜 이렇게 해야하는지에 대한설명은 위에 나와있다.func scrollViewDidScroll(_ scrollView: UIScrollView) {        let offsetY = scrollView.contentOffset.y        let contentHeight = scrollView.contentSize.height        let height = scrollView.frame.height                // 스크롤이 테이블 뷰 Offset의 끝에 가게 되면 다음 페이지를 호출        if offsetY &gt; (contentHeight - height) {            print(\"scroll\")        }    }작동하면 scroll이 출력이 되는걸 알 수 있다.2. 애플 repository에서 몇개의 값을 가져오는지 확인print를 찍어서 확인해보니 42가 나오는데, 현재 내가 가지고있는 repo가 12개니 30개만 받아오는걸 알 수 있다.실제로 내가 구현한 링크를 들어가보니 딱 30개만 나오는걸 알수있다. 아마 페이지 화 되어있는듯 하다.우선 이걸 먼저 해결해야할것같아 Docs를 찾아본다.Docs를 보다가 힌트를 얻어서 주소에 입력해보았다.잘나오는걸 확인했다.https://api.github.com/users/apple/repos?page=1 이렇게 사용해야했다.여태 계속 repos에서 끝냈는데 그게 잘못된 방식이었다.테스트하다가 갑자기 값을 못받아오길래 확인해보니 시간당 한도가 초과된것같다…오늘은 여기까지."
  },
  
  {
    "title": "챌린지반 과제 (2)",
    "url": "/posts/%EC%B1%8C%EB%A6%B0%EC%A7%80%EB%B0%98-%EA%B3%BC%EC%A0%9C-(2)/",
    "categories": "캠프, 챌린지반 과제",
    "tags": "",
    "date": "2024-03-31 06:50:00 +0900",
    





    
    "snippet": "Repository 내용 TableView에 업로드하기func fetchRequestRepo () {        AF.request(url+\"/repos\", method: .get, parameters: repoParameter).responseDecodable(of: GitRepoModel.self        ) { response in     ...",
    "content": "Repository 내용 TableView에 업로드하기func fetchRequestRepo () {        AF.request(url+\"/repos\", method: .get, parameters: repoParameter).responseDecodable(of: GitRepoModel.self        ) { response in            switch response.result {            case .success(let data) :                do {                    self.delegate?.sendRepo(data: [data])                    print(data)                } catch {                    print(error.localizedDescription)                }            case .failure(let error) :                print(error.localizedDescription)            }        }    }처음에는 이전에 했던 방식 그대로 해보았다.하지만 에러가 발생했고 주석으로 바꾸고 response가 제대로 출력이 되나 찍어보니 거기서부터 문제였다.에러는 다음과 같다failure(Alamofire.AFError.responseSerializationFailed(reason: Alamofire.AFError.ResponseSerializationFailureReason.decodingFailed(error: Swift.DecodingError.typeMismatch(Swift.Dictionary&lt;Swift.String, Any&gt;, Swift.DecodingError.Context(codingPath: [], debugDescription: \"Expected to decode Dictionary&lt;String, Any&gt; but found an array instead.\", underlyingError: nil)))))딕셔너리로 담아야할걸 배열에 담아서 생긴 문제로 보인다.참고자료에 나와 같은 증상의 질문이 있었고 바로 어디가 잘못된지 알았다.func fetchRequestRepo () {        AF.request(url+\"/repos\", method: .get, parameters: repoParameter).responseDecodable(of: [GitRepoModel].self        ) { response in                        switch response.result {            case .success(let data) :                do {                    self.delegate?.sendRepo(data: data)                } catch {                    print(error.localizedDescription)                }            case .failure(let error) :                print(error.localizedDescription)            }        }    }error와 data를 나눠 주고, 전달을 해보았다.잘된다.Cell 터치했을때 관련 Repository로 이동하기사이트를 참고했다.구현하는것은 크게 어렵지 않았다.func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        if let url = URL(string: repoList[indexPath.row].html_url) {            UIApplication.shared.open(url)        }    }실행화면pull to Refresh 구현하기override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.        tableView.delegate = self        tableView.dataSource = self        gitManager.delegate = self                activateConstraints()        gitManager.fetchRequest()        gitManager.fetchRequestRepo()        tableView.refreshControl = UIRefreshControl() //new        tableView.refreshControl?.addTarget(self, action: #selector(didPullToRefresh), for: .valueChanged) //new            }@objc func didPullToRefresh() {        gitManager.fetchRequestRepo()        DispatchQueue.main.asyncAfter(deadline: .now()+1) {            self.tableView.refreshControl?.endRefreshing()            self.tableView.reloadData()        }    } 리프레시 할때 함수를 다시 호출하게 하였다.레포지토리를 만들고 테스트를 했는데, 등록하고 바로 되는게 아니라 조금 시간이 지나고 가져오는걸 확인했다."
  },
  
  {
    "title": "챌린지반 과제 (1)",
    "url": "/posts/%EC%B1%8C%EB%A6%B0%EC%A7%80%EB%B0%98-%EA%B3%BC%EC%A0%9C-(1)/",
    "categories": "캠프, 챌린지반 과제",
    "tags": "",
    "date": "2024-03-30 15:00:00 +0900",
    





    
    "snippet": "과제소개본인의 깃허브 프로필 페이지를 만들어주세요.화면 상단에는 프로필 상세 정보가 출력되고 아래는 Repository 목록이 출력되는 앱을 만들어주세요.Repository 목록은 페이징처리를 위하여 본인 Repository를 가져온 후 apple 의 Repository를 붙여주세요.https://docs.github.com/en/rest/users?...",
    "content": "과제소개본인의 깃허브 프로필 페이지를 만들어주세요.화면 상단에는 프로필 상세 정보가 출력되고 아래는 Repository 목록이 출력되는 앱을 만들어주세요.Repository 목록은 페이징처리를 위하여 본인 Repository를 가져온 후 apple 의 Repository를 붙여주세요.https://docs.github.com/en/rest/users?apiVersion=2022-11-28 API를 참고하세요.요구사항  iOS 15이상  Swift 5이상  README를 작성해주세요.  git을 사용해주세요.  가능하다면 MVC 아키텍처를 사용해주세요.          기본 iOS에서 제공하는 ViewController를 사용하면 됩니다.        오픈소스 라이브러리는 아래의 룰을 따라주세요.          필수 사용                  Alamofire          KingFisher or SDWebImage                    ❌ 아래의 라이브러리는 사용하지 마세요                  RxSwift ,RxCocoa, Rx…          Moya          SnapKit                    그 외의 라이브러리는 사용하셔도 됩니다.   단 사용하시면 나중에 이유를 설명할 수 있어야 합니다.        Pull To Refresh 기능 구현해주세요.  다음 페이지 스크롤링 가능하게 해주세요.(페이징처리)  상단의 User profile의 디자인은 Code로 작성해주세요.  하단의 Repository 디자인은 Interface Builder(Storyboard or Xib) 로 작성해주세요.  TableView나 CollectionView를 사용해주세요.          Delegate, DataSource를 사용해주세요.        디자인은 과제채점에 영향을 주지 않습니다.샘플 이미지 와 레퍼런스      샘플 이미지        레퍼런스 : Github iOS 앱의 Profile 탭  AutoLayout Design위의 예시와 같이 디자인을 하기 위해 기존에는 StoryBoard를 사용하여 디자인을 했지만 과감히 버리고 코드로 디자인을 해보려고 한다.실행화면은 다음과 같다.확실히 저번 과제때 해봐서그런가, 익숙했다.Git API 테스트Git API 가 어떻게 값을 가져오는지 확인을 해보려고 한다.인터넷으로 어떻게 값을 가져와야할지 찾아보다가 해당사이트를 통해서 어떻게 값을 가져와야할지 알게 되었다.하지만 위의 사진으로는 repository까지는 나오지 않는다.뒤에 repos를 붙이니 원하는 정보가 다 나오는것같다.즉 fetchRequest가 두개가 필요해 보인다.이렇게 api 테스트가 끝이 났다.Alamofire 사용해보기Alamofire사이트를 들어가보니 SwiftPackage도 가능하고 Pod도 가능한데 저번 과제때는 SwiftPackage를 썼으니 이번엔 CocoaPods을 사용해보려 한다.생성과정은 생략.1. Model 생성api test를 바탕으로 어떻게 parameters들이 나오는지 확인을 했으니 그에 맞게 변수를 만들어 주었다.import Foundationstruct GitModel {        var login : String // id    var avatar_url : String // profile image url    var location : String // 지역    var followers : Int // 팔로워 수    var following : Int // 팔로잉 수    }2. fetchRequest 함수 만들기함수를 다음과 같이 Docs를 보고 만들었다.    func fetchRequest () {                AF.request(url).response { response in                       debugPrint(response)        }            }그리고 viewcontroller에 테스트용으로 gitManager.fetchRequest()를 사용하여 출력이 되는지, 즉 통신이 제대로 이루어 지는지 테스트를 해보았다.더 있지만 일부만 캡쳐한다. 우선 출력이 되는걸로 보아 잘 나오는 듯하다.responseJSON이 곧 사라질 기능이라 참고 사이트를 통해 responseDecodable을 사용했다.let parameter = [GitModel]()        func fetchRequest () {                AF.request(url, method: .get, parameters: parameter).responseDecodable(of: GitModel.self        ) { response in            print(response)        }    }print를 해보면이렇게 전달이 잘 되는걸 알 수 있다.import Foundationimport Alamofireprotocol SendProfile {    func sendData (data: [GitModel])}class GitManager {        var delegate : SendProfile?        let url = \"https://api.github.com/users/haroldfromk\"        let parameter = [GitModel]()        func fetchRequest () {                AF.request(url, method: .get, parameters: parameter).responseDecodable(of: GitModel.self        ) { response in                       switch response.result {            case .success(let data) :                do {                    self.delegate?.sendData(data: [data])                } catch {                    print(error.localizedDescription)                }            case .failure(let error) :                print(error.localizedDescription)            }        }    }    }extension ViewController: SendProfile {    func sendData(data: [GitModel]) {        gitList = data        DispatchQueue.main.async {            //profileImageView.image = gitList[0].avatar_url            self.idLabel.text = self.gitList[0].login            self.regionLabel.text = self.gitList[0].location            self.followerLabel.text = String(self.gitList[0].followers)            self.followingLabel.text = String(self.gitList[0].following)        }    }}이렇게 delegate를 통해 전달하게 했다.잘 나온다.이제 이미지를 사용해야하는데 url주소이기에 다른 방법을 사용해야한다.KingFisher 사용이제 다른 조건인 KingFisher라이브러리 사용을 해보자.사이트를 참고하여 설치를 해보자.설치후 사용법은 간단하다.위의 주석을 달았던 부분을 아래와 같이 작성한다.self.profileImageView.kf.setImage(with: URL(string: self.gitList[0].avatar_url))작동 확인 완료."
  },
  
  {
    "title": "3주차 과제 (10)",
    "url": "/posts/3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(10)/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-29 11:13:00 +0900",
    





    
    "snippet": "Lv.41. 소팅 중인상태에서 DB에 변화가있을때 처리지금은 소팅중인상태에서 (ex: segcontrol이 완료일때) 값의 변화가 있으면완료가 눌러진 상태에서 전체화면이 나온다.그것을 수정하기 위해서 전체로 선택되게 돌리는것이 최선이라고 생각을 했다.우선 다음과같이 함수로 만들어 주었다.func backTotal () {        segmentVi...",
    "content": "Lv.41. 소팅 중인상태에서 DB에 변화가있을때 처리지금은 소팅중인상태에서 (ex: segcontrol이 완료일때) 값의 변화가 있으면완료가 눌러진 상태에서 전체화면이 나온다.그것을 수정하기 위해서 전체로 선택되게 돌리는것이 최선이라고 생각을 했다.우선 다음과같이 함수로 만들어 주었다.func backTotal () {        segmentView.selectedSegmentIndex = 0        todayBtn.isSelected = false        totalBtn.isSelected = true    }현재 segcontrol = 0 이 전체인 상태이다.나머지는 버튼이다.이걸 DB의 변화를 주는곳에 추가해주었다.테스트 해보니 잘된다.이렇게 하는게 현재 내가 할수있는 최선인듯하다.2. 코드 리팩토링 및 변수이름 재조정.DBManager에 하나로 정리하면 될걸 의미없이 몇개로 나누었다고 판단하여최대한 CRUD에 맞게 하려고 조정했다.protocol sendLists {    func sendDB (data : [ToDoModel])}import Foundationimport FirebaseFirestoreclass DBManager {        var dbModel = DBModel()    var delegate : sendLists?    let dateFormat = DateFormatter()        // MARK: - id 최댓값을 가져온다.    func getID () -&gt; Int {                if dbModel.lists.count != 0 {            return self.dbModel.lists[dbModel.lists.count-1].id + 1        } else {            return 0        }            }        // MARK: - Create: DB 추가        func addDB (textfield : String ) {                dateFormat.dateFormat = Constants.dateFormat        dbModel.db.collection(Constants.collectionName).addDocument(data: [Constants.DataBase.dbID: self.getID()                                                                           , Constants.DataBase.dbTitle: textfield                                                                           , Constants.DataBase.dbIsComplete: false, Constants.DataBase.dbIsFavorite: false                                                                           , Constants.DataBase.dbImageTitle: \"https://firebasestorage.googleapis.com/v0/b/todolist-1a790.appspot.com/o/O9IY1C0.jpg?alt=media&amp;token=7e07e023-daf8-422d-a4ce-cdf43137e9cd\"                                                                           , Constants.DataBase.dbDate: dateFormat.string(from: Date())]) { (error) in            if let e = error { // DB에 업로드중 에러 발생시                print(\"error : \\(e.localizedDescription)\")            } else { // 업로드가 성공하면 콘솔로 알려준다.                print(\"Upload Done\")            }        }    }        // MARK: - Read: 조건없이 DB로부터 값을 가져온다.    func getData () {                dbModel.db.collection(Constants.collectionName).order(by: Constants.DataBase.dbID)            .addSnapshotListener { (querySnapshot, error) in                                self.dbModel.lists = []                                if let e = error {                    print(\"error : \\(e)\")                } else {                    if let snapshotDocuments = querySnapshot?.documents {                        for doc in snapshotDocuments {                            let data = doc.data()                            if let listId = data[Constants.DataBase.dbID] as? Int                                , let listTitle = data[Constants.DataBase.dbTitle] as? String                                , let listBool = data[Constants.DataBase.dbIsComplete] as? Bool                                , let listFav = data[Constants.DataBase.dbIsFavorite] as? Bool                                , let listImage = data[Constants.DataBase.dbImageTitle] as? String,                               let listDate = data[Constants.DataBase.dbDate] as? String {                                                                let list = ToDoModel(id: listId, title: listTitle, isComplete: listBool, isFav: listFav, imageTitle: listImage, date: listDate)                                self.dbModel.lists.append(list)                                self.delegate?.sendDB(data: self.dbModel.lists)                            }                                                    }                    }                }            }    }        // MARK: - Read: 특정 조건에 해당하는 db가져오기 (싱글쿼리)    func getSpecificData(whereCondition : String, condition : Any) {                dbModel.db.collection(Constants.collectionName).whereField(whereCondition, isEqualTo: condition).order(by: Constants.DataBase.dbID).getDocuments { (querySnapshot, error) in                        self.dbModel.lists = []                        if let e = error {                print(e)            } else {                                if let snapshotDocuments = querySnapshot?.documents {                    if snapshotDocuments != [] {                        for doc in snapshotDocuments {                            let data = doc.data()                            if let listId = data[Constants.DataBase.dbID] as? Int                                , let listTitle = data[Constants.DataBase.dbTitle] as? String                                , let listBool = data[Constants.DataBase.dbIsComplete] as? Bool                                , let listFav = data[Constants.DataBase.dbIsFavorite] as? Bool                                ,let listImage = data[Constants.DataBase.dbImageTitle] as? String                                , let listDate = data[Constants.DataBase.dbDate] as? String {                                                                let list = ToDoModel(id: listId, title: listTitle, isComplete: listBool, isFav: listFav, imageTitle: listImage, date: listDate)                                                                self.dbModel.lists.append(list)                                self.delegate?.sendDB(data: self.dbModel.lists)                                                            }                                                    }                    } else {                        self.dbModel.lists = []                        self.delegate?.sendDB(data: self.dbModel.lists)                    }                }            }        }    }        // MARK: - Read: 여러 조건의값 가져오기 (다중쿼리)    func getMultiQueryData(whereCondition : String, condition : Any, anotherWhereCondition : String, anotherCondtion:Any) {                dbModel.db.collection(Constants.collectionName).whereField(whereCondition, isEqualTo: condition).whereField(anotherWhereCondition, isEqualTo: anotherCondtion).order(by: Constants.DataBase.dbID).getDocuments { (querySnapshot, error) in                        self.dbModel.lists = []                        if let e = error {                print(e)            } else {                                if let snapshotDocuments = querySnapshot?.documents {                    if snapshotDocuments != [] {                        for doc in snapshotDocuments {                            let data = doc.data()                            if let listId = data[Constants.DataBase.dbID] as? Int                                , let listTitle = data[Constants.DataBase.dbTitle] as? String                                , let listBool = data[Constants.DataBase.dbIsComplete] as? Bool                                , let listFav = data[Constants.DataBase.dbIsFavorite] as? Bool                                ,let listImage = data[Constants.DataBase.dbImageTitle] as? String                                , let listDate = data[Constants.DataBase.dbDate] as? String {                                                                let list = ToDoModel(id: listId, title: listTitle, isComplete: listBool, isFav: listFav, imageTitle: listImage, date: listDate)                                                                self.dbModel.lists.append(list)                                                                self.delegate?.sendDB(data: self.dbModel.lists)                                                            }                                                    }                    } else {                        self.dbModel.lists = []                        self.delegate?.sendDB(data: self.dbModel.lists)                    }                }            }        }    }        // MARK: - Update : DB수정    func editDB (mainWhereCondition :String, mainCondition: Any , sideWhereCondition: String, sideCondition: Any) {        dbModel.db.collection(Constants.collectionName).whereField(mainWhereCondition, isEqualTo: mainCondition).getDocuments { (querySnapshot,error) in            if let e = error {                print(e)            } else {                if let documents = querySnapshot?.documents {                    for doc in documents {                        let docuId = doc.documentID                        self.dbModel.db.collection(Constants.collectionName).document(docuId).setData([sideWhereCondition: sideCondition], merge: true)                    }                }            }        }    }        // MARK: - Delete: DB 제거    func deleteCell (number : Int) {        dbModel.db.collection(Constants.collectionName).whereField(Constants.DataBase.dbID, isEqualTo: number).getDocuments { (querySnapshot, error) in            if let e = error {                print(e)            } else {                if let documents = querySnapshot?.documents {                    for doc in documents {                        let docuId = doc.documentID                        self.dbModel.db.collection(Constants.collectionName).document(docuId).delete()                    }                }            }        }    }}edit에 관한내용이 너무 세부적으로 작성이 되어있어서 다지우고 하나로 통일했다."
  },
  
  {
    "title": "3주차 과제 (9)",
    "url": "/posts/3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(9)/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-28 11:13:00 +0900",
    





    
    "snippet": "Lv.41. 전체, 오늘 구분하여 구현하기Tab bar를 사용하려다 back button이 생기면서 더 꼬일거같아서 버튼으로 구현하기로 했다.대부분 DB Query에 관한 내용이라 관련 내용은 pass하지만 처음 화면이 보여질때 전체 화면이 보이게끔 하기위해서totalBtn.isSelected = true 이걸 viewdidload에 적어주었다.그리고...",
    "content": "Lv.41. 전체, 오늘 구분하여 구현하기Tab bar를 사용하려다 back button이 생기면서 더 꼬일거같아서 버튼으로 구현하기로 했다.대부분 DB Query에 관한 내용이라 관련 내용은 pass하지만 처음 화면이 보여질때 전체 화면이 보이게끔 하기위해서totalBtn.isSelected = true 이걸 viewdidload에 적어주었다.그리고 각 버튼을 눌렀을때 눌러진 모습을 보여주기 위해서@IBAction func showTotalBtn(_ sender: UIButton) {        dbManager.getData()                todayBtn.isSelected = !todayBtn.isSelected        totalBtn.isSelected = !totalBtn.isSelected    }    @IBAction func showTodayBtn(_ sender: UIButton) {        dateFormat.dateFormat = \"yyyy-MM-dd\"        dbManager.getSpecificData(whereCondition: Constants.Fire.fireDate, condition: dateFormat.string(from: Date()))        todayBtn.isSelected = !todayBtn.isSelected        totalBtn.isSelected = !totalBtn.isSelected    }이런식으로 해주었다.서로 반대를 해주는데 어차피 viewDidload에 true로 잡혀있기에 가능하다.2. sideBar 달력을 tap했을때 이벤트 발생시키기Docs에 의하면 selection을 사용할수 있는데, 그전에 selection객체와, delegate를 만들라고 되어있다.viewDidload에 다음과 같이 적어서 만들어 주자let dateSelection = UICalendarSelectionSingleDate(delegate: self)calendarView.selectionBehavior = dateSelection그리고 UICalendarSelectionSingleDateDelegate를 채택해준다extension SideBarViewController : UICalendarSelectionSingleDateDelegate {               func dateSelection(_ selection: UICalendarSelectionSingleDate, didSelectDate dateComponents: DateComponents?) {                let selectedDate = dateComponents        let calendar = Calendar.current        let myDate = calendar.date(from: selectedDate!)                let dateFormat = DateFormatter()        dateFormat.dateFormat = \"yyyy-MM-dd\"                dbManager.getSpecificData(whereCondition: Constants.Fire.fireDate, condition: dateFormat.string(from: myDate!))            }        }이때 클릭했을때 보여주는 방식이 달라서 고민을 하고 찾아보다가 내가 원하는대로 변환하는게 있어서 가져왔다.위와같이 해주면 이제 정상적으로 “2024-03-23” 뭐 이런식으로 나오게 된다.3. TableView 구현하기코드로 구현하는 부분인데 하는 방식은 같다.이때 보이지 않는 증상이 있었는데 바로 AutoLayout문제였다.내가 여태 잘못주고 있었다는 생각이 들었다.TableView는 bottomLayout을 주지않으니 보이지 않았던 문제였다.튜터님과 대화하면서 코드로 작성한 autolayout의 문제점을 발견했다.그리고 이렇게 뭐가 안보일때는 view Hierchy를 써보라고 하셨다.튜터님에게 조언을 받으며 해당기능을 구현할수 있었다.DB 문제점 수정하기.가장큰 문제점이 남았다.1. 쿼리에 해당하지 않을때의 문제 수정쿼리문에 해당하지않는 조건의 값이 없을때 계속 해서 출력을 해봐도 [] 만 나와서하나하나 역추적을 제대로 해보기 시작했다.func getMultiQueryData(whereCondition : String, condition : Any, anotherWhereCondition : String, anotherCondtion:Any) {                dbModel.db.collection(Constants.collectionName).whereField(whereCondition, isEqualTo: condition).whereField(anotherWhereCondition, isEqualTo : anotherCondtion).order(by: Constants.Fire.fireId).getDocuments { (querySnapshot, error) in                        self.dbModel.lists = []                        if let e = error {                print(e)            } else {                                if let snapshotDocuments = querySnapshot?.documents {                    for doc in snapshotDocuments {                        let data = doc.data()                        if let listId = data[Constants.Fire.fireId] as? Int                            , let listTitle = data[Constants.Fire.fireTitle] as? String                            , let listBool = data[Constants.Fire.fireBool] as? Bool                            , let listFav = data[Constants.Fire.favBool] as? Bool                            ,let listImage = data[Constants.Fire.fireImageTitle] as? String                            , let listDate = data[Constants.Fire.fireDate] as? String {                                                        let list = ToDoModel(id: listId, title: listTitle, isComplete: listBool, isFav: listFav, imageTitle: listImage, date: listDate)                                                        self.dbModel.lists.append(list)                                                        self.delegate?.sendDB(data: self.dbModel.lists)                                                    }                                            }                }            }        }    }이것을 예로 든다면처음에는 마지막 부분인 let list != [] 이런식으로 했지만, 해결되지않았다.그래서 하나하나 올라가기 시작했고snapShotDocument에서 if snapshotDocuments != [] { } else { print(\"null\")} 로 했을때 null이 찍혔다.드디어 내가 원하는 부분에대한 위치를 찾게 되었고,self.dbModel.lists = [ToDoModel(id: 0, title: \"조건에 일치하는 데이터가 없습니다\", isComplete: false, isFav: false, imageTitle: \"https://firebasestorage.googleapis.com/v0/b/todolist-1a790.appspot.com/o/O9IY1C0.jpg?alt=media&amp;token=7e07e023-daf8-422d-a4ce-cdf43137e9cd\", date: todayDate)]    self.delegate?.sendDB(data: self.dbModel.lists)이렇게 list를 하나 만들어서 전달을 했다.이렇게 해주었다.하지만 이런부분도 데이터를 조작하게 하는건 좋지않을거라 판단하여 isHidden을 사용하여 가려보겠다.2. 데이터 없을 때 기능 숨기기if titleString != \"조건에 일치하는 데이터가 없습니다\" {                titleLabel.text = titleString    } else { // 아무것도 해당하지 않는 경우 기능을 숨기기위해 구현        titleLabel.text = titleString        datePicker.isHidden = true        uploadBtn.isHidden = true        deadlineLabel.isHidden = true        dateLabel.isHidden = true}전달받은 text값이 위와 같을때는 기능을 숨김 처리하였다.Cell Animation 주기.func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {        let duration = 0.7        let delayFactor = 0.005        cell.transform = CGAffineTransform(scaleX: 0.4, y: 0.8)        UIView.animate(withDuration: duration                       ,delay:  delayFactor * Double(indexPath.row)                       ,usingSpringWithDamping: 0.8                       ,initialSpringVelocity:  0.4                       ,options: [.autoreverse]                        , animations: {            cell.transform = CGAffineTransform(translationX: 0, y: 0)        })    }유튜브 영상을 보고 참고하여 만들어보았다미적감각이 개판이지만, 되는걸로 만족한다.가장 큰 문제가 남았는데, 어떻게 해결을 해야할지 아직도 고민중이다."
  },
  
  {
    "title": "3주차 과제 (8)",
    "url": "/posts/3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(8)/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-27 11:13:00 +0900",
    





    
    "snippet": "이번글은 참고자료를 위주로 따라한것밖에 없는듯 하다.주말에 제대로 하나씩 뜯어보면서 봐야할듯하다과제기간이 얼마 남지 않은 만큼 어쩔수가 없는게 아쉽다Lv41. Calendar 기능 추가하기1. 새로운 VC 파일 생성생략2. Sidebar의 구조 작성private func addDimmingView() {        dimmingView = UIVie...",
    "content": "이번글은 참고자료를 위주로 따라한것밖에 없는듯 하다.주말에 제대로 하나씩 뜯어보면서 봐야할듯하다과제기간이 얼마 남지 않은 만큼 어쩔수가 없는게 아쉽다Lv41. Calendar 기능 추가하기1. 새로운 VC 파일 생성생략2. Sidebar의 구조 작성private func addDimmingView() {        dimmingView = UIView(frame: self.view.bounds)        dimmingView?.backgroundColor = UIColor.black.withAlphaComponent(0.5)        dimmingView?.isHidden = true        view.addSubview(dimmingView!)                let tapGesture = UITapGestureRecognizer(target: self, action: #selector(handleDimmingViewTap))        dimmingView?.addGestureRecognizer(tapGesture)    }        @objc private func handleDimmingViewTap() {        let sideBarVC = self.sideBarViewController                UIView.animate(withDuration: 0.3, animations: {            // 사이드 메뉴를 원래 위치로 되돌림.            sideBarVC.view.frame = CGRect(x: -self.view.frame.width, y: 0, width: self.view.frame.width, height: self.view.frame.height)            // 어두운 배경 뷰를 숨김.            self.dimmingView?.alpha = 0        }) { (finished) in            // 애니메이션이 완료된 후 사이드 메뉴를 뷰 계층 구조에서 제거.            sideBarVC.view.removeFromSuperview()            sideBarVC.removeFromParent()            self.dimmingView?.isHidden = true        }    }        @IBAction func openSideBtn(_ sender: UIBarButtonItem) {        let sideBarVC = self.sideBarViewController                // 사이드 메뉴 뷰 컨트롤러를 자식으로 추가하고 뷰 계층 구조에 추가.        self.addChild(sideBarVC)        self.view.addSubview(sideBarVC.view)                // 사이드 메뉴의 너비를 화면 너비의 70%로 설정.        let menuWidth = self.view.frame.width * 0.70        let menuHeight = self.view.frame.height        let yPos = (self.view.frame.height / 2) - (menuHeight / 2) // 중앙에 위치하도록 yPos 계산                        // 사이드 메뉴의 시작 위치를 화면 왼쪽 바깥으로 설정.        sideBarVC.view.frame = CGRect(x: -menuWidth, y: yPos, width: menuWidth, height: menuHeight)                // 어두운 배경 뷰를 보이게 합니다.        self.dimmingView?.isHidden = false        self.dimmingView?.alpha = 0                UIView.animate(withDuration: 0.3, animations: {            // 사이드 메뉴를 화면에 표시.            sideBarVC.view.frame = CGRect(x: 0, y: yPos, width: menuWidth, height: menuHeight)            // 어두운 배경 뷰의 투명도를 조절.            self.dimmingView?.alpha = 1        })            }참고자료 보고 작성한 글이다 보니 아직 제대로된 이해를 하지못하였다.아무래도 주말에 해당부분을 완벽하게 이해하여, 프로젝트를 다음주부터할때 지장이 없게끔 해야할듯하다.2. Calendar에 표시하기.참고자료 를 보고 작성을 해본다.iOS 16부터 구현된 기능이라고 한다.작동화면3. CellDetailVC에 오늘 할일 등록하여 DB연동시키기1. DatePicker 구현DatePicker를 통해 날짜를 선택하면 그 날짜 값을 DB에 저장하려고 한다.우선 DatePicker에서 어떤 값을 리턴을 해야할지 생각을 해보았다.여러기능을 구현하는건 도움이 되겠지만 너무 막 만드는건 아니다 싶어날짜를 지정해서 보여주는게 좋다고 판단했다. @IBAction func setDate(_ sender: UIDatePicker) {               let datePicker = sender                let dateFormat = DateFormatter()        dateFormat.dateFormat = \"yyyy-MM-dd\"        print(dateFormat.string(from: datePicker.date))        print(dateFormat.string(from: Date()))    }출력을 하면2024-03-28 → 28일을 선택한경우2024-03-27 → 오늘날짜 print한경우이런식으로 나온다2. 새로운 Field 추가DB에 새로운 Attribute가 추가해야하므로 ToDoModel모델로 가주었다.struct ToDoModel {        var id : Int // 게시글 번호    var title : String // 제목    var isComplete : Bool // 다 끝냈는지?    var isFav : Bool // 즐겨찾기    var imageTitle : String // 이미지 업로드시 가질 이름    var date : String // 날짜 지정 new!    }그리고 문자열을 관리해주는 Constants에도 새로 추가를 해주자늘 그렇듯 문자열은 내가만든 ToDoModel 명을 그대로 사용하는걸 잊지말자.struct Constants {        static var cellIdentifier = \"ToDoCell\"    static var cellName = \"ToDoListCell\"    static var collectionName = \"ToDoList\"        struct Fire {        static var fireId = \"id\"        static var fireTitle = \"title\"        static var fireBool = \"isComplete\"        static var docuName = \"List\"        static var favBool = \"isFav\"        static var fireImageTitle = \"imageTitle\"        static var fireDate = \"date\" //new    }        struct Symbol {        static var star = \"star\"        static var fillStar = \"star.fill\"    }}시간으로해서 디테일있게 하는것보다는 날짜로만 지정해주는게 더 좋다고 판단했다.물론 시작날짜, 끝맺음날짜도 가능하지만, 그렇게 했을때 어떻게 그걸 표현을 할까에 대한 고민을 해야하고 그러기에일단은 날짜만 제대로 표현을 하는게 중요하다고 생각하여 결정했다.3. DB에 새로 값을 입력시 Today로 자동 리턴하게 설정DBManager를 가면 이제 새로운 Field가 생겼으므로 에러가 뜨기에그걸 해소해주도록 하자새롭게 DB에 값을 입력할때 날짜값을 오늘날짜로 Default를 주려고한다.func addDB (textfield : String ) {        let dateFormat = DateFormatter()        dateFormat.dateFormat = \"yyyy-MM-dd\"        dbModel.db.collection(Constants.collectionName).addDocument(data: [Constants.Fire.fireId : self.getID()                                                                           , Constants.Fire.fireTitle : textfield                                                                           , Constants.Fire.fireBool : false, Constants.Fire.favBool : false                                                                           , Constants.Fire.fireImageTitle : \"\"                                                                           , Constants.Fire.fireDate : dateFormat.string(from: Date()) // new                                                                           ]) { (error) in            if let e = error { // DB에 업로드중 에러 발생시                print(\"error : \\(e.localizedDescription)\")            } else { // 업로드가 성공하면 콘솔로 알려준다.                print(\"Upload Done\")            }        }    }DB를 가져오는 부분에 date를 추가해주었다.func getData () {                dbModel.db.collection(Constants.collectionName).order(by: Constants.Fire.fireId)            .addSnapshotListener { (querySnapshot, error) in                                self.dbModel.lists = []                                if let e = error {                    print(\"error : \\(e)\")                } else {                    if let snapshotDocuments = querySnapshot?.documents {                        for doc in snapshotDocuments {                            let data = doc.data()                            if let listId = data[Constants.Fire.fireId] as? Int                                , let listTitle = data[Constants.Fire.fireTitle] as? String                                , let listBool = data[Constants.Fire.fireBool] as? Bool                                , let listFav = data[Constants.Fire.favBool] as? Bool                                , let listImage = data[Constants.Fire.fireImageTitle] as? String,                               let listDate = data[Constants.Fire.fireDate] as? String // new                               {                                                                let list = ToDoModel(id: listId, title: listTitle, isComplete: listBool, isFav: listFav, imageTitle: listImage, date: listDate)                                self.dbModel.lists.append(list)                                self.delegate?.sendDB(data: self.dbModel.lists)                            }                                                    }                    }                }            }    }테스트를 해보자장보기라고 만들었다.DB를 확인해보니, 오늘 날짜가 제대로 입력된걸 알 수있다.4. 날짜를 선택한값을 DB로 보내기.@IBAction func setDate(_ sender: UIDatePicker) {                let datePicker = sender        let dateFormat = DateFormatter()        dateFormat.dateFormat = \"yyyy-MM-dd\"                // new        let selectedDate = dateFormat.string(from: datePicker.date)         dbManager.addCellDetailFeature(title: titleLabel.text!, field: Constants.Fire.fireDate, feature: selectedDate)    }func addCellDetailFeature (title: String, field : String ,feature : String) {        dbModel.db.collection(Constants.collectionName).whereField(Constants.Fire.fireTitle, isEqualTo: title).getDocuments { (querySnapshot,error) in            if let e = error {                print(e)            } else {                if let documents = querySnapshot?.documents {                    for doc in documents {                        let docuId = doc.documentID                        self.dbModel.db.collection(Constants.collectionName).document(docuId).setData([field : feature], merge: true)                    }                }            }        }    }기존에 이미지만 추가하던것을 파라미터를 좀더 확장하는게 좋다고 판단하여 내용을 바꿔주었다.29일로 바꿔보았다.잘 바뀐것을 알 수 있다.3. 오늘 버튼 눌렀을때 오늘 해당하는 list 보여주기.우선 CellDetailVC에 새로운 변수를 하나 만들어준다.var selectedDate : String? = \"\"그리고 셀을 클릭했을때 date값을 같이 넘기기 위해 TableViewVC에 다음과 같이 적어서 화면전환시 같이 넘기게 한다.extension TableViewController : UITableViewDelegate {        func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {                if let CellDetailVC = self.storyboard?.instantiateViewController(identifier: \"CellDetailViewController\") as? CellDetailViewController {                        CellDetailVC.titleString = lists[indexPath.row].title            CellDetailVC.selectedDate = lists[indexPath.row].date             // new                        if lists[indexPath.row].imageTitle != \"\" { // 이미지 파일을 업로드 한 경우                CellDetailVC.imageUrl = lists[indexPath.row].imageTitle            } else { // 이미지 파일을 업로드 하지 않은 경우                CellDetailVC.imageUrl = \"https://firebasestorage.googleapis.com/v0/b/todolist-1a790.appspot.com/o/upload-image-icon.png?alt=media&amp;token=52da5077-bebf-4f39-8692-14b376f6f7a6\"            }                        self.present(CellDetailVC, animated: true)        }                    }    }화면 전환시 보이게 해줘야하므로 ViewDidload부분을 수정하도록 하자override func viewDidLoad() {        super.viewDidLoad()                let dateFormat = DateFormatter() //new        dateFormat.dateFormat = \"yyyy-MM-dd\" //new                let date = dateFormat.date (from:selectedDate) // new                datePicker.setDate(date!, animated: false) //new        titleLabel.text = titleString                        getImage()    }현재 화면전환시 받아오는 파라미터의 타입이 optionalString이므로해당 값은 nil이 되지 않기에 강제로 Force Unwrapping 해주었다.그리고 String → Date로 형변환을 해줘야 하기에 dateFormat 을 사용 하였다.테스트를 해보면?잘된다.이미지는 용량상 어쩔수없이 화질저화를 했다 ㅠ 근데 사이즈도 너무 작아져버렸네..Nas통해 호스팅하는걸 빨리 해야하지 않을까싶다.이제 Date이용해서 하나의 기능만 더 구현하면 끝이 날것같다.그런데 마지막기능이 화룡점정 느낌인 만큼 헬스멜이 난다.그래도 아직 시간적 여유가 있으니 도전해보자."
  },
  
  {
    "title": "(Deep Dive) ImagePicker",
    "url": "/posts/(Deep-Dive)-ImagePicker/",
    "categories": "Udemy, Deep Dive",
    "tags": "Myself",
    "date": "2024-03-26 15:00:00 +0900",
    





    
    "snippet": "이미지 업로드할때, 꼭 필요한 기능이라 정리 할겸 적어보기로 한다.UIImagePickerControllerDelegate는 단독으로 쓰이지 않는다.UINavigationControllerDelegate와 같이 쓰이게 된다.UIImagePickerController라고 하면우리가 배달어플을 사용하고 리뷰를 할때 사진을 고를때 보이는 그 화면이다.이렇게...",
    "content": "이미지 업로드할때, 꼭 필요한 기능이라 정리 할겸 적어보기로 한다.UIImagePickerControllerDelegate는 단독으로 쓰이지 않는다.UINavigationControllerDelegate와 같이 쓰이게 된다.UIImagePickerController라고 하면우리가 배달어플을 사용하고 리뷰를 할때 사진을 고를때 보이는 그 화면이다.이렇게 새로운 NavigationView같은 창이 하나 더 올라오면서 보여주기에 UINavigationControllerDelegate이 더 필요할 수 밖에 없다고 생각한다.UIImagePickerController를 사용하면 곧 기능이 사라질거라 PHPicker를 사용하라고 뜨는데 그걸 사용해보도록 하겠다.WWDC영상1. 화면구성심플하게 위와 같이 구성해보았다.이미지를 보여줄 ImageView, 사진을 선택하게 하는 버튼 2개왼쪽 오른쪽을 구분해주었다.2. 코드 구성1. UIPickerContollerextension ViewController : UIImagePickerControllerDelegate, UINavigationControllerDelegate {        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {            }        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {            }   }비교를 위해 두개를 적어보았다.우선 보기쉽게하기위해 extension으로 분리하여 구현했다.imagePickerController(didFinishPickingMediaWithInfo),imagePickerControllerDidCancel이 두 함수는 내가 생각하기엔 필수로 구현해야 하는 기능이 아닐까 생각한다.func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {            }위의 함수는 내가 이미지를 선택하고 난 이후의 상황에 대해 지시를 하는 함수라고 보면된다.여기서 선택한 이미지를 imageView에 띄워준다.func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {            }이 함수는 내가 취소버튼을 눌렀을때의 어떻게 지시를 할건지에대한 내용을 담는다.취소버튼을 눌렀을때, 그냥 사라지게 할수도 있고(dismiss) 아니면 기존에 알아보았던 alertController를 이용해 취소되었습니다 라는 메세지를 남겨주어도 될것같다.2. PHPickerViewControllerimport PhotosUI// phpextension ViewController : PHPickerViewControllerDelegate {        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {           }}   하나의 함수만 존재한다, 여기서 dismiss와 imageview에 전달하는 방식으로 하게된다.3. 코드 구현1. UIImagePickerControllerDelegate우선 버튼을 눌렀을때 imagepicker가 나와야 하므로,@IBAction func uploadImage(_ sender: UIButton) {            }이부분에 먼저 pickerInstance를 하나 만들어준다.프로토콜을 채택했으니 델리게이트를 위임하는것을 잊지 말자.@IBAction func uploadImagePicker(_ sender: UIButton) {        let picker = UIImagePickerController()        picker.sourceType = .photoLibrary        picker.allowsEditing = true        picker.delegate = self        self.present(picker, animated: true)    }  sourceType : camera, photoLibrary, savedPhotosAlbum 이렇게 3개가 존재한다          camera 빼고 나머지 2개는 xcode 버전이 업데이트되면 사라질 예정        allowedEditing : 이미지 편집 허용          이렇게 이미지를 선택하면 사이즈조절 원하는부분 설정 등을 할 수 있다      extension ViewController : UIImagePickerControllerDelegate, UINavigationControllerDelegate {        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {                if let selectedImage = info[UIImagePickerController.InfoKey.editedImage] as? UIImage {            self.displayView.image = selectedImage        }        picker.dismiss(animated: true)            }        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {                self.dismiss(animated: true)    }    }위에 allowEditing = true 를 하면 반드시 editedImage로 해줘야한다. 안하면 사진이 보이지 않음.그리고 다운캐스팅을 해줘야 한다!2. PHPickerViewControllerDelegate@IBAction func uploadImage(_ sender: UIButton) {        var configuration = PHPickerConfiguration()        configuration.selectionLimit = 1        configuration.filter = .images        let picker = PHPickerViewController(configuration: configuration)                picker.delegate = self        self.present(picker, animated: true)    }extension ViewController : PHPickerViewControllerDelegate {        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {        self.dismiss(animated: true)                for result in results {            result.itemProvider.loadObject(ofClass: UIImage.self) { (image,error) in                if let selectedImage = image as? UIImage {                    DispatchQueue.main.async {                        self.displayView.image = selectedImage                    }                }            }        }        //        results.forEach { result in//            result.itemProvider.loadObject(ofClass: UIImage.self) { (image,error) in//                if let selectedImage = image as? UIImage {//                    DispatchQueue.main.async {//                        self.displayView.image = selectedImage//                    }//                }//            }//        }    }        }역시 미리 설정을 하지만, 위와는 다르게 최대 몇장의 이미지를 선택할수있을지 정할 수 있고filter에는 여러 프로퍼티가 있다.프로퍼티들은 Docs를 통해 확인할것.아래 함수는 주석친것과 안친것은 같은 내용이다.(for, forEach의 차이)특이한점이라면? 여러 이미지를 선택 할 수 있기에,반복문을 통해 접근을 하게 된다. 내가 선택한 이미지들은 results라는 배열에 담기게 되고, 그걸 하나씩 꺼내서 image로 리턴하는것이라고 보면 되겠다.UIpicker보다는 확실히 더 코드 구현에 있어 디테일 해졌다.그리고 특이한점이라면바로 DispatchQueue 하여 비동기방식으로 전달을 한다는 것이다.해당 내용을 적지 않으면 사진이 보이지 않고, mainthread에서 실행이 되어야한다는 보라색 창의 문구가 뜨게 된다.4. 작동화면 (통합)5. 참고자료https://www.youtube.com/watch?v=EuqUcn_p0tkhttps://www.youtube.com/watch?v=LlZUQW3Zj9c"
  },
  
  {
    "title": "3주차 과제 (7)",
    "url": "/posts/3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(7)/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-26 11:13:00 +0900",
    





    
    "snippet": "Lv4Cell 클릭시 새로운 화면 띄우기extension TableViewController : UITableViewDelegate {        func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {                if let CellDetailVC...",
    "content": "Lv4Cell 클릭시 새로운 화면 띄우기extension TableViewController : UITableViewDelegate {        func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {                if let CellDetailVC = self.storyboard?.instantiateViewController(identifier: \"CellDetailViewController\") as? CellDetailViewController {                        CellDetailVC.titleString = lists[indexPath.row].title                        self.present(CellDetailVC, animated: true)        }                    }    }present를 사용하여 새로운 화면을 띄우는것으로 하였고, 이때 제목이 그대로 전달이 되게끔 구현해두었다.아직 여기에 어느기능을 더 구현할지 생각중이다.여기까진 Easy새로운 VC에 간단한 일기형식으로 내용을 담게하는 기능을 구현할까 싶다.아니면 이미지 업로드만 하는식으로 할지 고민중이다.내일까지 Udemy공부를 끝마치고 생각해보자.공부하면서 아이디어가 떠오를지도.imageUpload 버튼 구현하기.참고영상은 초반부 까지만,구식 버전이긴 하지만 만드면서 전체적인 시퀀스를 이해하는데 도움이 되었다.버튼을 하나 만들고 해당 버튼을 통해 이미지를 업로드 하려고 한다.우선 UIImagePickerControllerDelegate, UINavigationControllerDelegate를 채택해주자.extension CellDetailViewController : UIImagePickerControllerDelegate, UINavigationControllerDelegate {        @IBAction func uploadImageBtn(_ sender: UIButton) {                var pickerController = UIImagePickerController ()                pickerController.sourceType = .photoLibrary // 사진 라이브러리에서 선택        pickerController.allowsEditing = true // 이미지를 선택하고 편집할수 있게                pickerController.delegate = self // 델리게이트 위임                self.present(pickerController, animated: true)                    }        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {        self.dismiss(animated: true)                let selectedImage = info[UIImagePickerController.InfoKey.editedImage] as? UIImage                self.detailImageView.image = selectedImage    }        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {               self.dismiss(animated: true)            }    }여기서 핵심은 2개의 프로토콜을 채택해줘야하며, pickerController를 객체화 하여 구현하는 것이다.그리고 UIImagePickerController.InfoKey.editedImage 이부분에 editedImage는 위에pickerController.allowsEditing = true이게 없으면 editedImage를 했을때 사진이 보이지 않는다.그럴땐 originalImage로 바꿔서 설정하면 된다.이젠 DB에 넣어보도록 해보자.FireBase와 연동시켜보기우선 FireBase Storage를 활성화 시킨다.DB와는 다르다.storage를 만들어 주었다.Docs대로 하면 되기에 어려울 건 없을것 같다.한번 만들어 보자.참고영상과 참고자료 을 보고 참고하며 작성했다.참고자료를 통해서 FireBase의 Storage에 어덯게 이미지를 업로드하고, 가져오는지에 대해서 알아보았다.내가 원했던 자료가 그대로 있어서 좋았다.func uploadImage(image: UIImage, completion: @escaping (URL?) -&gt; Void) {        guard let imageData = image.jpegData(compressionQuality: 0.4) else { return }        let metaData = StorageMetadata()        metaData.contentType = \"image/jpeg\"                let imageName = UUID().uuidString + String(Date().timeIntervalSince1970)                let firebaseReference = Storage.storage().reference().child(\"\\(imageName)\")        firebaseReference.putData(imageData, metadata: metaData) { metaData, error in            firebaseReference.downloadURL { url, _ in            completion(url)        }    }}    func downloadImage(urlString: String, completion: @escaping (UIImage?) -&gt; Void) {    let storageReference = Storage.storage().reference(forURL: urlString)    let megaByte = Int64(1 * 1024 * 1024)            storageReference.getData(maxSize: megaByte) { data, error in        guard let imageData = data else {            completion(nil)            return        }        completion(UIImage(data: imageData))    }}uploadImage함수의 가장 큰 특징은 UUID를 주었다는 점이다. 이전에 자바를 배울때 이미지를 업로드할때는 일반 이미지명이 아닌 UUID로 하여 하나의 고유 이미지 파일명을 주는게 포인트였다.왜냐하면 어떤 중복된 이름이 나올지 모르기 때문이다.그리고 downloadImage함수는 url주소에 있는것을 가져와서 이미지로 리턴하는 내용이다.대부분은 Firebase Storage와 관련되어있다.func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {        guard let selectedImage = info[UIImagePickerController.InfoKey.editedImage] as? UIImage else {            return        }                imageManager.uploadImage(image: selectedImage) { url in            if let url = url {                self.dbManager.addImage(title: self.titleLabel.text!, imageTitle: url.absoluteString)            }        }        self.detailImageView.image = selectedImage                picker.dismiss(animated: true)            }        func getImage() {    guard let urlString = imageUrl else { return }            imageManager.downloadImage(urlString: urlString) { [weak self] image in        self?.detailImageView.image = image    }}이미지를 선택하고 나면 위의 uploadImage함수가 작동이 되면서 이미지를 업로드하면서 handler를 통해 url을 가져온것을 absoluteString을 통해 절대주소로 반환을 하고 그값을 현재 화면에 표시되어있는 title과 같은 field의 imageTitle값을 변경하게 해주었다.그리고 getImage에서는 해당 url을 받아 가져와서 ViewDidload에 넣음으로써 화면이 올라가자마자 이미지가 보이게 했다.extension TableViewController : UITableViewDelegate {        func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {                if let CellDetailVC = self.storyboard?.instantiateViewController(identifier: \"CellDetailViewController\") as? CellDetailViewController {                        CellDetailVC.titleString = lists[indexPath.row].title                        if lists[indexPath.row].imageTitle != \"\" { // 이미지 파일을 업로드 한 경우                CellDetailVC.imageUrl = lists[indexPath.row].imageTitle            } else { // 이미지 파일을 업로드 하지 않은 경우                CellDetailVC.imageUrl = \"https://firebasestorage.googleapis.com/v0/b/todolist-1a790.appspot.com/o/upload-image-icon.png?alt=media&amp;token=52da5077-bebf-4f39-8692-14b376f6f7a6\"            }            self.present(CellDetailVC, animated: true)        }                    }    }이때 새로 만들거나, 이미지를 업로드를 하지않은 Field의 경우 imageTitle이 \"\"으로 되어잇으므로,그냥 클릭하면 에러가 발생하게 된다, 없는 url을 통해 값을 가져오려고 하기에 getImage와 충돌이 생겨버린다.그래서 샘플 이미지를 하나 등록하여, 이미지를 업로드 하지 않은 경우엔 ImageView가 있다는것을 표시하기 위해 샘플이미지를 업로드하였고, 해당 이미지 주소를 적음으로써 예외 경우를 처리하였다.작동화면은 다음과 같다."
  },
  
  {
    "title": "Todoey (4)",
    "url": "/posts/Todoey-(4)/",
    "categories": "Udemy, Todoey",
    "tags": "",
    "date": "2024-03-25 05:53:00 +0900",
    





    
    "snippet": "Query 사용하기.1. Search Bar 기능구현하기StoryBoard에서 Search Bar를 만들고, UISearchBarDelegate 프로토콜을 채택해주자.searchBarSearchButtonClicked 메서드를 사용할것이다.우리가 흔히 보는 그 돋보기 모양을 클릭했을때 트리거 되는 함수를 구현해보자.context를 가져오기위해선 항상 ...",
    "content": "Query 사용하기.1. Search Bar 기능구현하기StoryBoard에서 Search Bar를 만들고, UISearchBarDelegate 프로토콜을 채택해주자.searchBarSearchButtonClicked 메서드를 사용할것이다.우리가 흔히 보는 그 돋보기 모양을 클릭했을때 트리거 되는 함수를 구현해보자.context를 가져오기위해선 항상 request를 해서 가져와야한다.extension TodoListViewController : UISearchBarDelegate {        func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {                let request : NSFetchRequest&lt;Item&gt; = Item.fetchRequest()                print(searchBar.text!)            }    }그전에 print를 해서 잘 나오는지 보자.버튼을 클릭할때 부분은 아직 구현이 안되었으나, 엔터를 치니 출력이 되는걸 알 수 있다.쿼리를 작성해야 하는데 내가 전에 쓰던 MySQL과 는 달리 let predicate = NSPredicate(format: \"title CONTAINS[cd] %@\", searchBar.text!)이렇게 적었다. title에서 일치하는것을 가져온다. 이렇게 쿼리문을 해석 할 수 있다.약간 정규식이 들어간것으로 보인다.그리고 뒤에는 argument인데, searchBar.text의 값을 사용할 것이므로 적어두자.사이트 를 참고하자.여기서 cd란?  [c]          대소문자 무시      ex) ‘hello’ BEGINSWITH[c] ‘Hello World’        [d]          악센트 기호 무시      ex) ‘cafe’ CONTAINS[d] ‘café’        [cd]          둘 다 무시      참고사이트extension TodoListViewController : UISearchBarDelegate {        func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {                let request : NSFetchRequest&lt;Item&gt; = Item.fetchRequest()                let predicate = NSPredicate(format: \"title CONTAINS[cd] %@\", searchBar.text!)                request.predicate = predicate                let sortDescriptor = NSSortDescriptor(key: \"title\", ascending: true)                request.sortDescriptors = [sortDescriptor]                do {            itemArray = try context.fetch(request)        } catch {            print(\"Error fetching data from context \\(error)\")        }                tableView.reloadData()    }    }2. 코드 리팩토링func loadItems (with request : NSFetchRequest&lt;Item&gt; = Item.fetchRequest()) {                let request : NSFetchRequest&lt;Item&gt; = Item.fetchRequest()                do {            itemArray = try context.fetch(request)        } catch {            print(\"Error fetching data from context \\(error)\")        }                tableView.reloadData()    }extension TodoListViewController : UISearchBarDelegate {        func searchBarSearchButtonClicked(_ searchBar: UISearchBar) {                // let request : NSFetchRequest&lt;Item&gt; = Item.fetchRequest()                request.predicate = NSPredicate(format: \"title CONTAINS[cd] %@\", searchBar.text!)                request.sortDescriptors = [NSSortDescriptor(key: \"title\", ascending: true)]        loadItems(with: request)            }    }viewDidload 내부 수정loadItems(with: request)3. 검색 하고 지웠을때 다시 원복하기func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {        if searchBar.text?.count == 0 { // 입력안했을때            loadItems()                        DispatchQueue.main.async {                searchBar.resignFirstResponder()            }                    }    }resignFirstResponder 를 사용하면 현재 커서와, 키보드 활성화되었던게 해제가 된다."
  },
  
  {
    "title": "Todoey (3)",
    "url": "/posts/Todoey-(3)/",
    "categories": "Udemy, Todoey",
    "tags": "",
    "date": "2024-03-25 05:53:00 +0900",
    





    
    "snippet": "CoreData 사용해보기.1. CoreData 모델 만들기파일을 새로 만들때, 아래르 스크롤을 내리면 보인다.// MARK: - Core Data stacklazy var persistentContainer: NSPersistentContainer = {    /*     The persistent container for the applicatio...",
    "content": "CoreData 사용해보기.1. CoreData 모델 만들기파일을 새로 만들때, 아래르 스크롤을 내리면 보인다.// MARK: - Core Data stacklazy var persistentContainer: NSPersistentContainer = {    /*     The persistent container for the application. This implementation     creates and returns a container, having loaded the store for the     application to it. This property is optional since there are legitimate     error conditions that could cause the creation of the store to fail.    */    let container = NSPersistentContainer(name: \"school\")    container.loadPersistentStores(completionHandler: { (storeDescription, error) in        if let error = error as NSError? {            // Replace this implementation with code to handle the error appropriately.            // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.                         /*             Typical reasons for an error here include:             * The parent directory does not exist, cannot be created, or disallows writing.             * The persistent store is not accessible, due to permissions or data protection when the device is locked.             * The device is out of space.             * The store could not be migrated to the current model version.             Check the error message to determine what the actual problem was.             */            fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")        }    })    return container}()// MARK: - Core Data Saving supportfunc saveContext () {    let context = persistentContainer.viewContext    if context.hasChanges {        do {            try context.save()        } catch {            // Replace this implementation with code to handle the error appropriately.            // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.            let nserror = error as NSError            fatalError(\"Unresolved error \\(nserror), \\(nserror.userInfo)\")        }    }}이전에는 core data를 프로젝트 만들때 체크를 하면 App Delegate 에 위와 같은 코드가 뜬것같다.혹시나 필요할까 싶어 복사해두었다.2. Entities 생성하기  Entity(Table) : Class  Attributes : Properties로 생각하면 된다.Entity 이름은 우리가 만든 Item.swift와 똑같이 Item으로 이름을 맞춰주자.class Item : Codable {        var title : String = \"\"    var done : Bool = false}현재 이렇게 되어있는데, Attributes를 위와 동일하게 추가해준다.그리고 아래와 같이 Optional로 할지 안할지도 설정이 가능하다.이렇게 Attributes를 만들었다면.Item.swift파일은 지워주자.그리고 코어 데이터가 복잡해지면 (멀티 스레딩이 필요하다면)  해당부분으로 사용하지 않으면 에러가 발생 할 수 있으므로, 모듈도 꼭 세팅해주자.3. App Delegate 안에있는 내부 자료 이해.4. CRUD 사용해보기1. CreateContext를 만들어준다.AppDelegate.persistentContainer.viewContext를 사용하고 싶지만 불가능하다.그래서 다운캐스팅을 통하여 접근을 해줘야 한다.let context = (UIApplication.shared.delegate as! AppDelegate).persistentContainer.viewContextpersistentContainer는 일종의 SQL DB가 된다. 우리가 만든 데이터를 보관하는 공간으로 사용한다.그리고 context를 통해 CRUD 행동을 수행하게 된다@IBAction func addButtonPressed(_ sender: UIBarButtonItem) {                var textField = UITextField()                let alert = UIAlertController(title: \"Add New Todoey Item\", message: \"\", preferredStyle: .alert)                let action = UIAlertAction(title: \"Add Item\", style: .default) { (action) in            // what will happen once the user clicks the Add Item button on our UIAlert                                    let newItem = Item(context: self.context)            newItem.title = textField.text!            newItem.done = false                        self.itemArray.append(newItem)                        self.saveItems()        }                alert.addTextField { (alertTextField) in            alertTextField.placeholder = \"Create new item\"            textField = alertTextField        }                alert.addAction(action)                present(alert, animated: true, completion: nil)    }add 버튼을 눌렀을때 작동하게 끔 newItem부분을 바꿔주고.func saveItems() {                do {                        try context.save()                    } catch{              print(\"Error saving context \\(error)\")        }    }saveItems() 함수도 이렇게 바꿔주자.아직 Read부를 구현하지않아 버튼을 눌러 추가해도 보이지는 않지만.방금전 ㄹㄹㄹㄹ 을 추가했는데, 이젠 여기서 확인 할 수는 없다.왜냐하면 Encoder, decoder를 사용하지 않았기 때문이다.저 경로에 낚이지 말자.viewDidload에 ` print(FileManager.default.urls(for: .documentDirectory, in: .userDomainMask))` 이부분을 제거하니 에러가 발생한다.파일생성경로를 알려주다보니 없어서는 안되는 부분이다. 참고하자2. Read현재 plist 파일이 생성되는 경로에서 Documents가 아닌, Library → Application Support로 가게되면, sqilte파일이 생성되어있는걸 알 수 있다.이걸 실행해보자sqlite파일을 열수있는 프로그램을 설치하면 볼 수 있는데, 난 DB Browser for SQLite 라는 앱을 사용했다.데이터를 보면?이렇게 값을 추가하고 Refresh를 해보면 입력이 잘 되는걸 알 수있다.이제 loadItems 함수를 수정해보도록 하겠다.NSFetchRequest 를 사용하는데 보통 swift는 데이터 형식을 유추할수 있는데, 이녀석은 직접 언급을 해줘야한다.let request : NSFetchRequest&lt;Item&gt; = Item.fetchRequest()func loadItems () {                let request : NSFetchRequest&lt;Item&gt; = Item.fetchRequest()        do {            itemArray = try context.fetch(request)        } catch {            print(\"Error fetching data from context \\(error)\")        }      }request가 제대로 이뤄진다면, itemArray에 데이터를 담을 것이다.그리고 viewDidload 안에 함수를 호출하자실행해보면?잘 나온다.3. UpdateitemArray[indexPath.row].setValue(\"\", forKey: \"title\") setValue를 사용하여 업데이트 할 수 있다.4. Delete삭제는 아래 두줄을 추가해주면되는데,이때 주의 해야할건 아래 두줄의 순서이다.먼저 배열에서 제거를하고 하게되면 outofrange에러가 발생하므로 DB를 먼저 제거하고 그 이후에 배열에서 제거해주도록 하자.context.delete(itemArray[indexPath.row])itemArray.remove(at: indexPath.row)"
  },
  
  {
    "title": "Todoey (2)",
    "url": "/posts/Todoey-(2)/",
    "categories": "Udemy, Todoey",
    "tags": "",
    "date": "2024-03-25 05:53:00 +0900",
    





    
    "snippet": "UserDefault 사용하기  UserDefault란 일종의 로컬 DB라고 볼 수 있다.  사용자 기본 설정과 같은 단일 데이터 값에 적합하다.          대량의 유사한 데이터를 저장해야할때는 sqlite 같은 DB를 쓰는게 더 좋다.        [데이터, 키]로 데이터를 저장한다, plist파일에 저장된다.사용하기 위해서 오브젝트를 만들어 ...",
    "content": "UserDefault 사용하기  UserDefault란 일종의 로컬 DB라고 볼 수 있다.  사용자 기본 설정과 같은 단일 데이터 값에 적합하다.          대량의 유사한 데이터를 저장해야할때는 sqlite 같은 DB를 쓰는게 더 좋다.        [데이터, 키]로 데이터를 저장한다, plist파일에 저장된다.사용하기 위해서 오브젝트를 만들어 준다.let defaults = UserDefaults.standardUserDefaults에 저장하기.self.defaults.set(self.itemArray, forKey: \"TodoListArray\")하지만 실행시켜도 현재는 의미가 없다.userdefault에 저장이 되지만 쓸수가 없기 때문이다.UserDefaults 경로 확인하기.AppDelegate.swilf에서 didFinishLaunchingWithOptions 함수를 사용하여 경로를 확인할것이다.print(NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true).last! as String)이렇게 작성해준다.앱을 실행하자마자 위와같이 경로가 나온다.파인더를 통해 해당 경로를 확인해보자.이때 마지막에 Documents 그대로 가지말고 Library → Preferences에 가면 plist파일로 있다.더블클릭해서 실행해보면 우리가 추가한 값이 그대로 나온다.그렇다면 왜 테이블뷰에 보이지 않았을까?viewDidLoad에 세팅하기.` itemArray = defaults.array(forKey: “TodoListArray”)`이렇게 우리가 만든 배열에 userdefaults배열을 담아주자.옵셔널 바인딩을 해주어 더 안전하게 할수도 있다.이때 다운캐스팅을할때, 해당 배열에 어떤 데이터 타입을 담는지 정확하게 알고 다운캐스팅을 하도록 하자.override func viewDidLoad() {        super.viewDidLoad()                    if let items = defaults.array(forKey: \"TodoListArray\") as? [String] {            itemArray = items        }    }값을 새로 추가해보면?새로 추가된 내용이 보이는걸 알 수 있다.UserDefaults는 여러 데이터 타입을 담을 수 있다.하지만 단점은 어떤 값을 가져오려면, plist안에 있는 모든 내용을 불러와야하기때문에 효율적이지 못하다.즉, 많은양의 데이터를 저쟝하면 시간이 많이 소요된다.UserDefaults를 DB처럼 사용할 수는 있지만, DB는 아니다. 앱의 속도에 영향을 주기때문이다.문제 확인.화면을 벗어날만큼 배열에 많은 값들이 들어가면 해당 내용을 보기위해 스크롤을 하게되면Cell이 재사용 되면서 이상하게 보이게 된다.let cell = tableView.dequeueReusableCell(withIdentifier: \"ToDoItemCell\", for: indexPath)즉 첫번째 셀이 롤업하고 더 이상 보이지 않을때 재사용 가능한 셀로 다시 돌아온다.문제 해결은 뒤로 두고우선 Model화 시켜보자.Model화class Item {        var title : String = \"\"    var done : Bool = false}var itemArray = [Item]()Reload 메서드 추가하여 갱신되게 해주기.override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        //print(itemArray[indexPath.row])                if itemArray[indexPath.row].done == false {            itemArray[indexPath.row].done = true        } else {            itemArray[indexPath.row].done = false        }                tableView.reloadData() //new                tableView.deselectRow(at: indexPath, animated: true)    }계속 리로드 하게 해주었다if itemArray[indexPath.row].done == false {            itemArray[indexPath.row].done = true        } else {            itemArray[indexPath.row].done = false        }이코드를 한줄로 간결하게 해보겠다.itemArray[indexPath.row].done = !itemArray[indexPath.row].done추가 문제 해결하기테스트겸 추가를 해보니 App Crash가 발생한다.아까는 잘되던게 안되던 이유는 바로배열의 데이터 타입을 바꿔주었기 때문이다String → Itemuserdefault의 한계가 나타났다.그래서 UserDefaults는 아주 간단한 타입의 데이터를 쓸때만 사용하는것이 좋다.우리가 만든 Item이라는 사용자 지정 유형이나, 사용자 지정 개체는 사용 할 수 없기 떄문이다.이젠 다른 방식으로 바꿔야할 때가 되었다.NSCoder를 사용한 데이터 인코딩ViewDidLoad에 다음과 같이 적어준다.let dataFilePath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)실행해보니 다음과 같이 경로가 출력이 된다.아까와 같은 경로가 출력이 된다.해당 경로에 우리가 쓸 plist파일을 만들자let dataFilePath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first?.appendingPathComponent(\"Items.plist\")실행하면?self.defaults.set(self.itemArray, forKey: \"TodoListArray\") 이젠 사용하지 않으니 지워주자.해당위치에 이제는 encoder를 사용할것이다.let encoder = PropertyListEncoder()do {                let data = try encoder.encode(self.itemArray)                try data.write(to: self.dataFilePath!)            } catch{                    print(\"Error encoding itemn array, \\(error)\")            }이전에 JSON 디코딩 할때와 비슷하게 실패할수도 있는경우가 생기기에, do-catch문으로 작성한다.그리고 위에 try가 2개인데, 아래는 데이터를 작성할때 실패할 경우가 있으므로 try로 작성한다.그리고 Model 도 Encodable 프로토콜을 채택해준다.class Item : Encodable 그리고 작동 테스트를 하면잘된다.userdefault와의 차이는 위의 사진을 참고하자.하지만 아직 체크 항목에 대한 이슈는 해결되지 않았다.저장하는 부분만 따로 함수로 만들어 준다.func saveItems() {        let encoder = PropertyListEncoder()                do {            let data = try encoder.encode(itemArray)            try data.write(to: dataFilePath!)        } catch{                print(\"Error encoding itemn array, \\(error)\")        }    }데이터를 담고있는 plist load하기 (디코딩)함수를 하나 만들어준다.이걸 사용할건데 url은 바로 우리가 이전에 설정해둔 경로로 한다.역시나 실패할 경우를 대비해 try를 사용해주고 옵셔널 바인딩도 사용해준다.Decoding을 할때는 데이터 타입을 명시해준다.func loadItems () {        if let data = try? Data(contentsOf: dataFilePath!) {            let decoder = PropertyListDecoder()            do {                itemArray = try decoder.decode([Item].self, from: data)            } catch {                print(\"error\")            }        }    }위와 같이 적어준다.이때 [Item].self 처럼 뒤에 self를 붙여주자.그리고 ViewDidload에 해당 함수를 호출하면?작동이 잘 된다."
  },
  
  {
    "title": "Todoey (1)",
    "url": "/posts/Todoey-(1)/",
    "categories": "Udemy, Todoey",
    "tags": "",
    "date": "2024-03-25 02:53:00 +0900",
    





    
    "snippet": "TableView 만드는것은 생략.Cell 선택했을때 회색화면 잠깐 보였다가 사라지게 하기.override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        print(itemArray[indexPath.row])                tab...",
    "content": "TableView 만드는것은 생략.Cell 선택했을때 회색화면 잠깐 보였다가 사라지게 하기.override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        print(itemArray[indexPath.row])                tableView.deselectRow(at: indexPath, animated: true) // new    }      before        after  Cell 옆에 체크마크 표시하기1. StoryBoard2. FunctiondidSelectRowAt 함수에 적을 것이다.특정 인덱스 경로에 대한 셀정보를 가져오기위해 다음과 같이 적는다tableView.cellForRow(at: indexPath)tableView.cellForRow(at: indexPath)?.accessoryType = .checkmark                                   ----------------------------다음과 같은 부분을 추가해준다.그리고 실행해보면?일단 누르면 체크표시가 뜨는건 된다.하지만 다시 클릭했을때 사라져야하는데 그것은 아직 되지 않는다.3 해당 문제 해결하기if tableView.cellForRow(at: indexPath)?.accessoryType == .checkmark {                tableView.cellForRow(at: indexPath)?.accessoryType = .none                } else {        tableView.cellForRow(at: indexPath)?.accessoryType = .checkmark}현재 체크가 된것이라면 none으로, 그게 아니라면 체크하라는 내용을 추가하자.잘된다.Bar Button 기능구현하기.추가하는 부분은 생략.1. UIAlertController 호출하기.UIAlertController를 호출하여 기능을 구현해준다.@IBAction func addButtonPressed(_ sender: UIBarButtonItem) {                let alert = UIAlertController(title: \"Add New Todoey Item\", message: \"\", preferredStyle: .alert)                let action = UIAlertAction(title: \"Add Item\", style: .default) { (action) in            // what will happen once the user clicks the Add Item button on our UIAlert            print(\"Success!\")        }        alert.addAction(action)                present(alert, animated: true, completion: nil)    }잘 나온다.2. Alert에 TextField 추가하기 alert.addTextField { (alertTextField) in            alertTextField.placeholder = \"Create new item\"        }3. TextField에 입력한 값 출력하기@IBAction func addButtonPressed(_ sender: UIBarButtonItem) {                var textField = UITextField()                let alert = UIAlertController(title: \"Add New Todoey Item\", message: \"\", preferredStyle: .alert)                let action = UIAlertAction(title: \"Add Item\", style: .default) { (action) in            // what will happen once the user clicks the Add Item button on our UIAlert            print(textField.text) // new                    }                alert.addTextField { (alertTextField) in            alertTextField.placeholder = \"Create new item\"            textField = alertTextField        }                alert.addAction(action)                present(alert, animated: true, completion: nil)    }혹시라도 현재 추가한 부분을 alert.addTextField나 다른부분에 추가할 경우 해당 값을 받아 올 수 없다.왜냐하면 지금 아래 부분은 alert를 표현하는 부분이다. 즉 행동 이후에 대한 내용이 아닌, 행동과정에 대한 부분이다.우리가 textfield를 입력한 이후의 시점에 대해선 action 오브젝트 내부에서 실행이 되어야 한다.4. TextField 추가한값을 배열에 저장하기print문 대신 append를 사용하여 추가하자.하지만 값을 추가해도 현재 보이지는 않는다.1. Break Point 사용현재 추가하는 부분에 Break Point를 주었다.그리고 추가를 하면내가 설정한 부분에서 작동이 멈추고 이렇게 바뀐다.lldb 콘솔에 itemArray를 확인해보면?이렇게 나온다이때 step over 를 해주고 다시 print 해보면?값이 추가되어있는걸 알 수 있다.단지 TableView에 보이지만 않을 뿐이다.그래서 값을 추가하고 다시 불러오기 위해서 tableView.reloadData()를 배열 추가한 부분 뒤에 적어주자.잘 나온다."
  },
  
  {
    "title": "FlashChat (8)",
    "url": "/posts/FlashChat-(8)/",
    "categories": "Udemy, FlashChat",
    "tags": "",
    "date": "2024-03-24 16:53:00 +0900",
    





    
    "snippet": "TextField 입력시 키보드가 가리는것 방지하기.IQKeyboardManager를 사용해서 방지를 해보려 한다.링크에 들어가면 관련 내용이 있다.바로 이런 기능을 사용하는데 있어 도움을 준다.1. 해당 라이브러리 추가하기.이번엔 Package Manager를 이용해서 추가를 하려한다.전에도 언급했지만, 해당 github repository에 들어갔...",
    "content": "TextField 입력시 키보드가 가리는것 방지하기.IQKeyboardManager를 사용해서 방지를 해보려 한다.링크에 들어가면 관련 내용이 있다.바로 이런 기능을 사용하는데 있어 도움을 준다.1. 해당 라이브러리 추가하기.이번엔 Package Manager를 이용해서 추가를 하려한다.전에도 언급했지만, 해당 github repository에 들어갔을때 아래와 같은 파일이 없다면 지원이 되지 않는다.물론 제작자가 보통은 설치하는 방법을 적어두기에 그걸 따르면 되긴 한다.      File, Add Package~ 클릭        해당 깃 주소 복사.        해당 프로젝트를 확인후 설정. (POD X)        추가 확인.  2. 추가한 라이브러리 설정하기.이 부분을 AppDelegate.swift 파일에 적용시켜 주면 된다/3. 작동확인확인 완료.4. 부가적인 기능 설정 및 수정링크 를 들어가면 관련 프로퍼티 설정이 있는데 AppDelegate.swift 안에서 설정을 해주면 된다.수신자, 발신자 구분하기현재는 나만 확인할수있는 1인 메신저 형식으로 되어있는데,이제는 발신자와, 수신자를 구분해보도록 하자.1. ImageView 추가. 하기우선 Message.xib 파일로 가서 Right Image View를 복사해서 다시 그자리에 붙여넣긴한다.그냥 클릭하고 Command + c / Command + v로 해결하자그리고 제일 오른쪽에 있던 이미지를 왼쪽으로 붙여준다.이렇게 해주면 된다.그리고 outlet을 하나 만들어 주자.leftImageView로 해주었다.2. 함수를 수정하여 발신자/수신자 구분하기다시 ChatVC로 돌아가서 cellForRowAt 관련 함수를 수정을 해줄것이다.우선 메세지 내용을 담은 변수를 하나 만들어 준다.let message = messages[indexPath.row]그리고 발신자가 현재 로그인 된사람인지를 if조건으로 나타내고여러 조건을 설정해준다.if message.sender == Auth.auth().currentUser?.email {            cell.leftImageView.isHidden = true            cell.rightImageView.isHidden = false                        cell.messageBubble.backgroundColor = UIColor(named: K.BrandColors.lightPurple)            cell.label.textColor = UIColor(named: K.BrandColors.purple)        }그리고 다른사람이 보냈을 경우를 생각하여 else에는 그와 반대로 작성해주자.그리고 작동을 확인하면?그리고 새로운 계정을 만들어서 들어가보면?이렇게 다르게 표현이되는걸 볼 수 있다.이상태에서 메세지를 보내보면?잘 구분이 되는것을 볼 수 있다.3. 추가될때 자동으로 아래로 스크롤 되게 하기.값이 추가될때마다 loadMessages함수가 트리거 된다.그러므로 이부분을 수정하면 되겠다.우리는 tableView.scrollToRow 메서드를 사용할 것이다.이 메서드를 사용하기전, IndexPath를 먼저 초기화 해준다.IndexPath의 row에는 message 배열의 마지막 인덱스를 항상 가져와야하므로 message.count-1 을 해준다, section에는 현재 테이블이 하나만 있으므로 0을 해주면 된다.참고하자.테스트해보니 잘된다.4. 내용 입력후 TextField 초기화 하기.현재는 메세지를 보내면 textField에 내용이 그대로 담겨있다.그래서 새로운 메세지를 보낼때마다 지워야한다@IBAction func sendPressed(_ sender: UIButton) {                if let messageBody = messageTextfield.text, let messageSender = Auth.auth().currentUser?.email {            db.collection(K.FStore.collectionName).addDocument(data: [                K.FStore.senderField : messageSender,                K.FStore.bodyField : messageBody,                K.FStore.dateField : Date().timeIntervalSince1970                            ]) { (error) in                if let e = error {                    print(\"There was an issue saving dat to firestore. \\(e)\")                } else {                    print(\"Successfully saved data\")                    self.messageTextfield.text = \"\" // new                }            }        }            }해당부분만 추가해주면 된다 :)이때 그냥 추가하는게 아니라비동기 방식으로 처리하게 하여 메인 스레드에서 처리하게 해야한다.즉 DispatchQueue를 사용해야한다.DispatchQueue.main.async {                        self.messageTextfield.text = \"\"                    }이렇게 해주자.5. Navigation bar 디자인 변경우선 StoryBoard 에서 Navigation Bar를 클릭하자Inspector에서 Bar Tint의 색상을 변경하면모든 Navigation Bar의 색이 변경이 된다.Title에 관한건 아래 사진 을 참고하여 바꾸면 된다.Back 버튼의 색상은 여기서 바꾼다.6. 초기 화면의 Nav Bar 색상 비활성화.RootVC인 WelcomeVC에 다음과 같이 적어주자 override func viewWillAppear(_ animated: Bool) {        navigationController?.isNavigationBarHidden = true    }하지만 문제는다른 화면에서도 이렇게 되어버린다.즉 우리가 해둔 설정이 계속 이어지게 되는것이다. override func viewWillDisappear(_ animated: Bool) {        navigationController?.isNavigationBarHidden = false    }이렇게 반대속성을 바로 적어주면다음 화면으로 넘어가면 Nav Bar가 다시 생기게 된다.함수의 Docs내용을 잠깐 보면super를 사용하라고 되어있다.super.viewWillAppear(animated) 이걸 꼭 적어주자.변경이 안될때 하는 방법Xcode 13.0 이후부터 발생하는 문제라고 한다.1. StoryBoard2. viewDidLoad()에 설정let appearance = UINavigationBarAppearance()\t\tappearance.configureWithTransparentBackground()\t\tappearance.backgroundColor = UIColor.systemBlue\t\tappearance.titleTextAttributes = [.foregroundColor: UIColor.white]\t\tnavigationItem.standardAppearance = appearance\t\tnavigationItem.scrollEdgeAppearance = appearanceViewController LifeCycle참고 자료를 한번 읽어 보는걸 추천한다.1. viewDidLoad() 실행  모든 IBOutlet, IBAction 등 뷰와 관련된 모든 개체가 연결되며 엑세스가 가능해진다.  다만 viewDidLoad()는 뷰가 생성되었을때 딱 한번만 호출된다.2. viewWillAppear() 실행  화면에 뷰가 나타나기 직전에 호출된다.          사용자는 아직까진 아무것도 볼 수 없다.        특정 UI를 숨기거나, 보여주기엔 좋은 시점.  위의 예시에선 Nav Bar를 숨기게 했다.3. viewDidAppear() 실행  유져가 화면을 볼 수 있게 된다.4. viewWilldisappear() 실행  View가 사라지기 직전에 호출된다.  애니메이션을 멈추고 UI모습을 바꾸고 싶다면 사용한다.  위의 예시에선 Nav Bar를 숨겼던것을 다시 보이게했다.5. viewDidDisappear() 실행  이 시점에서는 이미 view는 사라졌다."
  },
  
  {
    "title": "3주차 과제 (6)",
    "url": "/posts/3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(6)/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-23 00:13:00 +0900",
    





    
    "snippet": "Lv41. UISegmentedControl 사용하여 기능 구현하기전에 유튜브로 어떻게 구현하나 7분짜리 짧은걸 잠깐 봤다.생각보다 어렵지 않아서 바로 도전 했다.디자인은 이렇게했다. @IBAction func changeSegAction(_ sender: UISegmentedControl) {        let selectedIndex = send...",
    "content": "Lv41. UISegmentedControl 사용하여 기능 구현하기전에 유튜브로 어떻게 구현하나 7분짜리 짧은걸 잠깐 봤다.생각보다 어렵지 않아서 바로 도전 했다.디자인은 이렇게했다. @IBAction func changeSegAction(_ sender: UISegmentedControl) {        let selectedIndex = sender.selectedSegmentIndex                switch selectedIndex {                    case 0 : // 전체        case 1 : // 진행중        case 2 : // 완료        default : // 즐겨찾기        }                    }이런식으로 각 인덱스에 해당하는 버튼이 눌러 졌을때 원하는 것을 보여주게 하려고 한다.우선 전체는 그냥 getData() 그대로 가져오면 될 것 같다.1,2,3에 해당하는 건 별도로 DBManager에서 parameter만 바꿔 값을 가져오게 하면 될것 같아서DBManager에 함수를 새로 만든다.func getSpecificData(whereCondition : String, condition : Bool) {        dbModel.db.collection(Constants.collectionName).whereField(whereCondition,isEqualTo: condition).getDocuments { (querySnapshot, error) in                        self.dbModel.lists = []                        if let e = error {                print(e)            } else {                                if let snapshotDocuments = querySnapshot?.documents {                    for doc in snapshotDocuments {                        let data = doc.data()                        if let listId = data[Constants.Fire.fireId] as? Int                            , let listTitle = data[Constants.Fire.fireTitle] as? String                            , let listBool = data[Constants.Fire.fireBool] as? Bool                            , let listFav = data[Constants.Fire.favBool] as? Bool {                            let list = ToDoModel(id: listId, title: listTitle, isComplete: listBool, isFav: listFav)                                                        self.dbModel.lists.append(list)                            self.delegate?.sendDB(data: self.dbModel.lists)                        }                                            }                }            }        }    }이렇게 해줬다.하도 Docs를 많이보고 그만큼 시도해서 그런가, 어떻게 함수를 구현해야할지 밑그림은 다 그려졌다.whereCondition, codition 이렇게 파라미터로 나누었다.whereCondition의 경우는 어떤 걸 기준으로 소팅할건지에 대한 내용을 담을것이고,condition은 그 기준에서 true/false 같은 구분값을 정하는 파라미터로 했다. @IBAction func changeSegAction(_ sender: UISegmentedControl) {        let selectedIndex = sender.selectedSegmentIndex                switch selectedIndex {                    case 0 : // 전체            dbManager.getData()        case 1 : // 진행중            dbManager.getSpecificData(whereCondition: Constants.Fire.fireBool, condition: false)        case 2 : // 완료            dbManager.getSpecificData(whereCondition: Constants.Fire.fireBool, condition: true)        default : // 즐겨찾기            dbManager.getSpecificData(whereCondition: Constants.Fire.favBool, condition: true)        }                    }그 결과 만들어진것이 바로 위의 함수.실행해보자.잘되네그리고 segment를 클릭할때마다 정렬이 document이름 순으로 보여진다.그래서 order 붙여 id순으로 정리하려고하니 안되고, 콘솔에 뭐가 프린트 되었다.주소가 나와서 그걸 복붙해보니 다음과 같다.그래서 해당조건에 맞게 두개를 추가 해주었다.이렇게 두개가 복합쿼리인데, 알아서 생성을 해주는데 시간이 좀 걸렸다.다시 확인해보니 이제는 내가 원하는대로 된다.다만 현재 문제점이라면, 소팅한상태에서 값을 추가하면,자동으로 getData() 함수가 돌아가기에 소팅한 페이지에서 전체 데이터가 보여지게 된다.이부분을 걱정하긴 했는데, 고민을 해야할듯하다.하나 더 발견하였다.아무것도 조건이 해당하지 않는것을 가져오면 이전 기록이 그대로 유지가된다.이부분은 DB를 사용하면서 값을 얻어올때 뭔가 작동을 안하는것 같은데 배열 초기화를 해줘도 안된다.뭔가를 담으려고 하긴하는건가… DB이런부분은 패스하고 진행하는게 맞는듯하다.2. UITableViewDelegate 사용하여 기능 구현UITableViewDelegate 를 사용하여 셀이 선택되었을때 관련된 내용을 좀 나와보게 하는건 어떨까? 라는 생각이 들어서, 그 부분을 좀 구현해보려고 한다.UITableViewDelegate는 생각만 했던건데, 뭔가 기능이 많아져서 조잡해 보이기도 할것같으나, 공부적인 측면에서는 여러가지를 활용하는게 좋아 구현해보기로 하였다.extension TableViewController : UITableViewDelegate {        func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        print(\"\\(indexPath.row) selected\")    }    }다음과 같이 하여 일단 클릭을 했을때 응답을 제대로 하는지 부터 체크를 해보기로 하였다.클릭했을때 응답이 잘 되었다.다음에 계속…복기.클로저 함수를 조금 더 공부 해서 alert부분을 깔끔하게 정리하고싶다."
  },
  
  {
    "title": "3주차 과제 (5)",
    "url": "/posts/3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(5)/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-22 15:00:00 +0900",
    





    
    "snippet": "Lv41. Edit 기능 구현func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {                let deleteBtn = UIContext...",
    "content": "Lv41. Edit 기능 구현func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {                let deleteBtn = UIContextualAction(style: .normal, title: \"Delete\") { (UIContextualAction, UIView, success: @escaping (Bool) -&gt; Void) in                        let alert = self.alertManager.makingAlert(title: \"삭제하기\", message: \"정말 삭제하실 건가요?\")            let ok = UIAlertAction(title: \"OK\", style: .destructive, handler: { _ in                                self.dbManager.deleteCell(number: self.lists[indexPath.row].id)                tableView.beginUpdates()                self.lists.remove(at: indexPath.row)                tableView.deleteRows(at: [indexPath], with: .fade)                tableView.endUpdates()                            })                        let cancel = self.alertManager.makingCancel(title: \"Cancel\")            alert.addAction(ok)            alert.addAction(cancel)            self.present(alert,animated: false)            success(true)                    }                let editBtn = UIContextualAction(style: .normal, title: \"Edit\") { (UIContextualAction, UIView, success: @escaping (Bool) -&gt; Void) in                        let alert = UIAlertController(title: \"수정하기\", message: \"수정할 내용을 간단하게 입력해주세요.\", preferredStyle: .alert)                        let ok = UIAlertAction(title: \"OK\", style: .default, handler: { _ in                                 self.dbManager.editTitle(number: self.lists[indexPath.row].id, title: alert.textFields?[0].text ?? \"Sample\")            })                        let cancel = self.alertManager.makingCancel(title: \"Cancel\")            alert.addTextField { (textField: UITextField!) in                 textField.placeholder = \"수정할 내용을 입력하세요.\"                textField.autocorrectionType = .no                textField.spellCheckingType = .no            }            alert.addAction(ok)            alert.addAction(cancel)            self.present(alert,animated: false)                    }                deleteBtn.backgroundColor = UIColor.systemRed        editBtn.backgroundColor = UIColor.systemGreen                return UISwipeActionsConfiguration(actions: [deleteBtn,editBtn])    }edit만 더 추가해주었다.크게 어려운점은 없었다.하면서 Firebase 점점 익숙해져간다.그리고 삭제할때도 alert를 줘서 함부로 삭제하지 않게 한번 더 물어보는 식으로 했다.이부분은 딱히 설명할 내용이 없다.작동화면2. Fav 기능 구현디자인은 앞에 별을 주었다.그런데 autolayout이 꼬여서 수정, 확인을 반복하면서 30분 넘게 걸린듯하다.작업 하기전 사전 준비를 해준다override func awakeFromNib() {        super.awakeFromNib()        finSwitch.setOn(false, animated: true)        favView.image = UIImage(systemName: \"star\") //new        selectionStyle = .none            }        override func prepareForReuse() {        super.prepareForReuse()        finSwitch.setOn(false, animated: false)        toDoLabel.attributedText = nil        favView.image = UIImage(systemName: \"star\") //new            }초기화를 해주었다.그리고 함수도 만들어 주었다.특별히 버튼은 이미지로 해주었다.func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {                let favBtn = UIContextualAction(style: .normal, title: \"\") { (UIContextualAction, UIView, success: @escaping (Bool) -&gt; Void) in            if self.lists[indexPath.row].isFav == false {                self.dbManager.editFav(number: self.lists[indexPath.row].id, isFav : true)            } else {                self.dbManager.editFav(number: self.lists[indexPath.row].id, isFav : false)            }            tableView.beginUpdates()            tableView.endUpdates()            success(true)        }                favBtn.backgroundColor = .init(patternImage: #imageLiteral(resourceName: \"Image\"))                return UISwipeActionsConfiguration(actions: [favBtn])    }그리고 tableview 함수부도 약간의 내용을 추가해주었다.let favBool = lists[indexPath.row].isFav if favBool == true {    cell.favView.image = UIImage(systemName: \"star.fill\")    } else {    cell.favView.image = UIImage(systemName: \"star\")}작동을 해보면?잘되는데버튼이 왜 저모양일까…기능은 되니까 나중에 하는걸로..나머지 기능은 주말에 해봐야겠다.오늘은 여기까지."
  },
  
  {
    "title": "3주차 과제 - Class화",
    "url": "/posts/3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-%ED%81%B4%EB%9E%98%EC%8A%A4%ED%99%94/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-22 11:00:00 +0900",
    





    
    "snippet": "약간 번외 편으로 저번과 마찬가지로 클래스화를 해야할 필요성을 느껴서과제의 최소단계는 해두었기에, 클래스화를 좀 해서 보기 좋게 하려고 한다.튜터님과 대화를 해봐도, 지금 이타이밍에 조금 더 간소화를 해보는게 좋다고 하셨다.요지는 이것이다  VC가 몰라도되는 내용을 현재 가지고 있는 건 아닌지?지금상황에선. 유일하게 하나가 있는데,바로 DB이다.그래서...",
    "content": "약간 번외 편으로 저번과 마찬가지로 클래스화를 해야할 필요성을 느껴서과제의 최소단계는 해두었기에, 클래스화를 좀 해서 보기 좋게 하려고 한다.튜터님과 대화를 해봐도, 지금 이타이밍에 조금 더 간소화를 해보는게 좋다고 하셨다.요지는 이것이다  VC가 몰라도되는 내용을 현재 가지고 있는 건 아닌지?지금상황에선. 유일하게 하나가 있는데,바로 DB이다.그래서 이부분을 DBManager로 별도로 만들어 관리를 하려고 한다.DBManager, DBModel라는 파일을 만들어 주었다.DB이부분에 이제 담을것이다.우선 코드는 DB와 관련된건 전부 이관을 하였다.코드는 생략!이젠 어떻게 list를 전달하고 받을것이냐의 문제만 남은듯 하다.고민을 하다가 Delegate를 사용해서 전달하는게 맞다고 판단을 했다.그래서 DBManager에 프로토콜과 델리게이트를 만들어 주었다.protocol sendLists {    func sendDB (data : [ToDoModel])}var delegate : sendLists?이렇게 전달 할 준비는 끝이 났다.하지만 문제가 발생했다.DB를 가져오지만 화면에는 표시가 안된다.TableVC getData 함수를 다시 확인해 보았다.func getData () {       dbManager.getData()    DispatchQueue.main.async {        self.tableView.reloadData()        }    }그냥 함수를 잘라내고 옮긴다음 저렇게 적었는데 지금생각하니 아찔하다.일단 저기에 print(lists)를 하니 [] 이게 떠버린다.즉 값이 없다는 뜻이다.값이 어디갔을까 싶어 생각을 해보다 delegate로 가져온곳에 있겠다 싶었다.생각해보니 getData는 리턴을 하지않기에 의미가 없었다.extension TableViewController : sendLists {        func sendDB(data: [ToDoModel]) {        lists = data    }    }여기에 프린트를 해보니 콘솔에 값이 출력된다.즉 값을 얻어오고있다는 의미였다.그래서 저기에다가DispatchQueue.main.async {            self.tableView.reloadData()        }넣어야겠다고 생각을 하고 작동을 해보니 바로 된다.getData 함수도 바로 지워버렸다.그리고 dbManager.getData() 해당부분만 viewDidload에 해서 값을 받아오게 하였다.그리고 var lists : [ToDoModel] = [] 이것을 어떻게 해야할까 고민을 하다 튜터님께 여쭤보러갔다.현재 TableVC에 변수로 선언해둔 유일한 녀석이다.튜터님께선 먼저 왜 이걸 지울것인지에 대한 질문을 했는데, 그에대한 답변을 하면서 내가 생각한 딜레마적인 요소를 대답했다.내가 생각하고있는 딜레마는 이것이었다.  tableVC가 알고있을 필요가 없는것들은 최대한 배제한다.      딜레마는 lists변수를 지우자니 TableView와 관련된 내용은 VC가 알아야한다. 즉 지우면 안된다.  TableVC입장에선 필요가 없는 변수이지만 TableView입장에선 필요한 내용이었다.튜터님도 지금상황에서 내수준에서는 이대로 두는게 더 좋다고 판단을 하셨다.이부분은 일단 그대로 두도록 하자.이렇게 클래스화도 끝.class화를 하면서 이전에 적었던 diagram에 변화가 생겼다."
  },
  
  {
    "title": "3주차 과제 복기 (Fin)",
    "url": "/posts/3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-Remind/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-22 11:00:00 +0900",
    





    
    "snippet": "그전까지는 이렇게까지 복기를 하지는 않았는데, 이제는 실제로 UIKit도 다루다 보니.이런식으로 글로 작성을 해두면 나중에 볼때도 그당시의 기분이나, 느낀점을 다시 회상할 수 있을 것같아서 글을 남긴다.Diagram현재 진행은 이렇게 되었다.Lv.1사실 1단계는 디자인적인 측면이 어서. 크게 어렵지는 않았다.물론 처음에는 Custom Cell이 아닌,...",
    "content": "그전까지는 이렇게까지 복기를 하지는 않았는데, 이제는 실제로 UIKit도 다루다 보니.이런식으로 글로 작성을 해두면 나중에 볼때도 그당시의 기분이나, 느낀점을 다시 회상할 수 있을 것같아서 글을 남긴다.Diagram현재 진행은 이렇게 되었다.Lv.1사실 1단계는 디자인적인 측면이 어서. 크게 어렵지는 않았다.물론 처음에는 Custom Cell이 아닌, Prototype Cell을 추가하여 사용하려고 하였으나, uiswitch라던가 그런걸 라벨링을 해주고 좀 장기적인 측면에서는 custom cell을 만들어 사용하는게 더 좋을 것이라는 생각이 들어 선회하게 되었다.아무래도 uiswitch를 코드로 addview이런식으로 하다보니, 뭔가 코드가 지저분해지지 않을까? 라는 생각을 했는데, 실질적으로 switch를 custom으로 만들었어도 tableview 함수내에서 쓰는 코드는 비슷비슷 했다.  before : addview로 cell 추가  after : Custom Cell 추가Lv.2가장 오랜 시간이 걸렸던 파트1. UIAlertController한번 정리를 쭉 하고 시작하니, 크게 구현하는데 있어 문제를 느끼지 않았다.확실히 그냥 찾으면서 주먹구구식으로 하는것 보다는 이렇게 한번 정리를 하고 시작하면, 에러가 나도 어느 부분인지 생각을 하게되고 대처를 할 수 있게 된다.이것에 대한 생각은 여기까지.2. UISwitch취소선을 구현하는데 있어 약간의 시간이 걸리긴 했다.처음에 커스템 셀이아닌 일반 적인 StoryBoard에 추가하는 방식으로 진행을 했을때, 생각해보니 Label을 만들지 않고 진행했다는 걸 알았는데, 그건 이미 Custom Cell을 구현하고 나서였다…구글링을 하다보면 내배켐 이전 기수에서도 똑같이 진행했던 과제같은데, 일부러 그 자료는 안봤다.그런것에 의존을 하고싶지 않았다. 그래서 더 시간이 걸렸던것 같은데, addTarget을 구현하여, on/off에 따른 함수 호출이었으나, 문제는 이것이었다.현재 호출한 Cell의 indexrow는 그래서 누구?그것과 관련된 자료를 찾다가 Stackoverflow에 나와 비슷한 문제를 올렸던 사람이 있었다.관련자료를 보고 indexpath에 관한 글을 조금 더 찾아 보았다.과제를 진행하면서 관련된 글을 적지 않았는데, 아래에 간단하게 정리를 해보겠다.1. IndexPath우리가 tableview하면 아무렇지 않게 쓰는 IndexPath와 IndexPath.row이걸 알기위해 Table의 cell이 어떻게 이뤄지는지를 봐야한다.이렇게 table을 section으로 구분을 짓게 되고,그안에 있는 하나의 cell을 row로 판단하게 된다.이걸 이해하자마자 바로 UISwitch에 대한 문제가 해결되었다.3. TableView가장 오랜시간이 걸렸고 밤새도록 수없이 많은 검색을 해도, 자료를 찾아봐도 힘들었던 부분.우선 TableView 구현 자체에는 큰 어려움은 없었다.구현을하고 시도를 하는것 자체는 좋았다.문제는 바로 셀이 reload될때, 이전 cell의 위치가 가지고 있는 정보를 가지고 있어 뒤죽 박죽으로 된다는 것이다.가장 시간이 오래걸렸던 부분이다, 내스스로 어떻게든 해보려고 검색과 여러 시도를 다해봤지만 안되었다.그러다 로컬의 문제인가? 싶어서 DB로 전환까지 가게한 녀석이다.DB전환은 이후에 하려고 했는데 본의아니게 미리해버린셈이 되었다.그래도 미리해버리니, 기능을 추가할때 마다 DB도 같이 하게되니 오히려 이게더 괜찮은데? 라는 생각도 든다.그리고 해봤지만 역시나 안되었다. DispatchQueue를 사용해서 비동기식으로 전화하면 되지 않을까? 라는 생각으로 DB화를 시켰던건데 나의 생각은 틀렸었다.결국 튜터님께 갔는데, 듣자마자 아차싶었다.바로 일종의 Cache 개념인데, 그전에 셀의 캐시가 남아있어, 내가 원하는대로 보여지지 않았던 것이다.튜터님은 prepareForReuse 메서드를 알려주셨고, 해당기능을 셀을 만든쪽에 오버라이딩 해서 써보라고 하셨다.그리고 switch를 어떻게 사용하는지 알려주셔서 그대로 적용을 했다.그렇게 또 잘되나 싶었다.하지만 이젠 취소선이 문제였다.근데 이건 똑같은 개념이라, 내가 prepareForReuse 에 대해 좀 더 알아보고 해야겠다는 생각이 들었다.생각히보니 너무 알려주신대로 곧이곧대로 내가 사용을 하는 것 같았다.그래서 이런저런 자료를 찾다보니, 이녀석들도 초기화를 해줘야한다는 글을 본것같다.이번에도 역시 아차싶었다. uiswitch도 결국 false로 해준게 초기화를 그렇게 해준건데, 취소선도 초기화를 해주면 되겠다 싶어toDoLabel.attributedText = nil을 추가 해줬다.바로 해결이 되었다.Lv.3삭제를 하는 기능이었다, 구현자체는 문제가 안되었다.하지만 이젠 DB에 대한것이 문제였다.1. DB documents 재설정그전에 Documents naming을 할때 즉, DB를 사용하게 되면 Document가 생기고 그곳에 내가 입력한 값이 하나씩 등록이 된다.처음에는 위와 같은 방식으로 그대로 사용을 하다가, Uiswitch를 할때 Query를 사용해야하는데, 그부분 사용을 해보려고 했는데 Query라는 데이터 타입으로 나오는것을 처음에 어떻게 사용해야할지 몰라서, 그냥 Documents를 id값과 동일하게 하면 되겠다 라고 생각하여 그렇게 진행을 했다.documents와 id값 그대로가니 삭제기능을 구현하기 전까지는 문제가 없었다.삭제기능을 구현하자마자 indexpath.row와 id값이 달라지는 경우가 발생하면서, 내가 구현했던 것들이 모두 꼬이기 시작하는 사태가 발생하였다.사실 삭제기능을 구현하면서 이미 꼬일줄은 알고 있었다. 일단은 삭제 기능을 먼저 구현하고 DB를 다시 고치자라는 생각으로 삭제기능을 우선적으로 구현하였고,바로 DB접근을해서 id값으로 Document 네이밍을 하던것을 고대로 다시 원복했다. (위의 사진과 같은 방식)그리고 실패했던 쿼리를 다시사용해서 어떻게든 해결해야겠다라는 생각을 갖고 다시 쿼리로 접근하였다. Sql을 이미 써봤기에, 무조건 이건 Query로 접근해서 해야한다는 생각 밖에 없었다.  Field가 id인 곳에서, 내가 선택한 그 셀의 id를 어떻게 가져와야할까?이게 근본적인 문제였고, 곰곰히 생각을 해보았다.그리고 바로 깨달았다.내가 구현해둔 getData 함수에는, DB로 부터 받아온 정보를 lists라는 배열에 담아둔다.거기엔 id,title,isComplete 이렇게 3가지의 정보를 가지고있는다.그리고 값이 추가 삭제가 되어도, 그값이 가지고 있는 기본틀은 변하지 않는다.즉 내가 원하는 indexPath.row의 위치에 해당하는 lists의 id값을 가져오면 되는 부분이었다.즉 lists[indexPath.row].id 를 하게 되면 그 행에 해당하는 DB로 부터 로컬개념에 저장된 id값을 반환할수 있던 것이었다.이것을 깨닫자마자 모든 문제가 해결이 되었다.그렇게 Lv.3 구현은 끝나게 되었다.튜터님과 대화를 하다 userdefault localDB가 있다고 하신다.주말에 해봐야겠다.LV.4 ~ 5MindmapDiagramlv.4, 51. 수정기능이부분은 크게 문제가 없었다.2. 즐겨찾기기능이부분 역시도 크게 문제가 없었다.3. segControl사용하는데 있어서는 크게 문제가 안되었다. 다만 SegControl을 사용함으로써, 여러 다중쿼리들을 만들어야했고,Firebase는 이런 다중쿼리를 실행하려면 별도로 콘솔에 링크를 알려주는데 그링크들 들어가서 쿼리를 추가해줘야 구현이 가능했다.4. 새로운 화면 보여주기이부분 역시 크게 어렵지는 않았다.5. SideView 구현이부분은 코드이해를 하기엔 시간이 없어 우선 코드를 그대로 차용 할 수 밖에 없었다.주말에 별도로 해보면서 여러 테스트를 좀 해봐야 하지 않을까 싶다.6. ImagePicker처음에는 너무 기능이 과한건가 싶었지만 사용해보면서 별거 없다는 생각이 들었다.edit일때는 무조건edit이미지만 사용해야한다는걸 알게 되었다.UIImagePicker는 곧 사라지므로 PHPicker를 앞으로 사용해 봐야겠다.7. SideViewTableView구현함수나 코드적인부분에서는 아무런 문제가 없는데 왜 보이지 않을까 생각을 했다.새로운 테스용 VC를 만들어서 했을때는 아무런 문제가 없는데 왜 안되는지 내 지식으로는 해결이 되지 않았다.그래서 결국 튜터님에게 찾아갔고, 너무나 어이없는 실수를 하고야 말았다.바로 AutoLayout설정에 대한 문제였다.총 4개를 코드로 구현하였는데, 3개는 bottom Constraints를 주지 않아도 보여서 tableview 아무렇지 않게 복붙을 해버리고 말았다.tableview에 bottom부분이 없는것 같다고 튜터님이 말씀하셔서 바로 적용해보니 보였다.그리고 AutoLayout을 함에 있어서 아직 스스로 부족함이 많다는 것 또한 알게 되는 기회였다.이것도 주말에 좀 연습을 해보면서 스스로 다듬어야겠다는 생각이 든다.8. DB 예외 처리쿼리에 해당이 되지 않는 내용을 조회할때 이전에 값이 그대로 보여지는 경우가 있었다. 그래서 하나하나 역으로 print를 하면서 찾아가기 시작했다.그리고 해당 부분을 발견하여 바로 예외 처리를 해주었다.하지만 값이 소팅된 상태에서 값이 추가 될때 그 소팅된 그상태로 추가되는 모습을 보여주고 싶은데 그부분은 아직 능력 부족으로 구현하지 못한게 아쉽다.제출시 작성한 내용.1. 과제를 구현하며 어려웠던 점이나 도움이 필요한 부분이 있다면 작성해주세요.  어려웠던 점          Cell 갱신시 Cell이 꼬이던 문제우선 TableView.reload 가 말그대로 모든걸 refresh하고 reload하는 개념이라고 생각을 했는데,uiswitch를 on -&gt; off로 바꾼상태에서 셀을 추가하게되면 cell이 꼬이는걸 확인하고 어떻게 해볼까 스스로 고민을 하다가 결국 튜터님을 찾아가서 해결을 했었다. 보이는부분도 일종의 cache개념이 남는다는걸 생각하지 못했다.            SideViewController 구현 WWDC의 자료도 보고 했지만, 스스로 하기엔 아직까지 부족함이 많아 결국 복사해서 붙여넣기하는 방법을 선택하고 말았다. 선호하지 않는 방법인데 워낙 구현하고 싶었던 기능이라 어쩔수없이 하고야 말았다.주말에 해당부분은 별도로 연습을해서 내것으로 만들어야겠다는 생각이 들었다.        DB에서 변경이 생겼을때 전체 DB가 다시보여지던 현상.어떤 값을 소팅한 상태에서, DB의 내용에 변경이 생겼을경우 (CRUD) 이때 전체 값이 다보이는 문제가 발생하였다.우선 임시조치로, 값이 변경될때 전체탭이 활성화 되게는 했지만, 이부분은 조금 더 공부를 해야하지 않을까 라는 생각이 들었다.        Code로 UI를 구성했을때 Autolayout문제로 tableview가 안보이던 문제tableview 제외하고 3개를 구현했는데, bottom부분을 주지않은상태에서 잘되어서 그대로 tableview도 해보았지만 보이지 않았다. 혼자서 별 시도를 다하다가 결국 튜터님께 찾아갔고, TableView의 Bottom부분을 주지않아서 보이지 않았던 문제라고 하셨다. 기본적인걸 망각했었다.        디자인 문제확실히 구현하면서 나의 미적감각은 좋지 않다라는것을 다시한번 인지할수있는 계기가 되었다. 그러다보니 디자인 보다는 최대한 기능을 여러개 만들어보자는 생각으로 구현을 하려 노력했다.디자인이 제일 어려운것같다.  2. 기술 질문 1 - 모든 View Controller 객체의 상위 클래스는 무엇이고 그 역할은 무엇인지 아는대로 작성해보세요.상위 클래스는 UIViewController이다.역할은데이터 변화에 따라 view 컨텐츠 업데이트view와의 사용자 상호작용에 응답view를 리사이징하고 전체적인 인터페이스의 레이아웃 관리앱 내에서 (다른 view controller를 포함한) 다른 객체와의 조정3. 기술 질문 2 - 옵셔널과 옵셔널 해제에 대해 아는대로 작성해보세요.옵셔널 : 값이 있을수도 없을 수도 있다는 의미.옵셔널 해제 :  강제 옵서녈 해제          ! 를 붙여 옵셔널타입을 강제로 해제하는 방법으로 사용하기는 편리하나, 예외처리가 안되어있는 경우 App Crash발생으로 인한 치명적인 단점이 존재        옵셔널 바인딩          if let 을 사용하여 해당 값이 존재하는 경우, 없는 경우를 통해 (1)의 방법의 위험성에서 벗어나, 안전하게 진행이  가능.        옵셔널 체이닝          일부 속성이나 메서드에 접근을할때 ?를 붙여 접근을 한다. 하나라도 nil이 있다면 리턴값 또한 nil이 된다.        옵셔널 병합연산자 사용          ?? 를 사용하여 nil인 경우 default값을 설정 해두어 nil을 방지한다.      4. 기술 질문 3 - UIKit에서 스토리보드로 UI 구현하기와 코드로 UI 구현 시의 각각의 장단점을 설명하시오[Storyboard]  장점          내가 구현하고자 하는 UI를 직관적으로 알 수 있다.      Component를 간편하게 추가 할 수 있다.        단점          AutoLayout을 설정할때 조금이라도 벗어나면 알람이 뜬다.      일일이 Code에 링크를 해줘야한다.      [Code]  장점          코드 구성에 대해 심도있는 공부가 가능.      여러 프로퍼티에 대해 바로바로 원하는대로 설정이 가능.        단점          코드로 되어있다보니 이해가 필요      Autolayout이 잘못될경우 아예 보이지 않는다.      preview를 사용하지 않으면 어떤 화면인지 내가 실행해 보지 않는 이상 알 수 없다.      5. 이번 챕터에서 학습을 하며 알게된 기술, 지식이 있다면 어떤 것이 있는지 작성합니다. (1)화면 전환시 상황에 맞는 데이터 전달 방식을 다시한번 리마인드하게 되었다.그전에 해당 내용에 대해 정리를 하면서는 그냥 이런게 있고, 내가 이런걸 공부했구나 라는 정도 였다면, 이번에 내가 자기주도적으로 코드를 구성하면서 공부했던 부분을 더 확고히 다질수있었다.예를 들면 Database로 부터 값을 전달 받을때는 Delegate를 통해서 VC에서 전달을 받게 하였고, A VC 에서 B VC로 화면전달이 될때는 프로퍼티를 통해서 데이터 전달을 하였는데, 왜 이런 상황에서 써야하는지 뭔가 판단을 나 스스로 할 수 있었다.      Delegate를 통한 데이터 전달보통 Delegate로 데이터를 전달하려는 주체가 어디로 내가 값을 보낼지 모르는 상태일때 사용을 하는데, 이때 프로토콜을 데이터를 보내려는쪽에 만들고, 데이터를 받는쪽에서 해당 프로토콜을 채택하면서 delegate를 통해 데이터를 받게 된다. 받는 쪽에서는 delegate = self를 통해 vc가 위임을 받는 주체임을 명시 해줘야한다.        프로퍼티를 통한 데이터 전달위의 경우와 달리 현재 VC가 화면전환시 어느 VC로 갈지를 이미 아는 상태에서 사용을 한다.목적지 VC를 객체화 하고, VC의 프로퍼티에 직접적으로 값을 전달하여 화면전환하면서 값을 넘겨받는 형태로 이루어진다.  두 방법의 공통점은 데이터 전달이지만, 가장 큰 차이점은 두 Class간의 관계이다.첫번째는 서로 모르는 상태이고, 두번째는 한 클래스는 무조건 상대 클래스에 대해 알고있다.6. 이번 챕터에서 학습을 하며 알게된 기술, 지식이 있다면 어떤 것이 있는지 작성합니다. (2)DataBase를 사용하면서 누가 작성한 것을 참고하기보다, 제공해주는 Docs를 통해서 쿼리문을 작성해보았다.값을 가져오는 부분에 있어서는 크게 문제가 없었으나, 쿼리문에 하나도 해당하지 않을 경우에 대한 예외처리를 하는것이 문제였다. 이때 하나하나 의심가는 위치에 print를 붙여 실행하기를 반복, 일종의 역추적으로 최하위 부분에서 상단으로 올라가는 Bottom to Top방식을 사용했는데, 결국 어느 위치에서 예외처리를 해야할지 알게 되었다.셀에 남아있는 일종의 Cache를 리셋해주는 prepareForReuse를 배웠다.해당부분은 튜터님을 통해 알게된 내용인데, 해당부분에대해 들으면서 VC의 생명주기에 대해서는 강의와 공부를 통해 알고있었던 부분인데 Cell의 생명주기도 있다는것은 생각지도 못했다.어떤 프로젝트를 하던지 TableView 반드시 사용할수밖에 없을것 같다는 생각이 드는데, Cell의 생명주기에 대해 새로 배우다보니, Initialization이 얼마나 중요한지 다시한번 생각하게 된다."
  },
  
  {
    "title": "3주차 과제 (4)",
    "url": "/posts/3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(4)/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-21 15:00:00 +0900",
    





    
    "snippet": "Lv3Todo 삭제 기능 구현하기키워드 : UITableView, UIButton  Todo 삭제하기 기능          Todo List에서 특정 Todo를 삭제할 수 있도록 화면과 기능을 자유롭게 구성해보세요.      삭제하는 2가지 방식                  예시와 같이, Todo를 스와이프하여 삭제 - UITableView의 기능 ...",
    "content": "Lv3Todo 삭제 기능 구현하기키워드 : UITableView, UIButton  Todo 삭제하기 기능          Todo List에서 특정 Todo를 삭제할 수 있도록 화면과 기능을 자유롭게 구성해보세요.      삭제하는 2가지 방식                  예시와 같이, Todo를 스와이프하여 삭제 - UITableView의 기능          Todo Cell에 삭제 UIButton을 구성                    삭제 기능 구현하기.우선 일반적으로 많이 쓰는 슬라이드를 통해 삭제를 해보려고한다.눌러서 어떤 창을 통해(ex: Alert, OtherVC) 하는 방법도 있겠지만,일단 눌러서 이벤트를 발생시키는건 Lv4에서 필요할것 같아서 슬라이드로 대체한다.swipe Button 구현하기왼쪽에 나올지 오른쪽에 나올지 정해야하는데  왼쪽 : leading  오른쪽 : trailing오른쪽엔 이미 UISwitch가 있어서 왼쪽에 하는게 나을것같다.그리고 여기서 사용해야하는것이. UIContextualAction 이다.func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {                let deleteBtn = UIContextualAction(style: .normal, title: \"Delete\") { (UIContextualAction, UIView, success: @escaping (Bool) -&gt; Void) in                success(true)        }                deleteBtn.backgroundColor = UIColor.systemRed        return UISwipeActionsConfiguration(actions: [deleteBtn])    }func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -&gt; UISwipeActionsConfiguration? {                        let deleteBtn = UIContextualAction(style: .normal, title: \"Delete\") { (UIContextualAction, UIView, success: @escaping (Bool) -&gt; Void) in                                tableView.beginUpdates()                self.lists.remove(at: indexPath.row)                self.db.collection(Constants.collectionName).document(String(indexPath.row)).delete()                tableView.deleteRows(at: [indexPath], with: .fade)                tableView.endUpdates()                success(true)                            }                        deleteBtn.backgroundColor = UIColor.systemRed            return UISwipeActionsConfiguration(actions: [deleteBtn])        }이렇게 구현해주었다.Documents 값 가져와서 변경하기.하지만 이제 고민을 해야하는것이 생겼다.지금까지는 내용을 삭제하지 않았기에 getID로 가져온 값이 indexPath.row 그리고 sender.tag와 같았는데 이제는 그렇지 않다.여러 고민을 해본결과 그냥 docs 그대로 가져오기로 결정했다.@objc func changeMode (sender : UISwitch) {        guard let currentCell = tableView.cellForRow(at: IndexPath(row: sender.tag, section: 0)) as? ToDoListCell else { return }                // switch를 조작했을때의 cell을 가져온다.        if sender.isOn {            db.collection(Constants.collectionName).whereField(\"id\",isEqualTo: sender.tag).getDocuments { (querySnapshot, error) in                if let e = error {                    print(e)                } else {                    if let documents = querySnapshot?.documents {                        for doc in documents {                            let docuId = doc.documentID                            self.db.collection(Constants.collectionName).document(docuId).setData([Constants.Fire.fireBool : sender.isOn],merge: true)                        }                    }                }            }            currentCell.toDoLabel.attributedText = currentCell.toDoLabel.text?.strikeThrough() // 취소선            lists[sender.tag].isComplete = sender.isOn // DB를 로컬에 저장한 lists에도 반영        } else {            db.collection(Constants.collectionName).whereField(\"id\",isEqualTo: sender.tag).getDocuments { (querySnapshot, error) in                if let e = error {                    print(e)                } else {                    if let documents = querySnapshot?.documents {                        for doc in documents {                            let docuId = doc.documentID                            self.db.collection(Constants.collectionName).document(docuId).setData([Constants.Fire.fireBool : sender.isOn],merge: true)                        }                    }                }            }            currentCell.toDoLabel.attributedText = currentCell.toDoLabel.text?.removeStrike()            lists[sender.tag].isComplete = sender.isOn        }            }상당히 내용이 길어졌지만.매커니즘은 uiswitch을 조작했을때의 그 행에 대한 값을 가져와서 그 행에대한 documents ID를 얻어오는 방식으로 했다.작동이 잘되니 만족.제대로 DB와 통신을 하고 있다.어떻게 해야하나 고민을 하다가 갑자기 아이디어가 떠올랐다너무 해당 값을 의식 했던것같다.어차피 우리가 데이터를 가져오면 lists에 담기때문에, 거기에 담긴 id값을 반환하면 되는 해결되는 부분이었다.잘된다.Lv3 까지 완료."
  },
  
  {
    "title": "3주차 과제 (3)",
    "url": "/posts/3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(3)/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-21 07:00:00 +0900",
    





    
    "snippet": "이건 나중에 하려고했던건데, reloadData가 이상한것 같아서먼저 DB를 구축하고 작업을 하려고 한다.전반적인 내용은 FlashChat글에 적혀있으니 참고하면 될것같다.이번엔 CocoaPods를 쓰지 않았고 package를 등록하였다.추가완료.기본 설정.초기화 코드를 추가하자.설명에 다 나와있으므로 그대로 하면 된다.import하는데 찾을수가 없다...",
    "content": "이건 나중에 하려고했던건데, reloadData가 이상한것 같아서먼저 DB를 구축하고 작업을 하려고 한다.전반적인 내용은 FlashChat글에 적혀있으니 참고하면 될것같다.이번엔 CocoaPods를 쓰지 않았고 package를 등록하였다.추가완료.기본 설정.초기화 코드를 추가하자.설명에 다 나와있으므로 그대로 하면 된다.import하는데 찾을수가 없다고 뜬다면아래와 같이 필요한걸 추가해주면 된다.DB 만들기Docs에 나온대로 하면 된다.자세한건 이전에 서술했으니 pass 하도록 하겠다.출력값이 나오므로 잘 연결이 되었다.DB에 값을 추가하기.func makeAlert () {                let alert = UIAlertController(title: \"Table View 추가해보기\", message: \"내용을 입력해주세요\", preferredStyle: .alert)                let ok = UIAlertAction(title: \"OK\", style: .default, handler: { _ in // ok를 눌렀을때 내가 텍스트 필드에 입력한 내용을 등록하게 한다.                        self.db.collection(Constants.collectionName).addDocument(data: [Constants.Fire.fireId : self.id, Constants.Fire.fireTitle : alert.textFields?[0].text ?? \"Sample\", Constants.Fire.fireBool : false]) { (error) in                if let e = error {                    print(\"error : \\(e.localizedDescription)\")                } else {                    print(\"Upload Done\")                }            }            self.id += 1        }) // id 1씩 추가                let cancel = UIAlertAction(title: \"Cancel\", style: .cancel)        alert.addTextField { (textField: UITextField!) in // textField 추가                    textField.placeholder = \"여기에 입력해주세요\"                    textField.autocorrectionType = .no                    textField.spellCheckingType = .no                }        alert.addAction(ok)        alert.addAction(cancel)        self.present(alert,animated: false)    }이젠 배열에 넣는것이 아닌 위처럼 db에 직접 등록하게 만들었다.일단 업로드가 되는지 확인 해보자.업로드 테스트라 적고 등록을 시도 해보았다.느낌이 좋다.전달도 잘 되었다.조금 더 작성을 해줘서 테스트 해보자.DB 값 불러오기. func getData () {        db.collection(Constants.collectionName).order(by: Constants.Fire.fireId)            .addSnapshotListener { (querySnapshot, error) in            self.lists = []                        if let e = error {                print(\"error : \\(e)\")            } else {                if let snapshotDocuments = querySnapshot?.documents {                    for doc in snapshotDocuments {                        let data = doc.data()                        if let listId = data[Constants.Fire.fireId] as? Int                            , let listTitle = data[Constants.Fire.fireTitle] as? String                            , let listBool = data[Constants.Fire.fireBool] as? Bool {                                                        let list = ToDoModel(id: listId, title: listTitle, isComplete: listBool)                                                        self.lists.append(list)                                                        DispatchQueue.main.async {                                self.tableView.reloadData()                            }                        }                                        }                }            }        }    }생각보다 내용이 길지만, DB서버에 접근하여 우리가 원하는 Documents를 가져와서 배열에 집어넣어 tableview로 표시하게 하는 내용이다,등록부분 id값 수정현재는 0이 기본값이고 하나 등록할때마다 1씩 올라가게 해주었는데, DB에 연동시킨만큼 이제는 DB에서 id의 최댓값을 가져와서 해야한다.하지만 어차피 실행하자마자 db로 가져와서 배열에 등록하므로, 배열에서 가져오기로 했다.func getID () -&gt; Int {                if lists.count != 0 {            return self.lists[lists.count-1].id + 1        } else {            return 0        }            }func makeAlert () {                let alert = UIAlertController(title: \"Table View 추가해보기\", message: \"내용을 입력해주세요\", preferredStyle: .alert)                let ok = UIAlertAction(title: \"OK\", style: .default, handler: { _ in // ok를 눌렀을때 내가 텍스트 필드에 입력한 내용을 등록하게 한다.                        self.db.collection(Constants.collectionName).addDocument(data: [Constants.Fire.fireId : self.getID() // new                                                                            , Constants.Fire.fireTitle : alert.textFields?[0].text ?? \"Sample\"                                                                            , Constants.Fire.fireBool : false]) { (error) in                if let e = error {                    print(\"error : \\(e.localizedDescription)\")                } else {                    print(\"Upload Done\")                }            }        })                let cancel = UIAlertAction(title: \"Cancel\", style: .cancel)        alert.addTextField { (textField: UITextField!) in // textField 추가                    textField.placeholder = \"여기에 입력해주세요\"                    textField.autocorrectionType = .no                    textField.spellCheckingType = .no                }        alert.addAction(ok)        alert.addAction(cancel)        self.present(alert,animated: false)    }TableView초기화 작업.uiswitch 부분이 이상해서 튜터님께 여쭤보러 갔는데, 딱 내가 막혔던 부분을 잘 뚫어 주셨다.내가만든 Cell Class에 prepareForReuse라는 함수를 오버라이딩 해서 재정의 하여 사용했어야 했다.override func prepareForReuse() {        super.prepareForReuse()        finSwitch.setOn(false, animated: true)    }이렇게하면 기본적으로 갱신하면 false로 뜰것이다.isComplete update현재 스위치를 on/off하면 값이 바뀌지만 이게 DB에 저장되지는 않는다.이제는 저장이 되게 수정 해보자.대부분 특정 documents를 직접 지정하여 수정하는 방식으로 진행이 되어가고 있었다.나는 그런 특정 documents를 알려면 웹사이트로 밖에 알 수가 없기에 document를 직접 네이밍 해주기로했다.func makeAlert () {         let alert = UIAlertController(title: \"Table View 추가해보기\", message: \"내용을 입력해주세요\", preferredStyle: .alert)                let ok = UIAlertAction(title: \"OK\", style: .default, handler: { _ in // ok를 눌렀을때 내가 텍스트 필드에 입력한 내용을 등록하게 한다.                        self.db.collection(Constants.collectionName).document(String(self.getID())).setData([Constants.Fire.fireId : self.getID()                                                                            , Constants.Fire.fireTitle : alert.textFields?[0].text ?? \"Sample\"                                                                            , Constants.Fire.fireBool : false]) { (error) in                if let e = error {                    print(\"error : \\(e.localizedDescription)\")                } else {                    print(\"Upload Done\")                }            }        })                let cancel = UIAlertAction(title: \"Cancel\", style: .cancel)        alert.addTextField { (textField: UITextField!) in // textField 추가                    textField.placeholder = \"여기에 입력해주세요\"                    textField.autocorrectionType = .no                    textField.spellCheckingType = .no                }        alert.addAction(ok)        alert.addAction(cancel)        self.present(alert,animated: false)    }기존엔 adddocuments였지만, 내가 직접 getID로 바꿨다. 즉 0, 1, 2, 3, 4, 5, 6 이런식으로 각 인덱스에 맞게 해주면 접근이 편하기 때문이었다.테스트를 해보니 아주 잘된다. @objc func changeMode (sender : UISwitch) {        guard let currentCell = tableView.cellForRow(at: IndexPath(row: sender.tag, section: 0)) as? ToDoListCell else { return }                // switch를 조작했을때의 cell을 가져온다.        if sender.isOn {            db.collection(Constants.collectionName).document(String(sender.tag)).setData([Constants.Fire.fireBool : sender.isOn],merge: true)            currentCell.toDoLabel.attributedText = currentCell.toDoLabel.text?.strikeThrough()            lists[sender.tag].isComplete = sender.isOn        } else {            db.collection(Constants.collectionName).document(String(sender.tag)).setData([Constants.Fire.fireBool : sender.isOn],merge: true)            currentCell.toDoLabel.attributedText = currentCell.toDoLabel.text?.removeStrike()            lists[sender.tag].isComplete = sender.isOn        }            }sender.tag와, getID는 같은 숫자로 가기때문에 접근이 더 편리해졌다.이젠 값을 바꿀수 있게 되었다.하지만 문제가 생겼다.취소선과 버튼이 제멋대로 놀기 시작했다.문제 해결튜터님께 질문을 해봤는데override func prepareForReuse() {        super.prepareForReuse()        finSwitch.setOn(false, animated: false) // 이전엔 true     }버튼이 제각각 놀았떤건 animated가 true로 되어있어서 생긴 문제였다.해당 부분은 false를 해주니 잘된다.이젠 취소선이 따로 노는것인데 그부분은 tableview에 cellForRowat 부분에 on / off 에대한 초기정보를 담지 않아서 생긴 문제인것 같다고 하셨다.이부분을 좀 보완해야겠다.func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        let cell = tableView.dequeueReusableCell(withIdentifier: Constants.cellIdentifier, for: indexPath) as! ToDoListCell        let cellTitle = lists[indexPath.row].title                cell.toDoLabel.text = cellTitle        cell.finSwitch.isOn = lists[indexPath.row].isComplete        cell.finSwitch.tag = indexPath.row        cell.finSwitch.addTarget(self, action: #selector(changeMode), for: .valueChanged)        if cell.finSwitch.isOn == true { //new            cell.toDoLabel.attributedText = cell.toDoLabel.text?.strikeThrough()        } else {            cell.toDoLabel.attributedText = cell.toDoLabel.text?.removeStrike()        }        return cell}               우선 cell에 attributedText에 관한 정보를 주었다.하지만 한두번 되다가 다시 적용이 안되었는데, 아래 참고자료를 보다가 깨달음을 얻었다.override func prepareForReuse() {        super.prepareForReuse()        finSwitch.setOn(false, animated: false)        toDoLabel.attributedText = nil //new    }이부분을 nil로 함으로써 초기화가 제대로 되었다.TableView 너무 쉽게 생각했다.주말에 Cell의 생명주기에 대해 좀 파고 들어봐야 할 것 같다.DB로 하면 될줄 알았는데, 알고보니 일종의 cache 문제였다.그래도 이후에 할거 미리 구현해뒀고, 배운것을 기반으로 내 나름대로 Docs를 보면서 이것저것 건드려보고 했으니 만족.이로써 Lv2 클리어.참고 자료https://velog.io/@loinsir/iOS-Cell%EC%9D%98-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0"
  },
  
  {
    "title": "FlashChat (7)",
    "url": "/posts/FlashChat-(7)/",
    "categories": "Udemy, FlashChat",
    "tags": "",
    "date": "2024-03-20 17:53:00 +0900",
    





    
    "snippet": "Firestore 사용해보기Firestore에 대한 Docs이다 참고하자.Database 구축하기Firebase의 Console로 들어가서 Firestore Database를 선택해주자.Realtime DB는 이전에 있었던것이라고 한다.DB를 만들어 보자.만들기를 누르면 다음과 같이 지역설정이 뜨는데 us-central로 해주자(난 모르고 Seoul을...",
    "content": "Firestore 사용해보기Firestore에 대한 Docs이다 참고하자.Database 구축하기Firebase의 Console로 들어가서 Firestore Database를 선택해주자.Realtime DB는 이전에 있었던것이라고 한다.DB를 만들어 보자.만들기를 누르면 다음과 같이 지역설정이 뜨는데 us-central로 해주자(난 모르고 Seoul을 했다. 어차피 테스트용도로 크게 상관은 없다.)그러면 모드 설정이 나오는데,프로덕션모드를 하면 타사에서 읽기 쓰기가 거부된다. 즉 우리가 테스트를 하기가 너무 어려워진다.테스트 모드는 한달동안 자유롭게 쓸 수 있다.테스트모드로 하고 만들어주자.그다음 다시 xcode로 돌아와서 Cloud Firestore를 초기화 해줘야한다.설명은 Docs에 있다.func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {            FirebaseApp.configure()            let db = Firestore.firestore()            print(db)            return true}db가 잘 나오는지 print를 넣어주었다.잘나온다.값이 안나온다면? Terminal에서 pod --version을 입력하여 버젼을 확인해보고 업데이트를 해줘야한다.그리고 다시 설치를 해봐야한다. sudo gem install cocoapods이게 프린트가 안되면 나중에 App Crash가 발생하기 때문이다.보내기 버튼 구현하기 (DB에 데이터 전달)    @IBAction func sendPressed(_ sender: UIButton) {                let messageBody = messageTextfield.text            }메세지의 내용은 textField의 값으로 가져온다.그리고 누가 보냈는지를 알기 위해 즉 아래에 있는 sender를 알기 위해서 다시 Firebase Docs로 돌아가자.struct Message {    let sender : String // email 형식으로    let body : String // 유져가 보내는 Message 내용}다음과 같이 옵셔널 바인딩도 해주었다.@IBAction func sendPressed(_ sender: UIButton) {                if let messageBody = messageTextfield.text, let sender = Auth.auth().currentUser?.email {                    }            }그런데 아직 내용은 적지 않았다, 왜냐 저부분은 이제 Database에 접근을 해야하기 때문에 위에 상수로 하나 db 오브젝트를 만들어 준다.let db = Firestore.firestore()이때 Firestore를 찾지못한다고 하면 import FirebaseFirestore 를 적어 import 해주자.이제 내용을 적어주자.@IBAction func sendPressed(_ sender: UIButton) {                if let messageBody = messageTextfield.text, let messageSender = Auth.auth().currentUser?.email {            db.collection(K.FStore.collectionName).addDocument(data: [K.FStore.senderField : messageSender, K.FStore.bodyField : messageBody]) { (error) in                if let e = error {                    print(\"There was an issue saving dat to firestore. \\(e)\")                } else {                    print(\"Successfully saved data\")                }            }        }            }우선 문자열로 된 내용들은 전부 상수화 시켜서 오타가 나지않게 하는건 이미 그전에 언급했으므로 제외하고,collection안에는 우리가 이름을 정해서 넣게 되는데 “messages”를 적었다.그리고 data는 보낸사람과 내용을 담기위해 Dictionary형식을 사용하였고,[K.FStore.senderField : messageSender, K.FStore.bodyField : messageBody] 이건[“sender” : messageSender, “body” : messageBody] 이것을 상수화 해서 적은것이다.그리고 뒤에 에러가 발생하였을 경우 출력하기 위해 Closure를 사용했다.작동해보자.그런데 입력해보려고하니…이렇게 짤려버린다. 이건 이따가 다시 보완하기로 하고 작동 테스트를 먼저 해보자.전달이 잘 되었다.그리고 DB를 확인해보면?여기도 등록이 잘 된것을 확인할 수 있다.DB 받아오기DB를 받아오려면 앱이 실행될때 받아와야 하므로 viewDidLoad에 함수를 호출하는 식으로 하면 된다.우선 안에 loadMessages() 를 적어주고 그 다음 함수를 구현하는 코드를 작성해보자.여러 클래스에 대한 타입은 Docs에 있으니 참고하자func loadMessages() {        messages = []                db.collection(K.FStore.collectionName).getDocuments { (querySnapshot, error) in            if let e = error {                print(\"There was an issue retrieving data from Firestore. \\(e)\")            } else {                if let snapshotDocuments = querySnapshot?.documents {                    for doc in snapshotDocuments {                        print(doc.data())                    }                }            }        }    }배열을 초기화 해주었다. 이제는 우리가 작성된 값을 테스트를 하는것이 아니기 때문이다.Documents에 우리가 가져와야할 DB가 있는데, 그곳에 접근해서 데이터를 가져오는 것이다.querySnapshot과 error 모두 옵셔널 타입이므로 옵셔널 바인딩을 해준다.에러가 발생하면 에러메세지를 출력하고, 그렇지 않은경우 데이터를 가져오게 한다.해당 내용을 출력해보면 아래와 같이 나온다.값을 잘 받아오고 있다.여기서 우리가 메세지를 한번 더 입력해보자.역시나 DB서버와의 통신이 잘 되는걸 알 수 있다.이제 저 doc을 더 세분화 해서 나눠 보자.let data = doc.data()    if let sender = data[K.FStore.senderField] as? String, let body = data[K.FStore.bodyField] as? String {  }이렇게 했는데 보니까 옵셔널 바인딩과 다운캐스팅을 다 해주었다 왜냐하면Data Type이 Any? 이기 때문이다. 그래서 우리가 쓰는 타입에 맞게 다운 캐스팅을 해주고 옵셔널 바인딩을 해준것이다.함수를 이렇게 작성해주었다.func loadMessages() {    messages = []            db.collection(K.FStore.collectionName).getDocuments { (querySnapshot, error) in        if let e = error {            print(\"There was an issue retrieving data from Firestore. \\(e)\")        } else {                if let snapshotDocuments = querySnapshot?.documents {                    for doc in snapshotDocuments {                        let data = doc.data()                        if let messageSender = data[K.FStore.senderField] as? String, let messageBody = data[K.FStore.bodyField] as? String {                            let newMessage = Message(sender: messageSender, body: messageBody)                            self.messages.append(newMessage)                        }                    }                }            }        }    }우리가 받아오는 값을 새로운 오브젝트에 집어넣고 그걸 배열에 다시 넣는 것이다.작동이 되는지 확인해보자.분명히 배열에 집어넣었는데 보이지 않는다?self.tableView.reloadData() 이걸 입력 하지 않아서 그렀다.말그대로 tableView를 refresh 해주는 것이다.그리고 이럴때 자주 사용하면 좋은게 우리가 뭔가 UI가 바뀔때 (여기선 TableView를 갱신할때)그리고 이렇게 클로저 내부에서 작업을 할때 우리가 이전에 사용했던 DispatchQueue를 통해서 비동기 작업을 해주는 것이 더 좋다.다시 작동확인을 해보자.데이터를 잘 받아온다.하지만 아직 메세지를 보내면 업데이트는 안된다.DB 자동 갱신현재 우리가 사용중인 getDocuments는 수동적이다. 무슨말이냐 하면우리가 호출하기전에는 해당 메서드가 자동으로 트리거 되지 않는다는 것이다.관련 내용이 있는 Docs이다.해당 내용을 참고하여 코드를 수정한다.getDocuments → addSnapshotListener 로 바꿔주자.그리고 실행해보자업로드는 되는데, 기존에 내역이 그대로 유지된 채로 추가가 되어버린다.즉 화면 전체가 리셋이 되고 반영이 되지 않고있다.문제 해결배열 초기화의 위치만 바꿔 주면 된다. func loadMessages() {            // messages = [] before    db.collection(K.FStore.collectionName).addSnapshotListener { (querySnapshot, error) in                    self.messages = [] // new                    if let e = error {            print(\"There was an issue retrieving data from Firestore. \\(e)\")        } else {                if let snapshotDocuments = querySnapshot?.documents {                    for doc in snapshotDocuments {                        let data = doc.data()                        if let messageSender = data[K.FStore.senderField] as? String, let messageBody = data[K.FStore.bodyField] as? String {                            let newMessage = Message(sender: messageSender, body: messageBody)                            self.messages.append(newMessage)                                                        DispatchQueue.main.async {                                self.tableView.reloadData()                            }                        }                    }                }            }        }    }다시 작동해보면?잘된다!가 아니다.뒤에 추가한 것을 보면 갑자기 중간에 내용이 들어가버린다..?Firebase사이트로 들어가서 DB를 한번 확인해보자.왜 마지막에 입력한 굿이 중간에 있는걸까?바로 messages의 내용을 담는 Docs가 오름차순으로 되어있다.git으로 비유하면 commit의 번호가 오름차순으로 정렬된셈이다.DB의 Data 정렬하기.현재 DB의 정보를 보면 언제 입력했는지에 대한 날짜, 시간 정보가 없다.이부분을 추가해주어 시간순으로 정렬을 하면 될 것 같다.다시 코드로 돌아가자.우리가 메세지를 보낼때 시간에 대한 값이 들어가야하므로. sendPressed로 가서 내용을 수정 해주면 된다.시간을 아는 방법은 Date 개체를 이용하는 것이다.초기화를 해주자 ` K.FStore.dateField : Date().timeIntervalSince1970`로 작성한다.개발자들이 많이 사용하는 방법이 바로 위의 timeIntervalSince1970을 사용하는 것이다.timeIntervalSince1970 은 1970년 1월 1일 이후의 시간을 알려준다.이제 시간을 새로 추가해주었으니 기존 메세지들은 DB로 돌아가서 다 지워준다.그리고 다시 실행시켜서 테스트용 값을 아무거나 입력하고 보내고 DB를 다시 확인해보자.시간 값이 추가가 되었다.이젠 정렬을 하면 되겠다.정렬에 관한 내용은 Docs 를 참고하면 된다.db.collection(K.FStore.collectionName).order(by: K.FStore.dateField).addSnapshotListener { (querySnapshot, error) in 이렇게 order를 가운데에 추가해주었다.위에 처럼 너무 코드가 가로로 길어지면? . 앞에서 엔터를 쳐서 끊어주면 가독성이 더 좋아진다.db.collection(K.FStore.collectionName)    .order(by: K.FStore.dateField)    .addSnapshotListener { (querySnapshot, error) in작동 확인을 해보면?굿!DB 보안설정현재는 누구나 사용가능하지만, 이젠 인증이 된사람만 사용하게 바꾸자.관련 내용 역시 Docs 를 참고하자.그리고 그에 맞게 바꿔주면?보안설정도 끝."
  },
  
  {
    "title": "FlashChat (6)",
    "url": "/posts/FlashChat-(6)/",
    "categories": "Udemy, FlashChat",
    "tags": "",
    "date": "2024-03-20 15:53:00 +0900",
    





    
    "snippet": "Cell Customizing새로운 파일을 하나 만든다.일반 Swift 파일이 아닌 CocoaTouch Class 파일이며,여기서 우린 일반적으로 UIViewController로 만들었는데, 이번에는Subclass릂 UITableViewCell로 지정 하고 그아래 XIB file도 체크해서 같이 만들어 준다!이렇게 2개의 파일이 새로 생성이 되었다.*...",
    "content": "Cell Customizing새로운 파일을 하나 만든다.일반 Swift 파일이 아닌 CocoaTouch Class 파일이며,여기서 우린 일반적으로 UIViewController로 만들었는데, 이번에는Subclass릂 UITableViewCell로 지정 하고 그아래 XIB file도 체크해서 같이 만들어 준다!이렇게 2개의 파일이 새로 생성이 되었다.*.xib은 디자인 파일이다override func awakeFromNib() {        super.awakeFromNib()        // Initialization code    }Nib은 xib의 예전 이름이다.1. Cell Design우리가 UIComponent 추가하듯이 추가해주고 사이즈를 맞춰준다.그리고 배경색을 지정해주자.UILabel도 추가를 해준다.그리고 ImageView도 만들어준다.사이즈를 조절해주고 StackView로 묶어준다.그리고 ImageView의 사이즈를 40, 40으로 맞춰 주었다.사이즈조절은?여기서 해준다.혹시라도 잊어버렸을까봐 리마인드겸 다시 사진으로 올려본다.StackView의 제약을 4방향으로 10을 주고, UILabel 또한 같은값으로 4방향 모두 주자.이렇게 나오는데 Cell을 좀 더 늘려서 맞춰주면 된다.조절이 되었으면 StackView 의 Spacing을 20으로 늘려서 UIView와 ImageView의 간격을 준다.그리고 ImageViewd의 이미지를 바꿔주면? 아래와 같이 된다.2. swift 파일과 연결우리가 StoryBoard에서 연결하듯이 Control을 누르고 드래그 해주면 된다.import UIKitclass MessageCell: UITableViewCell {        @IBOutlet weak var messageBubble: UIView!        @IBOutlet weak var label: UILabel!        @IBOutlet weak var rightImageView: UIImageView!        override func awakeFromNib() {        super.awakeFromNib()        // Initialization code    }    override func setSelected(_ selected: Bool, animated: Bool) {        super.setSelected(selected, animated: animated)        // Configure the view for the selected state    }    }이제 사용할 준비가 모두 끝났다.이제 ChatVC에 연결을 해주면 된다.viewDidLoad에 연결을 해줄 것이다.tableView의 메서드중 register를 사용 할 것이다.파라미터는 사진과 같다.tableView.register(UINib(nibName: &lt;#T##String#&gt;, bundle: &lt;#T##Bundle?#&gt;), forCellReuseIdentifier: &lt;#T##String#&gt;)  nibName : 우리가 만든 파일명(*.xib)을 써주면 된다.          여기선 MessageCell 이다.        bundle : nil로 설정  forCellReuseIdentifier : 우리가 Cell을 만들때 썼던 그 Identifier이다.          여기선 ReusableCell 이다.      그리고 MessageCell의 identifier도 똑같은 이름으로 설정해준다.이제 연결은 끝났다.3. Cell 만들기우리가 TableView를 만들던 그 함수로 돌아가자.func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        let cell = tableView.dequeueReusableCell(withIdentifier: K.cellIdentifier, for: indexPath)                cell.textLabel?.text = messages[indexPath.row].body                return cell    }바로 이 부분이다.여태까지는 일반적인 cell을 생성해주었다.우리가 만든 Message Cell을 사용하기 위해선let cell = tableView.dequeueReusableCell(withIdentifier: K.cellIdentifier, for: indexPath)이부분을 다운 캐스팅 해줘야한다.let cell = tableView.dequeueReusableCell(withIdentifier: K.cellIdentifier, for: indexPath) as! MessageCell이렇게 우리가 만들어준 셀의 클래스 명으로 다운캐스팅 해주자.이젠 textLabel이 아니라 Label로 해줄 수 있다.그리고 이젠 우리가 이전에 만들어 주었던 Prototype Cell이 필요가 없다. 지워주자.그게 뭔지 모르겠으면? 아래 사진을 보자이제 실행하여 확인해보자!우리가 만든대로 잘 적용이 된걸 알 수 있다.모서리를 약간 둥글게 하려고 한다.우리가 코드로 UIComponents의 여러 속성을 바꾸는 것처럼.모서리도 코드로 바꿀 수 있다.override func awakeFromNib() {        super.awakeFromNib()    }awakeFronNib은 VC의 ViewDidLoad와 같다고 생각하면 된다.messageBubble.layer.cornerRadius = messageBubble.frame.size.height / 5이렇게 해주었다. 특정한 값으로 해버리면 내용이 길어지면 이상할 수 있기에, 변화하는 높이값에 맞춰서 모서리를 준것이다.둥글게 잘 되었다.내용이 길어진다고 위에 언급을 해서 더 적어본다면, 현재 Cell의 label은바로 1줄로 되어있다.즉 길어지면 …으로 될 것이다.우리가 어떤 메세지를 주고 받을때 장문을 보내면 … 이 안생기는것 처럼. 이 부분도 0으로 바꿔주자.그럼 문제가 해결인가?아니다!위의 사진을 보면 내용이 길어지니 짤려버린다.StackView의 Alignment를 Top으로 바꿔주자.내용이 길어지니 자연스럽게 이렇게 된다."
  },
  
  {
    "title": "(Deep Dive) UIAlertController",
    "url": "/posts/(Deep-Dive)-UIAlertController/",
    "categories": "Udemy, Deep Dive",
    "tags": "Myself",
    "date": "2024-03-20 09:00:00 +0900",
    





    
    "snippet": "이번주차 과제를 진행하다보니 UIAlertController에 대해 사용하는 부분이 있어서인터넷으로 하나하나 계속 찾아보면서 진행하는 것 보다는 전반적으로 좀 파악을 하고 진행을 하는게 더 좋아보여서 별도로 글을 작성해본다.1. UIAlertController?  경고 메세지를 보여주는 오브젝트  기본형    @MainActorclass UIAlert...",
    "content": "이번주차 과제를 진행하다보니 UIAlertController에 대해 사용하는 부분이 있어서인터넷으로 하나하나 계속 찾아보면서 진행하는 것 보다는 전반적으로 좀 파악을 하고 진행을 하는게 더 좋아보여서 별도로 글을 작성해본다.1. UIAlertController?  경고 메세지를 보여주는 오브젝트  기본형    @MainActorclass UIAlertController : UIViewController      2. 선언let alert = UIAlertController(title: \"My Alert\", message: \"This is an alert.\", preferredStyle: .alert) alert.addAction(UIAlertAction(title: NSLocalizedString(\"OK\", comment: \"Default action\"), style: .default, handler: { _ in NSLog(\"The \\\"OK\\\" alert occured.\")}))self.present(alert, animated: true, completion: nil)출처 : Apple Docs3. 파헤쳐 보기    @IBAction func activateAlert(_ sender: UIButton) {        let alert = UIAlertController(title: \"My Alert\", message: \"This is an alert.\", preferredStyle: .alert)        alert.addAction(UIAlertAction(title: NSLocalizedString(\"OK\", comment: \"Default action\"), style: .default, handler: { _ in        NSLog(\"The \\\"OK\\\" alert occured.\")        }))        self.present(alert, animated: true, completion: nil)    }우선 버튼에 다음과 같이 넣었고 어떻게 작동이 되는지 확인을 해보기로 했다.아 이런느낌이구나 라는게 직관적으로 왔다.1. 1st Linelet alert = UIAlertController(title: \"My Alert\", message: \"This is an alert.\", preferredStyle: .alert)  title : 말그대로 제목  message : 우리가 내용을 담을 부분 (뭔가 안내등을 좀 더 나타내고자 할때)  preferredStyle : 어떻게 표시가 될것인지? 총 2가지의 종류가 있다.          alert : 정중앙에 나타나서 보여주는 방식                                      actionSheet : 하단에서 올라와서 보여주는 방식                                      2. 2nd Linealert.addAction(UIAlertAction(title: NSLocalizedString(\"OK\", comment: \"Default action\"), style: .default, handler: { _ in        NSLog(\"The \\\"OK\\\" alert occured.\")        }))말그대로 어떠한 행동을 추가해줄때 사용하며, 위의 내용은 OK 를 누르게끔 만들어 주고 그랬을때 콘솔에 알려주는 식으로 작성이 되었다.  title : 제목. 이것을 사용하여 경고의 이유를 전달  message : 추가 세부 정보를 제공하는 설명 텍스트  preferredStyle : 보여주는 스타일이며 3종류가 있다. 설명은 사진으로 대체한다.          default                                      cancel :                                      destructive :                                        handler : 해당 내용을 눌렀을때 특정한 기능을 수행하게 하는 것⭐️ alert.addAction도 있지만, 별도로 액션을 개체화 해서 사용하는 것도 가능하다.let action = UIAlertAction(title, style:) { (action) in }alert.addAction(action)4. 구현해보기.0. 구상  버튼을 눌러 UIAlertController를 구현한다.  Alert를 통해 내가 값을 입력한다.  입력한값을 TableView에 표시되게 한다.1. StoryBoard우선 심플하게 이렇게 구현을 해보았다.2. 코드 작성import UIKitclass ViewController: UIViewController {        @IBOutlet weak var tableView: UITableView!        var lists : [ArrayModel] = []        var id = 0        override func viewDidLoad() {        super.viewDidLoad()        tableView.dataSource = self        tableView.delegate = self    }    @IBAction func activateAlert(_ sender: UIButton) {        let alert = UIAlertController(title: \"Table View 추가해보기\", message: \"내용을 입력해주세요\", preferredStyle: .alert)        alert.addTextField()        alert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: { [self] _ in            lists.append(ArrayModel(id: id, title: alert.textFields?[0].text ?? \"\"))            tableView.reloadData()            id += 1            }        ))        alert.addAction(UIAlertAction(title: \"Cancel\", style: .cancel))        self.present(alert, animated: true, completion: nil)    }    }extension ViewController : UITableViewDelegate {    }extension ViewController : UITableViewDataSource {    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {                return lists.count    }        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        let cell = tableView.dequeueReusableCell(withIdentifier: \"table\", for: indexPath)        cell.textLabel?.text = lists[indexPath.row].title                return cell    }}직관적으로 작동하게 해두었다.현재 배열의 값을 확인하기 위해 Check List라는 버튼을 추가로 만들었다.3. 작동 테스트잘된다.6. ETCtextField를 조금 더 보완하고 싶다면?// beforealert.addTextField()// afteralert.addTextField { (textField: UITextField!) in             textField.placeholder = \"여기에 입력해주세요\"            textField.autocorrectionType = .no            textField.spellCheckingType = .no        }Done!7. 참고사이트https://developer.apple.com/documentation/uikit/uialertcontrollerhttps://nshipster.com/uialertcontroller/https://zeddios.tistory.com/249https://stackoverflow.com/questions/15760699/change-the-keyboard-type-of-uitextfield-in-uialertview"
  },
  
  {
    "title": "3주차 과제 (2)",
    "url": "/posts/3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(2)/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-20 08:00:00 +0900",
    





    
    "snippet": "Lv.2Todo 추가 및 완료 기능 구현하기 (TodoListViewController)키워드 : UIAlertController, UISegmentedControl**  Todo 추가하기 기능          Lv1에서 만든 Todo 추가 버튼을 이용해주세요.      UIAlertController를 활용해서 할 일 추가 UI 및 기능을 구현해보세...",
    "content": "Lv.2Todo 추가 및 완료 기능 구현하기 (TodoListViewController)키워드 : UIAlertController, UISegmentedControl**  Todo 추가하기 기능          Lv1에서 만든 Todo 추가 버튼을 이용해주세요.      UIAlertController를 활용해서 할 일 추가 UI 및 기능을 구현해보세요.   (Closure 등을 사용해서 Action을 추가해보세요.)      새로운 UI인 UIAlertController를 찾아보고 적용해봅시다.                  예시)                          로그인을 위한 회원정보 데이터 받아오기 예시              Alert안에 TextField 구현하기              iOS 입문 단계 강의에서 UIAlertController를 따로 다루지 않기에, 아래 개발자 공식문서를 참고하여 얼럿을 구현해봅니다.  UIAlertController | Apple Developer Documentation                                            Todo 완료하기 기능          버튼 혹은 UISegmentedControl을 활용, Todo의 완료 상태를 완료/미완료 상태로 변경합니다.                  UIButton을 활용          UISwitch를 활용 (예시에 적용된 컴포넌트)                    할일을 나타내는 Todo의 완료/미완료 상태에 따라 UI를 변경해주세요.                  할일 Title 옆에 완료 라는 표시를 붙여줄 수도 있겠네요!                    1. UIAlertController 사용하기.func makeAlert () {                let alert = UIAlertController(title: \"Table View 추가해보기\", message: \"내용을 입력해주세요\", preferredStyle: .alert)                let ok = UIAlertAction(title: \"OK\", style: .default, handler: { [self] _ in // ok를 눌렀을때 내가 텍스트 필드에 입력한 내용을 등록하게 한다.            lists.append(ToDoModel(id: id, title: alert.textFields?[0].text ?? \"\", isComplete: false)) // 배열에 등록            tableView.reloadData() // 테이블뷰 갱신            id += 1 }) // id 1씩 추가                let cancel = UIAlertAction(title: \"Cancel\", style: .cancel)        alert.addTextField { (textField: UITextField!) in                    textField.placeholder = \"여기에 입력해주세요\"                    textField.autocorrectionType = .no                    textField.spellCheckingType = .no                }        alert.addAction(ok)        alert.addAction(cancel)                self.present(alert,animated: false)    }alert를 호출 하는 함수를 별도로 구현을 해주었다.각각의 action을 오브젝트 화 해주었다.해당 함수를 호출을 하게 되면 아래와 같이 뜬다.작동 확인도 완료2. UISwitch 사용코드로 switch를 구현했기에 Storyboard에서는 삭제했다.1. 사용해보기cell 을 구성하는 함수로 가서 let finSwitch = UISwitch()    cell.textLabel?.text = lists[indexPath.row].title    finSwitch.setOn(false, animated: true)    finSwitch.tag = indexPath.row    cell.accessoryView = finSwitch이렇게 적어준다.  setOn : 처음에 어떤상태에서 보여질지?          난 on이되면 다했다고 할거기 때문에 false로 시작한다.        tag : 태그를 지정해둔다. 나중에 쓸것같아서 index맞게 지정 해두었다.  accessoryView : 특정 버튼이나 이런걸 추가하기 위해서 사용.확인 완료2. true / false 에 따라 표현해보기.현재는 추가만 해둔 상태인데, 이걸 통해서 true 즉 완료했을때 텍스트가 텍스트 가 되도록 해보자.func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        let cell = tableView.dequeueReusableCell(withIdentifier: \"TodoList\", for: indexPath)        let finSwitch = UISwitch()                cell.textLabel?.text = lists[indexPath.row].title        finSwitch.setOn(false, animated: true)        finSwitch.tag = indexPath.row        // new        finSwitch.addTarget(self, action: #selector(self.switchChanged), for: .valueChanged)        cell.accessoryView = finSwitch                return cell    }        @objc func switchChanged(_ sender : UISwitch) {        if sender.isOn {            print(\"on\")        } else {            print(\"off\")        }    }addtarget을 해줌으로써 해당 스위치가 작동했을때 특정한 기능을 수행하게 한다.함수는 별도로 아래 처럼 지정해줘야한다.지금은 테스트를 위해 on/off가 출력되게한다.잘된다.이것저것 시도를 해보다가 문제점을 하나 발견했다.func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        let cell = tableView.dequeueReusableCell(withIdentifier: \"TodoList\", for: indexPath)        let finSwitch = UISwitch()                cell.textLabel?.text = lists[indexPath.row].title        finSwitch.setOn(false, animated: true)        finSwitch.tag = indexPath.row        finSwitch.addTarget(self, action: #selector(self.switchChanged), for: .valueChanged)        cell.accessoryView = finSwitch                return cell    }여기서 cell을 리턴할때마다 setOn을 사용해서 그런지.만들고나서 다시 만들때 false로 돌아가지는 경우를 발견하였다.하지만 지우고 테스트를 해도 바뀌지 않았다.tableView에 대해 여러 자료를 찾다보면Custom Table View로 하는경우가 많던데.이참에 이걸 배워볼겸 코드를 뜯는것도 나쁘지 않을것 같다.어쩐지 너무 잘풀렸다 ㅋㅋ3. Cell DesignCell을 Custom 하고자 새롭게 파일을 만들었다.디자인을 해주었고 제약도 걸어 주었다.import UIKitclass ToDoListCell: UITableViewCell {    @IBOutlet weak var toDoView: UIView!        @IBOutlet weak var toDoLabel: UILabel!            @IBOutlet weak var finSwitch: UISwitch!        override func awakeFromNib() {        super.awakeFromNib()        // Initialization code    }    override func setSelected(_ selected: Bool, animated: Bool) {        super.setSelected(selected, animated: animated)        // Configure the view for the selected state    }        }필요한것들은 전부 outlet을 만들어 주었다.4. Custom Cell 연결하기.TableVC 로 돌아와서viewDidload() 에 아래와 같이 내가 만든 셀을 등록 해주었다.tableView.register(UINib(nibName: Constants.cellName, bundle: nil), forCellReuseIdentifier: Constants.cellIdentifier)그리고 tableView함수 역시 바꿔 주었다. func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        let cell = tableView.dequeueReusableCell(withIdentifier: Constants.cellIdentifier, for: indexPath) as! ToDoListCell                cell.toDoLabel.text = lists[indexPath.row].title        return cell    }그리고 실행하니 이게 웬걸? nil 이떠버린다.뭔가 제대로 된 값을 가져오지 못한다는 것인데, 이부분을 한번 해결해보자.뭔가 꼬인거같아서 파일을 지웠다가 다시 만드니 잘된다.5. 다시 switch on/off일때 기능 구현몇시간동안 검색하다가 드디어 찾아내었다. 감격…우선 스위치가 작동할때 내가 지정한 함수가 트리거 되게 하는cell.finSwitch.addTarget(self, action: #selector(changeMode), for: .valueChanged) 를 적어주었다.@objc func changeMode (sender : UISwitch) {        if let currentCell = tableView.cellForRow(at: IndexPath(row: sender.tag, section: 0)) as? ToDoListCell {            currentCell.toDoLabel.attributedText = currentCell.toDoLabel.text?.strikeThrough()        }}extension String {    func strikeThrough() -&gt; NSAttributedString {        let attributeString =  NSMutableAttributedString(string: self)        attributeString.addAttribute(NSAttributedString.Key.strikethroughStyle, value: NSUnderlineStyle.single.rawValue, range: NSMakeRange(0,attributeString.length))        return attributeString    }}현재 스위치가 토글이 될때의 indexpath에 해당하는 cell 정보만 가져올 수 있으면 바꿀 수 있다고 생각했는데, 생각보다 그것을 찾아내는 과정이 너무 어려웠다. 죄다 on/off 에대해 단순히 print만 하고 있었다.해당 메서드를 통해서 취소선을 드디어 만들어내었다. 이제 취소선도 false일때 없애야 하므로 코드를 더 수정한다.@objc func changeMode (sender : UISwitch) {        guard let currentCell = tableView.cellForRow(at: IndexPath(row: sender.tag, section: 0)) as? ToDoListCell else { return }        if sender.isOn {            currentCell.toDoLabel.attributedText = currentCell.toDoLabel.text?.strikeThrough()        } else {            currentCell.toDoLabel.attributedText = currentCell.toDoLabel.text?.removeStrike()                    }            }extension String {    func strikeThrough() -&gt; NSAttributedString {        let attributeString =  NSMutableAttributedString(string: self)        attributeString.addAttribute(NSAttributedString.Key.strikethroughStyle, value: NSUnderlineStyle.single.rawValue, range: NSMakeRange(0,attributeString.length))        return attributeString    }        func removeStrike () -&gt; NSAttributedString {        let attributeString = NSMutableAttributedString(string: self)        attributeString.removeAttribute(NSAttributedString.Key.strikethroughStyle, range: NSMakeRange(0, attributeString.length))        return attributeString    }}    6. 문제 해결현재 가장 큰 문제는 여러개를 추가하다보면 갑자기 스위치가 이상하게 되어버린다.아무래도 reload하면서 문제가 생기는듯하다.찾다가 하나의 글을 발견했는데, row를 제거하고 추가할때는 사용하면 안된다고한다.그럼 어느 위치에 해야하는걸까..어느 위치에둬도 매칭이 되지가 않는다. 그냥 DB에 연결해서 사용하는게 훨씬 나을것같다는 생각이 든다.참고자료https://stackoverflow.com/questions/58392615/get-label-value-on-uiswitch-value-change-inside-table-view-cell-swifthttps://longlivedrgn-miro.tistory.com/10"
  },
  
  {
    "title": "3주차 과제 (1)",
    "url": "/posts/3%EC%A3%BC%EC%B0%A8-%EA%B3%BC%EC%A0%9C-(1)/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-19 21:00:00 +0900",
    





    
    "snippet": "이번 주차 과제는 2주의 시간이 주어지며ToDoList App을 만드는 것이다.Lv.1Todo List 화면 만들기 (TodoListViewController)키워드 : UIButton, UITableView  Storyboard를 활용하여 기본 Todo List 화면 UI를 구성해주세요.          UI는 자유롭게 구성해도 됩니다. 다만, 요구...",
    "content": "이번 주차 과제는 2주의 시간이 주어지며ToDoList App을 만드는 것이다.Lv.1Todo List 화면 만들기 (TodoListViewController)키워드 : UIButton, UITableView  Storyboard를 활용하여 기본 Todo List 화면 UI를 구성해주세요.          UI는 자유롭게 구성해도 됩니다. 다만, 요구사항을 지켜주세요.        UIButton과 UITableView을 활용하여 화면을 구성해주세요.          Todo 추가하기 UIButton - Lv2에서 기능을 붙여봅니다.      Todo List 보여주기 UITableView        Todo에 필요한 데이터를 구성해주세요.          할일에 대한 데이터 구성                  할일 데이터의 고유값인 “id (Int)”          할일 제목인 “Title (String)”          완료 여부를 확인할 “isCompleted (Bool)”                    그 외 나타내주고 싶은 데이터가 있다면 자유롭게 추가해도 좋습니다.      필요하다면 테스트 데이터를 넣어서 UI에서 확인해볼 수 있습니다.      예시          struct Todo {  // 고유값 id (Int) - var id: Int와 같은 식으로 구성할 수 있겠죠!  // 타이틀 (String)  // 완료 여부 (Bool)  // 기타 추가로 나타내고 싶은 데이터가 있으면 구성해줍니다.  }                    1. Diagram우선 위와 같은 형태로 되게 하려고 한다.2. StoryBoard 구성기본적인 구성은 위와 같이 하였다.왜 굳이 VC를 하나 더 넣었느냐?화면전달을 이미 어느정도해서 익숙하지만 그래도 더 써보고 싶어서 그랬다.3. Model 구성우선 ToDoModel.swift 파일을 하나 만들어 주었다.import Foundationstruct ToDoModel {        var id : Int // 게시글 번호    var title : String // 제목    var isComplete : Bool // 다 끝냈는지?    }이 파일에서 ToDo에 대한 모든것을 담당 할 것이다.4. MainVCMainVC는 굳이 꾸밀게 없어서 최근에 배운걸 접목시켰다.import UIKitclass MainViewController: UIViewController {    @IBOutlet weak var titleLabel: UILabel!        override func viewDidLoad() {        super.viewDidLoad()                let titleText = \"📂 MyList📋\"                var index = 0.0                for letter in titleText {            Timer.scheduledTimer(withTimeInterval: 0.1 * index, repeats: false) { timer in                self.titleLabel.text?.append(letter)            }                index += 1            }        }   }확인 완료.5. TableVCimport UIKitclass TableViewController: UIViewController {    @IBOutlet weak var tableView: UITableView!        @IBOutlet weak var doneSwitch: UISwitch! // 연결 끊어주었음.        var lists : [ToDoModel] = [        ToDoModel(id: 0, title: \"test\", isComplete: false)    ]        override func viewDidLoad() {        super.viewDidLoad()                tableView.dataSource = self        tableView.delegate = self    }        @IBAction func addListBtn(_ sender: UIBarButtonItem) {            }    }extension TableViewController : UITableViewDataSource {    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {                return lists.count    }        func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        let cell = tableView.dequeueReusableCell(withIdentifier: \"TodoList\", for: indexPath)                cell.textLabel?.text = lists[indexPath.row].title                return cell    }        }extension TableViewController : UITableViewDelegate {    }일단은 이렇게 기본틀을 잡아주었다.시작하려고하니 에러가 발생한다.에러의 내용은 다음과 같다 The doneSwitch outlet from the TableViewController to the UISwitch is invalid. Outlets cannot be connected to repeating content.아무래도 반복적으로 생성이 되는곳이다보니 VC에 연결하지 말라는 것이다.일단은 연결을 끊어주고 작동확인을 먼저 해본다.굿.오늘은 여기까지."
  },
  
  {
    "title": "3주차 (2)",
    "url": "/posts/%EB%B3%B8%EC%BA%A0%ED%94%84-3%EC%A3%BC%EC%B0%A8-(2)/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-19 18:00:00 +0900",
    





    
    "snippet": "1. UISlider  값의 범위를 가지고 사용자가 원하는 값을 선택할 수 있는 UI 요소          value : 슬라이더의 현재 값을 나타낸다.      minimumValue : 슬라이더의 최소값을 설정.      maximumValue : 슬라이더의 최대값을 설정.      minimumTrackTintColor : 슬라이더의 왼쪽 트랙 ...",
    "content": "1. UISlider  값의 범위를 가지고 사용자가 원하는 값을 선택할 수 있는 UI 요소          value : 슬라이더의 현재 값을 나타낸다.      minimumValue : 슬라이더의 최소값을 설정.      maximumValue : 슬라이더의 최대값을 설정.      minimumTrackTintColor : 슬라이더의 왼쪽 트랙 색상을 설정.      maximumTrackTintColor : 슬라이더의 오른쪽 트랙 색상을 설정.      thumbTintColor : 슬라이더의 썸네일 색상을 설정.      func setUISlider () {        let slider = UISlider()      slider.value = 50 // 슬라이더 초기 값 설정      slider.minimumValue = 0 // 슬라이더의 최소값 설정      slider.maximumValue = 100 // 슬라이더의 최대값 설정      slider.minimumTrackTintColor = UIColor.red // 왼쪽 트랙 색상 설정      slider.maximumTrackTintColor = UIColor.blue // 오른쪽 트랙 색상 설정      slider.thumbTintColor = UIColor.white // 썸네일 색상 설정          // 슬라이더 값 변경 이벤트 처리      slider.addTarget(self, action: #selector(sliderValueChanged(_:)), for: .valueChanged)          @objc func sliderValueChanged(_ sender: UISlider) {          print(\"Slider value: \\(sender.value)\")      }}2."
  },
  
  {
    "title": "FlashChat (5)",
    "url": "/posts/FlashChat-(5)/",
    "categories": "Udemy, FlashChat",
    "tags": "",
    "date": "2024-03-19 15:53:00 +0900",
    





    
    "snippet": "상수 파일 생성하여 한 파일에서 관리하기.현재 performSegue를 통해 화면을 전환 하는 방식은,예를들어 performSegue를 입력한다고 하면 중간에 잘못 입력하게되면 에러가 뜨면서 잘못됨을 인지시켜준다.하지만 내부 parameter의 경우, 우리가 withIdentifier 의 파라미터를 \"RegisterToChat\" 이렇게 정확하게 입력을...",
    "content": "상수 파일 생성하여 한 파일에서 관리하기.현재 performSegue를 통해 화면을 전환 하는 방식은,예를들어 performSegue를 입력한다고 하면 중간에 잘못 입력하게되면 에러가 뜨면서 잘못됨을 인지시켜준다.하지만 내부 parameter의 경우, 우리가 withIdentifier 의 파라미터를 \"RegisterToChat\" 이렇게 정확하게 입력을 해야한다.즉 이 parameter는 우리가 잘못 입력해도 실행해서 그부분에 도달하면서 App Crash가 발생하지 않는 이상 우리가 잘못됨을 감지하기가 어렵다.그래서 상수파일을 하나 만들어 볼 것이다.파일명은 Constants.swift로 해주었다.struct Constants {        static let registerSegue = \"RegisterToChat\"    static let loginSegue = \"LoginToChat\"        }그리고 이렇게 Segue의 Identifier에 해당하는 값들을 만들어 주고, static을 사용해서 어디에서든 사용할 수 있게 해주었다.이걸 사용해서 performSegue 메서드를 수정해보자.  before      self.performSegue(withIdentifier: \"RegisterToChat\", sender: self)    after  self.performSegue(withIdentifier: Constants.registerSegue, sender: self)이렇게 하나의 상수파일에 변하지 않는 문자열 값들을 별도로 저장해두고, 사용하는게 더 관리적인 측면과 안정성에도 좋다.UITableViewUITableView란?우리가 메일이나, 연락처, 설정등 하나의 열에서 행을 사용하여 데이터를 보여주는 뷰이다.이 TableView를 사용하여 메세지를 담을것이다.Message Model 적용하기.우선 파일을 하나 만들어 주었다 Message.swiftimport Foundationstruct Message {    let sender : String // email 형식으로    let body : String // 유져가 보내는 Message 내용}그리고 다음과 같이 작성을 해주었다.이제 실질적으로 메세지의 전달과정을 담당할 ChatVC로 가서 코드를 작성해보자.message라는 변수를 만드는데, 독특하게 배열로 담으려고 한다.var messages : [Message] = [        Message(sender: \"1@2.com\", body: \"Hey!\"),        Message(sender: \"a@b.com\", body: \"Hello!\"),        Message(sender: \"1@2.com\", body: \"What's up?\")    ]이런식으로 누가 보내는지, 내용은 어떻게 되는지에 대한 정보를 보여주는 배열인것이다.TableView 연결하기.위의 메세지들을 이제 테이블뷰에 담아서 보여줘야한다.extension 활용하기.extension ChatViewController : UITableViewDataSource {    }이렇게 UITableViewDataSource 프로토콜을 채택해준다.그리고 viewDidLoad에 가서 tableView.dataSource = self 꼭 적어주자!그리고 에러가 나는 부분을 fix 해주면 두개의 함수가 생긴다. func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {                return messages.count    }    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {                let cell = tableView.dequeueReusableCell(withIdentifier: K.cellIdentifier, for: indexPath)                cell.textLabel?.text = \"This is a cell\"                return cell    }  numberOfRowsInSection : 몇개의 행을 만들건지를 리턴한다. (행의 개수)          배열이 대화 내용을 의미하므로 배열의 개수가 행의 개수가 된다        cellForRowAt : 각 행에 보여줄 셀을 리턴한다.          indexPath 는 위치이다.      cell을 하나 만들어주면                  tableView.dequeueReusableCell 메서드를 사용하게된다.                          withIdentifier : 아래 사진을 의미한다.                                                                                                          여기까지 작성한걸 확인해보자.그러면 우리가 원한대로 3개의 행이 나왔고, 현재 셀의 내용을 This is a cell이라고 딱 잘라 정의 했기에3개가 같은 내용을 보여주고있다.indexPath를 사용해서 각각의 행이 다른 내용을 보여주게 바꿔 보자.우선 indexPath.row가 어떤걸 반환하는지 확인해보자cell.textLabel?.text = \"\\(indexPath.row)\"위를 기준으로 배열의 인덱스 값을 리턴하는걸 알 수 있다.정확하게는 행의 값을 리턴한다.하지만 인덱스와 행의 값이 같이 0으로 시작한다.그래서 다음과 같이 바꿔주자 cell.textLabel?.text = messages[indexPath.row].body잘 나온다.그런데 일반적으로 tableView라면 구분선이 있는데 보이지가 않는다?None으로 되어있기 때문이다~ETCUITableViewDataSource 에는 UITableViewDelegate라는 프로토콜이 또 존재한다.우리가 사용한 UITableViewDataSource는 TableView를 채워주는 것을 담당한다.그래서 몇개의 셀이 우리가 필요로하고, 어떤 내용의 셀을 넣어야할지 알려준다.새로운 extension을 하나 더 만들어 준다.extension ChatViewController : UITableViewDelegate {    }그리고 UITableViewDelegate를 채택해준다.  프로토콜을 채택했으니 해야할것은? tableView.delegate = self 를 작성해준다이제 테이블 뷰의 특정 행이 선택이 되면 아래 함수가 트리거 될것이다.    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {        print(indexPath.row)    }지금은 클릭을 하면 몇번째 행인지를 출력하게 했다.실행해보자.몇번째 행인지 콘솔에 잘 나오고있다.이렇게 유져와 상호작용을 할 수 있게도 만들수가 있다.하지만 지금은 해당 기능은 우리의 의도와는 맞지 않으므로 주석처리해두겠다.다시 돌아와서 Selection을 None으로 바꿔준다.이제는 실행해도 해당부분을 클릭하면 회색으로 보이지 않는다."
  },
  
  {
    "title": "FlashChat (4)",
    "url": "/posts/FlashChat-(4)/",
    "categories": "Udemy, FlashChat",
    "tags": "",
    "date": "2024-03-19 11:53:00 +0900",
    





    
    "snippet": "회원가입 구현https://firebase.google.com/docs/auth/ios/password-auth?hl=ko&amp;authuser=0&amp;_gl=1*nhoeg5*_up*MQ..*_ga*ODkxMDIxNTcuMTcxMDgxMzgwMQ..*_ga_CW55HF8NVT*MTcxMDgxMzgwMS4xLjEuMTcxMDgxNDg1OC4wLjA...",
    "content": "회원가입 구현https://firebase.google.com/docs/auth/ios/password-auth?hl=ko&amp;authuser=0&amp;_gl=1*nhoeg5*_up*MQ..*_ga*ODkxMDIxNTcuMTcxMDgxMzgwMQ..*_ga_CW55HF8NVT*MTcxMDgxMzgwMS4xLjEuMTcxMDgxNDg1OC4wLjAuMA..해당 내용에 대한 Firebase Docs가 있다. 한번 읽어두자.다시 Firebase 사이트로 돌아와서 Authentication을 클릭하자.그리고 시작하기를 누르면여러가지가 나온다.이메일/비밀번호로 한번 해보자.활성화를 해주고 저장을 눌러서 나가자Docs로 가자.설명대로 진행해주면 된다.그리고 5번의 내용을회원가입을 담당하는 RegisterVC에 복붙하자.import UIKitimport FirebaseCoreimport FirebaseFirestoreimport FirebaseAuthclass RegisterViewController: UIViewController {    @IBOutlet weak var emailTextfield: UITextField!    @IBOutlet weak var passwordTextfield: UITextField!        @IBAction func registerPressed(_ sender: UIButton) {        Auth.auth().createUser(withEmail: email, password: password) { authResult, error in        }    }    }필요한 것들은 import를 해둔다.뭘해야할지 모르면? Docs에 다 나와있다.이후에 email, password 에러는 textField와 연관이 있다.변수를 만들어서 에러를 해결해 주자.class RegisterViewController: UIViewController {    @IBOutlet weak var emailTextfield: UITextField!    @IBOutlet weak var passwordTextfield: UITextField!        @IBAction func registerPressed(_ sender: UIButton) {                if let email = emailTextfield.text, let password = passwordTextfield.text {            Auth.auth().createUser(withEmail: email, password: password) { authResult, error in                if let e = error { // 에러 발생하면                    print(e)                } else { // 에러가 발생하지 않는다면                    //Navigate to the ChatViewController                    self.performSegue(withIdentifier: \"RegisterToChat\", sender: self)                }            }        }    }    }위와 같이 코드를 작성해 주었다.옵셔널 바인딩을 해주었고, 에러가 발생하지 않을때 즉 정상적으로 회원 가입이 완료 되었을때는 segue를 통해 채팅이 가능한 화면으로 이동하게 하였다.작동 테스트를 해보자.기능 테스트 할때는 1@2.com 이런식으로 간단하게 맞춰주면 된다.비밀번호는 최소 6자리를 입력해줘야한다!.안그러면 에러가 출력된다Error Domain=FIRAuthErrorDomain Code=17026 \"The password must be 6 characters long or more.\"무튼 기능은 잘된다.근데 콘솔창에 아래와 같은 내용이 나온다?Cannot show Automatic Strong Passwords for app bundleID: co.Harold.Flash-Chat-iOS13 due to error: iCloud Keychain is disabled이건 에러가 아니라, 우리가 보통 회원가입할때 비밀번호를 입력하려고하면이렇게 강력한 비밀번호로 세팅하는걸 추천하는데, 그게 활성화가 안되있어서 알려주는것이다.그리고 다시 Firebase 웹페이지로 돌아가서 Authentication의 사용자를 확인해보면?이렇게 연동이 되어 등록이 된걸 알 수 있다!예전에 회원가입 이런거 구현할때는 sql에 Database생각해가면서 만들었는데, 그때 고생을 해봐서 그런가이건 너무 신세계다 :)하지만 정보보안, 그리고 해킹의 경우를 생각해서 비밀번호를 보여주지는 않는다. 구글에서 관리를 한다.print(e.localizedDescription) 이걸 사용하게되면에러도 선택한 언어로 에러메세지가 나온다.확인해보자.애석하게도 한국은 안되나보다…나중에 여러 지역으로 테스트 해봐야겠다.로그인 구현Firebase Docs를 보면 이메일 주소와 비밀번호로 사용자 로그인에대한 글이 있다.읽어보자.일단 내방식 대로 적어봤다.@IBAction func loginPressed(_ sender: UIButton) {                if let email = emailTextfield.text, let password = passwordTextfield.text {            Auth.auth().signIn(withEmail: email, password: password) { [weak self] authResult, error in              guard let strongSelf = self else { return }                               if let e = error {                    print(e.localizedDescription)                } else {                                        self?.performSegue(withIdentifier: \"LoginToChat\", sender: self)                                    }                            }        }            }그런데 strongSelf는 뭘하려고 하는지 모르겠다.역시나 강의에서는 무시하고 진행했다. @IBAction func loginPressed(_ sender: UIButton) {                if let email = emailTextfield.text, let password = passwordTextfield.text {            Auth.auth().signIn(withEmail: email, password: password) { authResult, error in                if let e = error {                    print(e.localizedDescription)                } else {                                        self.performSegue(withIdentifier: \"LoginToChat\", sender: self)                                    }                            }        }            }그래도 작동은 잘 된다.로그아웃 구현하기Navigation Bar에 버튼을 추가한다.일반적인 buttond을 여태 썼다면, 이번엔 Bar Button 이다.@IBAction func logOutPressed(_ sender: UIBarButtonItem) {                do {          try Auth.auth().signOut()        } catch let signOutError as NSError {          print(\"Error signing out: %@\", signOutError)        }            }Docs대로 해주었다.근데 작동이 안된다? 에러메세지도 없다.뭐가 문제인걸까?생각해보니 진짜 로그아웃만 있고 이걸 눌렀을때 로그아웃이 되면서 특정 화면으로 이동해야하는 코드가 없다.그럼 메인화면까지 back을 누르면서 가야할까?아니다!한번에 rootVC까지 갈수있는 메서드가 있다!navigationController?.popToRootViewController(animated: true)이젠 작동이 잘 된다.채팅 화면에 있는 Back 버튼 지우기.override func viewDidLoad() {        super.viewDidLoad()                navigationItem.hidesBackButton = true    }사라졌다.팁앱을 재시동 할때마다 로그인을 해야하기 불편하다면이렇게 미리 부여를 해두는 방법도 있다.실행하면?이젠 간편하게 로그인 할 수 있다."
  },
  
  {
    "title": "FlashChat (3)",
    "url": "/posts/FlashChat-(3)/",
    "categories": "Udemy, FlashChat",
    "tags": "",
    "date": "2024-03-19 09:53:00 +0900",
    





    
    "snippet": "3rd party Library 실제로 사용해보기.설명대로 한번 사용해보자.StoryBoard에서 우리가 적용할 UILabel을 클릭하고 custom class를 가보니 이렇게 지정을 할수있다.한번 설정해보자.그리고 다시 VC로 돌아가서@IBOutlet weak var titleLabel: CLTypingLabel!를 해주었는데 찾을 수 없다고 에러가...",
    "content": "3rd party Library 실제로 사용해보기.설명대로 한번 사용해보자.StoryBoard에서 우리가 적용할 UILabel을 클릭하고 custom class를 가보니 이렇게 지정을 할수있다.한번 설정해보자.그리고 다시 VC로 돌아가서@IBOutlet weak var titleLabel: CLTypingLabel!를 해주었는데 찾을 수 없다고 에러가난다?import를 해주도록 하자. (잊지말자!)그리고 사용했던 for문을 지우고, override func viewDidLoad() {        super.viewDidLoad()                titleLabel.text = \"⚡️FlashChat\"            }titleLabel에 저렇게 값만 넣어보자.그리고 실행했더니?이럴수가.. 너무 잘된다.3rd party Library 제거해보기.우선 코드나 이런것들을 사용전으로 원복 시키고.podfile에서 설치에 관한 내용을 지웠다.그리고 다시 터미널로 돌아가서 pod install을 해주면?제거가 되었다.다시 프로젝트로 돌아가면? (이때도 .xcworkspace로 연다.)깨끗하게 프로젝트 내부에서도 제거가 된것이 확인이 된다.CocoaPods을 사용한 이유.이렇게 네이티브로 패키지를 추가할 수 있다.하지만 단점은 해당 Github를 먼저 들어가서 네이티브를 지원하는지 부터 알아봐야한다…Package.swift 이게 있다면 가능하다. 하지만 없다면…? 다른 방법으로 3rd party Library를 사용 할 수 밖에 없다.Firebase 설정하기.https://firebase.google.com/?hl=ko우선 로그인 해주자.로그인을 했다면 우측 상단의 Go to console을 클릭하자그리고 프로젝트를 하나 만들어 준다.프로젝트 명을 정하고 next하면 Google Analytics을 사용할건지 묻는데 일단은 사용하지 않고 진행한다.사용할 준비가 되었다.우린 iOS 개발자니까 당연히 iOS를 클릭한다.앱을 등록해야 하나보다.1. 번들 ID 등록  번들 ID는 아래 사진에 위치한 곳에 있으니 거기서 복사하여 적어주자.  지금은 아래 2개는 굳이 할 필요가 없기에 skip!2. plist 파일을 다운로드하고 프로젝트에 넣어주기  설명이 나와있기에 그대로 진행하자.잘 확인하자!3. firebase SDK 추가하기시간이 지나면서 여러 방식으로 추가를 할 수 있게 되었다.여기선 cocoapods으로 설치를 진행해볼것이다.// podfileplatform :ios, '13.0'target 'Flash Chat iOS13' do  use_frameworks!  # Pods for Flash Chat iOS13  pod 'FirebaseAuth'  pod 'FirebaseFirestore'end프로젝트를 종료하고 터미널로 들어가서 설치해보자.설치 과정은 생략 하겠다.4. 초기화 코드 추가하기친절하게 여러 종류에 따른 코드가 적혀있다.현재는 UIKit을 쓰기에 가운데에 있는 Swift의 항목을 복사해주자.프로젝트내 AppDelegate로 가서import UIKitimport FirebaseCore@UIApplicationMainclass AppDelegate: UIResponder, UIApplicationDelegate {    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {                FirebaseApp.configure()                return true    }이렇게 수정을 해준다.이렇게 FireBase설정이 끝났다."
  },
  
  {
    "title": "FlashChat (2)",
    "url": "/posts/FlashChat-(2)/",
    "categories": "Udemy, FlashChat",
    "tags": "",
    "date": "2024-03-19 08:00:00 +0900",
    





    
    "snippet": "Cocoapods 설치하기 (Terminal)      sudo gem install cocoapods을 입력한다        pod setup --verbose을 입력한다.        셋업이 잘되었다면 pod –version을 통해 확인한다.  프로젝트에 pod 설치하기      Terminal의 현재 경로를 현재의 프로젝트 디렉토리로 맞춰둔다. ...",
    "content": "Cocoapods 설치하기 (Terminal)      sudo gem install cocoapods을 입력한다        pod setup --verbose을 입력한다.        셋업이 잘되었다면 pod –version을 통해 확인한다.  프로젝트에 pod 설치하기      Terminal의 현재 경로를 현재의 프로젝트 디렉토리로 맞춰둔다.        pod init 입력 한다.  파일이 생성되었다.Podfile 수정하기.# Uncomment the next line to define a global platform for your project# platform :ios, '9.0'target 'Flash Chat iOS13' do  # Comment the next line if you don't want to use dynamic frameworks  use_frameworks!  # Pods for Flash Chat iOS13end우선 파일을 xcode를 통해 열면 다음과 같이 되어있다.주석을 제거(2번째 줄)하여 최소 9.0 이상 버전에서 작동이 가능하게 해주자.그리고 필요 없는 부분도 제거 해주었다.platform :ios, '9.0'target 'Flash Chat iOS13' do  use_frameworks!  # Pods for Flash Chat iOS13endhttps://cocoapods.org/ 에서 우리가 필요한 3rd party Libraries를 사용할건데, CLTypingLabel 을 이번 프로젝트에서 사용할 것이다.해당 부분을 추가하라고 한다. 추가해주자추가해주고 Command + S 를 눌러 저장을 해준다.Pod 설치하기그리고 다시 터미널로 돌아가자터미널로 돌아가서 pod install 을 입력한다.(디렉토리는 그대로 유지한 상태에서!)설치가 정상적으로 되었다.파인더를 통해 프로젝트 경로로 이동해보면파일이 생성되어있다.위의 터미널의 메세지에서도 나오지만 이제 우리는 저 파일을 통해서 프로젝트를 열고 닫을것이다.기존에 켜져있던 프로젝트를 종료하고 저 파일을 통해서 열어보자.프로젝트에 Pods가 새로 생겼다.Build test 및 오류 수정Command + B 를 눌러 Build를 해보자.바로 Failed가 뜬다.그리곤 에러들이 갑자기 뜬다?아마도 CLTypingLabel을 설치하면서 뭔가 설정이 바뀐듯 하다.해당 Github 주소로 들어가보자그리고 pull request → Closed를 가게되면사람들이 이 레포지토리를 업데이트하면서 해당 문제들을 해결하고 있는걸 볼 수 있다.character에 관한 에러도 있기에 해당부분을 들어가서 확인해보자.그러면 유져의 코멘트를 볼 수 있고, Files Changed를 클릭하면어떻게 코드가 바뀌었는지도 볼 수 있다.수정한 부분을 복사해서 적용하자.붙여넣기하면 Unlock할건지 묻는데 Unlock해주면 된다.그런데 버전이 뭔가 이상하다?Releases를 들어가보면 0.4.0 인데Podfile.lock을 열어서 버전을 확인해보면?두개의 버전이 다르다.설치를 했는데 왜 한단계 더 낮은 버전이 설치가 된걸까?CocoaPods 가이드를 보니 우리가 설정한 버전으로 설치를 할 수 있는 가이드가 있다.target 'MyApp'pod 'AFNetworking', '~&gt; 1.0'다시 Podfile을 열어보자 (.lock이 아니다)그리고 가이드에 맞게 바꿔 주자 ` pod ‘CLTypingLabel’, ‘~&gt; 0.4.0’`정확하게 입력을 했는지 꼭 크로스 체크를 한다!Command + S 로 저장을 다시 해주고 터미널로 돌아가자.그리고 pod install을 다시 해보자에러가 발생한다?해당 버전을 서버에서 찾지 못한것같다.그래서 낮은 버전이 설치가 되었나보다.그런데 아래를 보니 발견은 했으나 더 높은 최소 버전을 요구한다고 한다.그말은 즉 podfile의 제일 첫번째 문장 platform :ios, '9.0' 이게 너무 낮아서 설치를 못했다고 볼 수 밖에 없다.그럼 맞는 버전을 우리가 어떻게 확인을 해야할까?해당 Github에 다시 돌아가서podspec파일을 열어보자.Gotcha! 우리가 필요로 하던 정보가 바로 여기에 있었다.다시 podfile로 돌아가서 platform :ios, '13.0' 이렇게 바꿔 주었다.현재 공부하고 있는 ios 버전이 13이어서 맞춰주었다.다시 터미널로가서 pod install을 실행해보자!설치가 잘 되었다 :)프로젝트를 다시 열어서 빌드를 재시도 해보자. (.xcworkspace파일을 열어야한다!)빌드하니 아무런 문제가 없다.이젠 문제없이 정상적으로 사용 할 수 있게 되었다."
  },
  
  {
    "title": "(Deep Dive) Coordinator Pattern",
    "url": "/posts/(Deep-Dive)-Coordinator-Pattern/",
    "categories": "Udemy, Deep Dive",
    "tags": "Myself",
    "date": "2024-03-19 02:32:00 +0900",
    





    
    "snippet": "우연히 유튜브를 보다가 Coordinator Design Pattern 이라는 제목의 영상을 보게 되었다.1. 시초https://khanlou.com/2015/01/the-coordinator/https://khanlou.com/2015/10/coordinators-redux/https://vimeo.com/144116310Khanlou라는 분이 제안...",
    "content": "우연히 유튜브를 보다가 Coordinator Design Pattern 이라는 제목의 영상을 보게 되었다.1. 시초https://khanlou.com/2015/01/the-coordinator/https://khanlou.com/2015/10/coordinators-redux/https://vimeo.com/144116310Khanlou라는 분이 제안을 한 글이다. 시간이 되면 읽어보자.2. Coordinator Pattern 이란?  VC로 부터 화면 전환의 부담을 줄여주고, 화면 전환을 보다 더 관리하기 쉽도록 고안된 패턴.3. 장점  각각의 VC가 독립적인 개체가 된다.  VC를 여러번 사용할 수 있다.  앱의 모든작업과 하위 작업들을 캡슐화 하는 방법이 존재한다.  디스플레이 바인딩을 부작용으로 부터 분리한다.  Coordinator는 유져가 완전히 컨트롤 할수있는 개체이다.  하드 코딩에서 벗어난다.4. Diagram  without children  with children  보면 각각의 VC가 서로를 알 필요가 없다.  모든건 Coordinator가 관리한다.5. 기본 틀1. Coordinator Protocol 작성protocol Coordinator {    var children : [Coordinator] { get set }    var nav : UINavigationController { get set }    func start()}2. MainCoordinator 작성class MainCoordinator : Coordinator {    func start () {        let vc = ViewController ()        vc.coordinator = self        nav.pushViewController(vc, animated: false)    }}6. Main interface 지우기해당 영상을 보다보면 Main interface의 Main을 지우는데 버전이 바뀌었으므로위의 사진대로 하면 된다.그리고 info.plist에서 해당 부분을 지워준다.6-1. 코드 작성1. Coordinator Protocol 작성// Coordinator.swiftimport Foundationimport UIKitenum Event { // 현재 여기선 열거형으로 간단하게 만들었다.    case buttonTapped // 버튼을 탭했을 경우    }protocol Coordinator {    var navigationControlller : UINavigationController? { get set } // 화면전환에 필요한 UINavigationController        //var children : [Coordinator]? { get set } // 화면 전환시 생성될 하위 Coordinator를 저장할 때 사용.    // coordinator 생성후 저장하지 않으면 메모리에서 제거되기에 꼭 저장 해야한다.    func eventOccurred(with type : Event) // 이벤트가 발생했을때        func start () // 앱이 시작될때 호출하는 함수 설정}protocol Coordinating { // 모든 VC가 이벤트를 전달하기 위한 Coordinator에 대한 참조가 필요.        var coordinator : Coordinator? { get set }    }2. AppDelegate, SceneDelegate 수정// AppDelegatevar window: UIWindow?func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&gt; Bool {                        let navVC = UINavigationController()                let coordinator = MainCoordinator()        coordinator.navigationControlller = navVC                let window = UIWindow(frame:  UIScreen.main.bounds)        window.rootViewController = navVC        window.makeKeyAndVisible()        self.window = window                coordinator.start()                return true    }// SceneDelegatevar window: UIWindow?    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {        guard let windowScene = (scene as? UIWindowScene) else { return }                let navVC = UINavigationController()                let coordinator = MainCoordinator()        coordinator.navigationControlller = navVC                let window = UIWindow(windowScene: windowScene)        window.rootViewController = navVC        window.makeKeyAndVisible()        self.window = window                coordinator.start()            }  해당 과정을 거치면 Root VC가 앱 시작시 화면에 나오게 된다.3. MainCoordinator 작성  우선 뼈대만 작성한다.// MainCoordinator.swiftimport Foundationimport UIKitclass MainCoordinator : Coordinator {    var navigationControlller: UINavigationController?        func eventOccurred(with type: Event) {            }        func start() {        var vc : UIViewController &amp; Coordinating = ViewController()                vc.coordinator = self                navigationControlller?.setViewControllers([vc], animated: false)    }        }4. VC 작성import UIKitclass ViewController: UIViewController,Coordinating {        var coordinator : Coordinator?        override func viewDidLoad() {        super.viewDidLoad()                view.backgroundColor = .red        title = \"Home\"                let button = UIButton(frame: CGRect(x: 0, y: 0, width: 220, height: 55))        view.addSubview(button)        button.center = view.center        button.backgroundColor = .systemGreen        button.setTitleColor(.white, for: .normal)        button.addTarget(self, action: #selector(didTapButton), for: .touchUpInside)        button.setTitle(\"Tap me!\", for: .normal)    }        @objc func didTapButton () {        coordinator?.eventOccurred(with: .buttonTapped)            }}5. SecondVC 작성import UIKitclass SecondViewController: UIViewController, Coordinating {    var coordinator: Coordinator?        override func viewDidLoad() {        super.viewDidLoad()        title = \"Second\"        view.backgroundColor = .systemBlue                    }    }6. MainCoordinator 코드 보완class MainCoordinator : Coordinator {        var navigationControlller: UINavigationController?        func eventOccurred(with type: Event) {        switch type {        case .buttonTapped :            let vc : UIViewController &amp; Coordinating  = SecondViewController()                         navigationControlller?.pushViewController(vc, animated: true)        }    }        func start() {        var vc : UIViewController &amp; Coordinating = ViewController()                vc.coordinator = self                navigationControlller?.setViewControllers([vc], animated: false)    }        }7. 작동 테스트7. 복기우선 해당내용은 유튜브 알고리즘에 의해 우연히 알게 되었고, 튜터님과 이야기 하던중 VC간 서로 연결이 되어있지 않아도 데이터 전달이 가능하다고 해서 혹시 이건가? 싶어서 일단 유튜브 보면서 코드부분만 정리를 해보았다.조금 더 지식이 쌓이게 된다면 정리를 해야할 것 같다.얼추 어떤 느낌이다 라는건 감이 오지만 정확하게 각각 의미하는 바를 설명하기엔 완벽하지는 않다.그래도 이런것이 있고 찍먹만 해본것도 만족한다.주말에 진득하게 파봐야 할 것 같다.그리고 찾는 자료마다 표현하는 방식이 너무 다르다.출처https://siwon-code.tistory.com/38https://velog.io/@ellyheetov/Coordinator-Patternhttps://jintaewoo.tistory.com/58https://www.youtube.com/watch?v=SAZzcKvOvAE&amp;t=1124s"
  },
  
  {
    "title": "FlashChat (1)",
    "url": "/posts/FlashChat-(1)/",
    "categories": "Udemy, FlashChat",
    "tags": "",
    "date": "2024-03-18 16:00:00 +0900",
    





    
    "snippet": "VC 구성많아야 VC가 2개였는데 이번에는 4개의 VC로 이루어져있다.  초기화면  가입화면  로그인화면  채팅화면가입화면에서 textField로 보이는곳에 shadow가 있는것은 assets의 images를 사용하였다.현재 warning이 나오고 있다.VC가 서로 연결이 되어있지 안다보니 나타나는 경고이다.그리고 여기에 있는 화살표가, 앱이 어디서 ...",
    "content": "VC 구성많아야 VC가 2개였는데 이번에는 4개의 VC로 이루어져있다.  초기화면  가입화면  로그인화면  채팅화면가입화면에서 textField로 보이는곳에 shadow가 있는것은 assets의 images를 사용하였다.현재 warning이 나오고 있다.VC가 서로 연결이 되어있지 안다보니 나타나는 경고이다.그리고 여기에 있는 화살표가, 앱이 어디서 부터 시작될지를 나타내는 표시이다. (즉 앱을 실행하고 보여주는 초기화면이다)Segue를 사용하여 VC간 연결하기이건 뭐 워낙 쉽다보니 생략하겠다. Control 누른채로 드래그하자우린 여태 VC와 VC를 이어 주었다.하지만 VC의 특정 버튼을 통해 다른 VC로 이동하게 끔하려면 그 버튼을 Control 누른채로 드래그 해주면된다.Register를 우클릭 해보면?이렇게 action으로 RegisterVC로 이동이 되게끔 잘 연결이 되었다!.실행을 해보면?잘된다. 하지만 이렇게 나오는건 우리가 원하는게 아니다.Root View Controller(앱 구동시 보이는 초기 VC) 에서 NavigationVC를 만들면 된다.실행해보면?우리가 흔히 아는 back 버튼이 위에 생겼다.이게 보통 우리가 화면을 다른 화면으로 전환하는 흔한 방법이다.Navigation Stack 이라고 한다.Segue Identifier 명명하기사진으로 대체 하겠다.Animation 만들기Animation을 만들기 위해선 Loop 가 필요하다override func viewDidLoad() {        super.viewDidLoad()                titleLabel.text = \"\"                let titleText = \"⚡️FlashChat\"                for letter in titleText {            titleLabel.text?.append(letter)        }            }한글자씩 띄우게 하고 실행했는데 안된다?안된게 아니라 너무 빨라서 보이지 않았다가 맞다.즉 우리는 타이머가 필요하다!Timer를 만들어 보자.override func viewDidLoad() {        super.viewDidLoad()                titleLabel.text = \"\"                let titleText = \"⚡️FlashChat\"        for letter in titleText {            Timer.scheduledTimer(withTimeInterval: 0.1 , repeats: false) { timer in                self.titleLabel.text?.append(letter)            }        }    }이것 역시도 너무나 빠르다. 근데 빠른도 문제지만 결과가 이상하다?다시실행해보자타이머가 0.1초라는 아주 짧은 찰나에 이뤄지기에 거의 동시에 시작된다고 봐도 무방하다.이걸 고치기 위해서 즉 딜레이를 주기 위해서는 withTimeInterval을 변경해줘야한다.우선 charIndex라는 변수를 하나 만들어준다. 값은 0으로 한다.그리고 for문이 끝날때마다 1씩 증가하게 한다.override func viewDidLoad() {            super.viewDidLoad()                        titleLabel.text = \"\"                        var charIndex = 0                    let titleText = \"⚡️FlashChat\"            for letter in titleText {                print(charIndex)                print(letter)                Timer.scheduledTimer(withTimeInterval: 0.1 , repeats: false) { timer in                    self.titleLabel.text?.append(letter)                }                charIndex += 1            }        }/*0⚡️1F2l3a4s5h6C7h8a9t*/위와 같이 print가 되는걸 알 수 있다.그리고 원하는대로 다시 글자가 나오지만 아직도 애니메이션 효과를 볼 수는 없다.여기서 우리가 할 수 있는건 withTimeInterval의 parameter를 charIndex로 곱하는 것이다.이렇게 되면 하나가 실행 되면 그다음 0.2 초 뒤에 프린트가 되고 그다음건 0.3초 이렇게 자연스럽게 시간 딜레이가 발생하면서 보여지게 될것이다.그전에 type에러가 나므로 type을 맞춰주자.시간 딜레이를 보기 위해 다음과 같이 하고 실행을 해보자.override func viewDidLoad() {        super.viewDidLoad()                titleLabel.text = \"\"                let titleText = \"⚡️FlashChat\"        var charIndex = 0.0                for letter in titleText {            print(\"-\")            print(0.1 * charIndex)            print(letter)            Timer.scheduledTimer(withTimeInterval: 0.1 * charIndex, repeats: false) { timer in                self.titleLabel.text?.append(letter)            }            charIndex += 1        }    }/*-0.0⚡️-0.1F-0.2l-0.30000000000000004a-0.4s-0.5h-0.6000000000000001C-0.7000000000000001h-0.8a-0.9t*/이제 실행해보자위와 같이 시간 딜레이가 조금씩 증가하면서 print가 되는걸 알 수있다.잘된다."
  },
  
  {
    "title": "UIPreview",
    "url": "/posts/UI-Preview-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/",
    "categories": "Tip, UIPreview",
    "tags": "",
    "date": "2024-03-18 14:00:00 +0900",
    





    
    "snippet": "이젠 Command + R 을 할 필요가 없다.https://developer.apple.com/documentation/xcode/previewing-your-apps-interface-in-xcode 참고  view Controller#if canImport(SwiftUI) &amp;&amp; DEBUGimport SwiftUIstruct UIVi...",
    "content": "이젠 Command + R 을 할 필요가 없다.https://developer.apple.com/documentation/xcode/previewing-your-apps-interface-in-xcode 참고  view Controller#if canImport(SwiftUI) &amp;&amp; DEBUGimport SwiftUIstruct UIViewControllerPreview&lt;ViewController: UIViewController&gt;: UIViewControllerRepresentable {    let viewController: ViewController    init(_ builder: @escaping () -&gt; ViewController) {        viewController = builder()    }    // MARK: - UIViewControllerRepresentable    func makeUIViewController(context: Context) -&gt; ViewController {        viewController    }    func updateUIViewController(_ uiViewController: ViewController, context: UIViewControllerRepresentableContext&lt;UIViewControllerPreview&lt;ViewController&gt;&gt;) {        return    }}#endif#if canImport(SwiftUI) &amp;&amp; DEBUGimport SwiftUIlet deviceNames: [String] = [    \"iPhone SE\",    \"iPhone 11 Pro Max\",    \"iPad Pro (11-inch)\"]@available(iOS 13.0, *)struct ViewController_Preview: PreviewProvider {  static var previews: some View {    ForEach(deviceNames, id: \\.self) { deviceName in      UIViewControllerPreview {        ViewController()      }.previewDevice(PreviewDevice(rawValue: deviceName))        .previewDisplayName(deviceName)    }  }}#endif// WWDC2023 #Preview(\"ViewController\"){    ViewController()}//#if DEBUGimport SwiftUIstruct ViewControllerRepresentable: UIViewControllerRepresentable {    typealias UIViewControllerType = ViewController    func makeUIViewController(context: Context) -&gt; UIViewControllerType {        ViewController(nibName: nil, bundle: nil)    }        func updateUIViewController(_ uiViewController: UIViewControllerType, context: Context) {            }}struct ViewController_Previews: PreviewProvider {    static var previews: some View {        ViewControllerRepresentable()    }}#endif  UIViewimport Foundationimport UIKitfinal class SimpleView: UIView {        let label = UILabel()        override init(frame: CGRect) {        super.init(frame: frame)                label.translatesAutoresizingMaskIntoConstraints = false        label.text = \"Simple Label\"                addSubview(label)                NSLayoutConstraint.activate([            label.centerXAnchor.constraint(equalTo: centerXAnchor),            label.centerYAnchor.constraint(equalTo: centerYAnchor)        ])    }        required init?(coder: NSCoder) {        fatalError(\"init(coder:) has not been implemented\")    }        override var intrinsicContentSize: CGSize {        return CGSize(width: 200, height: 200)    }}#if canImport(SwiftUI) &amp;&amp; DEBUGimport SwiftUI@available(iOS 13, *)public struct UIViewPreview&lt;View: UIView&gt;: UIViewRepresentable {    public let view: View    public init(_ builder: @escaping () -&gt; View) {        view = builder()    }    // MARK: - UIViewRepresentable    public func makeUIView(context: Context) -&gt; UIView {        return view    }    public func updateUIView(_ view: UIView, context: Context) {        view.setContentHuggingPriority(.defaultHigh, for: .horizontal)        view.setContentHuggingPriority(.defaultHigh, for: .vertical)    }}#endif#if canImport(SwiftUI) &amp;&amp; DEBUGimport SwiftUI@available(iOS 13.0, *)struct SimpleView_Preview: PreviewProvider {  static var previews: some View {    UIViewPreview {      let button = SimpleView()      return button    }.previewLayout(.sizeThatFits)     .padding(10)  }}#endif해당내용은 주말에 정리를 해야겠다."
  },
  
  {
    "title": "3주차 Counter App",
    "url": "/posts/Main-campus_3rd_week_Counter-App/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-18 14:00:00 +0900",
    





    
    "snippet": "문제다음과 같이 주어졌다.만들어 보자.우선 프로젝트생성 및 UILabel, UIButton은 생략하겠다.해결 과정      우선 숫자를 표현해야하므로 변수 value를 하나 만들어 주었다.        그리고 앱을 구동하자마자 Label이라고 그대로 보이는것이 아니라,숫자 0으로 보이기 위해서 viewDidLoad에 displayLabel.text =...",
    "content": "문제다음과 같이 주어졌다.만들어 보자.우선 프로젝트생성 및 UILabel, UIButton은 생략하겠다.해결 과정      우선 숫자를 표현해야하므로 변수 value를 하나 만들어 주었다.        그리고 앱을 구동하자마자 Label이라고 그대로 보이는것이 아니라,숫자 0으로 보이기 위해서 viewDidLoad에 displayLabel.text = String(value) 작성해주었다.        버튼을 구현해준다.up / down 목적에 맞게 + / - 를 해주고 눌렀을때 값만 변하는게 아닌 화면에 보여줘야하므로 displayLabel.text = String(value) 를 작성해주었다.        작동 테스트  잘 된다.AutoLayout  StackView 지정          우선 3개의 Component를 하나의 Stack View로 지정을 해준다.        정중앙에 오도록 지정          이번엔 정중앙에 깔끔하게 정리하려고 별도의 Constraints(제약)을 주지는 않겠다.        label 조금 삐뚤다 가운데 정렬만 해주자                  작동 테스트잘 된다.완성 코드import UIKitclass ViewController: UIViewController {        @IBOutlet weak var displayLabel: UILabel!        var value = 0        override func viewDidLoad() {        super.viewDidLoad()        displayLabel.text = String(value)    }            @IBAction func upBtn(_ sender: UIButton) {        value += 1        displayLabel.text = String(value)    }                @IBAction func downBtn(_ sender: UIButton) {        value -= 1        displayLabel.text = String(value)    }    }  updated(19.Mar)못들었던 강의를 들으며 해당 부분에대한 설명을 듣는데.viewDidLoad의 생명주기를 활용을 해주었다고 한다.import UIKitclass ViewController: UIViewController {    @IBOutlet weak var textLabel: UILabel!    private var count: Int = 0    // 감소 버튼이 클릭된 경우    @IBAction func tappedDecreaseButton(_ sender: UIButton) {        self.count -= 1 // count를 -1 합니다.        self.refreshTextLabel() // textLabel을 새로고침 합니다.    }        // 증가 버튼이 클릭된 경우    @IBAction func tappedIncreaseButton(_ sender: UIButton) {        self.count += 1 // count를 +1 합니다.        self.refreshTextLabel() // textLabel을 새로고침 합니다.    }        // count값을 self.textLabel의 text에 반영합니다.    private func refreshTextLabel() {        self.textLabel.text = String(self.count)    }        // viewDidLoad 생명주기 활용    override func viewDidLoad() {        super.viewDidLoad()        self.refreshTextLabel()    }}이부분은 미처 생각하지 못했던 부분이다.생명주기에 대해서 주말에 한번 글을 적어봐야 할 것 같다."
  },
  
  {
    "title": "3주차 (1)",
    "url": "/posts/Main-campus_2nd-week-9/",
    "categories": "캠프, 3주차",
    "tags": "",
    "date": "2024-03-18 14:00:00 +0900",
    





    
    "snippet": "UIView Component1. UILabel      텍스트를 표시하는 데 사용되는 UI Component        함수를 통한 UILabel 생성  func setUIlabel () {        let label = UILabel()        label.text = \"Hello World!\" // Label에 보여주기        la...",
    "content": "UIView Component1. UILabel      텍스트를 표시하는 데 사용되는 UI Component        함수를 통한 UILabel 생성  func setUIlabel () {        let label = UILabel()        label.text = \"Hello World!\" // Label에 보여주기        label.font = UIFont.systemFont(ofSize: 15) // Font size 설정        label.textColor = UIColor.red // Font color 설정        label.textAlignment = .center // Text alignment 설정        label.numberOfLines = 2 // Number of lines 최대 2줄까지 표시                                // 0으로 하면 자동으로 줄을 바꾼다.        label.lineBreakMode = .byTruncatingTail // Text가 너무 길면 ... 으로 표시                label.frame = CGRect(x:150, y:150, width: 150, height: 150)        // 생성될 label의 위치와 크기를 세팅        label.backgroundColor = #colorLiteral(red: 0.1019607857, green: 0.2784313858, blue: 0.400000006, alpha: 1) // label 배경색을 설정.                label.layer.borderWidth = 3 // label에 테두리 굵기를 설정한다.        label.layer.borderColor = UIColor.red.cgColor // label 테두리 색을 설정                                                                // 뒤에 cgColor가 오는걸 명심하자                self.view.addSubview(label)        // 실제로 해당 뷰를 띄우겠다. 이걸 작성하지 않으면 함수를 호출해도 보이지 않는다.    }2. UIImageView  Image를 표시하는 데 사용되는 UI Component          image : 표시할 이미지를 설정, UIImage 객체 할당      contentMode : 이미지가 UIImageView에 맞춰질 대의 크기 및 배치 방법을 설정한다.      isUserInteractionEnabled : 사용자 상호작용을 허용할지에 대한 여부      animationImages : 애니메이션을 위한 이미지 배열을 설정, 여러 UIImage객체를 할당하여 애니메이션을 만들 수 있다.`      func setImageView () {        let imageView = UIImageView()        let image = UIImage(named: \"test\") // Image File 명으로 UIImage 오브젝트 생성        imageView.image = image                // 이미지 뷰의 프레임 설정        imageView.frame = CGRect(x: 150, y: 350, width: 150, height: 150)                // contentMode 설정        imageView.contentMode = .scaleAspectFit // 이미지 비율 유지하면서 맞춘다.                // 뷰를 화면에 표시        self.view.addSubview(imageView)    }3. UITextField  사용자로부터 텍스트를 입력받기 위해 사용되는 UI Component          text : TextField에 표시되는 문자열      placeholder : TextField에 입력을 유도하기 위해 표시되는 플레이스 홀더 텍스트를 설정      keyboardType : 사용자가 텍스트 필드에 입력할 때 표시되는 키보드 유형을 설정      isSecureTextEntry : 입력된 텍스트를 숨기기 위해 설정하는 속성      returnKeyType :  키보드의 리턴키의 타입을 설정      func setUITextField() {        let textField = UITextField()                textField.placeholder = \"여기에 입력해\"        textField.borderStyle = .roundedRect // TextField의 모양 (둥근 테두리)        textField.keyboardType = .default // 일반 키보드        textField.isSecureTextEntry = false // 비밀번호처럼 *** 이런식으로 가릴건지의 여부        textField.returnKeyType = .done // Return키의 종류                textField.frame = CGRect(x: 150, y: 400, width: 150, height: 40)                self.view.addSubview(textField)            }4. UIButton  사용자가 터치하여 상호작용 할 수 있는 UI Component          titleLabel : 버튼에 표시되는 텍스트 레이블에 대한 접근 제공      setImage(_:for:) : 버튼에 이미지를 설정하고 상태에 따라 다른 이미지를 사용 할 수 있다.      setTitle(_:for:) : 버튼에 텍스트를 설정하고 상태에 따라 다른 텍스트를 사용할 수 있도록 한다.      addTarget(_:action:for:) : 버튼이 터치되었을 때 실행할 액션을 등록한다. 버튼의 동작을 정의한다.      isEnabled : 버튼이 활성화 되었는지의 여부를 나타낸다.                  비활성화 된 버튼은 터치 또는 클릭 이벤트를 무시한다.                     func setUIButton() {        let uiButton = UIButton(type: .system)                uiButton.setTitle(\"눌러봐\", for: .normal) // 현재 버튼의 text        uiButton.setTitleColor(UIColor.green, for: .normal) // 글자색        uiButton.frame = CGRect(x: 150, y: 500, width: 150, height: 50)        uiButton.backgroundColor = .blue // 배경색        uiButton.addTarget(self, action: #selector(buttonTapped), for: .touchUpInside) // 버튼을 눌렀을때 실행할 함수를 지정해준다.                self.view.addSubview(uiButton)    }        @objc func buttonTapped() {        print(\"Button Pressed\")    }5. UISwitch  On/Off 상태를 표시하고 전환하는데 사용되는 UI Component          isOn : 스위치의 현재 상태      onTintColor : 스위치가 켜져있을 때의 배경 색      thumbTintColor : 스위치의 썸네일 색상      OnImage : 스위치가 켜져있을 때 표시되는 이미지      offImage : 스위치가 꺼져있을 때 표시되는 이미지      func setUISwitch () {        let uiSwitch = UISwitch()        uiSwitch.isOn = true        uiSwitch.onTintColor = .blue        uiSwitch.thumbTintColor = .orange                uiSwitch.addTarget(self, action: #selector(switchValueChanged(_ :)), for: .valueChanged) // valuechanged : 값이 변했을때 인지                uiSwitch.frame = CGRect(x: 50, y: 70, width: 40, height: 40)                self.view.addSubview(uiSwitch)    }        @objc func switchValueChanged (_ sender : UISwitch ) {        if sender.isOn {            print(\"switch on\")        } else {            print(\"switch off\")        }    }"
  },
  
  {
    "title": "2주차 (8)",
    "url": "/posts/Main-campus_2nd-week-8/",
    "categories": "캠프, 2주차",
    "tags": "",
    "date": "2024-03-17 07:11:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "(Deep Dive) Data Communication",
    "url": "/posts/(Deep-Dive)-Data-Communication/",
    "categories": "Udemy, Deep Dive",
    "tags": "Myself",
    "date": "2024-03-16 13:32:00 +0900",
    





    
    "snippet": "1. Intro이번에 Byte Coin을 하면서 ViewController를 통해 데이터를 전송하려고 하였으나nil이 되면서 에러가 떴다, 하지만 아이러니한건 print를 했을때는 그 값이 출력이 되었다는 것이다.도대체 뭐가 문제일까를 내 스스로 해답을 찾아가보기 위해 처음으로 나만의 Deep Dive를 해본다.기존에 Deep Dive들은 강의를 통해...",
    "content": "1. Intro이번에 Byte Coin을 하면서 ViewController를 통해 데이터를 전송하려고 하였으나nil이 되면서 에러가 떴다, 하지만 아이러니한건 print를 했을때는 그 값이 출력이 되었다는 것이다.도대체 뭐가 문제일까를 내 스스로 해답을 찾아가보기 위해 처음으로 나만의 Deep Dive를 해본다.기존에 Deep Dive들은 강의를 통해서 정리를 한것이어서 뭔가 수동적인 느낌이었다면, 이번엔 내가 직접 자료를 찾아보고 테스트를 하면서하는능동적인 Deep Dive이다.앞으로 내가 직접 분석을 하면서 찾아내는 결과를 담은 Deep Dive엔 별도의 태그(Myself)를 붙여서 관리를 할 생각이다.그럼 이제 진짜 시작해보자2. 데이터 전달 방식의 종류Swift에서 View Controller간 데이터 전달을 하는 방식에는 크게 2가지로 나뉘게 된다.  직접 전달 방식(동기 방식) : 데이터를 직접 넘겨준다          present, push시 프로퍼티에 접근해 넘겨주는 방식      Segue prepare 메서드를 활용하여 데이터를 넘겨주는 방식      Protocol / Delegation을 활용하여 데이터를 넘겨받는 방식      Closure를 활용하여 데이터를 넘겨받는 방식      Notification Centre를 활용해 데이터를 넘기는 방식        간접 전달 방식(비 동기 방식) : 데이터를 다른곳에 저장하고, 필요할때마다 꺼내는 방식          AppDelegate.swift 활용      UserDefaults 사용      CoreData or Realm 활용      3. 가장 많이 쓰이는 전달 방식은?  present, push시 프로퍼티에 접근해 넘겨주는 방식  Protocol / Delegation을 활용하여 데이터를 넘겨받는 방식  Closure를 활용하여 데이터를 넘겨받는 방식  Notification Center를 활용해 데이터를 넘기는 방식실제로 내가 시도했던것도, 1번, 2번이었고 1번을 시도했을때 잘 안되어서 튜터님께 물어봤을때도 3번을 활용해보는게 어떠냐고 하셨다.그리고 4번의 경우는 야구게임을 할때 Tuple로 리턴을 해야하는 경우가 생겼는데, notification을 활용해서 넘기는 방식도 있다고 하셨다.즉 가장 많이쓰이는 전달 방식 4개는 모두 알아 두는게 좋다!4. Instance Property (present, push)0. 어떻게 전달이 되는가?  프로퍼티를 사용해서 데이터를 전달할때는 보통 present/push를 통해 데이터를 전달을 한다.  VC Instance를 생성하고, 해당 Instance에 내가 전달할 값을 추가로 달아둔다.  그리고 화면을 전환하는 present를 통해 전달된 데이터를 다른 VC가 받아 처리.  보통 First → Second로 갈때 사용한다1. 코드 작성 (내가하던 방식)  Property를 사용하여 데이터를 전송해보자우선 테스트용 뷰컨트롤러를 하나 더 만들어주었다.  FirstViewController  SecondViewController이렇게 구분을 지어주었다.그리고 textfield에 입력한값을 send버튼을 눌러 두번째 뷰 컨트롤러에 전달할 것이다.우선은 내가 실패했던 방법으로 해보았다.import UIKitclass FirstViewController: UIViewController {    @IBOutlet weak var textField: UITextField!        let secondVC = SecondViewController()        override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.    }    @IBAction func sendData(_ sender: UIButton) {                    secondVC.message = textField.text            secondVC.modalPresentationStyle = .fullScreen            self.present(secondVC,animated: true,completion: nil)           }    }import UIKitclass SecondViewController: UIViewController {    @IBOutlet weak var secondLabel: UILabel!        var message : String?        override func viewDidLoad() {        super.viewDidLoad()        getText()    }        func getText() {        if let gotMessage = message {            secondLabel.text = gotMessage        } else {            secondLabel.text = \"sending text failed\"        }    }        @IBAction func back(_ sender: Any) {        self.dismiss(animated: true,completion: nil)    }}역시 저번처럼 print할때는 값을 전달하나, 그걸 label에 전달하려고하니 nil이 되어버린다.2. 코드 수정 (구글링)아무리 찾아봐도 viewcontroller를 인스턴스화 해서 전달할때는 instantiateViewController 를 사용하고있다.일단 위의 방식대로 해보았다.@IBAction func sendData(_ sender: UIButton) {                guard let secondVC = self.storyboard?.instantiateViewController(identifier: \"SecondViewController\") as? SecondViewController        else {            return        }                secondVC.message = textField.text        secondVC.modalPresentationStyle = .fullScreen        self.present(secondVC,animated: true,completion: nil)            }    as를 통해 DownCasting을 하지 않으니 SecondViewController의 프로퍼티에 접근을 할수가 없었다.실행해보았다.3. 문제 해결??? 이건 identifier의 값이 잘못되었거나 내가 뷰컨트롤러에 제대로 네이밍을 하지 않았을때 발생하는것인데왜 이게 발생했을까?확인을 해보았다.아… 내가 해주질 않았다. 단순히 클래스만 연결을 해주었다.그래서 위에 instantiateViewController(identifier: \"SecondViewController\") 적었음에도 불구하고secondVC. 했을때 아무런 값이 안나온걸끼? 다운캐스팅을 지워봤는데 역시나 에러가 난다. 일단 하던대로 하자다시 실행해보면?전달이 잘된다.4. 복기그럼 왜 이전 방식은 왜 안될까에대한 생각을 해봤다. 갑자기 아차 싶었다.우리가 하고있는 이 뷰컨트롤러도 결국은 클래스였다….아마 저렇게 할경우 계속 새로운 인스턴스가 만들어지기에 내가 의도한 연결과는 다르게 될것이다.내가 아무렇지않게 클래스간 값을 전달할때 각각의 클래스가 값을 따로 가지고 있어서 벙쪘던 기억이 되살아나버렸다.이제서야 모든것이 이해가 되기 시작한다. 왜 내가 전달을 못했는지, 왜 뷰컨트롤러를 단순히 인스턴스화 시키면 안되는지를갑자기 머리속이 맑아진다. 뭔가 득도한 느낌이다.클래스를 인스턴스화 시켜서하려면 결국 함수를 만들고 리턴을 하는 방식으로 해야하는데 뷰컨트롤러는 모든것을 포함하고 있는 메인의 느낌이라,아마 그렇게 하면 복잡해질 것이다.5. 최종 코드// FirstVCimport UIKitclass FirstViewController: UIViewController {        @IBOutlet weak var textField: UITextField!        override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.    }        @IBAction func sendData(_ sender: UIButton) {                guard let secondVC = self.storyboard?.instantiateViewController(identifier: \"SecondViewController\") as? SecondViewController        else {            return        }                secondVC.message = textField.text        secondVC.modalPresentationStyle = .fullScreen        self.present(secondVC,animated: true,completion: nil)        // present로 위로 화면을 띄워주면서 Data 전달.    }    }// SecondVCimport UIKitclass SecondViewController: UIViewController {        @IBOutlet weak var secondLabel: UILabel!        var message : String?        override func viewDidLoad() {        super.viewDidLoad()        getText()    }        func getText() {        if let gotMessage = message {            secondLabel.text = gotMessage        } else {            secondLabel.text = \"sending text failed\"        }    }        @IBAction func back(_ sender: Any) {        self.dismiss(animated: true,completion: nil)    }    }6. 결론ViewController간 통신을 할때는 내가 굳이 인스턴스화를 하고 싶다면 instantiateViewController를 사용 하도록 하자.해당 함수를 사용하기위해선 그함수를 사용하려는 뷰컨트롤러에서 self.storyboard?. 이렇게 해서 사용하면 된다.그리고 이 방식을 사용할때는 화면 전환 할때 주로 사용한다. (애초에 bytecoin할때도 방식이 잘못되었다..)7. instantiateViewController 사용 시 주의사항  instantiateViewController는 지정된 identifier를 이용하여 ViewController를 만들고, 그걸 초기화한다.          즉, 내가 instanciateViewController를 사용할때마다 해당 내용은 초기화가 되어있다는 것이다.        First -&gt; Second -&gt; First 일때          second에서도 instanciateViewController를 사용하게 되면 같은 First이긴 하나 데이터는 서로 다르다.                  즉 First -&gt; Second -&gt; First인 경우에 두 First는 서로 다른녀석이다.                    5. Protocol (Delegate)이게 실제로 위의 방법을 했을때 나의 잘못된 생각으로 먹히지 않아서 강의에서 배웠던 내용 그대로를 적용하여 해결했던 방식이다.  Delegate를 사용하는 이유?      객체지향 프로그래밍에서 하나의 객체가 모든일을 처리하는 것이 아닌 처리해야 하는 기능 일부를 다른 객체에 위임(Delegate)한다.그래서 대리인의 의미로 Delegate로 변수를 만들어서 많이 사용한다.          위임된 기능은 프로토콜에서 정의하며, delegate가 위임된 기능을 제공한다.위임은 특정 작업에 응답하거나 외부에서 데이터를 가져오는데 사용할 수 있다.      혹시라도 나중에 다시 프로젝트를 참고 할지도 몰라서 새프로젝트로 한다. 하지만 이름은 동일하게.  ⭐️Delegate는 주는쪽과 받는쪽의 코드작성이 헷갈리기에 주의하자0. 어떻게 전달이 되는가?  프로토콜을 구현을 한다.  그 후 Delegate Instance(Type은 프로토콜로)를 생성한다.  프로토콜을 생성하고 메서드를 구현한다. (Extension을 해서 코드를 깔끔하게 해도 괜찮다.)          데이터를 보내는쪽에서 프로토콜을 작성한다. (찾아보니 사이트마다 설명이 다르다?)        Delegate 위임을 한다.          데이터를 받는 쪽에서 프로토콜을 채택하고, delegate에 위임을 한다.        동작하는 시점을 설정해두고 작동을 해서 전달을 한다.  보통 되돌아오는 방향일때(Second → First) 사용한다.1. 코드 작성우선 테스트용 뷰컨트롤러를 하나 더 만들어주었다.  FirstViewController  SecondViewController이렇게 구분을 지어주었다.그리고 textfield에 입력한값을 send버튼을 눌러 두번째 뷰 컨트롤러에 전달할 것이다.(property와 동일한 형태로 진행한다.)우선 내가 생각하는 방식으로 코드 작성을 해보았다.protocol sendDataProtocol {    func sendData (data : String)}import UIKitclass FirstViewController: UIViewController {        var delegate : sendDataProtocol?        @IBOutlet weak var textField: UITextField!        override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.    }    @IBAction func sendButton(_ sender: UIButton) {                if let secondVC = self.storyboard?.instantiateViewController(identifier: \"SecondViewController\") as? SecondViewController {            if let data = textField.text {                self.delegate?.sendData(data: data)            }                        self.present(secondVC, animated: true, completion: nil)        }    }    }import UIKitclass SecondViewController: UIViewController {    let firstVC = FirstViewController()        @IBOutlet weak var textLabel: UILabel!        override func viewDidLoad() {        super.viewDidLoad()                firstVC.delegate = self    }        @IBAction func backButton(_ sender: UIButton) {        self.dismiss(animated: true)    }    }extension SecondViewController : sendDataProtocol {    func sendData(data: String) {            self.textLabel.text = data        print(data)    }}실행을 해보니 데이터가 전달이 안되는걸까? label이 바뀌지가 않는다.값이 제대로 전달이 되는지 확인을 먼저 해봐야겠다.print도 안된다. 즉 현제 delegate를 통해 값이 전달이 안되는것 같다.증상확인을 위해 breakpoint를 줘봤다.되지않는다. 즉 이 함수가 실행이 안될 가능성이 높다.breakpoint를 다른곳에 줘봤다.뭔가 전달이 안되는걸까 싶어서 다른곳에 breakpoint를 줘보고 다시 실행해보았다.왜 안되는지 모르겠다…일단 방향을 바꿔서 했는데 된다.처음에는 프로토콜을 Second에 만들었는데 안되었다.2. 코드 전면 수정 (ChatGPT의 방식)import UIKitprotocol SendDataDelegate {    func sendData (_ vc : SecondViewController, data : String)}class FirstViewController: UIViewController, SendDataDelegate {    @IBOutlet weak var textField: UITextField!        override func viewDidLoad() {        super.viewDidLoad()            }        @IBAction func sendButton(_ sender: UIButton) {        if let secondVC = self.storyboard?.instantiateViewController(identifier: \"SecondViewController\") as? SecondViewController {            secondVC.delegate = self            if let dataToSend = textField.text {                secondVC.message = dataToSend            }                        self.present(secondVC, animated: true)        }    }        func sendData(_ vc: SecondViewController, data: String) {        DispatchQueue.main.async {            vc.secondLabel.text = data            print(data)        }    }    }import UIKitclass SecondViewController: UIViewController {        @IBOutlet weak var secondLabel: UILabel!    var delegate : SendDataDelegate?        var message : String = \"\"        override func viewDidLoad() {        super.viewDidLoad()        delegate?.sendData(self, data: message)    }        @IBAction func backButton(_ sender: UIButton) {        self.dismiss(animated: true)    }     }진짜 앵간하면 ChatGPT안쓰고 나의 노력으로 하는데 이건 너무 안되어서 물어보았다.뭔가 ChatGPT의 방식은 이렇게 나오는데 작동이 되긴한다.하지만 내가아는 방식과는 좀 다르다. 내가 구현하려고 한 부분이 도대체 무엇이 문제인걸까?다시 테스트를 해봐야 겠다.3. 복기좀 더 찾아보니 Delegate는 Second View Controller를 present한 상황에서 First View Controller로 전달을 하고 싶을때사용한다고 한다.그래서 위에도 적어두었다.구글링을 해보니 설마했던 부분이었는데역시나 이번에도 이부분이 말썽이다.그리고 사이트마다 프로토콜의 위치가 각각 다르다. 나만의 기준을 확실하게 정립을 해야겠다는 생각이 든다.정말 Second → First이어야 하는건가 싶어 그렇게 해서 도전을 해본다.그리고 이번엔 navigation을 사용하기 위해서이렇게 해주었다.4. 코드 재작성 해보기 (Second → First)import UIKitclass FirstViewController: UIViewController, SendDelegate {        @IBOutlet weak var currentLabel: UILabel!        override func viewDidLoad() {        super.viewDidLoad()    }        func sendData(data: String) {        currentLabel.text = data    }    @IBAction func getDataButton(_ sender: UIButton) {        if let secondVC = self.storyboard?.instantiateViewController(identifier: \"SecondViewController\") as? SecondViewController {            secondVC.delegate = self                        self.navigationController?.pushViewController(secondVC, animated: true)        }    }    }import UIKitprotocol SendDelegate {    func sendData(data : String)}class SecondViewController: UIViewController {    @IBOutlet weak var textField: UITextField!        var delegate : SendDelegate?        override func viewDidLoad() {        super.viewDidLoad()    }      @IBAction func dataSendButton(_ sender: UIButton) {        if let text = textField.text {            delegate?.sendData(data: text)        }                self.navigationController?.popViewController(animated: true)    }    }5. 재 복기이젠 내가 원하는대로 된다.왜 이게 작동을 하는걸까? 한번 생각을 해보았다.first에서 내가 위임할거다 라는걸 제공한 상태에서, second에서 데이터를 받아서 그걸 가져온다 라는 생각을 해보았다.근데 내가 처음에 생각한 first to second는 그런부분이 반대로 된다.6. 빌드업4번항목에서 제대로 작동하였기에, 빌드업을 한번 적어본다.  보내는쪽 (SecondVC)            프로토콜을 생성한다.        protocol SendDelegate {func sendData(data : String)}                    var delegate : SendDelegate? delegate 변수 생성                  위임을 해야하기에 변수를 만들어 준다                    delegate를 통해 함수로 값을 전달한다.                  delegate?.sendData(data: text)                      받는쪽 (FirstVC)            프로토콜을 채택한다.      프로토콜의 함수를 작성해준다.        func sendData(data: String) {    currentLabel.text = data}                    SecondVC에서 선언해둔 delegate가 self. 즉 대신해서 처리할 부분이 FirstVC라는 것을 선언한다 (중요!)                  secondVC.delegate = self                    7. 나의 결론근본적으로 왜 Second→First 일까를 물어보러 갔다.튜터님이 딱 한마디로 쉽게 알려주셨다.  First에서 Second 로 전달할때, First는 이미 Second에 대해 모든걸 알고 있다. 굳이, delegate를 통해 위임해서 전달 할 필요가 없기 때문이다.이걸 들었을때 내가 주말동안 이글을 작성하면서 고민해왔던 것들 그리고 내가 이렇게 정리한 내용들이 어떤 상황일때 써야하는지에 대해 밑그림이 그려졌다.즉 Diagram으로 표현을 한다면  FirstVC→SecondVC          이미 우리가 secondVC를 instantiate를 통해 만들어서 이동하기에, FirstVC가 SecondVC에 대해 알고 있는 상태이다.        SecondVC→FirstVC          SecondVC는 FirstVC에 대하여 아무런 정보가 없다.                  왜냐 다시 돌아갈때도 dismiss를 통해서 돌아가기 때문.                    그러므로 SecondVC에서 데이터를 전달하기 위해서, delegate가 대신 그 값을 받아서 FirstVC로 가는 것이다.      6. Closure로 데이터 전달0. 어떻게 전달이 되는가?  보통 되돌아오는 방향일때(Second → First) 사용한다.          protocol과 같은 맥락        차이점이라면 수신VC가 송신VC의 저장속석인 클로저에 접근하여 상세내용을 직접 주입한다.  이미 메모리에 올라와 있는 상태에서 데이터를 전달할때 사용한다.1. 코드 작성import UIKitclass FirstViewController: UIViewController {    @IBOutlet weak var displayLabel: UILabel!        override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.    }    @IBAction func nextBtn(_ sender: UIButton) {                if let secondVC = self.storyboard?.instantiateViewController(identifier: \"SecondViewController\") as? SecondViewController {            secondVC.dataClosure = { data in                self.displayLabel.text = data            }            self.present(secondVC, animated: true)        }            }    }import UIKitclass SecondViewController: UIViewController {    // Data전달 Closure    var dataClosure : ((_ data:String) -&gt; Void )?        @IBOutlet weak var textField: UITextField!            override func viewDidLoad() {        super.viewDidLoad()    }        @IBAction func sendDataBtn(_ sender: UIButton) {        if let text = textField.text {            dataClosure?(text)        }        self.dismiss(animated: true)    }    }2. 코드 분석  클로저는 일종의 데이터 전달 통로로 생각을 하면 된다고한다.  데이터를 보내려는 VC에 만들어준다    var dataClosure : ((_ data:String) -&gt; Void )?var dataClosure1 : ((String) -&gt; ())?        클로저에 전달하려는 데이터를 담는다 (dataClosure?(text))  수신을 하는 VC에 데이터를 받으면 어떻게 처리를 할지에 대한 내용을 적는다.          SecondVC로 화면전환을 하기 이전에 해당 연결통로에서 데이터가 들어오면 어떻게 처리할지를 정의한다.      클로저 형태로 연결된다는 것을 선언함과 동시에, 데이터 처리 어떻게 하겠다는걸 정의한다.      7. Notification Center로 데이터 전달0. 어떻게 전달이 되는가?  메모리에 올라와 있는 객체 모두에게 신호를 보낸다.  객체에서 같은 신호 이름을 가진 옵저버가 존재하면 데이터를 수신  delegate, closure의 차이는 우리가 직접 대리자를 지정했지만, Notification은 옵저버가 존재하면 알아서 데이터를 전달받아 처리한다.  NotificationCenter는 싱글톤이다.          싱글톤 : 객체의 인스턴스가 오직 1개만 생성되는 패턴을 의미한다      1. 코드 작성해당부분은 실제로 해본적이 없어서 인터넷을 참고하여 코드를 작성해보기로 하였다.전개방식은 protocol과 같이 Second to First 로 한다.  FirstVC          addObserver : Notification을 관찰                  전달 받은 신호를 관찰하여 함수를 실행한다,                      SecondVC          post : Notification 신호를 보낸다.                  원하는 데이터를 전달한다.                    import UIKitclass FirstViewController: UIViewController {    @IBOutlet weak var displayLabel: UILabel!        override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.    }    @IBAction func getDataBtn(_ sender: UIButton) {                if let secondVC = self.storyboard?.instantiateViewController(identifier: \"SecondViewController\") as? SecondViewController {                        self.navigationController?.pushViewController(secondVC, animated: true)        }                NotificationCenter.default.addObserver(self, selector: #selector(dataReceived(_:)), name: NSNotification.Name(\"test\"), object: nil)            }        @objc func dataReceived (_ notification : Notification) {                if let text = notification.object as? String { // DownCasting            displayLabel.text = text        }            }    }import UIKitclass SecondViewController: UIViewController {        @IBOutlet weak var textField: UITextField!        override func viewDidLoad() {        super.viewDidLoad()    }        @IBAction func sendDataBtn(_ sender: Any) {                if let text = textField.text {                        NotificationCenter.default.post(name: NSNotification.Name(\"test\"), object: text)        }                self.navigationController?.popViewController(animated: true)    }    }2. 코드 파헤쳐 보기  SecondVC(데이터 전송)          Notification을 전송할땐 Notification.default을 사용한다                  앱 전체적으로 하나의 객체에서 관리할 수 있도록 default가 정의 되어있다.                          대부분 default에 접근하여 메서드를 호출한다.                                          post : 객체가 NotificationCenter로 이벤트를 보내는 행위      name : Notificaion 에서 우리가 설정한 알람의 이름                  만약 여러개면 하나하나 이름을 붙여 구분해두면 된다.                    object : 전달하고자 하는 데이터        FirstVC(데이터 수신)          addObserver : 알림을 받는 주체      selector : 알림을 받은 주체가 수행하는 함수.                  ⭐️obj-C 형태이다!                    name : 알람의 이름      object : post된 object값이 여기의 object와 동일할때만 값을 받는다.      dataReceived : notification이 생기면 실행하는 함수로 함수의 내용을 서술.                  parameter로  Notification type을 해주었다.                          Notification.object로 값을 가져온다.              DownCastin을 한 것은 object 타입이 Any? 이기 때문이다.                                            별도로 name 등록하기    extension Notification.Name { static let test = Notification.Name(\"test\")}              이렇게 extension형식으로도 가능하다.      3. 복기뭔가 여러 viewcontroller를 만들었을때 VC마다 다른 값을 전달할때는 효과적일 것 같다는 생각이 든다.그리고 서로 접접이 없는 컨트롤러끼리도 데이터를 주고 받을 수 있을 것 같다.8. Segue로 데이터 전달0. 어떻게 전달이 되는가?  Segue는 Source, Destination으로 이루어져 있다.          Source : 출발지점, 화면전환의 시작점      Destination : 도착지점, 화면이 전환되는 곳        performSegue 를 통해 Segue를 실행한다.          화면이 전환된다.      이때 identifier에 전환하는 Segue의 명칭을 정확히 적어준다.        그리고 prepare함수를 오버라이딩을 해준다. (Segue가 실행되기전 해당 함수를 통헤 데이터를 넘길 준비를 한다.)          destination은 내가 화면을 전환하려고 하는 VC를 설정해준다.      identifier를 정확하게 입력을 해야한다.      우선 Segue로 전달을 하기위해선 꼭 해야하는 작업이 있다.바로 이렇게 VC끼리 서로 연결해주어 Segue를 만들어 주고 꼭 identifier에 명칭을 부여해준다.1. 코드 작성import UIKitclass FirstViewController: UIViewController {        @IBOutlet weak var textField: UITextField!            override func viewDidLoad() {        super.viewDidLoad()    }    @IBAction func dataSendBtn(_ sender: UIButton) {        performSegue(withIdentifier: \"goToVC\", sender: nil)    }        override func prepare(for segue: UIStoryboardSegue, sender: Any?) {        if segue.identifier == \"goToVC\" {            let secondVC = segue.destination as? SecondViewController            if let text = textField.text {                secondVC?.message = text            }        }    }    }import UIKitclass SecondViewController: UIViewController {        @IBOutlet weak var displayLabel: UILabel!        var message : String = \"\"        override func viewDidLoad() {        super.viewDidLoad()        displayLabel.text = message    }        @IBAction func backBtn(_ sender: UIButton) {                self.dismiss(animated: true)    }    }2. 복기Segue는 Udemy에서 공부하면서 초창기에 나왔던 부분이라, 그리 어려운 부분은 아니었다.주의해야할거라면 identifier와 DownCasting정도가 될 것 같다.destination은 UIViewController 즉 데이터 타입이 최상위로 되어있기에 DownCasting을 꼭 해줘야한다!9. 정리 후기생각보다 정리할것도 많고 검색해야할것도 많았다.지금은 초창기라 뭔가 두서없이 정리를 했지만 조금씩 지식이 쌓이고 이해를 제대로 하면서 내용을 지속적으로 수정하고 보강할 생각이다.튜터님과 대화를 하고 난후, 내가 정리한 방식을 무작정 내가 쓴다고 해서 되는것이 아닌, VC간의 관계를 파악하고, 그에따른 적절한 방법을 사용해야겠다. 라는 생각이 들었다.확실히 튜터님과 이런 대화를 하면 할수록 얻어가는게 많다.출처https://hellozo0.tistory.com/365https://990427.tistory.com/90https://minnit-develop.tistory.com/8https://medium.com/hcleedev/swift-notificationcenter%EC%99%80-%EC%82%AC%EC%9A%A9%EB%B2%95-6eb4490aac88https://silver-g-0114.tistory.com/106"
  },
  
  {
    "title": "(Deep Dive) Constants & Functions",
    "url": "/posts/(Deep-Dive)-Constants/",
    "categories": "Udemy, Deep Dive",
    "tags": "",
    "date": "2024-03-15 14:52:00 +0900",
    





    
    "snippet": "Constants(상수)  변수(Variables)와 달리 값이 변하지 않는다.상수를 생성하는 방법var는 변수였다면, 상수는 let을 사용한다!즉let a = 3변수와 상수의 차이를 아래 코드를 통해서 본다면// 변수var a = 3a = 5print(a) //5// 상수let b = 4b = 7print(b)바로 이렇게 에러가 발생하게된다.  변수...",
    "content": "Constants(상수)  변수(Variables)와 달리 값이 변하지 않는다.상수를 생성하는 방법var는 변수였다면, 상수는 let을 사용한다!즉let a = 3변수와 상수의 차이를 아래 코드를 통해서 본다면// 변수var a = 3a = 5print(a) //5// 상수let b = 4b = 7print(b)바로 이렇게 에러가 발생하게된다.  변수와 상수의 기준      내가 만든 parameter에 값을 바꿀수 있느냐 없느냐          있다면 변수 / 없다면 상수      Q : 그렇다면 상수는 왜 필요할까?A : 효율성과 관련이 있다. 그래서 바꿀필요가 없는 기본값들은 상수로 만드는 것이 좋다.Randomisation (난수생성)생성하는 법은 다음과 같다// 정수Int.random(in:lower ... uppper)//예시print(Int.random(in: 10...20)) // 10~20 사이의 임의의 숫자가 생성// 배열array.shuffle()// 예시var array = (0...9).map{$0}print(array.shuffled())함수의 생성함수를 생성할땐 다음과 같이한다.func functionName ( parameters : type of parameters) {    //code}그리고 호출을 할땐functionName(parameters:parameter) 이렇게 한다함수는 우리가 원하는 지시사항을 코드블록으로 패키지화 했다고 생각하면 될 것 같다.그리고 함수안에 코드를 작성할땐 tab을 눌러 들여쓰기를 하면서 경계를 명확하게 해주면 좋다연습 해보기아래 컴파일러를 통해 연습을 해보자."
  },
  
  {
    "title": "216. 로또의 최고 순위와 최저 순위",
    "url": "/posts/216.-%EB%A1%9C%EB%98%90%EC%9D%98-%EC%B5%9C%EA%B3%A0-%EC%88%9C%EC%9C%84%EC%99%80-%EC%B5%9C%EC%A0%80-%EC%88%9C%EC%9C%84/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-15 02:37:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ lottos:[Int], _ win_nums:[Int]) -&gt; [Int] {        var arr : [Int] = []    var winNums : [Int] = []    var convert : [Int] = []    var answer : [Int] = []        ...",
    "content": "import Foundationfunc solution(_ lottos:[Int], _ win_nums:[Int]) -&gt; [Int] {        var arr : [Int] = []    var winNums : [Int] = []    var convert : [Int] = []    var answer : [Int] = []        var zerocount : Int = 0    var count : Int = 0        arr = lottos.filter{$0 != 0}.sorted()    zerocount = lottos.filter{$0 == 0}.count        winNums = win_nums.sorted()        for i in arr {        for j in winNums {            if i == j {                count += 1            }        }    }        convert.append(count+zerocount)    convert.append(count)        for i in convert {                switch i {            case 6 :                answer.append(1)            case 5 :                answer.append(2)            case 4 :                answer.append(3)            case 3 :                answer.append(4)            case 2 :                answer.append(5)            default :                answer.append(6)        }    }        return answer}처음에는 문제가 뭔가 싶었다.알고보니 0이 가려진 숫자였고 그 가려진 숫자가 맞거나 아니거나인 경우를 생각해서 구하면 되는문제였다.우선 원래의 배열에서 0을 제외한 배열을 새로 만들어 주었고, 0의 갯수도 별도로 카운트 해주었다.그리고 계산하기 쉽게 오름차순 정렬도 한번 해주었다.그리고 for문을통해 두개의 값이 일치할때 카운트를 증가 해주었다.그리고 해당 카운트와 0의 갯수를 더한 값이 최고 성적일 것이고,최저성적은 그냥 카운트만 했을때 이므로 일단 두배열애 담아주었고또 for문을 돌려서 switch case를 통해 등수를 리턴하게 하였다.푸는것에 의미를 두기위해 1차원 적으로 접근을 해보았다."
  },
  
  {
    "title": "ByteCoin (4)",
    "url": "/posts/ByteCoin-(4)/",
    "categories": "Udemy, Clima",
    "tags": "",
    "date": "2024-03-14 19:04:00 +0900",
    





    
    "snippet": "protocol 만들기protocol CoinProtocol {    func didUpdateCoin(coinManager : CoinManager, coin : CoinModel)}다음과 같이 프로토콜을 만들어 주었다.그리고 강의에서 했던 그대로 delegate를 만들어 주었다.첨에 무의식적으로 :이 아닌 =으로 해서 자꾸 이상하게 되었다…머리가 ...",
    "content": "protocol 만들기protocol CoinProtocol {    func didUpdateCoin(coinManager : CoinManager, coin : CoinModel)}다음과 같이 프로토콜을 만들어 주었다.그리고 강의에서 했던 그대로 delegate를 만들어 주었다.첨에 무의식적으로 :이 아닌 =으로 해서 자꾸 이상하게 되었다…머리가 굳었나보다.다시 돌아가서performRequest에if let coin = self.parseJSON(safeData) { // 클로저 안이라 self를 명시                                                                  // safeData를 parseJSON을통해 파싱 해준 값을 저장                        self.delegate?.didUpdateCoin(coinManager: self, coin: coin)                    }delegate를 통해 전달하게 하였다.그리고 CoinViewController에 CoinProtocol 따르게 하였고일부러 이렇게해서 실행했다.역시 안된다생각해보니 프로토콜을 사용하면 이걸 써줘야했는데 까먹었다.coinManager.delegate = self바로 viewDidLoad쪽해 해당 내용을 적어주었다.DispatchQueue 사용하기func didUpdateCoin(coinManager: CoinManager, coin: CoinModel) {        DispatchQueue.main.async {            self.bitCoinLabel.text = coin.stringRate        }            }이렇게 dispatchqueue를 통해 전달하게 하였다.그리고 실행한다.잘되긴 한다.하지만 왜 프로토콜을 통해서 전달을 해야할까?뭔가 궁금해지기 시작한다.이부분을 주말에 좀 더 해봐야하지 않을까 싶다.프로토콜을 통해 전달을 할때는 보통 데이터를 보내는쪽에 프로토콜을 선언하고,받는쪽에서 해당 프로토콜을 채택해서 사용하는듯 하다.좀 더 찾아봐야겠다.extension으로 나누기.extension CoinViewController : CoinProtocol {    func didUpdateCoin(coinManager: CoinManager, coin: CoinModel) {        DispatchQueue.main.async {            self.bitCoinLabel.text = coin.stringRate        }            }}extension CoinViewController : UIPickerViewDataSource, UIPickerViewDelegate {        func numberOfComponents(in pickerView: UIPickerView) -&gt; Int {        return 1    }        func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {        return coinManager.currencyArray.count    }        func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -&gt; String? {        return coinManager.currencyArray[row]    }        func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {        let selectedCurrency = coinManager.currencyArray[row]        coinManager.getCoinPrice(for: selectedCurrency)            }}생각해보니 currency가 계속 USD로 고정이 되어있어서 그부분 수정을 해주었다.    func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {        let selectedCurrency = coinManager.currencyArray[row]        coinManager.getCoinPrice(for: selectedCurrency)        currencyLabel.text = selectedCurrency // new    }이젠 정확하게 잘된다.복기강의도 영어지만 발번역이라 내가 영어 자막으로해서 이해를 하고 수업을 듣다보니 생각보다 오래걸렸다.그리고 더군다나 자막 싱크가 맞지않는것도 컸다 (한글일때)그래서 어쩔땐 그냥 영어로 해놓고 보는게 더 편할때가 많았다.네트워크로 가져오는것에 대해 확실히 처음하다보니 그부분에 있어 코드를 작성할때, 뼈대는 아무래도 좀 이전 코드를 참고해서 사용하는게 많았다.보완해야할 점  perform Request 부분 구현하기.          코드를 작성하면서 확실히 뭐랄까 Flow는 이해가 되었다.              ⭐️ 다만 Escaping Closure 를 사용해서 리턴을 할수 있다고 튜터님이 하시는데, 아직 리턴을 내가 해보진 못했다.                  Escaping Closure에 대한 자료를 더 찾아봐야겠다. 영어가 되었든 일본어가 되었든 (근데 영어가 더 편하긴하다.)                      각 file(편의상 파일이라고 하겠다.) 간 데이터 통신문제.          처음에는 프로토콜을 사용하지 않고 데이터 전달을 하고 싶었다.              그래서 viewcontroller를 인스턴스화 해서 값을 전달하려고 하였다.                  그게 안되어서 튜터님께 여쭤본결과, 그렇게하면 값이 전달이 안될거에요 라고 하시고, escaping closure를 사용해보라고 하셨다.                          즉 1번의 내용과 비슷.                                          인스턴스화를 하는 위치의 문제                  struct안에 하다보니… 실행이 잘되던게 갑자기 실행이 안된다.                          메모리 누수를 의심해보았다.              실제로 인스턴스를 무한히 생성하고있었다.                                          프로토콜을 사용했고 데이터 전달을 했다.                  너무 잘된다…                          데이터 통신에 대한 내스스로의 분석이 필요할거같아 주말에 Deep-Dive형식으로 글을 한번 작성해보려 한다.                                            프로토콜 채택시 viewDidLoad에 추가하지 않았다.          분명히 공부할때도 사람들이 자주 깜빡하는게 저것이라고 했고, 나도 그렇게 정리하며 적었는데, 역시 나도 그 부류였다.              바로 문제점을 캐치하고 delegate.self 를 사용해 해결하였다.      일단 큰틀에서는 이렇게 3개 같다.아무래도 네트워킹을 처음해보다보니 조금은 빡셌지만, 확실히 수업을 정리할땐 이게 맞나 싶으면서 정리한게 많았는데,실제로 내가 막힐때 내가 쓴글을 보며 참고하는데, 아 이게 이거구나 하면서 이해한게 많았다.뭐든 해봐야한다.그럼 이건 여기까지."
  },
  
  {
    "title": "ByteCoin (3)",
    "url": "/posts/ByteCoin-(3)/",
    "categories": "Udemy, Clima",
    "tags": "",
    "date": "2024-03-14 12:04:00 +0900",
    





    
    "snippet": "pickerview를 통해 내가 원하는 원화로 바꾸기현재는 json값을 제대로 파싱하는지 확인하기위해 baseURL을 USD로 자체적으로 설정을 해두었다.그리고 print를 사용해서 pikcerview에 해당하는 그 값만 출력하게 해두었다.이젠 이렇게 출력되는 값을 \\()을 사용하여 집어 넣어보려고 한다.우선 fetchCoin 함수를 하나 더 만들어 ...",
    "content": "pickerview를 통해 내가 원하는 원화로 바꾸기현재는 json값을 제대로 파싱하는지 확인하기위해 baseURL을 USD로 자체적으로 설정을 해두었다.그리고 print를 사용해서 pikcerview에 해당하는 그 값만 출력하게 해두었다.이젠 이렇게 출력되는 값을 \\()을 사용하여 집어 넣어보려고 한다.우선 fetchCoin 함수를 하나 더 만들어 주었다.func fetchCoin (curreny: String) {        let urlString = \"\\(baseURL)\\(curreny)?apikey=\\(storage.apiKey)\"        performRequest(with: urlString)    }기존껀 파라미터로 뭔가를 가져오지 않았지만 이번엔 가져와야하기에 위와 같이 해주었다.https://rest.coinapi.io/v1/exchangerate/BTC/USD?apikey=값을 받아오기위한 url양식은 위와 같다.이젠 저기 usd를 빼고 만들어보자.그리고 getCoinPrice도 다음과 같이 해주었다.func getCoinPrice(for currency: String){        fetchCoin(curreny: currency)    }이전 글에서 print로 각각의 currency가 출력이 되는것을 확인 했으니. 위의 함수를 이용해서 테스트를 한번 해보도록 하자.이제 실행을 시키고 제대로 나오는지 테스트를 해보도록 하자잘나오는걸 확인할 수 있다.이젠 우리가 이 모든 값을 알 필요가 없기에 실제 코인 가격만 나오게끔 바꿔보자.우선 coinModel에서 다음과 같음 computed value를 하나 만들어 준다var stringRate : String {        return String(format:\"%.2f\", rate)    }그리고 performRequest의 부분에 stringRate를 출력하게 해두었다.if let safeData = data { // 데이터를 정상적으로 받아온다면 옵셔널 바인딩을 해준다.                    if let coin = self.parseJSON(safeData) { // 클로저 안이라 self를 명시                        print(coin.stringRate)                    }                                }테스트 해보자잘나온다!다음과 같이 이젠 콘솔이 아닌 UI를 통해 보이도록 표현을 해보자.UI로 해당 값을 보이게 하기.일단 현재 가격을 어떻게 해서 가져오는지에 대해서 생각을 먼저 했다.1. pickerView 실행viewController의 pickerView를 통해서func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {        let selectedCurrency = coinManager.currencyArray[row]        coinManager.getCoinPrice(for: selectedCurrency)    }코인의 가격을 가져오게한다.2. getCoinPrice 실행coinManager로 가서 getCoinPrice 작동.func getCoinPrice(for currency: String){        fetchCoin(curreny: currency)    }3. fetchCoin 실행func fetchCoin (curreny: String) {        let urlString = \"\\(baseURL)\\(curreny)?apikey=\\(storage.apiKey)\"        performRequest(with: urlString)    }4. performRequest 실행func performRequest(with urlString : String) {        if let url = URL(string: urlString) { // 1. URL 생성                        let session = URLSession(configuration: .default) // 2. URL Session 생성                        let task = session.dataTask(with: url) { data, response, error in // 3. Session에 task 부여                                if error != nil { // 에러가 발생하는 경우                                        print(error ?? \"Error\")                                        return // 리턴을 하여 아무것도 하지 못하게 한다.                }                                if let safeData = data { // 데이터를 정상적으로 받아온다면 옵셔널 바인딩을 해준다.                    if let coin = self.parseJSON(safeData) { // 클로저 안이라 self를 명시                        print(coin.stringRate)                    }                                }            }                        // 4. task 실시            task.resume()        }    }5. parseJSON 실행func parseJSON(_ coinData : Data) -&gt; CoinModel? {        let decoder = JSONDecoder()        do {            let decodedData = try            decoder.decode(CoinData.self, from: coinData)            let asset_id_base = decodedData.asset_id_base            let asset_id_quote = decodedData.asset_id_quote            let rate = decodedData.rate                        let coin = CoinModel(base: asset_id_base, quote: asset_id_quote, rate: rate)            return coin                    } catch {                        print(error)                        return nil        }    }5. parsing된 값 출력if let coin = self.parseJSON(safeData) { // 클로저 안이라 self를 명시                        print(coin.stringRate)                    }출력부분을 리턴으로 받아서 그걸다시 전달을 하면 어떨까 라는 생각이 들었다.그래서 performRequest부터 리턴을 하도록 고쳐주었다.바로 에러가 발생하였다.어떻게 해야할지 기억도 나지않아 이전에 작성했던 글을 참고해서 보았다.clima를 할때 didupdate라는 함수를 사용하였고 파라미터 타입을 우리가 만든 모델로 하여 전달을 받았다.해당 함수를 사용하여 한번 진행해보자.func didUpdateCoin(coin : CoinModel) {        print(coin.stringRate)    }이렇게 viewController에 만들어 주었다.이젠 CoinManager에 해당 함수를 호출해보자.let coinVC = CoinViewController() if let safeData = data { // 데이터를 정상적으로 받아온다면 옵셔널 바인딩을 해준다.                    if let coin = self.parseJSON(safeData) { // 클로저 안이라 self를 명시                                                                  // safeData를 parseJSON을통해 파싱 해준 값을 저장                        coinVC.didUpdateCoin(coin: coin)                                        }                                }잘된다.그전에 잘못생각해둔게 있어 적는다. 바로 viewController를 인스턴스화 할때의 생성 위치이다.처음엔 아무생각없이 여기 안에 넣었다.메모리 누수가 발생하는것으로 보인다.뭔가 서로 인스턴스화가 계속 무한반복생성? 그런 느낌이 들어서 튜터님께 찾아가보았고 여쭤보았다.그게 맞다고 하셨다.그래서 인스턴스화하는 위치를 struct밖으로 빼주었다.그렇게 해보니 잘된다.하지만 에러는 아닌데 뭔가 warning같은 경고 메세지가 뜬다.Main Thread Checker: UI API called on a background thread: -[UIViewController init]PID: 33377, TID: 2572006, Thread name: (none), Queue name: com.apple.NSURLSession-delegate, QoS: 0Background Thread 에서 실행이 되는데, 우린 Main Thread 에서의 실행이 필요하다.확실히 여기서부터가 어려워지기 시작한다.일단 label의 text를 변경하려고하니 optional이 된다.튜터님께 여쭤보니 ViewController를 인스턴스화 했는데, 그게 아마 전달이 안될거라고 하셨다.print는 되었지만, 값이 제대로 전달이 안되는걸까…결국 고민을 하다 수업시간에 했던 프로토콜을 사용해보기로했다.그건 다음글에서 계속 하겠다."
  },
  
  {
    "title": "2주차 과제 class화 (4)",
    "url": "/posts/Main-campus_2nd-week_Arrange_class4/",
    "categories": "캠프, 2주차",
    "tags": "야구, 과제",
    "date": "2024-03-13 17:30:00 +0900",
    





    
    "snippet": "static을 사용했던게 좀 찝찝해서 튜터님과 대화를 하던중,내가 구현했던 함수들이 return을 하는게 많이 없었다.그래서 static을 사용할 수 밖에 없었다.대화를 하던중 갑자기 아이디어가 생각나서 하던걸 잠시 멈추고 야구를 좀 더 다듬어 보기로 했다.우선 GameModel의 static부터 고치기로 하였다.import Foundationstru...",
    "content": "static을 사용했던게 좀 찝찝해서 튜터님과 대화를 하던중,내가 구현했던 함수들이 return을 하는게 많이 없었다.그래서 static을 사용할 수 밖에 없었다.대화를 하던중 갑자기 아이디어가 생각나서 하던걸 잠시 멈추고 야구를 좀 더 다듬어 보기로 했다.우선 GameModel의 static부터 고치기로 하였다.import Foundationstruct GameModel {        var answer = Array&lt;Int&gt;()    var question = Array&lt;Int&gt;()        var gameStart : Bool = true    var ansCheck : Bool = true    var gameTitle : Bool = true    }InputManagerimport Foundationclass InputManager {        let recordManager = RecordManager()    var recordModel = RecordModel()        func answerCheck (answer : [Int]) -&gt; Bool {                if answer.count != 3 {                        print(\"         Please Enter 3 Numbers again.\\n\")            recordManager.inreaseAnsCount()                        return true        } else {                        if answer[0] == answer [1] || answer[0] == answer [2] || answer[1] == answer [2] { // to avoid duplicated number                                print(\"         Duplicated numbers detected!\\n         Please Enter 3 Numbers again.\\n\")                recordManager.inreaseAnsCount()                                return true                            } else {                                recordManager.inreaseAnsCount()                                return false            }        }            }    }return을 함으로써 해결하였는데문제는 recordManager쪽이다. 모든 클래스가 다 쓰고 있어서 이걸 어떻게 해야할지 많은 고민이 든다.recordManager는 수많은 시행착오를 겪다가 갑자기 아이디어가 떠올랐다.요지는 이것이었다.  static을 사용하지 않고 어떻게 숫자가 증가하고, 배열에 담을것인가?그래서 recordManager와 recordModel을 보았다.일단 의미없는 gameCount를 삭제했다. 쓰이지도 않았고, 또한 게임횟수는 배열에서 i+1로 이미 횟수를 보이고있기 때문이었다.그래서 배열은 후순위에 두고 ansCount를 어떻게 내가 1씩 증가를 시킬것인가를 생각해보았다.func start () {                // 기록 데이터 초기화.        recordModel.ansCount = 0        recordModel.scoreArray = []일단 사용하기 위해서 이부분에 게임시작과 동시에 사용하게 초기화를 해주었다.그리고 함수도 무의미한 것들은 죄다 지웠다.그리고 게임을 재시작의 경우를 생각하여 1을 눌렀을때 다시 0으로 초기화 하게 해주었다.case 1 : // 1을 눌렀을때                    gameModel.question = makingQuestion.makeQuestion() // 문제 생성 시작                    gameModel.gameStart = true // 실제 게임을 실행할 while문의 조건을 true                    recordModel.ansCount = recordManager.resetCount() // 게임 재시작의 경우도 고려하여 시도횟수 0으로 초기화시도횟수를 튜플을 안쓰고 오기를 부려보다, 결국 안되었다.튜터님께도 여쭤보았지만, 튜플을 사용하지 않고도 하는 방법은 있다고 하셨으나, 현재 단계에서는 튜플이 제일 좋은 방법이라고 하셨다.그래서 결국 튜플을 사용하였다.let result = inputManager.answerCheck(answer: gameModel.answer, number: recordModel.ansCount)                            // 유져가 입력한 값을 검증한다.                                                       gameModel.ansCheck = result.0                            recordModel.ansCount = result.1inputManager에서 원래는 answer만 받아오는걸로 하다가, inputManager안에는 시도 횟수를 증가시키는 함수가 존재하기에,다음과 같이 수정해주었다.  inputManager.answerCheck(answer: gameModel.answer, number: recordModel.ansCount)      parameter : 내가 입력한 값, 현재의 시도횟수          return (Bool, Int)      이렇게 했다func answerCheck (answer : [Int], number : Int) -&gt; (Bool, Int) {                if answer.count != 3 { // 3자리가 아닌 수를 입력했을때                        print(\"         Please Enter 3 Numbers again.\\n\")            var Number = number            Number = recordManager.inreaseAnsCount(number: Number) // 1번 시도했으므로 시도횟수 1 증가                        return (true, Number)        } else {                        if answer[0] == answer [1] || answer[0] == answer [2] || answer[1] == answer [2] { // 중복숫자를 입력했을 경우                                print(\"         Duplicated numbers detected!\\n         Please Enter 3 Numbers again.\\n\")                var Number = number                Number = recordManager.inreaseAnsCount(number: Number) // 1번 시도했으므로 시도횟수 1 증가                                return (true, Number)                            } else {                                var Number = number                Number = recordManager.inreaseAnsCount(number: Number) // 1번 시도했으므로 시도횟수 1 증가                                return (false, Number)            }        }            }위에서 바뀐거라면 파라미터를 하나더 받고, 1을 증가시키고 그걸 튜플로 리턴하게 하는것이었다.그렇게 받은 데이터를 이제 입력해야하는데, 처음에는 무식하게 해버렸다.gameModel.ansCheck = inputManager.answerCheck(answer: gameModel.answer, number: recordModel.ansCount).0recordModel.ansCount = inputManager.answerCheck(answer: gameModel.answer, number: recordModel.ansCount).1변수를 생성하지 말고 해야한다는 그런 의미없는 생각이 뇌를 지배해버려서 만들어낸 괴짜 코드이다.저렇게 실행하면 함수가 두번 호출되기에 출력도 2번, 그리고 시도횟수도 2로 올라가기에 의미가 없었다.순간 멍해졌다. 어떻게해야할지 아무 생각이 없었다..튜터님께 여쭤봤는데, 너무 기본적인걸 망각했다.그냥 변수를 하나 만들어서 처리하면 되는것이었는데, 이미 뇌를 잠식당해서 그랬던것이었을까 생각을 하질 못했다.그래서 튜터님의 조언을 받아 다음과같이 수정하였다.let result = inputManager.answerCheck(answer: gameModel.answer, number: recordModel.ansCount)// 유져가 입력한 값을 검증한다.                               gameModel.ansCheck = result.0    recordModel.ansCount = result.1RecordManager의 increaseAnsCount 함수도 다음과 같이 수정해주었다.func increaseAnsCount (number : Int) -&gt; Int {        var Number = number        Number += 1        return Number    }while문 안에 print를 넣어 테스트를 해보니 잘 되었다.이제 남은 건 배열에 어떻게 넣는가? 이다.원래는 3strike일때, 함수를 사용하여, 배열에 담으려고 하였다.근데 생각해보니 그 배열은 어떻게 내가 가져오고 다시 리턴을 시키느냐? 였다.이미 클래스에서 리턴없이 했을때 아무리 내가 배열에 넣어도 현재 실행중인곳에는 값이 전달이 되지 않았던 것을 경험 하였기에,생각이 많아졌다.그러다가 문특 아이디어가 떠올랐다.while문 밖에 하는건 어떨까? 였다.그래서 처음에는 테스트를 하기위해 recordModel.scoreArray.append() 를 사용하여 3스트라이크 이후 게임이 종료되고 메인 화면으로돌아갔을때, 기록에 배열값이 남느냐를 확인해보았다.잘되었다.즉 베열에 관한 내용은 여기에 담으면 되나? 라는 생각에서 확신으로 되는데는 그리 오랜시간이 걸리지 않았다.이젠 이걸 어떻게 함수로 바꾸냐? 였다.  recordModel.scoreArray = recordManager.saveCount(array: recordModel.scoreArray, count: recordModel.ansCount)      parameter : 시도횟수를 담을 배열, 시도횟수          return (Array)      그리고 recordModel의 saveCount도 다음과 같이 바꿔주었다.func saveCount (array : [Int], count : Int) -&gt; [Int] {        var scoreArray = array        scoreArray.append(count)        return scoreArray    }이러고나니 기록을 확인할 showRecord역시 바꿔야해서 바꿔주게 되었다.왜냐 파라미터를 받아서 그걸 통해 넘겨야만 값이 전달이 되기때문이다.recordManager.showRecord(array: recordModel.scoreArray)이렇게 하고 함수도 다음과 같이 바꿔 주었다.func showRecord (array : [Int]) {        let scoreArray = array                if scoreArray.count != 0 { // 게임을 한판이라도 했다면                        print(\"         &lt;&lt;&lt;&lt;&lt; Game Records &gt;&gt;&gt;&gt;&gt;\")            for i in 0 ..&lt; scoreArray.count {                print(\"           \\(i+1) Game, Attempts : \\(scoreArray[i])\\n\")            }                    } else { // 아예 한판도 안했다면                        print(\"          There is no Game Record.\\n\")        }    }작동 테스트를 해보니 잘된다.팀원들과 이야기를 했던 것이 생각나서 하나의 예외를 더 처리해주었다.Lv3인데, 나는 문제 생성만 0이 안되게 하면 되는줄 알았다.근데 아닌것 같아서 예외를 별도로 처리한다.let input = readLine() Int로 형변환을 했던것을, String optional로 하였다.if let input = input {을 사용해 옵셔널 바인딩 처리를 했다.처음에는 이렇게만 하고 돌려봤는데 아니나 다를까 문자를 입력하니gameModel.answer = input.map{Int(String($0))!} 이부분에서 에러가 발생한다.그래서 생각을 해보다가, 어차피 옵셔널 바인딩은 했고 문자와 숫자를 구별하기 위해서 isNumber를 사용하기로 했다.그래서 if조건을 하나 더 추가해줬다.` if input.filter({$0.isNumber}).count == input.count {`고차함수를 사용해서 내가 입력한게 정수인지를 판별하고 그것의 갯수와, 내가 입력한 값의 문자열의 갯수를 카운트해서 같으면 진행하게 하였다.그게 아니면 횟수만 증가하게 하였다.이렇게 얼추 구현할 건 다한것같다.최종 코드는 아래와 같다.Model// GameModelimport Foundationstruct GameModel {        var answer = Array&lt;Int&gt;()    var question = Array&lt;Int&gt;()        var gameStart : Bool = true    var ansCheck : Bool = true    var gameTitle : Bool = true    }// QuestionModelimport Foundationstruct QuestionModel {        var numbers = Array&lt;Int&gt;()    var quesMaking : Bool = true    }// BallCountModelimport Foundationstruct BallCountModel {        var ballCount = Dictionary&lt;String,Int&gt;()    }// RecordModelimport Foundationstruct RecordModel {       var ansCount : Int = 0   var scoreArray = Array&lt;Int&gt;()    }Controller// BaseballGameimport Foundation// MARK: - 게임 큰틀에 대해 구현class BaseballGame{        var gameModel = GameModel()    var recordModel = RecordModel()        let recordManager = RecordManager()    let makingQuestion = MakingQuestion()    let ballCountManager = BallCountManager()    let inputManager = InputManager()            func start () {                // 기록 데이터 초기화.        recordModel.ansCount = 0        recordModel.scoreArray = []                while gameModel.gameTitle { // gameTitle이 true일때 무한 반복                        print(\"               ⚾️ Play Ball ⚾️\")            print(\" [1]. Game Start! [2]. Game Record [3]. Exit \")                        let titleInput = Int(readLine()!)                        switch titleInput { // 유져의 값에 따라 각각 다른 기능 실행                            case 1 : // 1을 눌렀을때                                gameModel.question = makingQuestion.makeQuestion() // 문제 생성 시작                                gameModel.gameStart = true // 실제 게임을 실행할 while문의 조건을 true로 다시 바꾼다                                                 // 게임이끝나면 false로 바뀌기 때문.                                recordModel.ansCount = recordManager.resetCount() // 게임 재시작의 경우도 고려하여 시도횟수 0으로 초기화                                while gameModel.gameStart {                                        gameModel.ansCheck = true // 위의 내용과 이하동문                                        while gameModel.ansCheck { // ansCheck를 통해 유져가 3자리의 숫자만 입력하게한다.                                                     // 3자리를 입력했을때 false로 빠져나간다.                                                print(\"           Please Enter 3 Numbers\")                        print(gameModel.question)                                                let input = readLine() // 유져의 입력값을 받는다.                                                if let input = input { // 옵셔널 바인딩                                                        if input.filter({$0.isNumber}).count == input.count {                                // 내가 입력한 값에 혹시라도 문자가 있는지 없는지 확인 숫자만 이루어진다면 양변의 값은 같다.                                                                gameModel.answer = input.map{Int(String($0))!}                                                                let result = inputManager.answerCheck(answer: gameModel.answer, number: recordModel.ansCount)                                // 유져가 입력한 값을 검증한다.                                                                gameModel.ansCheck = result.0                                recordModel.ansCount = result.1                                                            }                            else { // 유져가 숫자가 아닌 값을 입력했을때.                                                                print(\"      Please Enter the Number Correctly\")                                recordModel.ansCount = recordManager.increaseAnsCount(number: recordModel.ansCount)                                // 시도 횟수 1증가.                            }                                                    } else { // 옵셔널 바인딩에 실패했을경우                                                        print(\"Exception Detected\")                            break                                                    }                                            }                                                                                ballCountManager.resetAllBallCount() // 볼카운트를 초기화                    ballCountManager.getTotalCount(gameModel.question, gameModel.answer) // 문제와 내가 입력한 값을 통해 볼카운트를 구한다.                                        gameModel.gameStart = ballCountManager.checkBallCount() // 현재 볼카운트를 체크하여 해당 조건에따라 결과를 다르게함.                                                        }                                recordModel.scoreArray = recordManager.saveCount(array: recordModel.scoreArray, count: recordModel.ansCount) // 게임 종료 후 현재 값을 배열에 저장해준다.                                            case 2 : // 메인화면에서 2를 입력했을때                                recordManager.showRecord(array: recordModel.scoreArray) // 현재 배열을 가져와서 기록을 보여준다.                            case 3 : // 메인화면에서 3을 입력했을때                                print(\"                  Good Bye👋\")                gameModel.gameTitle = false                            default : // 그 외의 숫자나 문자를 입력했을때                                print(\"      Please Enter the Number Correctly\\n\")                            }        }    }    }// MakingQuestionimport Foundationclass MakingQuestion {        var gameModel = GameModel()    var questionModel = QuestionModel()        func makeQuestion() -&gt; [Int] {                // initialize        gameModel.question = [] // 재시작의 경우를 고려 초기화        questionModel.numbers = (0...9).map{$0} // 0~9까지 배열을 만들어준다        questionModel.quesMaking = true                // making question        while questionModel.quesMaking {                        var a = 0                        a = questionModel.numbers.randomElement()! // 랜덤의 수를 하나 배열에서 추출            gameModel.question.append(a) // 문제에 해당 값을 추가            questionModel.numbers.remove(at:questionModel.numbers.firstIndex(of: a)!) // 추가한값은 0~9까지의 배열에서 제거 (중복을 피하기위해)                        if gameModel.question[0] == 0 { // 처음에 0이 들어가면                gameModel.question = [] // 빈배열로 초기화                continue            }                        if gameModel.question.count == 3 { // 3자리의 수가 만들어지면                questionModel.quesMaking = false            }                    }                return gameModel.question // 문제 리턴    }    }// BallCountManagerimport Foundationclass BallCountManager {    var ballCountModel = BallCountModel()    var gameModel = GameModel()    var recordManager = RecordManager()    let recordModel = RecordModel()        func getTotalCount(_ question : [Int], _ answer : [Int]) {                // 고차함수를 사용하고 싶어서 사용해보았다.                answer.enumerated().forEach{ // enumerated를 사용하여 인덱스 값 생성            (aoffset, aelement) in question.enumerated().forEach{                (qoffset, qelement) in                                if aoffset == qoffset { // 문제와 내 대답의 인덱스가 서로 일치할때                    if aelement == qelement { // 그 상태에서 값이 같다면                        ballCountModel.ballCount[\"Strike\"]! += 1 // strike 1 추가                    }                                    }else { // 문제와 내 대답의 인덱스가 서로 다를때                    if aelement == qelement { // 그상태에서 값이 같다면                        ballCountModel.ballCount[\"Ball\"]! += 1 // ball 1 추가                    }                                    }            }        }                   }    func getBallCount () -&gt; Int { // 볼카운트를 가져온다.                if let ballCount = ballCountModel.ballCount[\"Ball\"] {            return ballCount                    } else {            return 0        }            }        func getStrikeCount () -&gt; Int { // 스트라이크 카운트를 가져온다.                if let strikeCount = ballCountModel.ballCount[\"Strike\"] {            return strikeCount                    } else {            return 0        }            }        func resetAllBallCount () { // 한번 문제와 나의 대답을 한번 비교 한 후, 값 초기화                ballCountModel.ballCount[\"Strike\"] = 0        ballCountModel.ballCount[\"Ball\"] = 0            }        func getAllBallCount () -&gt; [String:Int] { // 현재 X strike Y Ball 인지 알기 위해 가져온다.                let ballCount = ballCountModel.ballCount            return ballCount            }        func checkBallCount () -&gt; Bool {                if getStrikeCount() == 3 { // 3스트라이크라면                        print(\"                HomeRun!!!!!\\n\")                        return false                    } else if getStrikeCount() == 0 &amp;&amp;  getBallCount() == 0 { // 아무것도 일치하는게 없다면                        print(\"                    Out!\\n\")                        return true                    } else { // 볼 스트라이크가 존재한다면                        print(\"               \\(getStrikeCount()) Strike \\(getBallCount()) Ball!\\n\")                        return true        }    }}// RecordManagerimport Foundationclass RecordManager {         var recordModel = RecordModel()        // 숫자 1씩 증가    func increaseAnsCount (number : Int) -&gt; Int {        var Number = number        Number += 1        return Number    }        // 현재의 카운트를 배열에 저장    func saveCount (array : [Int], count : Int) -&gt; [Int] {        var scoreArray = array        scoreArray.append(count)        return scoreArray    }        func resetCount () -&gt; Int {                return 0    }        // 현재 기록을 본다.    func showRecord (array : [Int]) {        let scoreArray = array                if scoreArray.count != 0 { // 게임을 한판이라도 했다면                        print(\"         &lt;&lt;&lt;&lt;&lt; Game Records &gt;&gt;&gt;&gt;&gt;\")            for i in 0 ..&lt; scoreArray.count {                print(\"           \\(i+1) Game, Attempts : \\(scoreArray[i])\\n\")            }                    } else { // 아예 한판도 안했다면                        print(\"          There is no Game Record.\\n\")        }    }    }// InputManagerimport Foundation// MARK: - 입력 담당class InputManager {        let recordManager = RecordManager()            func answerCheck (answer : [Int], number : Int) -&gt; (Bool, Int) {                if answer.count != 3 { // 3자리가 아닌 수를 입력했을때                        print(\"         Please Enter 3 Numbers again.\\n\")            var Number = number            Number = recordManager.increaseAnsCount(number: Number) // 1번 시도했으므로 시도 횟수 1 증가                        return (true, Number)                    } else {                        if answer[0] == answer [1] || answer[0] == answer [2] || answer[1] == answer [2] { // 중복 숫자를 입력했을 경우                                print(\"         Duplicated numbers detected!\\n         Please Enter 3 Numbers again.\\n\")                var Number = number                Number = recordManager.increaseAnsCount(number: Number) // 1번 시도했으므로 시도 횟수 1 증가                                return (true, Number)                            } else {                                if answer[0] == 0 { // 처음에 0을 입력한다면                                        print(\"          First number must not be 0\\n         Please Enter 3 Numbers again.\")                    var Number = number                    Number = recordManager.increaseAnsCount(number: Number) // 1번 시도했으므로 시도 횟수 1 증가                                        return (true, Number)                                    } else { // 제대로 된 값을 입력한다면                                        var Number = number                    Number = recordManager.increaseAnsCount(number: Number) // 1번 시도했으므로 시도 횟수 1 증가                                        return (false, Number)                                    }                            }        }            }    }// mainimport Foundationlet game = BaseballGame()game.start()FeedBack피드백을 받았다.코드에서는 이견이 없다고 하셨다.이것만큼 극찬이 더 이상 존재할까?사실 과제 제출 마감일 오전에 나에게 큰 영감을 주셨던 튜터님과의 대화에서도 코드에서는더이상 손댈부분이 없다고 하셨다.유일하게 하나 뽑는다면 변수의 이름을 어떻게 하는지?문제는 3시간만에 풀고, 클래스화 하는데 이틀 반이 걸렸는데, 그러면서class화에 대해서 끝없이 튜터님과 대화를 하면서 깨달음을 얻은 결과가 아닐까 싶다.커밋 히스토리만 조금 더 자세히 적도록 해보자.지속적으로 해당 코드를 어떻게 발전을 시킬것인가에 대한 고민을 했던게 너무 의미가 있지 않았나 내 스스로 평가해본다."
  },
  
  {
    "title": "ByteCoin (2)",
    "url": "/posts/ByteCoin-(2)/",
    "categories": "Udemy, Clima",
    "tags": "",
    "date": "2024-03-13 16:04:00 +0900",
    





    
    "snippet": "과제 및 필요한것들을 좀 적다보니 이제서야 시작하게 된다.API Request 구현하기지난번에 이어서 시작하겠다.주소에 값을 입력했을때 결과가 어떻게 나오는지 확인을 하고 끝났었다.이제 제대로 만들어 보도록 해보자.1. performRequest 구현하기해당 기능을 구현하기 앞서 내가 실제로 가져와햘 값들에 대해 Data와 Model을 만들어 주었다....",
    "content": "과제 및 필요한것들을 좀 적다보니 이제서야 시작하게 된다.API Request 구현하기지난번에 이어서 시작하겠다.주소에 값을 입력했을때 결과가 어떻게 나오는지 확인을 하고 끝났었다.이제 제대로 만들어 보도록 해보자.1. performRequest 구현하기해당 기능을 구현하기 앞서 내가 실제로 가져와햘 값들에 대해 Data와 Model을 만들어 주었다.struct CoinModel { //Model의 변수명은 JSON의 parameter값에서 따왔다.        let base : String // ex) asset_id_base -&gt; base    let quote : String    let rate : Double    }struct CoinData : Decodable {        let asset_id_base : String    let asset_id_quote : String    let rate : Double    }func fetchCoin () {        let urlString = \"\\(baseURL)apikey=\\(storage.apiKey)\"        performRequest(with: urlString)    }func performRequest(with urlString : String) {        if let url = URL(string: urlString) { // 1. URL 생성                        let session = URLSession(configuration: .default) // 2. URL Session 생성                        let task = session.dataTask(with: url) { data, response, error in // 3. Session에 task 부여                                if error != nil { // 에러가 발생하는 경우                                        print(error ?? \"Error\")                                        return // 리턴을 하여 아무것도 하지 못하게 한다.                }                                if let safeData = data { // 데이터를 정상적으로 받아온다면 옵셔널 바인딩을 해준다.                        print(safeData)                    }                                }            }                        // 4. task 실시            task.resume() }일단은 원하는 값을 내가 제대로 가져오는지 확인이 필요했다.프린트 해보았다.잘나온다.일단은 통신이 된다는 뜻이다!2. parseJSON 구현하기이젠 이 내용을 Decoding 해서 내가 원하는 값이 나오게 표현해야한다.JSON을 Decoding 해야하기에 우선 Decodable 프로토콜을 채택하였다. (CoinData)그리고 JSON을 parsing 하기위해 parseJSON이라는 함수를 만들어 주었다.파라미터는 내가 만들어둔 CoinData이며, type 은 Data 이다.func parseJSON(_ coinData : Data) -&gt; CoinModel? {        let decoder = JSONDecoder()        do {            let decodedData = try            decoder.decode(CoinData.self, from: coinData)            let asset_id_base = decodedData.asset_id_base            let asset_id_quote = decodedData.asset_id_quote            let rate = decodedData.rate                        let coin = CoinModel(base: asset_id_base, quote: asset_id_quote, rate: rate)            return coin                    } catch {                        print(error)                        return nil        }    }그리고 실제로 decoding을 실행할 Decoder를 하나 만들어 주고, decoding이 성공했을때, 아닐때를 구분하기 위하여try-catch 문을 사용 하였다. 그래서 리턴을 CoinModel을 리턴하는데 parsing이 실패 할수도 있기에, 옵셔널로 한다.다시 돌아가서, 디코딩이 된다면, decodedData로 전달이 되고, CoinModel로 리턴 해야하기에JSON값과 똑같이 변수를 만들어주고, 담아주었다.그리고 model를 인스턴스화 하였고 그곳에 각각의 파라미터에 맞는 값을 담아주고, 리턴하게 하였다.이제 이 함수를 사용해야하기에 다시 performRequest로 돌아간다.그리고 다음과같은 내용을 추가해준다if let coin = self.parseJSON(safeData) {}그리고 다시 테스트 해본다이제는 원하는 값이 출력이 된다."
  },
  
  {
    "title": "2주차 (7)",
    "url": "/posts/Main-campus_2nd-week-7/",
    "categories": "캠프, 2주차",
    "tags": "",
    "date": "2024-03-13 07:11:00 +0900",
    





    
    "snippet": "Generic (제네릭)  제네릭으로 구현한 기능과 타입은 재사용하기도 쉽고, 코드의 중복을 줄일 수 있다.  제네릭을 사용하고자 할 때는 제네릭이 필요한 타입 또는 메서드의 이름 뒤의 홀화살괄호 기호 사이에 제네릭을 위한 타입 매개변수를 써주어 제네릭을 사용할 것임을 표시한다.  제네릭은 실제 타입 이름을 써주는 대신에 placeholder를 사용한...",
    "content": "Generic (제네릭)  제네릭으로 구현한 기능과 타입은 재사용하기도 쉽고, 코드의 중복을 줄일 수 있다.  제네릭을 사용하고자 할 때는 제네릭이 필요한 타입 또는 메서드의 이름 뒤의 홀화살괄호 기호 사이에 제네릭을 위한 타입 매개변수를 써주어 제네릭을 사용할 것임을 표시한다.  제네릭은 실제 타입 이름을 써주는 대신에 placeholder를 사용한다. [ eg: T, V, U ]  placeholder는 타입의 종류를 알려주지 않지만 어떤 타입이라는 것은 알려준다.  placeholder의 실제 타입은 함수가 호출되는 순간 결정된다.  placeholder는 타입 매개변수로 쓰일 수도 있는데, 이 타입 매개변수는 함수를 호출할 때마다 실제 타입으로 치환된다.  하나의 타입 매개변수를 갖지 않고 여러 개의 타입 매개변수를 갖고 싶다면 홀화살괄호 기호 안쪽에 쉼표로 분리한 여러 개의 타입 매개변수를 지정해줄 수 있다. [ eg: &lt;T, U&gt; ]  제네릭 타입을 구현하면 구조체, 클래스, 열거형 등이 어떤 타입과도 연관되어 동작할 수 있다.  제네릭 타입을 정해주면 그 타입에만 동작하도록 제한할 수 있어 안전하고 의도한 대로 기능을 사용하도록 유도할 수 있다./*inout 키워드는 함수 내에서 매개변수로 전달된 값을 변경하고, 이를 함수 외부에서도 반영할 수 있도록 하는 데 사용된다. 이를 통해 함수 내에서 매개변수의 값을 직접 수정할 수 있다.inout 키워드 사용 방법:1. 매개변수에 inout 키워드를 붙여 선언한다.2. 함수 호출 시 매개변수를 &amp; 기호로 전달하여 해당 값을 참조로 전달한다.*/// 함수 정의func increment(_ value: inout Int) {    value += 1}var number = 5print(\"Before increment: \\(number)\") // 출력: Before increment: 5// 함수 호출 시 매개변수에 &amp;를 사용하여 변수의 참조를 전달increment(&amp;number)print(\"After increment: \\(number)\") // 출력: After increment: 6// 두 변수의 값을 바꿔주는 함수를 타입별로 작성해야함(제네릭 사용 X)func swapTwoInts(_ a: inout Int, _ b: inout Int) {    let temporaryA = a    a = b    b = temporaryA}func swapTwoStrings(_ a: inout String, _ b: inout String) {    let temporaryA = a    a = b    b = temporaryA}func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {    let temporaryA = a    a = b    b = temporaryA}// 제네릭을 사용하면 타입에 상관없이 사용가능함func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) {    let temporaryA = a    a = b    b = temporaryA}// 이전에 배웠던 큐, 스택을 다시 살펴보자struct Queue&lt;T&gt; {    private var queue: [T] = []        public var count: Int {        return queue.count    }        public var isEmpty: Bool {        return queue.isEmpty    }        public mutating func enqueue(_ element: T) {        queue.append(element)    }        public mutating func dequeue() -&gt; T? {        return isEmpty ? nil : queue.removeFirst()    }}var queue = Queue&lt;Int&gt;()queue.enqueue(10)queue.enqueue(20)queue.dequeue() // 10struct Stack&lt;T&gt; {    private var stack: [T] = []        public var count: Int {        return stack.count    }        public var isEmpty: Bool {        return stack.isEmpty    }        public mutating func push(_ element: T) {        stack.append(element)    }        public mutating func pop() -&gt; T? {        return isEmpty ? nil : stack.popLast()    }}var stack = Stack&lt;Int&gt;()stack.push(10)stack.push(20)stack.pop() // 20// 딕셔너리 예시@frozen public struct Dictionary&lt;Key, Value&gt; where Key : Hashable {    /// The element type of a dictionary: a tuple containing an individual    /// key-value pair.    public typealias Element = (key: Key, value: Value)var fruitsInventory: Dictionary&lt;String, Int&gt; = [:]fruitsInventory[\"apple\"] = 3/*Key, Value 타입의 제네릭으로 되어있어 우리는 원하는 타입으로 딕셔너리를 생성할 수 있음제약조건은 Key가 Hashable 프로토콜만 따르면 되는 것이다기본 자료형인 String은 Hashable 프로토콜을 따르고 있음만약 다른 자료형을 Key로 사용하려면 Hashable 프로토콜을 채택해야 함*//*where 란?제네릭의 제약조건(Constraints)인 where 키워드는 제네릭 타입에 특정 조건을 부여하여 해당 제약을 충족하는 타입만을 사용할 수 있도록 하는 기능이다. where 키워드를 사용하여 제네릭 타입에 특정 프로토콜 채택, 특정 타입과의 상속 관계 등을 제한할 수 있다.*/// 프로토콜 채택 제약 예시func process&lt;T&gt;(value: T) where T: Numeric {    // Numeric 프로토콜을 채택하는 타입만을 제네릭 타입 T로 받음    print(\"Value is a numeric type.\")}process(value: 5) // 출력: Value is a numeric type.process(value: 3.14) // 출력: Value is a numeric type.// process(value: \"Hello\") // 컴파일 에러 - 문자열은 Numeric 프로토콜을 채택하지 않음// 클래스의 상속 관계 제약 예시class MyClass {}class MySubclass: MyClass {}func process&lt;T&gt;(value: T) where T: MyClass {    print(\"Value is an instance of MyClass or its subclasses.\")}let obj = MySubclass()process(value: obj) // 출력: Value is an instance of MyClass or its subclasses.// process(value: \"Hello\") // 컴파일 에러 - 문자열은 MyClass 또는 그 하위 클래스가 아님"
  },
  
  {
    "title": "2주차 (6)",
    "url": "/posts/Main-campus_2nd-week-6/",
    "categories": "캠프, 2주차",
    "tags": "",
    "date": "2024-03-13 06:11:00 +0900",
    





    
    "snippet": "1. Protocol (프로토콜)1. 프로토콜  특정 역할을 하기 위한 메소드, 프로퍼티, 기타 요구사항 등을 정의 해놓은 “규약” 혹은 “약속”  class, structure, enum이 프로토콜을 ‘채택’하고 모든 요구사항을 충족하면 프로토콜을 ‘준수’했다고 한다.  class, structure, enum이 프로토콜을 채택해서 특정 기능을 실행...",
    "content": "1. Protocol (프로토콜)1. 프로토콜  특정 역할을 하기 위한 메소드, 프로퍼티, 기타 요구사항 등을 정의 해놓은 “규약” 혹은 “약속”  class, structure, enum이 프로토콜을 ‘채택’하고 모든 요구사항을 충족하면 프로토콜을 ‘준수’했다고 한다.  class, structure, enum이 프로토콜을 채택해서 특정 기능을 실행하기 위한 프로토콜의 요구사항을 실제로 구현할 수 있다.  프로토콜은 설계된 조건만 정의를 하고 제시를 할 뿐 스스로 기능을 구현하지 않는다.  프로토콜에서는 이름과 타입 그리고 gettable, settable을 명시한다  프로퍼티는 항상 var로 선언해야 한다.  메서드를 정의할 때 메서드 이름과 리턴값을 지정할 수 있고, **{}(구현 코드)는 적지 않는다.  상속과 유사하다고 볼 수도 있겠지만 class 이외에 struct나 enum도 프로토콜을 채택할 수 있다는 특징이 있다  상속은 다중 상속이 불가능하지만 프로토콜은 다중 상속이 가능(확장성이 높음)protocol 프로토콜이름 { // 프로토콜 정의}// 상속받는 클래스의 프로토콜 채택class 클래스이름: 슈퍼클래스, 프로토콜1, 프로토콜2 { // 클래스 정의}protocol Vehicle {    var speed: Double { get set } // get과 set을 모두 요구하는 가변 속성    var manufacturer: String { get } // 읽기 전용 속성}class Car: Vehicle {    var speed: Double = 0.0 // get과 set이 요구되는 속성을 구현    var manufacturer: String = \"Toyota\" // 읽기 전용 속성을 구현}class Bicycle: Vehicle {    var speed: Double = 0.0 // get과 set이 요구되는 속성을 구현    var manufacturer: String { return \"Giant\" } // 읽기 전용 속성을 연산 프로퍼티로 구현}let car = Car()car.speed = 60.0 // set 가능print(car.speed) // get 가능print(car.manufacturer) // get 가능let bike = Bicycle()bike.speed = 20.0 // set 가능print(bike.speed) // get 가능print(bike.manufacturer) // get 가능// 예시protocol Student {    var studentId: Int { get set }    var name: String { get }    func printInfo() -&gt; String}struct UnderGraduateStudent: Student {    var studentId: Int    var name: String    var major: String        func printInfo() -&gt; String {        return \"\\(name), whose student id is \\(studentId), is major in \\(major)\"    }}struct GraduateStudent: Student {    var studentId: Int    var name: String    var degree: String    var labNumber: Int        func printInfo() -&gt; String {        return \"\\(name), member of lab no.\\(labNumber), has a \\(degree) degree\"    }}// 프로토콜은 타입으로서도 사용가능let underGraduate: Student = UnderGraduateStudent(studentId: 1, name: \"홍길동\", major: \"computer\")let graduate: Student = GraduateStudent(studentId: 2, name: \"김철수\", degree: \"master\", labNumber: 104)let studentArray: [Student] = [underGraduate, graduate]// 프로토콜의 다중상속protocol Coordination {    var top: String { get set }    var pants: String { get set }    init(top: String, pants: String)    func checkCoordination()}protocol Hair {    var hair: String { get }    func checkHairStyle()}struct Person: Coordination, Hair {    var top: String    var pants: String    let hair: String = \"포마드\"    func checkHairStyle() {        print(\"오늘의 헤어스타일은 \\(hair)스타일\")    }    func checkCoordination() {        print(\"상의: \\(top)\\n하의: \\(pants)\")    }    init(top: String, pants: String) {        self.top = top        self.pants = pants    }     }let safari: Person = Person(top: \"긴팔\", pants: \"반바지\")safari.checkHairStyle()safari.checkCoordination()//오늘의 헤어스타일은 포마드스타일//상의: 긴팔//하의: 반바지2.associatedtype, typealias  associatedtype          associatedtype은 프로토콜 내에서 실제 타입을 명시하지 않고, 해당 프로토콜을 채택하는 타입에서 실제 타입을 결정하도록 하는데 사용된다.      프로토콜에서 특정 메서드, 속성 또는 서브스크립트의 반환 타입이나 매개변수 타입으로 구체적인 타입을 명시하지 않고 대신 associatedtype으로 선언하여 프로토콜을 채택하는 타입에서 실제 타입을 정의할 수 있다.        typealias          typealias는 기존 타입에 대해 새로운 이름을 지정하거나 복잡한 타입에 대한 간결한 별칭을 생성할 때 사용된다.      코드를 읽기 쉽게 만들거나 여러 번 사용되는 긴 타입 이름을 간략하게 대체할 때 유용하다.      protocol Container {    associatedtype Item // 연관 타입    var count: Int { get }    mutating func append(_ item: Item)    func item(at index: Int) -&gt; Item}struct IntContainer: Container {    typealias Item = Int // 연관 타입을 Int로 typealias하여 구현    var items = [Item]()        var count: Int {        return items.count    }        mutating func append(_ item: Item) {        items.append(item)    }        func item(at index: Int) -&gt; Item {        return items[index]    }}var intBox = IntContainer()intBox.append(5)intBox.append(10)print(intBox.item(at: 0)) // 출력: 5/*위의 예시에서 Container 프로토콜은 Item이라는 연관 타입을 가지고 있다. 이 연관 타입은 Container 프로토콜을 채택하는 구체적인 타입에서 실제 타입으로 정의된다. IntContainer 구조체에서 Item을 Int로 typealias하여 실제 타입을 정의하고, 이를 사용하여 배열에 Int 값을 저장하고 반환하는 메서드를 구현한다.*/2. Extension (확장)1. Extension  확장을 이용하여 structure, class, enum, protocol 타입에 새로운 기능을 추가할 수 있다.  기존 타입에 기능을 추가하는 수평 확장하는 개념이다.  확장은 타입에 새로운 기능을 추가할 수는 있지만, 기존에 존재하는 기능을 재정의할 수는 없다.  외부에서 가져온 타입에 내가 원하는 기능을 추가하고자 할 때 확장을 사용할 수 있다.extension 확장할 타입 이름 {\t //타입에 추가될 새로운 기능 구현}extension 확장할 타입 이름: 프로토콜1, 프로토콜2, 프로토콜3 {\t//프로토콜 요구사항 구현}2. 확장(Extension)이 가능한 경우와 불가능한 경우1. Extension으로 구현 가능한 것들  새로운 계산된 속성(Computed Property) 추가  새로운 인스턴스/타입 메서드 추가  새로운 초기화(Initializer) 추가  프로토콜 채택(Protocol Conformance)  서브스크립트 추가(Subscripting)  중첩 타입(Nested Type) 추가// 1. 새로운 계산된 속성(Computed Property) 추가// String 타입에 확장하여 문자열의 길이를 반환하는 속성 추가extension String {    var length: Int {        return self.count    }}let str = \"Hello\"print(str.length) // 출력: 5// 2. 새로운 인스턴스/타입 메서드 추가// Int 타입에 확장하여 제곱 값을 반환하는 메서드 추가extension Int {    func squared() -&gt; Int {        return self * self    }}let number = 3print(number.squared()) // 출력: 9// 3. 새로운 초기화(Initializer) 추가// Double 타입에 확장하여 특정 숫자로 초기화하는 초기화 메서드 추가extension Double {    init(fromString str: String) {        self = Double(str) ?? 0.0    }}let value = Double(fromString: \"3.14\")print(value) // 출력: 3.14// 4. 프로토콜 채택(Protocol Conformance)protocol Printable {    func printDescription()}struct MyStruct {}// Extension을 사용하여 기존 타입에 프로토콜 채택extension MyStruct: Printable {    func printDescription() {        print(\"Printing description of MyStruct\")    }}let myInstance = MyStruct()myInstance.printDescription() // 출력: Printing description of MyStruct// 5. 서브스크립트 추가(Subscripting)struct Matrix {    private var data: [[Int]]        init(rows: Int, columns: Int) {        data = Array(repeating: Array(repeating: 0, count: columns), count: rows)    }}extension Matrix {\t\t// Extension을 사용하여 서브스크립트 추가    subscript(row: Int, column: Int) -&gt; Int {        get {            return data[row][column]        }        set {            data[row][column] = newValue        }    }}    var matrix = Matrix(rows: 3, columns: 3)matrix[0, 0] = 1matrix[1, 1] = 2print(matrix[0, 0]) // 출력: 1print(matrix[1, 1]) // 출력: 2// 6. 중첩 타입(Nested Type) 추가struct Container {    // 기존 타입 내에서 중첩된 타입    struct NestedType {        var value: Int    }}// Extension을 사용하여 중첩 타입 추가extension Container {    struct AnotherNestedType {        var name: String    }}let nested = Container.NestedType(value: 5)print(nested.value) // 출력: 5let anotherNested = Container.AnotherNestedType(name: \"NestedType\")print(anotherNested.name) // 출력: NestedType2. Extension으로 구현 불가능한 것들  저장 프로퍼티(Stored Property) 추가          Extension으로는 저장 프로퍼티를 추가할 수 없다. 오직 계산된 프로퍼티만 추가할 수 있다.        기존 기능의 재정의(Override)          이미 존재하는 기능을 Extension에서 재정의(Override)할 수 없다. 상속과 재정의는 클래스에서만 가능.        초기화 메서드(Initializer)의 재정의          Extension으로는 새로운 편의 초기화 메서드를 추가할 수 있지만, 기본 초기화 메서드 또는 지정 초기화 메서드를 재정의할 수는 없다.        기존 타입의 저장된 프로퍼티에 기본값 설정          Extension에서는 기존 타입에 저장된 프로퍼티에 기본값을 설정할 수 없다.      // 1. 저장 프로퍼티(Stored Property) 추가// Extension으로 저장 프로퍼티 추가 시 컴파일 에러 발생extension Int {    var newProperty: Int = 5 // 컴파일 에러 발생}// 2. 기존 기능의 재정의(Override)// Extension으로 기존 메서드 재정의 시 컴파일 에러 발생extension Int {    func description() -&gt; String { // 컴파일 에러 발생        return \"This is an extension method\"    }}// 3. 초기화 메서드(Initializer)의 재정의// Extension으로 기존 타입의 초기화 메서드 재정의 시 컴파일 에러 발생extension String {    init() { // 컴파일 에러 발생        self = \"Default Value\"    }}// 4. 기존 타입의 저장된 프로퍼티에 기본값 설정// Extension으로 기존 타입의 저장된 프로퍼티에 기본값 설정 시 컴파일 에러 발생extension Double {    var defaultValue: Double = 10.0 // 컴파일 에러 발생}"
  },
  
  {
    "title": "215. 기사단원의 무기",
    "url": "/posts/215.-%EA%B8%B0%EC%82%AC%EB%8B%A8%EC%9B%90%EC%9D%98-%EB%AC%B4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-13 02:37:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ number:Int, _ limit:Int, _ power:Int) -&gt; Int {        var numberArray : [Int] = []    var numbers : [Int] = []    var answer : Int = 0        numberArray = (1......",
    "content": "import Foundationfunc solution(_ number:Int, _ limit:Int, _ power:Int) -&gt; Int {        var numberArray : [Int] = []    var numbers : [Int] = []    var answer : Int = 0        numberArray = (1...number).map{$0}    for i in numberArray {        var count = 0       for j in 1...Int(sqrt(Double(i))){           if i % j == 0 {               if (j * j) == i {                   count += 1               } else {                   count += 2               }           }       }       numbers.append(count)     }        answer = numbers.map{$0 &gt; limit ? power : $0}.reduce(0,+)        return answer}사실 이건 온전히 내가 적은건 아니다.초기에 적은건 다음과 같다.import Foundationfunc solution(_ number:Int, _ limit:Int, _ power:Int) -&gt; Int {        var numberArray : [Int] = []    var numbers : [Int] = []    var answer : Int = 0        numberArray = (1...number).map{$0}    for i in numberArray {        numbers.append((1...i).filter{i%$0 == 0}.count)    }        answer = numbers.map{$0 &gt; limit ? power : $0}.reduce(0,+)        return answer}단순히 약수의 개수를 구하면 된다고 생각했기에, 하나하나 직접 구해서 하는 방식으로 하게되었다.그런데 이건 위에서도 적었지만 하나하나 다 구해서 배열에 담는 구조이기에 숫자가 커지면 커질수록 그만큼 시간이 오래걸린다는 단점이 존재했다.그냥 문제가 약수의 개수를 구하고 삼항연산자를 통해 약수의 개수가 특정 값보다 큰지를 확인하고 크면 지정한 값으로 리턴하고, 그것을 그냥 더하면 되었기에 너무 쉬운문제인데? 라고 생각하고 넘어갔다.하지만 오산이었다. 55.6/100 이라는 점수가 나왔다.성공한것도 시간대가 꽤나 높게나왔다.어떻게하면 시간을 줄일 수 있을까? 에 대한 생각을 해보다 도저히 안되어 구글링을 해본 결과다른 방법을 하나 찾게 되었다.import Foundationfunc solution(_ number:Int, _ limit:Int, _ power:Int) -&gt; Int {        var numberArray : [Int] = []    var numbers : [Int] = []    var answer : Int = 0        numberArray = (1...number).map{$0}    for i in numberArray {                if i != 1 {            numbers.append((1...(i/2)).filter{i%$0 == 0}.count + 1)        } else {            numbers.append(1)        }            }        answer = numbers.map{$0 &gt; limit ? power : $0}.reduce(0,+)        return answer}이 방식이다. 하지만 이것도 점수는 전과 같았다, 그나마 나의 초기코드보다는 시간이 단축이 되었지만, 아직도 큰 범위의 수에서는 오래걸린다는것을 의미한다.매커니즘이 거의 비슷하기 때문이다. 그저 절반으로 나누어서 계산을 했다는 차이 밖엔 없었다.그래서 더 찾아보았다.제곱근을 사용하여 구하는 방식이 있다고 한다.제일위의 코드가 바로 그런 예이다.아직 제대로 이해를 하지못해서, 내 나름대로 다시 분석을 해봐야 하지 않을까 싶다.제곱근을 통하여 계산하는건 조만간 deepdive 형식으로 하나하나 파헤쳐봐야겠다."
  },
  
  {
    "title": "2주차 과제 class화 (3)",
    "url": "/posts/Main-campus_2nd-week_Arrange_class3/",
    "categories": "캠프, 2주차",
    "tags": "야구, 과제",
    "date": "2024-03-13 00:30:00 +0900",
    





    
    "snippet": "이젠 더이상 건드릴게 없어 보인다.Model// GameModelimport Foundationstruct GameModel {        static var answer = Array&lt;Int&gt;()    var question = Array&lt;Int&gt;()        static var gameStart : Bool = true ...",
    "content": "이젠 더이상 건드릴게 없어 보인다.Model// GameModelimport Foundationstruct GameModel {        static var answer = Array&lt;Int&gt;()    var question = Array&lt;Int&gt;()        static var gameStart : Bool = true    static var ansCheck : Bool = true    var gameTitle : Bool = true    }// QuestionModelstruct QuestionModel {        var numbers = Array&lt;Int&gt;()    var quesMaking : Bool = true    }// BallCountModelstruct BallCountModel {        var ballCount = Dictionary&lt;String,Int&gt;()    }// RecordModelstruct RecordModel {        static var gameCount : Int = 0    static var ansCount : Int = 0    static var scoreArray = Array&lt;Int&gt;()    }Controller// BaseballGameimport Foundationclass BaseballGame{        var gameModel = GameModel()    let recordManager = RecordManager()    let makingQuestion = MakingQuestion()    let ballCountManager = BallCountManager()    let gameManager = InputManager()        func start () {                while gameModel.gameTitle { // Game must be operated when gameTitle is true                        print(\"               ⚾️ Play Ball ⚾️  \")            print(\" [1]. Game Start! [2]. Game Record [3]. Exit \")                        let titleInput = Int(readLine()!)                        switch titleInput {                            case 1 :                                gameModel.question = makingQuestion.makeQuestion()                                GameModel.gameStart = true                                recordManager.resetCount()                                while GameModel.gameStart { // Game must be operated when gameStart is true                                        GameModel.ansCheck = true                                        while GameModel.ansCheck { // Player should follow the rule which is answer's count is 3                                                print(\"           Please Enter 3 Numbers\")                        print(gameModel.question)                                                let input = Int(readLine()!)                                                if let input = input {                                                        GameModel.answer = String(input).map{Int(String($0))!}                            gameManager.answerCheck()                                                    }                        else {                                                        print(\"      Please Enter the Number Correctly\")                            recordManager.inreaseAnsCount()                                                    }                    }                                        ballCountManager.resetAllBallCount() // reset ball counts                    ballCountManager.getTotalCount(gameModel.question, GameModel.answer) // to get ball count                    ballCountManager.checkBallCount() // get ball count using checkballcount function                                    }                            case 2 :                 recordManager.showRecord()                            case 3 :                                print(\"                  Good Bye👋\")                gameModel.gameTitle = false                            default :                                print(\"      Please Enter the Number Correctly\\n\")                            }        }    }   }// MakingQuestionimport Foundationclass MakingQuestion {        var gameModel = GameModel()    var questionModel = QuestionModel()        func makeQuestion() -&gt; [Int]{                // initialize        gameModel.question = []        questionModel.numbers = (0...9).map{$0}        questionModel.quesMaking = true                // making question        while questionModel.quesMaking {                        var a = 0                        a = questionModel.numbers.randomElement()!            gameModel.question.append(a)            questionModel.numbers.remove(at:questionModel.numbers.firstIndex(of: a)!)                        if gameModel.question[0] == 0 {                gameModel.question = []                continue            }                        if gameModel.question.count == 3 {                questionModel.quesMaking = false            }                    }                return gameModel.question    }    }// BallCountManagerimport Foundationclass BallCountManager {    var ballCountModel = BallCountModel()    var gameModel = GameModel()    var recordManager = RecordManager()    let recordModel = RecordModel()        func getTotalCount(_ question : [Int], _ answer : [Int]) {                ballCountModel.ballCount = [\"Strike\": 0, \"Ball\" : 0 ]                // Just want to use High order Function for getting ball count                answer.enumerated().forEach{            (aoffset, aelement) in question.enumerated().forEach{                (qoffset, qelement) in                                if aoffset == qoffset {                    if aelement == qelement {                        ballCountModel.ballCount[\"Strike\"]! += 1                    }                                    }else {                    if aelement == qelement {                        ballCountModel.ballCount[\"Ball\"]! += 1                    }                                    }            }        }                   }        func getBallCount () -&gt; Int {                if let ballCount = ballCountModel.ballCount[\"Ball\"] {            return ballCount                    } else {            return 0        }            }        func getStrikeCount () -&gt; Int {                if let strikeCount = ballCountModel.ballCount[\"Strike\"] {            return strikeCount                    } else {            return 0        }            }        func resetAllBallCount () {                ballCountModel.ballCount[\"Strike\"] = 0        ballCountModel.ballCount[\"Ball\"] = 0            }        func getAllBallCount () -&gt; [String:Int] {                let ballCount = ballCountModel.ballCount            return ballCount            }        func checkBallCount () {                if getStrikeCount() == 3 {                        print(\"                HomeRun!!!!!\\n\")            recordManager.increaseGameCount()            recordManager.saveCount()            GameModel.gameStart = false                    } else if getStrikeCount() == 0 &amp;&amp;  getBallCount() == 0 {                        print(\"                    Out!\\n\")                    } else {                        print(\"               \\(getStrikeCount()) Strike \\(getBallCount()) Ball!\\n\")                    }    }}// RecordManagerimport Foundationclass RecordManager {         // increase Count    func inreaseAnsCount (){        RecordModel.ansCount += 1    }        func increaseGameCount () {        RecordModel.gameCount += 1    }        // Reset Count    func resetCount () {        RecordModel.ansCount = 0    }        // add ansCount into Array    func saveCount () {        RecordModel.scoreArray.append(RecordModel.ansCount)    }        // Current game count    func getGameCount () -&gt; Int {        let gameCount = RecordModel.gameCount        return gameCount    }        // Current score count    func getScoreCount () -&gt; [Int] {        let scoreCount = RecordModel.scoreArray        return scoreCount    }        func showGameScore () {        for i in 0 ..&lt; getGameCount() {            print(\"           \\(i+1) Game, Attempts : \\(getScoreCount()[i])\\n\")        }    }        func showRecord () {        if getGameCount() != 0 {                        print(\"         &lt;&lt;&lt;&lt;&lt; Game Records &gt;&gt;&gt;&gt;&gt;\")            showGameScore()                    } else {                        print(\"          There is no Game Record.\\n\")        }    }    }import Foundationclass InputManager {        let recordManager = RecordManager()        func answerCheck () {                if GameModel.answer.count != 3 {                        print(\"         Please Enter 3 Numbers again.\\n\")            recordManager.inreaseAnsCount()                    } else {                        if GameModel.answer[0] == GameModel.answer [1] || GameModel.answer[0] == GameModel.answer [2] || GameModel.answer[1] == GameModel.answer [2] { // to avoid duplicated number                                print(\"         Duplicated numbers detected!\\n         Please Enter 3 Numbers again.\\n\")                recordManager.inreaseAnsCount()                            } else {                                recordManager.inreaseAnsCount()                GameModel.ansCheck = false                            }        }            }    }이렇게 끝났다.세분화 한건 InputManager의 추가와 BallCountManager에서의 checkBallCount 함수이다.2와 비교하면 모델들 앞에 static이 몇개 붙었다.checkBallCount 함수를 먼저 만들고 나서, 실행을 했는데 함수에서 시도횟수가 1씩 증가하지도 않고,정답을 맞추면 false를 리턴하여 벗어나야하는데 그렇지 않았다.그래서 생각을 해봤는데 두개의 다른 클래스 안에서 서로 값이 따로 논다는걸 이해했을때 아차 싶었다.그래서 다른 클래스에서도 접근이 가능하게하기위해 static을 사용해 주었다.안그래도 튜터님이 클래스와, 구조체 / Value Type, Reference Type의 중요성을 말해 주셨는데, 그걸 순간 망각하지 않았나 싶다.덕분에 중요성을 더 알게 된 계기가 되었다.요근래 static을 사용해서 뭔가를 만들어 본적이 없었던것같은데, 좋은 경험이었다.역시 사람은 만족을 해서는 안되나보다.다시 돌아가서 해당문제를 해결하고나니 진짜 튜터님이 원했던 기능을 InputManager를 통해 만들었다.근데 생각을 해보니 각 조건의 끝에 continue를 붙여서 다시 처음으로 돌아갔는데, 이젠 그럴 수 없는 상황이 되어버렸다.순간 벙쪘다가 while을 하나 더 만들자라는 생각이 들어서 여태 boolean으로 빠져나가고를 했던것을 생각하여,input에 관한 while을 하나더 만들어 주게 되었다.그리고 그전까지는 if를 그냥 여러개 써서 하는식으로 하다가 이렇게 나눠버리니 숫자 2하나만 입력하면 카운트에대한 조건이 나와야하는데, if순서때문에 중복값을 찾게하는 로직이 먼저 발동되어 out of range가 떠버렸다.그래서 길이가 3일때 아닐때를 기준으로 잡고, 3일때 중복값을 확인하는 식으로 로직을 조금 수정하였다.그리고 보면서 이건 static이 필요하다 싶은것들은 몇개 더 바꿔 주었다.이렇게까지 하고 나니, 진짜 내가 원했던 그런 프로젝트가 되었다.아주 만족스럽다.사운드도 넣고 싶었지만, 찾는것도 그렇고 저작권 무료인것도 찾아야 하기에 pass 하겠다. 너무 사족을 다는것 같아서 여기까지…"
  },
  
  {
    "title": "2주차 과제 class화 (2)",
    "url": "/posts/Main-campus_2nd-week_Arrange_class2/",
    "categories": "캠프, 2주차",
    "tags": "야구, 과제",
    "date": "2024-03-12 14:11:00 +0900",
    





    
    "snippet": "조금 더 세분화를 하였다.기존에 GameModel로 모든 변수에 대해 관리를 하였다면?그것을 좀 더 쪼개서 세분화 하였다.// GameModelstruct GameModel {        var question = Array&lt;Int&gt;()    var answer = Array&lt;Int&gt;()      var gameStart : B...",
    "content": "조금 더 세분화를 하였다.기존에 GameModel로 모든 변수에 대해 관리를 하였다면?그것을 좀 더 쪼개서 세분화 하였다.// GameModelstruct GameModel {        var question = Array&lt;Int&gt;()    var answer = Array&lt;Int&gt;()      var gameStart : Bool = true    var gameTitle : Bool = true    }// QuestionModelstruct QuestionModel {        var numbers = Array&lt;Int&gt;()    var quesMaking : Bool = true    }// RecordModelstruct RecordModel {        var gameCount : Int = 0    var ansCount : Int = 0    var scoreArray = Array&lt;Int&gt;()    }// BallCountModelstruct BallCountModel {        var ballCount = Dictionary&lt;String,Int&gt;()    }여기까지가 모델이다.// BaseballGameimport Foundationclass BaseballGame{        var gameModel = GameModel()    let recordManager = RecordManager()    let makingQuestion = MakingQuestion()    let ballCountManager = BallCountManager()        func start () {                while gameModel.gameTitle {                        print(\"&lt;&lt;&lt;&lt;&lt;게임을 시작합니다&gt;&gt;&gt;&gt;&gt;\")            print(\"1. 게임 시작하기. 2. 게임 기록 보기 3. 종료하기\")                        let titleInput = Int(readLine()!)                        switch titleInput {                            case 1 :                                gameModel.question = makingQuestion.makeQuestion()                gameModel.gameStart = true                                recordManager.resetCount()                                while gameModel.gameStart {                                        print(\"숫자를 입력해주세요.\")                    print(gameModel.question)                                        let input = Int(readLine()!)                                        if let input = input {                                                gameModel.answer = String(input).map{Int(String($0))!}                                                if gameModel.answer.count != 3 {                            print(\"3자리의 숫자가 아닙니다. 3자리로 입력해주세요\\n\")                            recordManager.inreaseAnsCount()                            continue                        }                                                if gameModel.answer[0] == gameModel.answer [1] || gameModel.answer[0] == gameModel.answer [2] || gameModel.answer[1] == gameModel.answer [2] {                            print(\"중복된 수가 존재 합니다. 다시 입력해주세요\\n\")                            recordManager.inreaseAnsCount()                            continue                        }                                            }                    else {                        print(\"숫자가 아닌 값이 입력 되었습니다. 숫자만 입력해주세요\\n\")                        recordManager.inreaseAnsCount()                        continue                    }                                        recordManager.inreaseAnsCount()                    ballCountManager.resetAllBallCount()                           ballCountManager.getTotalCount(gameModel.question, gameModel.answer)                                                           if ballCountManager.getStrikeCount() == 3 {                        print(\"&lt;&lt;&lt;&lt;&lt;축하합니다 정답입니다&gt;&gt;&gt;&gt;&gt;.\\n\")                        recordManager.increaseGameCount()                        recordManager.saveCount()                        gameModel.gameStart = false                                            } else if ballCountManager.getStrikeCount() == 0 &amp;&amp;  ballCountManager.getBallCount() == 0 {                        print(\"Nothing\\n\")                                            } else {                        print(\"현재 \\(ballCountManager.getStrikeCount()) Strike \\(ballCountManager.getBallCount()) Ball 입니다.\\n\")                    }                                    }                            case 2 :                                if recordManager.getGameCount() != 0 {                                        print(\"&lt;게임 기록 보기&gt;\")                                        for i in 0 ..&lt; recordManager.getGameCount() {                        print(\"\\(i+1) 번째 게임, 시도 횟수 : \\(recordManager.getScoreCount()[i])\")                    }                    print(\"\")                    continue                                    } else {                    print(\"게임 기록이 없습니다.\\n\")                    continue                }                            case 3 :                                print(\"종료합니다\")                gameModel.gameTitle = false                            default :                                print(\"1, 2, 3 숫자만 입력하세요\\n\")            }        }    }   }// MakingQuestionclass MakingQuestion {        var gameModel = GameModel()    var questionModel = QuestionModel()        func makeQuestion() -&gt; [Int]{                // initialize        gameModel.question = []        questionModel.numbers = (0...9).map{$0}        questionModel.quesMaking = true                // making question        while questionModel.quesMaking {                        var a = 0                        a = questionModel.numbers.randomElement()!            gameModel.question.append(a)            questionModel.numbers.remove(at:questionModel.numbers.firstIndex(of: a)!)                        if gameModel.question[0] == 0 {                gameModel.question = []                continue            }                        if gameModel.question.count == 3 {                questionModel.quesMaking = false            }                    }                return gameModel.question    }    }// BallCountManagerimport Foundationclass BallCountManager {    var ballCountModel = BallCountModel()            func getTotalCount(_ question : [Int], _ answer : [Int]) {                ballCountModel.ballCount = [\"Strike\": 0, \"Ball\" : 0 ]                // Just want to use High order Function                answer.enumerated().forEach{            (aoffset, aelement) in question.enumerated().forEach{                (qoffset, qelement) in                                if aoffset == qoffset {                    if aelement == qelement {                        ballCountModel.ballCount[\"Strike\"]! += 1                    }                }else {                    if aelement == qelement {                        ballCountModel.ballCount[\"Ball\"]! += 1                    }                }            }        }                   }        func getBallCount () -&gt; Int {                if let ballCount = ballCountModel.ballCount[\"Ball\"] {            return ballCount        } else {            return 0        }            }        func getStrikeCount () -&gt; Int {                if let strikeCount = ballCountModel.ballCount[\"Strike\"] {            return strikeCount        } else {            return 0        }            }        func resetAllBallCount () {        ballCountModel.ballCount[\"Strike\"] = 0        ballCountModel.ballCount[\"Ball\"] = 0    }        func getAllBallCount () -&gt; [String:Int] {        let ballCount = ballCountModel.ballCount            return ballCount            }    }// RecordManagerimport Foundationclass RecordManager {        var recordModel = RecordModel()        func showRecords () {        for i in recordModel.scoreArray.indices{            print(\"\\(i+1) 번째 게임, 시도 횟수 : \\(recordModel.scoreArray[i])\")        }    }        // increase Count    func inreaseAnsCount (){        recordModel.ansCount += 1    }        func increaseGameCount () {        recordModel.gameCount += 1    }        // Reset Count    func resetCount () {        recordModel.ansCount = 0    }        // add ansCount into Array    func saveCount () {        recordModel.scoreArray.append(recordModel.ansCount)    }        func getGameCount () -&gt; Int {        let gameCount = recordModel.gameCount        return gameCount    }        func getScoreCount () -&gt; [Int] {        let scoreCount = recordModel.scoreArray        return scoreCount    }    }확실히 이렇게 구분해놓으니 좀 더 코드를 처음 보는사람도 이게 어떤의미로 쓰였는지 보기 좋다는 생각이 들었다.나누면서 뭔가 swift공부할때처럼 내가 class, struct를 나눠서 쓰는게 더 와닿았다!튜터님께 다시 피드백을 받으러 갔다.확실히 전보다 낫다고 하셨고, 튜터님 개인적인 욕심이라면, 실제 게임내 부분에 관한 로직도 조금 더 숨길수 있을것 같다고 하셨다.물론 그건 튜터님 개인 욕심이라 지금도 충분하다고 하시지만, 뭔가 좀 더 도전해보고 싶은 마음이 생긴다."
  },
  
  {
    "title": "2주차 과제 class화 (1)",
    "url": "/posts/Main-campus_2nd-week_Arrange_class1/",
    "categories": "캠프, 2주차",
    "tags": "야구, 과제",
    "date": "2024-03-12 09:11:00 +0900",
    





    
    "snippet": "이미 과제는 끝났지만, 클래스화를 하고싶은데 생각대로 그게 되지않았다.사실 어떻게 나눠야할지 모르겠다가 더 맞는 표현인듯 하다.그래서 새롭게 클래스 화 하려고 한다. 각 레벨에 대한 내용은 생략하겠다.Lv.1// main.swiftimport Foundationlet game = BaseballGame()game.start()// BaseballGam...",
    "content": "이미 과제는 끝났지만, 클래스화를 하고싶은데 생각대로 그게 되지않았다.사실 어떻게 나눠야할지 모르겠다가 더 맞는 표현인듯 하다.그래서 새롭게 클래스 화 하려고 한다. 각 레벨에 대한 내용은 생략하겠다.Lv.1// main.swiftimport Foundationlet game = BaseballGame()game.start()// BaseballGame.swiftimport Foundationclass BaseballGame{        var answer = Array&lt;Int&gt;()    var numbers = Array&lt;Int&gt;()        init(answer: [Int] = Array&lt;Int&gt;(), numbers: [Int] = Array&lt;Int&gt;() ) {        self.answer = answer        self.numbers = numbers    }        func start () {        let answer = makeAnswer()        print(answer)    }        func makeAnswer() -&gt; [Int]{        numbers = (1...9).map{$0}        for _ in 0...2 {            let a = numbers.randomElement()!            answer.append(a)            numbers.remove(at:numbers.firstIndex(of: a)!)        }                return answer    }}Lv.2import Foundationclass BaseballGame{        var question = Array&lt;Int&gt;()    var numbers = Array&lt;Int&gt;()    var answer = Array&lt;Int&gt;()    var gameStart : Bool = true    var ball : Int = 0    var strike : Int = 0            func start () {                let question = makeAnswer()        gameStart = true        print(\"&lt;&lt;&lt;&lt;&lt;게임을 시작합니다&gt;&gt;&gt;&gt;&gt;\")        while gameStart {            print(\"숫자를 입력해주세요.\") // for notification when app starts            print(question)            let input = Int(readLine()!)            if let input = input { // if type is Int                answer = String(input).map{Int(String($0))!}                if answer.count != 3 {                    print(\"3자리의 숫자가 아닙니다. 3자리로 입력해주세요\")                    continue                }                if answer[0] == answer [1] || answer[0] == answer [2] || answer[1] == answer [2] {                    print(\"중복된 수가 존재 합니다. 다시 입력해주세요\")                    continue                }            }            else { // if type is not Int                print(\"숫자가 아닌 값이 입력 되었습니다. 숫자만 입력해주세요\")                continue            }            strike = 0            ball = 0            for i in question.indices {                for j in question.indices {                    if i == j {                        if answer[i] == question[j] {                            strike += 1                        }                    } else {                        if answer[i] == question[j] {                            ball += 1                        }                    }                }            }            if strike == 3 {                print(\"&lt;&lt;&lt;&lt;&lt;축하합니다 정답입니다&gt;&gt;&gt;&gt;&gt;.\")                gameStart = false            } else if strike == 0 &amp;&amp; ball == 0 {                print(\"Nothing\")            } else {                print(\"현재 \\(strike) Strike \\(ball) Ball 입니다.\")            }        }            }        func makeAnswer() -&gt; [Int]{        numbers = (1...9).map{$0}        for _ in 0...2 {            let a = numbers.randomElement()!            answer.append(a)            numbers.remove(at:numbers.firstIndex(of: a)!)        }                return answer    }}Lv.3import Foundationclass BaseballGame{        var question = Array&lt;Int&gt;()    var numbers = Array&lt;Int&gt;()    var answer = Array&lt;Int&gt;()        var gameStart : Bool = true    var quesMaking : Bool = true        var ball : Int = 0    var strike : Int = 0        func start () {                let question = makeQuestion()        gameStart = true        print(\"&lt;&lt;&lt;&lt;&lt;게임을 시작합니다&gt;&gt;&gt;&gt;&gt;\")                while gameStart {                        print(\"숫자를 입력해주세요.\") // for notification when app starts            print(question)            let input = Int(readLine()!)                        if let input = input { // if type is Int                answer = String(input).map{Int(String($0))!}                if answer.count != 3 {                    print(\"3자리의 숫자가 아닙니다. 3자리로 입력해주세요\\n\")                    continue                }                                if answer[0] == answer [1] || answer[0] == answer [2] || answer[1] == answer [2] {                    print(\"중복된 수가 존재 합니다. 다시 입력해주세요\\n\")                    continue                }                            }            else { // if type is not Int                print(\"숫자가 아닌 값이 입력 되었습니다. 숫자만 입력해주세요\\n\")                continue            }                        strike = 0            ball = 0                        for i in question.indices {                for j in question.indices {                    if i == j {                        if answer[i] == question[j] {                            strike += 1                        }                    } else {                        if answer[i] == question[j] {                            ball += 1                        }                    }                }            }                                    if strike == 3 {                print(\"&lt;&lt;&lt;&lt;&lt;축하합니다 정답입니다&gt;&gt;&gt;&gt;&gt;.\\n\")                gameStart = false            } else if strike == 0 &amp;&amp; ball == 0 {                print(\"Nothing\\n\")            } else {                print(\"현재 \\(strike) Strike \\(ball) Ball 입니다.\\n\")            }                    }            }        func makeQuestion() -&gt; [Int]{                numbers = (0...9).map{$0}                while quesMaking {            var a = 0            a = numbers.randomElement()!            question.append(a)            numbers.remove(at:numbers.firstIndex(of: a)!)                        if question[0] == 0 {                question = []                continue            }                        if question.count == 3 {                quesMaking = false            }        }                return question    }}Lv.4~6// BaseballGameimport Foundationclass BaseballGame{        var question = Array&lt;Int&gt;()    var numbers = Array&lt;Int&gt;()    var answer = Array&lt;Int&gt;()    var ballCount = Dictionary&lt;String,Int&gt;()        var gameStart : Bool = true    var quesMaking : Bool = true    var gameTitle : Bool = true        var ball : Int = 0    var strike : Int = 0        // MARK: - Function : Game Start    func start () {                var recordManager = RecordManager()                while gameTitle {            print(\"&lt;&lt;&lt;&lt;&lt;게임을 시작합니다&gt;&gt;&gt;&gt;&gt;\") // for notification when app starts            print(\"1. 게임 시작하기. 2. 게임 기록 보기 3. 종료하기\")            let titleInput = Int(readLine()!)            switch titleInput {            case 1 :                question = makeQuestion()                gameStart = true                recordManager.ansCount = 0                while gameStart {                                        print(\"숫자를 입력해주세요.\") // for notification when app starts                    print(question)                    let input = Int(readLine()!)                                        if let input = input { // if type is Int                        answer = String(input).map{Int(String($0))!}                        if answer.count != 3 {                            print(\"3자리의 숫자가 아닙니다. 3자리로 입력해주세요\\n\")                            recordManager.ansCount += 1                            continue                        }                                                if answer[0] == answer [1] || answer[0] == answer [2] || answer[1] == answer [2] {                            print(\"중복된 수가 존재 합니다. 다시 입력해주세요\\n\")                            recordManager.ansCount += 1                            continue                        }                                            }                    else { // if type is not Int                        print(\"숫자가 아닌 값이 입력 되었습니다. 숫자만 입력해주세요\\n\")                        recordManager.ansCount += 1                        continue                    }                    recordManager.ansCount += 1                    strike = 0                    ball = 0                                        ballCount = getBallCount(question, answer)                                        if ballCount[\"Strike\"] == 3 {                        print(\"&lt;&lt;&lt;&lt;&lt;축하합니다 정답입니다&gt;&gt;&gt;&gt;&gt;.\\n\")                        recordManager.gameCount += 1                        recordManager.scoreArray.append(recordManager.ansCount)                        gameStart = false                    } else if strike == 0 &amp;&amp; ball == 0 {                        print(\"Nothing\\n\")                    } else {                        print(\"현재 \\(ballCount[\"Strike\"] ?? 0) Strike \\(ballCount[\"Ball\"] ?? 0) Ball 입니다.\\n\")                    }                                    }            case 2 :                if recordManager.gameCount != 0 {                                        print(\"&lt;게임 기록 보기&gt;\")                                        for i in 0..&lt;recordManager.gameCount {                        print(\"\\(i+1) 번째 게임, 시도 횟수 : \\(recordManager.scoreArray[i])\")                    }                    print(\"\")                    continue                                    } else { // when user type 2, before starting game                    print(\"게임 기록이 없습니다.\\n\")                    continue                }            case 3 :                print(\"종료합니다\")                gameTitle = false            default :                print(\"1, 2, 3 숫자만 입력하세요\\n\")            }        }    }        // MARK: - Getting Ball count    func getBallCount(_ question : [Int], _ answer : [Int]) -&gt; [String : Int]{                // init strike &amp; ball count        strike = 0        ball = 0        ballCount = [\"Strike\": 0, \"Ball\" : 0 ]                answer.enumerated().map{$0}.forEach{            (aoffset, aelement) in question.enumerated().map{$0}.forEach{                (qoffset, qelement) in                if aoffset == qoffset {                    if aelement == qelement {                        strike+=1                    }                }else {                    if aelement == qelement {                        ball+=1                    }                }            }        }                ballCount[\"Strike\"] = strike        ballCount[\"Ball\"] = ball                return ballCount    }        // MARK: - Making Question    func makeQuestion() -&gt; [Int]{                // initialize        question = []        numbers = (0...9).map{$0}        quesMaking = true                // making question        while quesMaking {            var a = 0            a = numbers.randomElement()!            question.append(a)            numbers.remove(at:numbers.firstIndex(of: a)!)                        if question[0] == 0 {                question = []                continue            }                        if question.count == 3 {                quesMaking = false            }        }                return question    }}// RecordManagerimport Foundationstruct RecordManager {        var gameCount : Int = 0    var ansCount : Int = 0    var scoreArray = Array&lt;Int&gt;()        func showRecords () {        for i in scoreArray.indices{            print(\"\\(i+1) 번째 게임, 시도 횟수 : \\(scoreArray[i])\")        }    }    }튜터님과 대화를 하던중. 변수를 Model화 해서 별도의 Struct에 넣는게 어떨까라는 생각이 들었다.// Record Managerimport Foundationstruct RecordManager {        var gameCount : Int = 0    var ansCount : Int = 0    var scoreArray = Array&lt;Int&gt;()        func showRecords () {        for i in scoreArray.indices{            print(\"\\(i+1) 번째 게임, 시도 횟수 : \\(scoreArray[i])\")        }    }        // increase Count    mutating func inreaseCount (){        ansCount += 1    }        // Reset Count    mutating func resetCount () {        ansCount = 0    }    }// MakingQuestionimport Foundationclass MakingQuestion {        var gameModel = GameModel()        func makeQuestion() -&gt; [Int]{                // initialize        gameModel.question = []        gameModel.numbers = (0...9).map{$0}        gameModel.quesMaking = true                // making question        while gameModel.quesMaking {                        var a = 0                        a = gameModel.numbers.randomElement()!            gameModel.question.append(a)            gameModel.numbers.remove(at:gameModel.numbers.firstIndex(of: a)!)                        if gameModel.question[0] == 0 {                gameModel.question = []                continue            }                        if gameModel.question.count == 3 {                gameModel.quesMaking = false            }                    }                return gameModel.question    }    }// Handling Ball Countimport Foundationclass HandlingBallCount {        var gameModel = GameModel()        func getBallCount(_ question : [Int], _ answer : [Int]) -&gt; [String : Int]{                gameModel.ballCount = [\"Strike\": 0, \"Ball\" : 0 ]                // Just want to use High order Function                answer.enumerated().map{$0}.forEach{            (aoffset, aelement) in question.enumerated().map{$0}.forEach{                (qoffset, qelement) in                if aoffset == qoffset {                    if aelement == qelement {                        gameModel.ballCount[\"Strike\"]! += 1                    }                }else {                    if aelement == qelement {                        gameModel.ballCount[\"Ball\"]! += 1                    }                }            }        }                return gameModel.ballCount    }}// Baseball Gameimport Foundationclass BaseballGame{        var gameModel = GameModel()        func start () {                var recordManager = RecordManager()        let makingQuestion = MakingQuestion()        let handlingBallCount = HandlingBallCount()                while gameModel.gameTitle {                        print(\"&lt;&lt;&lt;&lt;&lt;게임을 시작합니다&gt;&gt;&gt;&gt;&gt;\")            print(\"1. 게임 시작하기. 2. 게임 기록 보기 3. 종료하기\")                        let titleInput = Int(readLine()!)                        switch titleInput {                            case 1 :                                gameModel.question = makingQuestion.makeQuestion()                gameModel.gameStart = true                                recordManager.resetCount()                                while gameModel.gameStart {                                        print(\"숫자를 입력해주세요.\")                    print(gameModel.question)                                        let input = Int(readLine()!)                                        if let input = input {                                                gameModel.answer = String(input).map{Int(String($0))!}                                                if gameModel.answer.count != 3 {                            print(\"3자리의 숫자가 아닙니다. 3자리로 입력해주세요\\n\")                            recordManager.inreaseCount()                            continue                        }                                                if gameModel.answer[0] == gameModel.answer [1] || gameModel.answer[0] == gameModel.answer [2] || gameModel.answer[1] == gameModel.answer [2] {                            print(\"중복된 수가 존재 합니다. 다시 입력해주세요\\n\")                            recordManager.inreaseCount()                            continue                        }                                            }                    else {                        print(\"숫자가 아닌 값이 입력 되었습니다. 숫자만 입력해주세요\\n\")                        recordManager.inreaseCount()                        continue                    }                                        recordManager.inreaseCount()                                        gameModel.ballCount[\"Strike\"] = 0                    gameModel.ballCount[\"Ball\"] = 0                                        gameModel.ballCount = handlingBallCount.getBallCount(gameModel.question, gameModel.answer)                                        if gameModel.ballCount[\"Strike\"] == 3 {                        print(\"&lt;&lt;&lt;&lt;&lt;축하합니다 정답입니다&gt;&gt;&gt;&gt;&gt;.\\n\")                        recordManager.gameCount += 1                        recordManager.scoreArray.append(recordManager.ansCount)                        gameModel.gameStart = false                                            } else if gameModel.ballCount[\"Strike\"] == 0 &amp;&amp;  gameModel.ballCount[\"Ball\"] == 0 {                        print(\"Nothing\\n\")                                            } else {                        print(\"현재 \\(gameModel.ballCount[\"Strike\"] ?? 0) Strike \\(gameModel.ballCount[\"Ball\"] ?? 0) Ball 입니다.\\n\")                    }                                    }                            case 2 :                                if recordManager.gameCount != 0 {                                        print(\"&lt;게임 기록 보기&gt;\")                                        for i in 0..&lt;recordManager.gameCount {                        print(\"\\(i+1) 번째 게임, 시도 횟수 : \\(recordManager.scoreArray[i])\")                    }                    print(\"\")                    continue                                    } else {                    print(\"게임 기록이 없습니다.\\n\")                    continue                }                            case 3 :                                print(\"종료합니다\")                gameModel.gameTitle = false                            default :                                print(\"1, 2, 3 숫자만 입력하세요\\n\")            }        }    }   }// mainimport Foundationlet game = BaseballGame()game.start()// Game Modeimport Foundationstruct GameModel {        var question = Array&lt;Int&gt;()    var numbers = Array&lt;Int&gt;()    var quesMaking : Bool = true        var answer = Array&lt;Int&gt;()    var ballCount = Dictionary&lt;String,Int&gt;()    var gameStart : Bool = true    var gameTitle : Bool = true        var gameCount : Int = 0    var ansCount : Int = 0        var scoreArray = Array&lt;Int&gt;()    }어떻게 보면 이렇게 바꾸면서gameModel.property 로 다 바뀐것같다.이게 맞는지는 솔직히 잘 모르겠다.다른 튜터님과 이야기 해본결과, 좀 더 Model에 대해 세분화를 해보는게 어떠냐는 말을 들어 더 세분화를 해보기로한다."
  },
  
  {
    "title": "2주차 (5)",
    "url": "/posts/Main-campus_2nd-week-5/",
    "categories": "캠프, 2주차",
    "tags": "",
    "date": "2024-03-12 06:11:00 +0900",
    





    
    "snippet": "예외처리실패 가능한 상황과 예외 처리  에러처리          프로그램에서 에러가 발생한 상황에 대응하고 이에 대응하는 과정.      Swift에서는 런타임에 에러가 발생한 경우, 이를 처리를 지원하는 클래스를 제공한다.      프로그램에서 모든 기능이 개발자가 예상하고 원하는대로 동작한다는 보장은 없다.                  따라서 예...",
    "content": "예외처리실패 가능한 상황과 예외 처리  에러처리          프로그램에서 에러가 발생한 상황에 대응하고 이에 대응하는 과정.      Swift에서는 런타임에 에러가 발생한 경우, 이를 처리를 지원하는 클래스를 제공한다.      프로그램에서 모든 기능이 개발자가 예상하고 원하는대로 동작한다는 보장은 없다.                  따라서 예외 처리를 통해 예외 상황을 구별하고 프로그램 자체적으로 오류를 해결하거나, 사용자에게 어떤 에러가 발생했는지 알려주는 등에 대한 조치와 대응을 해야한.                      Error          Error는 던져질 수 있는 오류 값을 나타내는 유형을 말한다.      Error 프로토콜을 채택하여 사용자 정의 에러를 정의하여 사용할 수 있다      enum VendingMachineError: Error {    case invalidSelection    case insufficientFunds(coinsNeeded: Int)    case outOfStock}throw와 do-catch문 &amp; try문  throw와 throws          throws는 리턴 값을 반환하기 전에 오류가 발생하면 에러 객체를 반환한다는 의미.      throws는 오류가 발생할 가능성이 있는 메소드 제목 옆에 써준다.      throw는 오류가 발생할 구간에서 써준다.        throw로 던진 에러를 do-catch문에서 처리한다.// 표현func canThrowErrors() throws -&gt; Stringfunc cannotThrowErrors() -&gt; Stringenum CustomError: Error {    case outOfBounds    case invalidInput(String)}func processValue(_ value: Int) throws -&gt; Int {    if value &lt; 0 {        throw CustomError.invalidInput(\"Value cannot be negative\")    } else if value &gt; 100 {        throw CustomError.outOfBounds    }        return value * 2}// do-catch 블록을 이용하여 throwing 함수 호출 및 에러 처리하기do {    let result = try processValue(50)    print(\"Result is \\(result)\")} catch CustomError.outOfBounds {    print(\"Value is out of bounds!\")} catch CustomError.invalidInput(let errorMessage) {    print(\"Invalid Input: \\(errorMessage)\")} catch {    print(\"An error occurred: \\(error)\")}// 출력 : Result is 100do {    let result = try processValue(-10)    print(\"Result is \\(result)\")} catch CustomError.outOfBounds {    print(\"Value is out of bounds!\")} catch CustomError.invalidInput(let errorMessage) {    print(\"Invalid Input: \\(errorMessage)\")} catch {    print(\"An error occurred: \\(error)\")}// 출력 : Invalid Input: Value cannot be negativetry , try? , try!  try          에러가 발생할 수 있는 코드 블록을 표시      에러를 던질 수 있는 함수나 메서드를 호출할 때 사용된다.      해당 코드 블록에서 발생한 에러를 잡거나 처리할 수 있다(do - catch문).        try?          do - catch 구문 없이도 사용이 가능하다.      에러 발생시 nil값을 반환.      에러가 발생하지 않으면 리턴 값의 타입은 옵셔널로 반환.        try!          에러가 발생을 하면 앱이 강제 종료된다.      반환 타입은 옵셔널이 언래핑된 값이 리턴된다.      오류가 발생하지 않는다는 보장아래 사용해야한다.      enum MyError: Error {    case invalidInput}func someThrowingFunction(value: Int) throws -&gt; String {    guard value &gt;= 0 else {        throw MyError.invalidInput // value가 음수인 경우 에러를 던짐    }    return \"The value is \\(value)\"}// throwing 함수 호출과 에러 처리하기do {    let result = try someThrowingFunction(value: 5)    print(result)} catch {    print(\"Error occurred: \\(error)\")}do {    let result = try someThrowingFunction(value: -2) // 에러 발생    print(result)} catch {    print(\"Error occurred: \\(error)\") // 음수 값을 처리하는 에러}// try?를 사용하여 에러 처리하기let result1 = try? someThrowingFunction(value: 5) // 유효한 값 호출print(result1) // Optional(\"The value is 5\")let result2 = try? someThrowingFunction(value: -2) // 에러 발생print(result2) // nil// try!를 사용하여 에러 처리하기let result3 = try! someThrowingFunction(value: 5) // 유효한 값 호출print(result3) // The value is 5let result4 = try! someThrowingFunction(value: -2) // 에러 발생print(result4)"
  },
  
  {
    "title": "2주차 (4)",
    "url": "/posts/Main-campus_2nd-week-4/",
    "categories": "캠프, 2주차",
    "tags": "",
    "date": "2024-03-12 04:11:00 +0900",
    





    
    "snippet": "클로저1. 클로저  클로저는 이름없는 함수 즉, 코드 블록을 의미한다.  클로저는 상수나 변수의 참조를 캡쳐(capture)해 저장할 수 있다          스위프트의 클로저는 주변 환경에 있는 변수나 상수를 캡처하여 저장하고, 이를 나중에 사용할 수 있도록 한다. 이것은 클로저가 생성될 때 클로저가 참조하는 변수 또는 상수의 값에 대한 복사본을 유...",
    "content": "클로저1. 클로저  클로저는 이름없는 함수 즉, 코드 블록을 의미한다.  클로저는 상수나 변수의 참조를 캡쳐(capture)해 저장할 수 있다          스위프트의 클로저는 주변 환경에 있는 변수나 상수를 캡처하여 저장하고, 이를 나중에 사용할 수 있도록 한다. 이것은 클로저가 생성될 때 클로저가 참조하는 변수 또는 상수의 값에 대한 복사본을 유지하고 저장하는 메커니즘이다      값(value) 캡처: 클로저가 변수나 상수의 값을 캡처 이때, 클로저 내부에서 캡처한 값이 변경되어도 원본 값은 변경되지 않는다.      참조(reference) 캡처: 클로저가 변수나 상수의 참조를 캡처. 따라서 클로저 내에서 해당 변수나 상수를 변경하면 원본 값도 변경된다.      // 값 캡처func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int {    var total = 0        // 클로저를 반환합니다.    let incrementer: () -&gt; Int = {        // total 변수를 캡처하여 저장합니다.        total += amount        return total    }        return incrementer}let incrementByTen = makeIncrementer(forIncrement: 10)print(incrementByTen()) // total = 10, 결과: 10print(incrementByTen()) // total = 20, 결과: 20// 참조 캡처class SimpleClass {    var value: Int = 10}func createClosure() -&gt; (() -&gt; Int) {    let instance = SimpleClass()        // 참조 캡처를 사용하여 SimpleClass의 인스턴스를 캡처.    let closure: () -&gt; Int = {        // 클로저가 참조하는 인스턴스의 속성을 업데이트.        instance.value *= 2        return instance.value    }        return closure}// 클로저 생성let myClosure = createClosure()print(myClosure()) // 20print(myClosure()) // 40// 클로저 내부에서 참조된 인스턴스의 속성을 변경하였으므로 원본에도 영향을 준다.  클로저를 사용하는 이유는 ? 가장 일반적으로는 기능을 저장하기 위해 사용한다.  클로저는 비동기 처리가 필요할 때 사용할 수 있는 코드 블록이다.(반드시 비동기에만 사용하는 것은 아님)  클로저는 클래스와 마찬가지로 참조 타입(reference type)이다.{ (parameters) -&gt; return type in    // 구현 코드}// 함수와 클로저 비교func pay(user: String, amount: Int) {    // code}let payment = { (user: String, amount: Int) in    // code}/// 예시1// 1) (클로저를 파라미터로 받는 함수)정의func closureFunc2(closure: () -&gt; ()) {    print(\"시작\")    closure()}// 파라미터로 사용할 함수/클로저를 정의func doneFunc() {          // 함수를 정의    print(\"종료\")}let doneClosure = { () -&gt; () in      // 클로저를 정의    print(\"종료\")}// 함수를 파라미터로 넣으면서 실행 (그동안에 배운 형태로 실행한다면)closureFunc2(closure: doneFunc)closureFunc2(closure: doneClosure)// 2) 함수를 실행할때 클로저 형태로 전달 (클로저를 사용하는 이유)closureFunc2(closure: { () -&gt; () in    print(\"프린트 종료\")           // 본래 정의된 함수를 실행시키면서, 클로저를 사후적으로 정의 가능})                              // (활용도가 늘어남)closureFunc2(closure: { () -&gt; () in    print(\"프린트 종료 - 1\")    print(\"프린트 종료 - 2\")    })/// 예시2// 1) (클로저를 파라미터로 받는 함수)정의func closureCaseFunction(a: Int, b: Int, closure: (Int) -&gt; Void) {    let c = a + b    closure(c)}// 2) 함수를 실행할 때 (클로저 형태로 전달)closureCaseFunction(a: 1, b: 2, closure: { (n) in    // 사후적 정의    print(\"plus : \\(n)\")})closureCaseFunction(a: 1, b: 2) {(number) in      // 사후적 정의    print(\"result : \\(number)\")}closureCaseFunction(a: 4, b: 3) { (number) in      // 사후적 정의    print(\"value : \\(number)\")}/* 파라미터 생략 등 간소화 문법 */// 함수의 정의func performClosure(param: (String) -&gt; Int) {    param(\"Swift\")}// 문법을 최적화하는 과정// 1) 타입 추론(Type Inference)performClosure(param: { (str: String) in    return str.count})performClosure(param: { str in    return str.count})// 2) 한줄인 경우, 리턴을 안 적어도 됨(Implicit Return)performClosure(param: { str in    str.count})// 3) 아규먼트 이름을 축약(Shorthand Argements)performClosure(param: {    $0.count})// 4) 트레일링 클로저performClosure(param: {    $0.count})performClosure() {    $0.count}performClosure { $0.count }let closureType1 = { (param) in    return param % 2 == 0}let closureType2 = { $0 % 2 == 0 }// 축약 형태로의 활용let closureType3 = { (a: Int, b:Int) -&gt; Int in    return a * b}let closureType4: (Int, Int) -&gt; Int = { (a, b) in    return a * b}let closureType5: (Int, Int) -&gt; Int = { $0 * $1 }2. 탈출 클로저  코드의 순차적 실행과 비동기의 실행 순서// 순차적 실행func sequentialExecutionExample() {    print(\"Start\")    // 1. 첫 번째 작업    for i in 1...3 {        print(\"Task \\(i)\")    }    // 2. 두 번째 작업    print(\"Next Task\")    // 3. 세 번째 작업    let result = 5 + 3    print(\"Result: \\(result)\")    print(\"End\")}sequentialExecutionExample()/*위의 코드는 함수 sequentialExecutionExample 내에서 순차적으로 실행된다.각각의 작업은 순서대로 실행되며, 한 작업이 끝나야 다음 작업이 실행된다. 이 예시에서는 'Start', 'Task 1', 'Task 2', 'Task 3', 'Next Task', 'Result: 8', 'End'와 같은 순서로 출력.*/​func asynchronousExecutionExample() {    print(\"Start\")    // 1. 비동기로 실행되는 작업    DispatchQueue.global().async {        for i in 1...3 {            print(\"Async Task \\(i)\")        }    }    // 2. 순차적으로 실행되는 작업    print(\"Next Task\")    // 3. 또 다른 비동기 작업    DispatchQueue.global().async {        let result = 5 + 3        print(\"Async Result: \\(result)\")    }    // 4. 끝 부분    print(\"End\")}asynchronousExecutionExample()/*위의 코드는 비동기적으로 실행되는 예시 DispatchQueue.global().async를 사용하여 클로저가 다른 스레드에서 비동기적으로 실행된다. 따라서 비동기 작업은 순차적인 흐름을 방해하지 않고 별도의 스레드에서 실행된다.실행 결과는 'Start', 'Next Task', 'End' 순서로 출력되고, 비동기 작업은 나중에 완료되어 'Async Task 1', 'Async Task 2', 'Async Task 3', 'Async Result: 8'와 같이 순서는 보장되지 않는 시점에 출력된다. 이는 비동기 작업이 별도의 스레드에서 동작하기 때문에, 주 스레드의 작업과 병행적으로 실행됨을 보여준다.*//* 실제로 해당 코드를 xcode에서 실행을 해보면 StartNext TaskEnd이렇게 출력이 되고 끝난다. 즉 비동기로 실행되는 작업의 결과가 나타나기전에 해당 함수가 끝이나버리는 경우인것이다.강의의 내용을 보통 올렸지만 해당코드는 조금 수정을 해서 올려본다.*/  이스케이핑 클로저(escaping closure)          1) 어떤 함수의 내부에 존재하는 클로저(함수)를 외부 변수에 저장하는 경우      2) 이스케이핑 클로저는 클로저가 메서드의 인자로 전달됐을 때, 메서드의 실행이 종료된 후 실행되는 클로저(비동기)      이 경우 파라미터 타입 앞에 @escaping이라는 키워드를 명시해야 한다.                  예를들어, 비동기로 실행되거나 completionHandler로 사용되는 클로저의 경우                    클로저를 메서드의 파라미터로 넣을 수 있다.      // 1) 외부 변수 저장var defaultFunction: () -&gt; () = { print(\"출력\") }func escapingFunc(closure: @escaping () -&gt; ()) {\t\t// 클로저를 실행하는 것이 아니라  aSavedFunction 변수에 저장. \t\t// 함수는 변수와 달리 기본적으로 외부 할당이 불가능    defaultFunction = closure        }// 2) GCD 비동기 코드func asyncEscaping(closure: @escaping (String) -&gt; ()) {        var name = \"iOS튜터\"        DispatchQueue.main.asyncAfter(deadline: .now() + 3) { //3초뒤에 실행하도록 만들기        closure(name)    }}asyncEscaping { str in    print(\"name : \\(str)\")}  @escaping 를 사용하는 클로저에서 self의 요소를 사용할 경우, self를 명시적으로 언급해야 한다.var completionHandlers: [() -&gt; Void] = []func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) {    completionHandlers.append(completionHandler)}func someFunctionWithNonescapingClosure(closure: () -&gt; Void) {    closure()    // 함수 안에서 끝나는 클로저}class SomeClass {    var x = 10    func doSomething() {        someFunctionWithEscapingClosure { self.x = 100 }        // escaping이 붙은상태에서 self를 붙이지 않으면 에러가 난다. 그러므로 명시적으로 self를 적어줘야 한다.        someFunctionWithNonescapingClosure { x = 200 }    }}let instance = SomeClass()instance.doSomething()print(instance.x)// Prints \"200\"completionHandlers.first?()print(instance.x)// Prints \"100\"고차함수1. map  map 함수는 컬렉션 내부의 기존 데이터를 변형(transform)하여 새로운 컬렉션를 생성한다.  기존의 컬렉션의 요소에 대해 정의한 익명함수로 매핑한 결과를 새로운 컬렉션으로 반환.// for 문으로 구현let num = [\"1\", \"2\", \"3\", \"4\", \"5\"]var numberArray: [Int] = []for index in num {    if let changeToInt = Int(index) {        numberArray.append(changeToInt)    }}print(numberArray)// [1, 2, 3, 4, 5]// map으로 구현let stringArray = [\"1\", \"2\", \"3\", \"4\", \"5\"]numberArray = stringArray.map { \t\tif let changeToInt = Int($0) {\t\t\t\treturn changeToInt\t\t}\t\treturn 0}/*$0와 $1{ } 를 익명함수인 클로저라고 한다.클로저의 매개변수 이름이 필요하지 않은 경우 단축 인자 이름을 활용할 수 있다.($0, $1)단축 인자이름은 순서대로 $0 , $1 , $2, $3 ...으로 표현한다.$0 은 첫번째 인자, $1은 두번째 인자를 뜻한다.*/print(numberArray)// [1, 2, 3, 4, 5]2. filter  기존 컨테이너의 요소 중 조건에 만족하는 값에 대해 새로운 컨테이너를 만들어 반환.// for 문으로 구현// numbers에서 짝수만 추출하기let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]var evenNumbers: [Int] = []for number in numbers {    if number % 2 == 0 {        evenNumbers.append(number)    }}print(evenNumbers)// [2, 4, 6, 8]// filter로 구현// numbers에서 짝수만 추출하기let numbers1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]let evenNumbers2 = numbers1.filter { $0 % 2 == 0 }print(evenNumbers2)// [2, 4, 6, 8]3. reduce  기존의 컨테이너의 요소에 대해 정의한 클로저로 매핑한 결과를 새로운 컨테이너로 반환.// for 문으로 구현// 각 요소의 합 구하기let numbers2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]var sum = 0for number in numbers2 {    sum += number}print(sum)// 55// reduce로 구현// 표현식1// 각 요소의 합 구하기let numbers3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]let sum1 = numbers3.reduce(0, +)print(sum1)// 55//표현식2// 각 요소의 합 구하기let numbers4 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]let sum2 = numbers4.reduce(0) { $0 + $1 }print(sum2)// 55"
  },
  
  {
    "title": "214. 소수 만들기",
    "url": "/posts/214.-%EC%86%8C%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-12 02:37:00 +0900",
    





    
    "snippet": "import Foundationfunc getPrime(_ number : Int) -&gt; Int {        var result : Int = 0    var i : Int = 1        while i &lt;= number{        if number%i == 0 {                result += 1        } ...",
    "content": "import Foundationfunc getPrime(_ number : Int) -&gt; Int {        var result : Int = 0    var i : Int = 1        while i &lt;= number{        if number%i == 0 {                result += 1        }        i += 1    }        return result}func solution(_ nums:[Int]) -&gt; Int {    var answer = 0            for i in 0..&lt;nums.count-2 {        for j in i+1..&lt;nums.count-1 {            for k in j+1..&lt;nums.count {                if getPrime(nums[i]+nums[j]+nums[k]) == 2{                    answer += 1                }            }        }    }        return answer}요새는 고차함수를 애매하게 쓰는것 보다 문제풀이에 집중을 하다보니. for문을 사용하였다.그리고 코드가 길어질것같아 소수를 구하는 함수를 새로 만들어서 풀었다.확실히 하나하나 걸러서 풀다보니 테스트시간이 만족스럽지가 않다."
  },
  
  {
    "title": "2주차 (3)",
    "url": "/posts/Main-campus_2nd-week-3/",
    "categories": "캠프, 2주차",
    "tags": "",
    "date": "2024-03-12 02:11:00 +0900",
    





    
    "snippet": "접근 제한자  접근 제한자는 다른 소스 파일이나 모듈의 코드에서 코드 일부에 대한 접근을 제한.  [제약이 적음] open &lt; public &lt; internal &lt; fileprivate &lt; private [제약이 많음]          open : 모든 소스 파일에서 해당 level 접근 가능 + 모든 곳에서 서브클래싱 가능    ...",
    "content": "접근 제한자  접근 제한자는 다른 소스 파일이나 모듈의 코드에서 코드 일부에 대한 접근을 제한.  [제약이 적음] open &lt; public &lt; internal &lt; fileprivate &lt; private [제약이 많음]          open : 모든 소스 파일에서 해당 level 접근 가능 + 모든 곳에서 서브클래싱 가능      public : 모든 소스 파일에서 해당 level 접근 가능 + 같은 모듈 내에서만 서브클래싱 가능      internal : 같은 모듈 내에서만 접근 가능, default      fileprivate : 같은 소스파일 내에서만 접근 가능      private : 클래스 내부에서만 접근 가능        접근 제한자를 작성하지 않으면  internal로 판단  상위 요소보다 하위 요소가 더 높은 접근 수준을 가질 수 없다.private struct Car {\t  public var model: String // 🚨 에러 : private이 하위인데 public이 사용되었다}   모듈과 소스파일          모듈(module)                  배포할 코드의 묶음 단위          하나의 프레임워크/ 라이브러리/ 어플리케이션이 모듈 단위가 될 수 있다.          import 키워드를 통해 불러올 수 있다.                    소스파일                  하나의 swift 소스 코드 파일을 의미한다.                      public, open          둘 다 모듈 외부까지 접근할 수 있다.      open은 클래스와 클래스 맴버에서만 사용할 수 있고 다른 모듈에서 서브클래싱이 가능하지만 public은 그렇지 않다.      open으로 클래스를 개방 접근 수준으로 명시하는 것은 그 클래스를 다른 모듈에서도 수퍼클래스로 사용하겠다는 의미로 해당 클래스를 설계하고 만들었다는 것을 의미한다. (다른 모듈에서 상속을 허용함)      public은 주로 프레임워크에서 외부와 연결될 인터페이스를 구현하는데 많이 사용한다.        internal          모든 요소에 암묵적으로 지정하는 디폴트 접근 제어자      소스 파일이 속해있는 모듈 어디에든 접근할 수 있지만 외부 모듈에서는 접근할 수 없다.        fileprivate          소스 파일 내부에서만 접근할 수 있다.      서로 다른 클래스가 같은 하나의 소스 파일에 정의되어있고 fileprivate로 선언되어 있다면 두 클래스는 서로 접근할 수 있다.        private          가장 제한적인 접근제어자      fileprivate과 달리 같은 파일 안에 있어도 서로 다른 클래스이고 private로 선언되어 있다면 두 요소는 서로 접근할 수 없다.      // open open class Vehicle {    open func startEngine() {        print(\"Engine started\")    }}open class Car: Vehicle {    open var carType: String = \"Sedan\"}// public public struct Point {    public var x: Int    public var y: Int    public init(x: Int, y: Int) {        self.x = x        self.y = y    }    public mutating func moveByX(_ deltaX: Int, y deltaY: Int) {        self.x += deltaX        self.y += deltaY    }}// internalinternal class InternalClass {    internal var internalProperty: Int = 10    internal func doSomethingInternally() {        print(\"Internal operation performed\")    }}internal let internalConstant = 20// fileprivateclass OuterClass {    fileprivate var outerVariable = 30    fileprivate func outerFunction() {        print(\"Outer function called\")    }    fileprivate class InnerClass {        fileprivate func innerFunction() {            print(\"Inner function called\")        }    }}// privateclass MyClass {    private var privateVariable = 40    private func privateFunction() {        print(\"Private function called\")    }}/*Swift에서 mutating 키워드는 구조체(Structs)나 열거형(Enum) 내에서 메서드(Method)가 해당 구조체 또는 열거형의 속성을 수정할 수 있도록 하는 키워드.기본적으로 Swift에서는 구조체나 열거형의 인스턴스가 상수로 선언되면 해당 인스턴스의 속성을 변경할 수 없다. 그러나 메서드 내에서 해당 인스턴스의 속성을 변경하려면 mutating 키워드를 사용하여 해당 메서드가 해당 인스턴스의 속성을 수정할 수 있도록 허용해야 한다.*/// 구조체 예시struct Point {    var x = 0.0, y = 0.0    mutating func moveBy(x deltaX: Double, y deltaY: Double) {        x += deltaX        y += deltaY    }}var point = Point(x: 1.0, y: 1.0)print(\"Before moving: x = \\(point.x), y = \\(point.y)\")point.moveBy(x: 2.0, y: 3.0)print(\"After moving: x = \\(point.x), y = \\(point.y)\")// Before moving: x = 1.0, y = 1.0// After moving: x = 3.0, y = 4.0// 열거형 예시enum TrafficLight {    case red, yellow, green    mutating func next() {        switch self {        case .red:            self = .green        case .yellow:            self = .red        case .green:            self = .yellow        }    }}var currentLight = TrafficLight.redprint(\"Current light is \\(currentLight)\")currentLight.next()print(\"Next light is \\(currentLight)\")// Current light is red// Next light is green"
  },
  
  {
    "title": "2주차 과제",
    "url": "/posts/Main-campus_2nd-week_Arrange/",
    "categories": "캠프, 2주차",
    "tags": "야구, 과제",
    "date": "2024-03-11 09:11:00 +0900",
    





    
    "snippet": "2주차 과제가 주어졌다.Lv1  1에서 9까지의 서로 다른 임의의 수 3개를 정하고 맞추는 게임입니다  정답은 랜덤으로 만듭니다.(1에서 9까지의 서로 다른 임의의 수 3자리)나의 코드var question : [Int] = []var numbers : [Int] = (1...9).map{$0} for _ in 0...2 { // operate 3 t...",
    "content": "2주차 과제가 주어졌다.Lv1  1에서 9까지의 서로 다른 임의의 수 3개를 정하고 맞추는 게임입니다  정답은 랜덤으로 만듭니다.(1에서 9까지의 서로 다른 임의의 수 3자리)나의 코드var question : [Int] = []var numbers : [Int] = (1...9).map{$0} for _ in 0...2 { // operate 3 times    var a = 0    a = numbers.randomElement()!    question.append(a)    numbers.remove(at:numbers.firstIndex(of: a)!)우선 1~9까지의 서로다른 임의의 수 3개를 생성 하는것이었고, 랜덤으로 추출하지만 중복값은 없어야 했다.1~9까지 수를 numbers라는 변수에 담았고, 해당 배열에서 1개를 뽑아 a라는 변수에 넣었고, 그 a 값을 실제 문제를 담을 question에 넣어 주었다.그리고 중복이 없어야 하기에 배열에서 그 수를 제거 해주었다.Lv2  정답을 맞추기 위해 3자리수를 입력하고 힌트를 받습니다          힌트는 야구용어인 볼과 스트라이크입니다.      같은 자리에 같은 숫자가 있는 경우 스트라이크, 다른 자리에 숫자가 있는 경우 볼입니다      ex) 정답 : 456 인 경우                  435를 입력한 경우 → 1스트라이크 1볼          357를 입력한 경우 → 1스트라이크          678를 입력한 경우 → 1볼          123를 입력한 경우 → Nothing                    ex) 정답 : 456 인 경우                  435를 입력한 경우 → 1스트라이크 1볼          357를 입력한 경우 → 1스트라이크          678를 입력한 경우 → 1볼          123를 입력한 경우 → Nothing          만약 올바르지 않은 입력값에 대해서는 오류 문구를 보여주세요                    3자리 숫자가 정답과 같은 경우 게임이 종료됩니다          &lt; 게임을 시작합니다 &gt;  숫자를 입력하세요  435  1스트라이크 1볼  숫자를 입력하세요  357  1스트라이크  숫자를 입력하세요  123  Nothing  숫자를 입력하세요  dfg // 세 자리 숫자가 아니어서 올바르지 않은 입력값  올바르지 않은 입력값입니다  숫자를 입력하세요  199 // 9가 두번 사용되어 올바르지 않은 입력값  올바르지 않은 입력값입니다  숫자를 입력하세요  103 // 0이 사용되어 올바르지 않은 입력값  올바르지 않은 입력값입니다  숫자를 입력하세요  456  정답입니다!          나의 코드var numbers : [Int] = (1...9).map{$0} // for creating random numbersvar question : [Int] = []var answer : [Int] = []var gameStart : Bool = truevar strike : Int = 0var ball : Int = 0for _ in 0...2 { // operate 3 times    var a = 0    a = numbers.randomElement()!    question.append(a)    numbers.remove(at:numbers.firstIndex(of: a)!) }print(question)// MARK: - Input user's numberprint(\"&lt;&lt;&lt;&lt;&lt;게임을 시작합니다&gt;&gt;&gt;&gt;&gt;\")while gameStart {    print(\"숫자를 입력해주세요.\") // for notification when app starts    let input = Int(readLine()!)    if let input = input { // if type is Int        answer = String(input).map{Int(String($0))!}        if answer.count != 3 {            print(\"3자리의 숫자가 아닙니다. 3자리로 입력해주세요\")            continue        }        if answer[0] == answer [1] || answer[0] == answer [2] || answer[1] == answer [2] {            print(\"중복된 수가 존재 합니다. 다시 입력해주세요\")            continue        }    }    else { // if type is not Int        print(\"숫자가 아닌 값이 입력 되었습니다. 숫자만 입력해주세요\")        continue    }    strike = 0    ball = 0    for i in question.indices {        for j in question.indices {            if i == j {                if answer[i] == question[j] {                    strike += 1                }            } else {                if answer[i] == question[j] {                    ball += 1                }            }        }    }    if strike == 3 {        print(\"&lt;&lt;&lt;&lt;&lt;축하합니다 정답입니다&gt;&gt;&gt;&gt;&gt;.\")        gameStart = false    } else if strike == 0 &amp;&amp; ball == 0 {        print(\"Nothing\")    } else {        print(\"현재 \\(strike) Strike \\(ball) Ball 입니다.\")    }}이제는 게임 로직을 구현해야 한다.우선 내가 만들어진 문제를 맞출때 까지 계속 풀어야 하므로 무한 루프인 while을 사용해주었고, true일때 계속 돌게하고,정답을 맞출때 false로 while문을 빠져나가도록 틀을 잡았다.그리고 실제로 내가 입력한 값을 받아야 하므로 일반적인 type선언이 아닌. readLine()을 사용했다.기본적으로 readLine은 optional String을 가지고 있어 !를 통해 unwrapping을 해주었다.누군가가 입력을 할때 숫자가아닌 다른 수를 입력 할 수도 있으므로 옵셔널 바인딩을 해주었다.그리고 내가 입력한 수를 그대로 배열로 만들어 주었다.숫자를 입력 다하고 엔터를친 시점에 2개의 if문이 돌아서 3자리를 입력하지 않았거나, 또는 중복숫자를 입력했을때 다시 돌아가게끔 로직을 구현해주었다.그리고나서 ball, strike의 값을 초기화 해주었고, 반복문을 통해 i, j이가 같을때, 즉 같은 자리일때 strike를 1씩 올려주고,다른자리에서 같을때 ball을 1씩 올려주게 하였다.그리고 그 값에 따라 정답이거나 또는 ball, strike, nothing이런 조건을 통해 값을 보여 유져로 하여금 문제의 값을 추론하게 만들었다.Lv3  정답이 되는 숫자를 0에서 9까지의 서로 다른 3자리의 숫자로 바꿔주세요          맨 앞자리에 0이 오는 것은 불가능합니다                  092 → 불가능          870 → 가능          300 → 불가능                    var numbers : [Int] = (0...9).map{$0} // for creating random numbersvar question : [Int] = []var answer : [Int] = []var gameStart : Bool = truevar gameMaking : Bool = truevar strike : Int = 0var ball : Int = 0while gameMaking {    var a = 0    a = numbers.randomElement()!    question.append(a)    numbers.remove(at:numbers.firstIndex(of: a)!)    if question[0] == 0 {        question = []        continue    }    if question.count == 3 {        gameMaking = false    }}print(\"&lt;&lt;&lt;&lt;&lt;게임을 시작합니다&gt;&gt;&gt;&gt;&gt;\") // for notification when app startswhile gameStart {    print(\"숫자를 입력해주세요.\")         let input = Int(readLine()!)    if let input = input { // if type is Int        answer = String(input).map{Int(String($0))!}        if answer.count != 3 {            print(\"3자리의 숫자가 아닙니다. 3자리로 입력해주세요\")            continue        }                if answer[0] == answer [1] || answer[0] == answer [2] || answer[1] == answer [2] {            print(\"중복된 수가 존재 합니다. 다시 입력해주세요\")            continue        }            }    else { // if type is not Int        print(\"숫자가 아닌 값이 입력 되었습니다. 숫자만 입력해주세요\")1~9까지의 수였다면, 0~9까지의 수로 바뀌었다.그래서 for문을 통해 문제를 만들던것을 while로 바꿔 주었다.그래서 0번째 인덱스 즉 첫번째 수가 0이 되면 다시 반복하게 하였고, 길이가 3일때, 즉 3개의 수가 만들어 졌을때 false를 하여 while문을 빠져 나가게 했다.Lv4      프로그램을 시작할 때 안내문구를 보여주세요      // 예시  환영합니다! 원하시는 번호를 입력해주세요  1. 게임 시작하기  2. 게임 기록 보기  3. 종료하기            1번 게임 시작하기의 경우 “필수 구현 기능” 의 예시처럼 게임이 진행됩니다          정답을 맞혀 게임이 종료된 경우 위 안내문구를 다시 보여주세요          // 예시  환영합니다! 원하시는 번호를 입력해주세요  1. 게임 시작하기  2. 게임 기록 보기  3. 종료하기  1 // 1번 게임 시작하기 입력  &lt; 게임을 시작합니다 &gt;  숫자를 입력하세요  .  .  .      Lv5      2번 게임 기록 보기의 경우 완료한 게임들에 대해 시도 횟수를 보여줍니다      // 예시  환영합니다! 원하시는 번호를 입력해주세요  1. 게임 시작하기  2. 게임 기록 보기  3. 종료하기  2 // 2번 게임 기록 보기 입력  &lt; 게임 기록 보기 &gt;  1번째 게임 : 시도 횟수 - 14  2번째 게임 : 시도 횟수 - 9  3번째 게임 : 시도 횟수 - 12  .  .  .      Lv6  3번 종료하기의 경우 프로그램이 종료됩니다          이전의 게임 기록들도 초기화됩니다          // 예시  환영합니다! 원하시는 번호를 입력해주세요  1. 게임 시작하기  2. 게임 기록 보기  3. 종료하기  3 // 3번 종료하기 입력  &lt; 숫자 야구 게임을 종료합니다 &gt;            1, 2, 3 이외의 입력값에 대해서는 오류 메시지를 보여주세요      // 예시  환영합니다! 원하시는 번호를 입력해주세요  1. 게임 시작하기  2. 게임 기록 보기  3. 종료하기  4  올바른 숫자를 입력해주세요!      import Foundation// MARK: - Define Parametersvar numbers : [Int] = []var question : [Int] = []var answer : [Int] = []var scoreArray : [Int] = []var ballCount : [String : Int] = [:]var gameTitle : Bool = truevar gameStart : Bool = truevar gameMaking : Bool = truevar gameCount : Int = 0var scoreCount : Int = 0var strike : Int = 0var ball : Int = 0// MARK: - Making Questionfunc makeQuestion () -&gt; [Int] {    numbers = (0...9).map{$0} // for creating random numbers    question = [] // init array        while gameMaking {        var a = 0        a = numbers.randomElement()!        question.append(a)        numbers.remove(at:numbers.firstIndex(of: a)!) // to avoid duplicated numbers                if question[0] == 0 { // to avoid the first of number which is 0            question = [] // init array            continue        }                if question.count == 3 { // finishing making array            gameMaking = false        }    }        return question}// MARK: - Comparing answer and question &amp; Get ball countfunc getBallCount(_ question : [Int], _ answer : [Int]) -&gt; [String : Int]{        // init strike &amp; ball count    strike = 0    ball = 0    ballCount = [\"Strike\": 0, \"Ball\" : 0 ]        for i in question.indices {        for j in question.indices {            if i == j {                if answer[i] == question[j] { // same position                    strike += 1                }            } else {                if answer[i] == question[j] { // different position                    ball += 1                }            }        }    }        ballCount[\"Strike\"] = strike    ballCount[\"Ball\"] = ball        return ballCount}// MARK: - Game Logicfunc gamePart () {    while gameStart {                print(\"숫자를 입력해주세요.\")                print(question)                let input = Int(readLine()!) // to get user's answer                if let input = input { // if type is Int            answer = String(input).map{Int(String($0))!}                        if answer.count != 3 { // when count is not 3                print(\"3자리의 숫자가 아닙니다. 3자리로 입력해주세요\\n\")                scoreCount += 1 // count up                continue            }                        if answer[0] == answer [1] || answer[0] == answer [2] || answer[1] == answer [2] { // when duplicated numbers extist                print(\"중복된 수가 존재 합니다. 다시 입력해주세요\\n\")                scoreCount += 1 // count up                continue            }                    } else { // if type is not Int            print(\"숫자가 아닌 값이 입력 되었습니다. 숫자만 입력해주세요\\n\")            scoreCount += 1 // count up            continue        }                scoreCount += 1 // count up                ballCount = getBallCount(question, answer)                if ballCount[\"Strike\"] == 3 {            print(\"&lt;&lt;&lt;&lt;&lt;축하합니다 정답입니다&gt;&gt;&gt;&gt;&gt;.\\n\")            gameCount += 1            scoreArray.append(scoreCount)            gameStart = false        } else if strike == 0 &amp;&amp; ball == 0 {            print(\"Nothing\\n\")        } else {            print(\"현재 \\(ballCount[\"Strike\"] ?? 0) Strike \\(ballCount[\"Ball\"] ?? 0) Ball 입니다.\\n\")        }    }}// MARK: - Game Main Titlewhile gameTitle {        // init game logic    gameStart = true    gameMaking = true        scoreCount = 0        print(\"&lt;&lt;&lt;&lt;&lt;게임을 시작합니다&gt;&gt;&gt;&gt;&gt;\") // for notification when app starts    print(\"1. 게임 시작하기. 2. 게임 기록 보기 3. 종료하기\")        let titleInput = Int(readLine()!)        if let titleInput = titleInput { // if type is Int                if titleInput == 1 {                        question = makeQuestion() // Make question            gamePart() // game start                                } else if titleInput == 2 {                        if gameCount != 0 {                                print(\"&lt;게임 기록 보기&gt;\")                                for i in 0..&lt;gameCount {                    print(\"\\(i+1) 번째 게임, 시도 횟수 : \\(scoreArray[i])\")                }                print(\"\")                continue                            } else { // when user type 2, before starting game                print(\"게임 기록이 없습니다.\\n\")                continue            }                    } else if titleInput == 3 {            print(\"종료합니다\")            gameTitle = false                    } else { // except for 1,2,3            print(\"1, 2, 3 숫자만 입력하세요\\n\")        }            } else{ // if type is not Int        print(\"1, 2, 3 숫자만 입력하세요\\n\")    }}코드가 꽤 길어졌다 4~6은 나누는것보다 한번에 하는게 나을것같았다.ball strike 카운트를 고차함수로도 표현해 보았다.    answer.enumerated().map{$0}.forEach{        (aoffset, aelement) in question.enumerated().map{$0}.forEach{            (qoffset, qelement) in            if aoffset == qoffset {                if aelement == qelement {                    strike+=1                }            }else {                if aelement == qelement {                    ball+=1                }            }        }    }튜터님께 문의 결과 역시 가독성이나 이런부분에선 선호 받지 못하는듯하다.시간복잡도는 for문보다는 낫긴 하지만, 굳이 라는 생각이 든다.function으로 나누었는데, 클래스로 나누는것을 추천해주셔서 클래스로 한번 나눠봐야겠다."
  },
  
  {
    "title": "213. 모의고사",
    "url": "/posts/213.-%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-11 02:37:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ answers:[Int]) -&gt; [Int] {        var score : [Int] = []    var answer : [Int] = []         var arrA : [Int] = [1,2,3,4,5]    var arrB : [Int] = [2,1,2,3,2,4,2,5]...",
    "content": "import Foundationfunc solution(_ answers:[Int]) -&gt; [Int] {        var score : [Int] = []    var answer : [Int] = []         var arrA : [Int] = [1,2,3,4,5]    var arrB : [Int] = [2,1,2,3,2,4,2,5]    var arrC : [Int] = []        var scoreA : Int = 0    var scoreB : Int = 0    var scoreC : Int = 0        while arrA.count != 10000 {        arrA += [1,2,3,4,5]    }        while arrB.count != 10000 {        arrB += [2,1,2,3,2,4,2,5]    }        while arrC.count != 10000 {        arrC += [3,3,1,1,2,2,4,4,5,5]    }            scoreA = zip(arrA,answers).filter{$0==$1}.count    scoreB = zip(arrB,answers).filter{$0==$1}.count    scoreC = zip(arrC,answers).filter{$0==$1}.count        score.append(scoreA)    score.append(scoreB)    score.append(scoreC)        let max = score.max()        for i in 0..&lt;score.count{        if max == score[i]{            answer.append(i+1)        }    }    return answer}zip을 사용해보고자 이렇게 만들었다. 사실 효율성에선 좋지 못한 코드이다.굳이 안만들어도 되는 배열을 3개나 그것도 길이를 10000까지 만들기 때문이다.하지만 zip을 사용해서 풀고싶어서 이렇게 해보았다.제일 많이 맞춘사람만 뽑으면 되기에 max를 사용하였다."
  },
  
  {
    "title": "2주차 (2)",
    "url": "/posts/Main-campus_2nd-week-2/",
    "categories": "캠프, 2주차",
    "tags": "",
    "date": "2024-03-11 02:11:00 +0900",
    





    
    "snippet": "타입 캐스팅1. is  is 연산자는 타입을 체크하는 연산자로, 비교 결과를 bool 타입을 반환 (타입 체킹)let char: Character = \"A\" print(char is Character)// 출력값: trueprint(char is String)   // 출력값: false let bool: Bool = trueprint(bool is ...",
    "content": "타입 캐스팅1. is  is 연산자는 타입을 체크하는 연산자로, 비교 결과를 bool 타입을 반환 (타입 체킹)let char: Character = \"A\" print(char is Character)// 출력값: trueprint(char is String)   // 출력값: false let bool: Bool = trueprint(bool is Bool)     // 출력값: trueprint(bool is Character)// 출력값: false2. as, as!, as?1. as  as 연산자는 컴파일 단계에서 캐스팅이 실행됩니다. 따라서 항상 타입 캐스팅이 성공할 경우에만 사용할 수 있습니다.  캐스팅에 실패할 경우 에러가 발생합니다.  캐스팅하려는 타입이 같은 타입 이거나 수퍼클래스 타입이라는 것을 알 때 as 연사자를 사용합니다.    2.as?    as? 연산자는 런타임에 캐스팅이 실행됩니다.  성공하면 옵셔널 타입의 인스턴스를 반환하고 실패하면 nil 을 반환합니다.  실패할 가능성이 있으면 as?를 사용하는 것이 좋습니다.    3. as!    as! 연산자는 런타임에 특정 타입으로 강제 캐스팅합니다.  강제 타입 캐스팅에 실패할 경우 런타임 에러가 발생할 수 있습니다.  캐스팅에 성공한 경우 인스턴스를 반환합니다.(옵셔널 x)class Person {    var id = 0    var name = \"name\"    var email = \"hgk@gmail.com\"}class Worker: Person {    // id    // name    // email    var salary = 300}class Programmer: Worker {    // id    // name    // email    // salary    var lang = \"Swift\"}// 업캐스팅 - aslet person1 = Person()let worker1 = Worker()let programmer1 = Programmer()let personList = [person1, worker1, programmer1] // 타입을 선언하지 않았지만 Person 타입으로 인식 -&gt; 즉 업캐스팅이 되었음personList[1].name//personList[1].salary // Person 타입으로 보고 있기 때문에 salary에 접근하지 못함let worker2 = Worker()worker2.salarylet workerPerson = worker2 as Person// workerPerson.salary // Person 타입으로 보고 있기 때문에 salary에 접근하지 못함// Worker클래스를 인스턴스화 하였어도, as를 통해 업캐스팅을 했으므로 Person이다.print(type(of:workerPerson)) // Worker// 타입을 출력하게되면 Worker로 나오긴 하므로 주의하자.// 다운캐스팅 - as? / as!// as?let pro = programmer1 as? Programmer // 타입 변환이 될 수도 있고 안될 수도 있기 때문에 옵셔널을 리턴if let person2 = programmer1 as? Programmer {    person2.lang}if let person3 = worker1 as? Programmer {    person3.lang }// person3은 현재 더 높은 캐스팅이 되어있는 상태이다. 그러므로 그 하위인 down Casting은 안된다.// as!let pro2 = worker2 as! Programmer // Error : 타입 변환 실패시 오류"
  },
  
  {
    "title": "ByteCoin (1)",
    "url": "/posts/ByteCoin-(1)/",
    "categories": "Udemy, Clima",
    "tags": "",
    "date": "2024-03-10 13:54:00 +0900",
    





    
    "snippet": "디자인은 생략이라, git clone 이후 부터 시작하겠다.이번엔 특별히 git 협업 글을 생각해서 맥북과 맥미니 번갈아 가면서 코드를 작성해보려고 한다.IBOutlet 만들기import UIKitclass ViewController: UIViewController {            @IBOutlet weak var bitcoinLabel: UI...",
    "content": "디자인은 생략이라, git clone 이후 부터 시작하겠다.이번엔 특별히 git 협업 글을 생각해서 맥북과 맥미니 번갈아 가면서 코드를 작성해보려고 한다.IBOutlet 만들기import UIKitclass ViewController: UIViewController {            @IBOutlet weak var bitcoinLabel: UILabel!        @IBOutlet weak var currencyLabel: UILabel!        @IBOutlet weak var currencyPicker: UIPickerView!        override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.    }}UIpickerView를 사용하기위해 protocol 채택하기.채택하면 에러가 발생한다.관렴 함수를 안써서 나오는 에러이다. 일단은 다음과 같이 작성해주자func numberOfComponents(in pickerView: UIPickerView) -&gt; Int {        return 1    }    func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int {        return CoinManager.currencyArray.count    }numberOfComponents : picker view에 사용된 컴포넌트의 개수를 가져온다.API Request 구현하기어떻게 json으로 가져오나 확인해보았다.https://rest.coinapi.io/v1/exchangerate/BTC/USD?apikey= 이런식으로 되었다.다음과 같이 출력이 되는 것을 확인했다."
  },
  
  {
    "title": "2주차 (1)",
    "url": "/posts/main-campus_2nd-week-1/",
    "categories": "캠프, 2주차",
    "tags": "",
    "date": "2024-03-10 02:11:00 +0900",
    





    
    "snippet": "1. 프로퍼티 옵저버  변수에 프로퍼티 옵저버를 정의하여 프로퍼티 값의 변경 사항을 모니터링하고, 미리 구현한 코드로 이에 대응할 수 있다.  다시 말하면 해당 프로퍼티를 관찰(observe)하면서 변경 사항이 발생할 때 실행된다  willSet보다는 didSet이 많이 사용된다  willSet과 didSet을 둘 다 작성했을 경우 willSet이 먼...",
    "content": "1. 프로퍼티 옵저버  변수에 프로퍼티 옵저버를 정의하여 프로퍼티 값의 변경 사항을 모니터링하고, 미리 구현한 코드로 이에 대응할 수 있다.  다시 말하면 해당 프로퍼티를 관찰(observe)하면서 변경 사항이 발생할 때 실행된다  willSet보다는 didSet이 많이 사용된다  willSet과 didSet을 둘 다 작성했을 경우 willSet이 먼저 실행\u001f다  추가할 수있는 경우          저장 프로퍼티(stored property)      연산 프로퍼티(computed property)        didSet          새 값이 저장된 직후에 호출된다.      이전 프로퍼티의 값이 oldValue 로 제공된다.        willSet          값이 저장되기 직전에 호출된다.      새로운 프로퍼티의 값이 newValue 로 제공된다.      var myProperty: Int = 20{   didSet(oldVal){      //myProperty의 값이 변경된 직후에 호출, oldVal은 변경 전 myProperty의 값   }   willSet(newVal){      //myProperty의 값이 변경되기 직전에 호출, newVal은 변경 될 새로운 값   }}var name: String = \"Unknown\" {    willSet {        print(\"현재 이름 = \\(name), 바뀔 이름 = \\(newValue)\")    }    didSet {        print(\"현재 이름 = \\(name), 바뀌기 전 이름 = \\(oldValue)\")    }} name = \"Peter\"// willSet이 먼저 실행됨// 현재 이름 = Unknown, 바뀔 이름 = Peter// 현재 이름 = Peter, 바뀌기 전 이름 = Unknownclass UserAccount {    var username: String    var password: String    var loginAttempts: Int = 0 {        didSet {            if loginAttempts &gt;= 3 {                print(\"로그인 시도가 3회 이상 실패하였습니다. 계정이 잠겼습니다.\")                lockAccount()            }        }    }        var isLocked: Bool = false {        didSet {            if isLocked {                print(\"계정이 잠겼습니다.\")            } else {                print(\"계정이 잠금 해제되었습니다.\")            }        }    }        init(username: String, password: String) {        self.username = username        self.password = password    }        func login(with enteredPassword: String) {        if enteredPassword == password {            print(\"로그인 성공!\")            loginAttempts = 0 // 로그인 성공 시 로그인 시도 횟수 초기화        } else {            print(\"잘못된 비밀번호입니다.\")            loginAttempts += 1 // 로그인 실패 시 로그인 시도 횟수 증가        }    }        private func lockAccount() {        isLocked = true    }        func unlockAccount() {        isLocked = false    }}// 사용자 계정 생성let user = UserAccount(username: \"user123\", password: \"password123\")// 로그인 시도user.login(with: \"wrongpassword\") // 출력:// 잘못된 비밀번호입니다.user.login(with: \"wrongpassword\") // 출력:// 잘못된 비밀번호입니다.user.login(with: \"wrongpassword\") // 출력:// 잘못된 비밀번호입니다.// 로그인 시도가 3회 이상 실패하였습니다. 계정이 잠겼습니다.// 계정이 잠겼습니다.// 계정 잠금 해제user.unlockAccount() // 계정이 잠금 해제되었습니다."
  },
  
  {
    "title": "212. 삼총사",
    "url": "/posts/212.-%EC%82%BC%EC%B4%9D%EC%82%AC/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-09 13:37:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ number:[Int]) -&gt; Int {            var answer : Int = 0        for i in 0..&lt;number.count-2 {        for j in i+1..&lt;number.count-1 {            for k in j+1....",
    "content": "import Foundationfunc solution(_ number:[Int]) -&gt; Int {            var answer : Int = 0        for i in 0..&lt;number.count-2 {        for j in i+1..&lt;number.count-1 {            for k in j+1..&lt;number.count {                if number[i]+number[j]+number[k] == 0 {                    answer += 1                }            }        }    }            return answer}두개 뽑아서 더하기 문제와 비슷한 방식으로 풀었다.딱히 후술할게 없다."
  },
  
  {
    "title": "211. 문자열 내 마음대로 정렬하기 (ing)",
    "url": "/posts/211.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4-%EB%A7%88%EC%9D%8C%EB%8C%80%EB%A1%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-09 13:37:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "210. K번째수",
    "url": "/posts/210.-K%EB%B2%88%EC%A7%B8%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-09 13:09:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ array:[Int], _ commands:[[Int]]) -&gt; [Int] {        var answer : [Int] = []    var arr : [Int] = []        for i in 0..&lt;commands.count {        arr = array[(co...",
    "content": "import Foundationfunc solution(_ array:[Int], _ commands:[[Int]]) -&gt; [Int] {        var answer : [Int] = []    var arr : [Int] = []        for i in 0..&lt;commands.count {        arr = array[(commands[i][0]-1)...(commands[i][1]-1)].sorted()        answer.append(arr[commands[i][2]-1])    }               return answer}새로운 배열을 하나 만들어서 commands 배열 조건에 맞는 숫자 범위로 해서 값을 넣었다.commands안에 있는 번째는 1을 처음부터 하기에, 우리가 사용하는 인덱스의 개념과 달라 -1을 해주었다."
  },
  
  {
    "title": "209. 두 개 뽑아서 더하기",
    "url": "/posts/209.-%EB%91%90-%EA%B0%9C-%EB%BD%91%EC%95%84%EC%84%9C-%EB%8D%94%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-09 13:09:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ numbers:[Int]) -&gt; [Int] {        var arr = Set&lt;Int&gt;()    var answer : [Int] = []        for i in 0..&lt;numbers.count-1 {        for j in i+1..&lt;numbers....",
    "content": "import Foundationfunc solution(_ numbers:[Int]) -&gt; [Int] {        var arr = Set&lt;Int&gt;()    var answer : [Int] = []        for i in 0..&lt;numbers.count-1 {        for j in i+1..&lt;numbers.count {            arr.insert(numbers[i]+numbers[j])        }    }        answer = arr.map{$0}.sorted()        return answer}for문을 사용하였고, 중복값을 제거하기 위해서 우선 Set을 사용해 집어넣었다.첫번째 for문은 마지막값 전까지 들어가야 하고 두번째 포문은 i부터 마지막까지 하게 하였다.그리고나서 문제에션 set이 아닌 array를 리턴해야 하므로, 배열을 만들었다"
  },
  
  {
    "title": "Clima (6)",
    "url": "/posts/Clima-(6)/",
    "categories": "Udemy, Clima",
    "tags": "API, Networking",
    "date": "2024-03-08 21:54:00 +0900",
    





    
    "snippet": "extionsion을 사용하여 기능을 별도로 부여하기.제일 하단에 만들어보자!extension WeatherViewController : UITextFieldDelegate {    }그리고 UITextFieldDelegate와 관련된 함수들을 모~두 extension안에 넣어준다!관련된 함수를 어떻게 구별하는가?기능적인 측면에서 생각을 해서 구별하였...",
    "content": "extionsion을 사용하여 기능을 별도로 부여하기.제일 하단에 만들어보자!extension WeatherViewController : UITextFieldDelegate {    }그리고 UITextFieldDelegate와 관련된 함수들을 모~두 extension안에 넣어준다!관련된 함수를 어떻게 구별하는가?기능적인 측면에서 생각을 해서 구별하였다. 그게 맞나 애매할땐override func viewDidLoad() {        super.viewDidLoad()                weatherManager.delegate = self        searchTextField.delegate = self    }이 위임자가 어떻게 되어있는지를 보고 좀 추론해서 정리하기도 했다.이렇게 extension에 옮겨주니 다음과 같은 에러가 발생한다뭐 간단하게 이야기하면 중복사용 했다는 것이다.class로 올라가서 UITextFieldDelegate를 지워주자.그럼 에러가 말끔하게 사라진다.WeatherViewController가 extension에 UITextFieldDelegate를 사용하고 있기에 class에 있는것을 지워도 괜찮다!그래서 중복사용이라고 떴던것이다.extension WeatherViewController : UITextFieldDelegate {        @IBAction func searchPressed(_ sender: UIButton) {        searchTextField.endEditing(true)        print(searchTextField.text!)    }        func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {        searchTextField.endEditing(true)        print(searchTextField.text!)        return true    }        func textFieldShouldEndEditing(_ textField: UITextField) -&gt; Bool {        if textField.text != \"\" {            return true        } else {            textField.placeholder = \"Type something Here\"            return false        }    }        func textFieldDidEndEditing(_ textField: UITextField) {                if let city = searchTextField.text {            weatherManager.fetchWeather(cityName: city)        }                //Use searchTextField.text to get the weather for that city        searchTextField.text = \"\"    }}그럼 이와 똑같은 방법으로 WeatherManagerDelegate도 해보자extension WeatherViewController : WeatherManagerDelegate {    func didUpdateWeather(_ weatherManager:WeatherManager, weather : WeatherModel) {        DispatchQueue.main.async{            self.temperatureLabel.text = weather.temperatureString            self.conditionImageView.image = UIImage(systemName: weather.conditionName)        }    }        func didFailWithError(error: Error) {        print(error)    }}GPS기능을 사용해 현재 위치 리턴우선 해당기능을 사용하기 위해선 Apple이 개발한 CoreLocation을 가져와야한다.즉, import 해야한다는 것이다.해보자import CoreLocation그리고 CoreLocationManager를 인스턴스화 한다.let locationManager = CLLocationManager()이 매니저가 현재 휴대폰의 현재 gps위치를 알려주는 역할을 한다.그전에 먼저 트리거 해준다!delegate와 마찬가지!locationManager.requestWhenInUseAuthorization()항상 내 위치를 허용하는건 안되니 내가 필요로 사용할때만 값을 가져오게 해야하기 때문이다.그리고 이것으로 끝난게 아니다.Info.plist를 확인하자.보명 위와 같이 되어있는데, 여러 Key : Value 형식으로 되어 있다.이 값들이 앱의 기본 설정을 결정한다!새로 값을 하나 만들어 주어야하고, 쭉 내리다보면Privacy - Location When In Use Usage Description 항목이 있다. 이걸 추가해주자!value에는 다음과 같이 적었다.We need your location to get the current weather for where you are.우리가 이 정보가 왜 필요한지에대한 설명을 해주는 것이다.실행을 해보면?앱을 키자마자 우리가 어느 어플에서나 현위치를 확인할때 물어보던 그 창이 뜬다!그리고 우리가 적었던 We need your location to get the current weather for where you are.이 멘트도 보인다.앱을 테스트 할때는 항상 허용으로 해두도록 하자.그렇지 않으면 또 이리저리 설정을 해야해서 복잡해진다..그렇게 유져의 동의를 얻었다면?다시 코드로 돌아가서locationManager.requestWhenInUseAuthorization() 다음에 추가로 locationManager.requestLocation() 을 적어주자.이녀석은 유져의 위치를 일회성으로 제공한다.그런데 네비게이션 앱처럼 실시간으로 위치를 요청하려면?locationManager.startUpdatingLocation() 이걸 사용한다.그렇다면 requestLocation을 사용했는데 위치를 어떻게 알아낼까?무슨 말이냐 하면, 리턴하는것이 없다?그럼 우리가 사용하는 어플들은 어떻게 위치를 조회했던걸까?방법이 있다.그 아래를 잘 보면 locationManager(_:didUpdateLocations) 메서드를 사용하면된다.해당 메서드는 다음과 같다optional func locationManager(    _ manager: CLLocationManager,    didUpdateLocations locations: [CLLocation])parameters      manager : The location manager object that generated the update event.        locations : An array of CLLocation objects containing the location data. This array always contains at least one object representing the current location. If updates were deferred or if multiple locations arrived before they could be delivered, the array may contain additional entries. The objects in the array are organized in the order in which they occurred. Therefore, the most recent location update is at the end of the array.  Challenge : 현위치를 출력하게 기능을 구현해보자.  강의에서 extension 사용을 해보라고 하였다.extension을 사용하라는건 즉 프로토콜이 있다는 말인데, 옵션키를 누르면서 이것저것 메서드에 대해 눌러봤다.CLLocationManager 에 대해 좀 읽어보던중 이 부분을 발견했다.역시 프로토콜이 존재했다.extension에 함수만 넣고 실행만 해봤는데 바로 팅겨버린다?extension WeatherViewController : CLLocationManagerDelegate {        func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {        if let location = locations.first {            print(location)        }    }    }안에 코드 구성은 구글링을 해서 작성했다.우선은 내힘으로 해봐야하기에 이것저것 검색을 좀 해봤다.Delegate가 더 먼저 호출이 되어야 했다.override func viewDidLoad() {        super.viewDidLoad()                       weatherManager.delegate = self        searchTextField.delegate = self        locationManager.delegate = self                locationManager.requestWhenInUseAuthorization()        locationManager.requestLocation()                    }그래서 이렇게 위에 먼저 호출하게 하였다.그리고 실행을 해봤다.또 팅긴다.이번엔 해당 함수가 없어서 그런것같다. 함수를 추가해보자…extension WeatherViewController : CLLocationManagerDelegate {        func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {        if let location = locations.first {            print(location)        }    }        func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {        print(error)    }    }그리고 실행을 해보자.일단은 출력이 된다.강의에선 이렇게 했다extension WeatherViewController : CLLocationManagerDelegate {         }우선 extension을 통해 CLLocationManagerDelegate을 채택했다.그리고 똑같이 함수를 적었다.extension WeatherViewController : CLLocationManagerDelegate {        func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {        print(\"Got location data\")    }        }그리고 내가 간과했던것 콕 찝어주었다.좀 제대로 읽어볼걸 그랬다…역시나 강의에서도 delegate의 순서를 말해주었다.override func viewDidLoad() {        super.viewDidLoad()                        locationManager.delegate = self        locationManager.requestWhenInUseAuthorization()        locationManager.requestLocation()        weatherManager.delegate = self        searchTextField.delegate = self            }그리고 위의 밑줄친대로 didFailWithError 이것도 구현해주자.extension WeatherViewController : CLLocationManagerDelegate {        func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {        print(\"Got location data\")    }        func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {        print(error)    }}실행하니 잘 나왔다.이렇게 출력만 하게 하는것이었나보다…내가 조금 더 찾아보고 하긴 했지만 강의 흐름을 따라 다시 적어본다.이제 위도 경도 이런정보를 출력해보자CLLocation 배열에서 제일 마지막 값을 호출하면 가장 정확한 값이 나올것이다. - 이부분은 좀더 찾아보고 정리해야할듯하다.다음과 같은 경고가 뜬다?타입을 보니 옵셔널이다. 일단 옵셔널 바인딩을 해주자.그리고 위도와 경도를 출력하게 해보았다.extension WeatherViewController : CLLocationManagerDelegate {        func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {        if let location = locations.last {            let lat = location.coordinate.latitude            let lon = location.coordinate.longitude            print(lat)            print(lon)        }    }        func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {        print(error)    }}실행해보니 잘나온다.혹시라도 location을 테스트 해보고싶다면?이걸 사용해보자.그리고 현재 이 변수들은 api의 JSON과 같은 변수명을 사용했다.우선 weatherURL을 복사하자.그리고 https://api.openweathermap.org/data/2.5/weather?appid=b5005bab606b11d2b82b3dae1b2bc221&amp;units=metric&amp;lat=51&amp;lon=-0.1이렇게 뒤에 &amp;를 붙여서 lat과 lon을 이용하여 테스트를 해보니날씨 값이 나온다.즉 우린 저걸 이용해서 현재 받은 좌표를 주소에 넘길것이다.즉func fetchWeather (cityName : String) {        let urlString = \"\\(weatherURL)&amp;q=\\(cityName)\"        performRequest(with: urlString)    }이 함수를 다듬어 주면 된다.한번 해보자.Challenge : 새로추가한 코드가 작동이 되게 해보자extension WeatherViewController : CLLocationManagerDelegate {        func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {        if let location = locations.last {            let lat = location.coordinate.latitude            let lon = location.coordinate.longitude            weatherManager.fetchWeather(latitude: lat, longitude: lon) // new        }    }        func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {        print(error)    }}우선 필요한값을 모델에 만들어준다.struct WeatherModel {        let conditionId : Int    let cityName : String    let temperature : Double    let latitude : Double    let longitude : Double그리고 weatherData에도 필요한값을 만들어 주었다.여기엔 json과 변수를 맞춰주어야한다.struct WeatherData : Codable {    let name : String    let main : Main    let weather : [Weather]    let coord : coord //new}struct Main : Codable {    let temp : Double}struct Weather : Codable {    let description : String    let id : Int}struct coord : Codable { //new    let lon : Double    let lat : Double}그리고 JSON 값을 가지고오는 코드 부분을 수정해주었다.func parseJSON(_ weatherData: Data) -&gt; WeatherModel? {        let decoder = JSONDecoder()        do {            let decodedData = try decoder.decode(WeatherData.self, from: weatherData)            let id = decodedData.weather[0].id            let temp = decodedData.main.temp            let name = decodedData.name            let lat = decodedData.coord.lat //new            let lon = decodedData.coord.lon //new                                    let weather = WeatherModel(conditionId: id, cityName: name, temperature: temp, latitude: lat, longitude: lon) // modified            return weather                        print(weather.temperatureString)        } catch { // JSON Decoder Fail            delegate?.didFailWithError(error: error)            return nil        }            }그리고 함수이름은 같지만 파라미터가 다르게 하여 다음과 같이 만들었다.func fetchWeather (latitude: Double, longitude: Double) { //new        let urlString = \"\\(weatherURL)&amp;lat=\\(latitude)&amp;lon=\\(longitude)\"        performRequest(with: urlString)    }    func fetchWeather (cityName : String ) {        let urlString = \"\\(weatherURL)&amp;q=\\(cityName)\"        performRequest(with: urlString)    }실행해보았다.좀 딜레이가 있지만 된다!강의와 비교해보자func fetchWeather (latitude: CLLocationDegrees, longitude: CLLocationDegrees) {        let urlString = \"\\(weatherURL)&amp;lat=\\(latitude)&amp;lon=\\(longitude)\"        performRequest(with: urlString)    }이것만 했다.생각해보니. 저 json에서 가져올 필요가 전혀없었다.왜냐하면 저 json은 우리가 도시를 검색할때 쓰기 때문이다 ㅠ아 멍청했다.Challenge 이젠 도시명이 나오게 하고 좌측 상단 버튼을 눌렀을때 현재 위치가 나오게 해보자!우선 이부분에서 label이 업데이트 되도록 해보려고 했다extension WeatherViewController : WeatherManagerDelegate {    func didUpdateWeather(_ weatherManager:WeatherManager, weather : WeatherModel) {        DispatchQueue.main.async{            self.temperatureLabel.text = weather.temperatureString            self.conditionImageView.image = UIImage(systemName: weather.conditionName)            self.cityLabel.text = weather.cityName // new        }    }        func didFailWithError(error: Error) {        print(error)    }}추가하니 잘된다.그리고 IBAction을 만들고@IBAction func locationPressed(_ sender: UIButton) {        locationManager.requestLocation()    }다음과 같이 위치만 요청하게 했다.extension WeatherViewController : CLLocationManagerDelegate {        func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {        if let location = locations.last {            locationManager.startUpdatingLocation() //new            let lat = location.coordinate.latitude            let lon = location.coordinate.longitude            weatherManager.fetchWeather(latitude: lat, longitude: lon)        }    }        func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {        print(error)    }}startUpdatingLocation()를 통해 작동할때마다, 현재 위치를 업데이트 하게 해준다.현재 문제점이라면, simulator에서 원래는 현위치로 받다가, debug로 위치를 임의대로 설정 할 수 있다고 했는데,그 이후로 현위치 설정이 이상하게 안된다…현위치를 가져오면서 자꾸만 다음과 같은 에러가 콘솔에 나오기 시작했다.일단 여러모로 해보고있지만 안되고 있다….공기계를 하나 구해서 현위치 테스트를 하니 잘된다.근데 Seolman 어디냐?경도 위도로 찾아보니 얼추 근처로 나오긴하는데 처음보는 지명이다."
  },
  
  {
    "title": "Clima (5)",
    "url": "/posts/Clima-(5)/",
    "categories": "Udemy, Clima",
    "tags": "API, Networking",
    "date": "2024-03-08 15:21:00 +0900",
    





    
    "snippet": "파라미터 수정과 프로토콜현재 이렇게 함수가 되어있는데, _ 를 사용하여 value만 입력하게 해보자func didUpdateWeather(weather : WeatherModel) {        print(weather.temperature)    }그리고 이 함수가 근본적으로 어디서 왔는지? 를 함수안의 변수에 명시를 해준다.이 함수는 잘 생각 해...",
    "content": "파라미터 수정과 프로토콜현재 이렇게 함수가 되어있는데, _ 를 사용하여 value만 입력하게 해보자func didUpdateWeather(weather : WeatherModel) {        print(weather.temperature)    }그리고 이 함수가 근본적으로 어디서 왔는지? 를 함수안의 변수에 명시를 해준다.이 함수는 잘 생각 해보면?protocol WeatherManagerDelegate{    func didUpdateWeather(weather : WeatherModel)}이 프로토콜에서 왔다!그리고 이 대리자(delegate)를 발생시킨 개체는?struct WeatherManager {    // 기타 코드 생략.        var delegate : WeatherManagerDelegate?여기서 발생시켰다.즉 우리는 다시 didupdateWeather로 돌아가서 파라미터에 그 delegate를 발생시킨 개체, 즉 정체성을 부여해준다.func didUpdateWeather(_ weatherManager:WeatherManager, weather : WeatherModel) {        print(weather.temperature)   }함수의 내역을 수정했으니 다시 프로토콜로 돌아가서 변수를 다음과 같이 바꿔주자!지금은 역순으로 프로토콜의 구성을 해보았다.protocol WeatherManagerDelegate{    func didUpdateWeather(_ weatherManager:WeatherManager, weather : WeatherModel)}즉 프로토콜을 구현할때는 다음과 같이 한다.protocol myProtocol {    func myFunc (_ delegate발생시킨개체, 일반적으로 사용하는 매개변수와 타입)}이것을 생각해서 위의 프로토콜과 내용을 다시 정리한다면?  weatherManager:WeatherManager : delegate 발생시킨 개체          var delegate : WeatherManagerDelegate?        weather : WeatherModel : 실제로 우리가 사용할 변수, 타입이렇게 되는 것이다.구글링을 좀 해보니 일반적으로는 이런식으로 프로토콜을 사용하여 코드를 구현하는것 같다.      프로토콜 구현        일을시킬 컨트롤러에 delegate 선언 (우리는 구조체로 했다.)        일을할 컨트롤러를 대리자로 설정        할 일을 지시        지시 받은 동작을 대리자에서 대신 처리하기  그렇다면 위의 순서를 현재까지 내가 한 내용에 접목을 시켜 보자물론 우리는 공부를 하고 있는 입장이라 역순으로 갔지만, 이렇게 대입을 해보는것도 나쁘지 않다는 생각이 들었다.  프로토콜 구현protocol WeatherManagerDelegate{    func didUpdateWeather(_ weatherManager:WeatherManager, weather : WeatherModel)}  일을시킬 컨트롤러에 delegate 선언 (우리는 구조체로 했다.)struct WeatherManager {    var delegate : WeatherManagerDelegate?}      일을할 컨트롤러를 대리자로 설정// WeatherViewController override func viewDidLoad() {    weatherManager.delegate = self }  할 일을 지시func performRequest(urlString : String){        if let url = URL(string: urlString) {            let session = URLSession(configuration: .default)            let task = session.dataTask(with: url) { (data, response, error) in                if error != nil { // 에러가 발생하면 출력                    print(error!)                    return // 여기선 return을 사용하면 함수를 빠져나가 아무것도 하지말라는 것이다                }                                if let safeData = data {                    if let weather = self.parseJSON(weatherData: safeData) {                        self.delegate?.didUpdateWeather(self, weather: weather)                                            }                }            }                        task.resume()        }    }  지시 받은 동작을 대리자에서 대신 처리하기    func didUpdateWeather(_ weatherManager:WeatherManager, weather : WeatherModel) {     print(weather.temperature) }      이렇게 되는 것이다!이렇게 정리를 하고 나니 뭔가 좀 전체적인 흐름이 이해가 갔다!현재 정리한 부분에 미리 self로 하나를 적어놨는데 그부분부터 시작하겠다.다시 돌아가서,if let safeData = data {     if let weather = self.parseJSON(weatherData: safeData) {             self.delegate?.didUpdateWeather(weather: weather)              }     }다음과 같이 에러가 난다왜냐 우린 프로토콜을 다음과 같이 정의 했기 때문이다protocol WeatherManagerDelegate{    func didUpdateWeather(_ weatherManager:WeatherManager, weather : WeatherModel)}현재 weatherManager가 빠져있는 걸 알 수 있다. fix를 눌러보면?위와 같이 된다.현재 WeatherManager에서 작성하고 있으므로, 그자신이니까 self로 해주자!에러가 수정되었다.에러를 다룰 함수 만들기protocol WeatherManagerDelegate{    func didUpdateWeather(_ weatherManager:WeatherManager, weather : WeatherModel)    func didFailWithError (error: Error)}다음과 같이 프로토콜에 함수를 하나 만들어주자!이 함수는if error != nil {             print(error!)             return            }이 부분을 다룰 목적으로 만들어졌다.print대신 delegate를 써서 위임을 해보도록 하자.if error != nil { // 에러가 발생하면 출력               self.delegate?.didFailWithError(error: error!)                return // 여기선 return을 사용하면 함수를 빠져나가 아무것도 하지말라는 것이다                }역시나 클로저 안이기에 self를 작성해주자.그리고 또한 parseJSON에서도 catch 구문이 바로 에러가 발생할때인데, 이때도 delegate에 위임을 하도록 해보자.catch {       delegate?.didFailWithError(error: error)        return nil        }Weather뷰 컨트롤러에서 에러가 치고있다우리가 만든 WeatherManagerDelegate 프로토콜을 준수하는데함수가 새로 생겼는데 현재 여기엔 없으니 프로토콜을 준수하지 않아 발생하는 에러이다.이제 에러가 발생하지 않게 함수를 만들어 주자.func didFailWithError(error: Error) {        print(error)    }가장 쉬운방법은 이렇게 에러를 프린트 하는 것이다.하지만 어떤 오류가 발생하느냐에 따라 그걸 사용자에게 알려줘야할 필요가 있다!여기선 네트워크 에러와, JSON Decoder 작동 실패 이렇게 두가지로 나뉜다.실시간 데이터 업데이트 해보기 (dispatchQueue)이제 뷰 컨트롤러로 돌아가서 데이터를 업데이트할 준비를 해보자.실제로 데이터 업데이트를 담당할 함수는 이녀석이다.func didUpdateWeather(_ weatherManager:WeatherManager, weather : WeatherModel) {        print(weather.temperature)    }우리는 여태 작동확인을 위해 print를 사용해 콘솔로 출력을 하였지만,이번에는 label 바꾸도록 해보자! func didUpdateWeather(_ weatherManager:WeatherManager, weather : WeatherModel) {        temperatureLabel.text = weather.temperatureString    }이렇게 작성해주었다.그러면 바뀌는지 확인을 해보자?? 안된다.. 그리고 팅겨버렸다.팅겼다는것 뭔가 충돌이 발생했다는건데 뭐가 문제일까분명히 temperature 값을 프린트 할때는 잘만 넘어갔는데??console에러도 엄청 길고, 새로운 창도 뜬다.일단 뷰컨트롤러에 뜬 저 보라색 메세지 부터 확인을 해보자.UiLabel은 반드시 메인스레드에서만 사용하라고 나온다.현재는 관련된 documents가 삭제가 되었나보다…강의의 내용을 좀 번역해서 정리를 해본다면,네트워킹같이 오래걸리는 일은 종종 background에서 실행이 된다. 그래서 보통 UI를 막지 않는다.그렇지 않으면 유져가 어떤 버튼을 눌러 조작을 하여 앱과 상호작용을 하기 전에 과정이 끝날때 까지 기다린다.그러면 해당 어플은 뭔가 정지된 것 처럼 보일것이다.삭제되기전 documents의 문제가 되는 상황은 바로 이거였다. 그리고 글의 원문도 같이 적는다  Updating UI from a Completion Handler      Long-running tasks such as networking are often executed in the background, and provide a completion handler to signal completion. Attempting to read or update the UI from a completion handler may cause problems.  let task = URLSession.shared.dataTask(with: url){ (data, response, error) in    if let data = data {        self.label.text = \"\\(data.count) bytes downloaded.\"        // Error : label updated on background thread    }}task.resume()이 문제애 대한 솔루션은 이거였다.  Solution      Dispatch the call to update the label text to the main thread  let task = URLSession.shared.dataTask(with: url){ (data, response, error) in    if let data = data {        DispatchQueue.main.async { // Correct        self.label.text = \"\\(data.count) bytes downloaded.\"        }    }}task.resume()즉, 요소를 업데이트 할 경우, 백그라운드에서 사용자 인터페이스를 업데이트 하기 위해 Main thread를 호출해야 한다는 것이다.그렇다면 삭제된 Docs이긴 하지만 해당내용을 바탕으로 수정을 해보자!func didUpdateWeather(_ weatherManager:WeatherManager, weather : WeatherModel) {        DispatchQueue.main.async{            self.temperatureLabel.text = weather.temperatureString        }    }이제 다시 실행해보자.아주 잘 된다.아까 에러났을때 화면을 터치해보니, 즉 클릭을 해보니 온도가 바뀌었는데, 위의 내용을 알고나니 왜 그랬나 이해가 조금은 간다.이 기세를 이어나가 우린 이제 기상조건을 id값으로 받고, swich-case문을 통해 어떤 symbol 이 리턴 되는지 알고있다.이미지도 바뀌게 해보자!self.conditionImageView.image = UIImage(systemName: weather.conditionName)이부분을 추가해 주었다.imageView의 이미지는 UIImage type이어야 하는데,이때 우리가 만든 conditionName이 바로 systemName에 들어가는 항목이다!그럼 이제 도시명을 바꾸면 되지만!처음에 나오는 현재 장치의 위치에 따라 다르게 나오기 할것이기 때문에 잠시 보류하도록 하겠다."
  },
  
  {
    "title": "(Deep Dive) Parameter Names",
    "url": "/posts/(Deep-Dive)-Parameter-Names/",
    "categories": "Udemy, Deep Dive",
    "tags": "",
    "date": "2024-03-08 14:52:00 +0900",
    





    
    "snippet": "Swift에서는 기능을 명확히 설명하는 이름의 매개변수가 중요하다!그리고 Swift 메서드와 함수의 기능은 Swift 매개 변수 이름의 특정 기능에 의존을 하는데,일반적으로 우리는 이렇게 사용을 하지만func myFunc(name : DataType) {    print(name)}이렇게 외부와 내부 변수이름을 분리 할 수 있다.func myFunc(...",
    "content": "Swift에서는 기능을 명확히 설명하는 이름의 매개변수가 중요하다!그리고 Swift 메서드와 함수의 기능은 Swift 매개 변수 이름의 특정 기능에 의존을 하는데,일반적으로 우리는 이렇게 사용을 하지만func myFunc(name : DataType) {    print(name)}이렇게 외부와 내부 변수이름을 분리 할 수 있다.func myFunc(name    eman: DataType) {//          ----    ----    //        external internal    print(eman)}내부가 우리가 보통 함수안에서 매개변수를 사용할때의 그 매개변수이다.그리고 우리가 함수를 호출을 한다면?myFunc(name: value)이런식으로 할 것이다.이때 name이 바로 외부 변수 이름이다.그리고, 외부 변수명을 사용하고 싶지 않고, 함수를 호출하고 바로 value를 입력하고 싶다면?즉, myFunc(value)로 하고 싶다면?처음에 함수를 만들때 나도 변수명을 생략하고 싶은데 왜 나는 안될까? 라고 공부를 해본사람이라면 다들 겪었을 경험이다.이제 그 해답을 찾아보자.해답은 바로 ?  _ 를 내부변수 앞에 붙여주면 된다.그럼 한번 만들어 보자func myFunc(_ eman: DataType) {    print(eman)}뭔가 저 형식이 낯이 익다?그렇다. 보통 우리가 코딩테스트 문제를 풀때 많이 봤을 그 부분이다.func solution(_ a:Int, _ b:Int) -&gt; String {}여기서도 외부변수 명이 들어갈 자리에 _이 있다.이렇게 _ 를 사용하면 이제 우리가 함수를 호출해도 값만 넣으면 되니 훨씬 편해진다."
  },
  
  {
    "title": "(Deep Dive) Extensions",
    "url": "/posts/(Deep-Dive)-Extensions/",
    "categories": "Udemy, Deep Dive",
    "tags": "",
    "date": "2024-03-08 14:52:00 +0900",
    





    
    "snippet": "Extensions는 본질적으로 기존클래스, 구조, 기타데이터유형에 추가 기능을 추가 할 수 있게 한다.기본형태는 다음과 같다extension SomeType {    // new functionality}우리가 늘상 만드는 것과 형태가 다르지 않다.그저 앞에 class, protocol, struct 대신 extension이 사용되었다.다음과 같은 ...",
    "content": "Extensions는 본질적으로 기존클래스, 구조, 기타데이터유형에 추가 기능을 추가 할 수 있게 한다.기본형태는 다음과 같다extension SomeType {    // new functionality}우리가 늘상 만드는 것과 형태가 다르지 않다.그저 앞에 class, protocol, struct 대신 extension이 사용되었다.다음과 같은 수가 있고let myDouble = 3.14159//반올림let myRoundedDouble = String(format:\"%.1f\", myDouble)print(myRoundedDouble) // 3.1그런데 문자열을 생성하지않고 만들고 싶다.var myDouble = 3.14159print(myDouble.round(to: 3))하지만 작동하지 않는다.우리가 직접 작동하게 만들어 보자.일단 시퀀스는 다음과 같다// ex) 넷째자리에서 반올림한다면?myDouble=myDouble*1000 // 3141.59myDouble.round()       // 3142myDouble=myDouble/1000 // 3.142extension을 다음과 같이 해주었다.extension Double {    func round(to places: Int) -&gt; Double {        let precisionNumber = pow(10, Double(places)) // 1000처럼 10의 x제곱 형태로 나타내었다.        var n = self // 해당수 자신을 10제곱수 곱해야 한다.        n = n * precisionNumber        n.round()        n = n / precisionNumber        return n    } }print(myDouble.round(to: 3)) // 3.142이젠 원하는 자리수 만큼 반올림이 가능해졌다.자세한건 애플 깃허브에 들어가보면 있다애플이 공개한 오픈 소스들이 있다.하지만 공개되지 않은 코드들도 많다.https://github.com/apple/swift우리가 UIlabel같은 기능을 만들면서 코드에 대해선 접근 권한이 있는건 아니다.하지만, 클래스들을 확장 할 수 있다.let button = UIButton(frame: CGRect(x:0, y:0, width: 50, height: 50))button.backgroundColor = .redbutton.layer.cornerRadius = 25button.clipsToBounds = true이렇게 작성을 하면그렇다면 UIButton을 확장해서, 버튼의 디자인을 동그랗게 해주게 해보자extension UIButton {    func makeCircular() {        self.clipsToBounds = true        self.layer.cornerRadius = self.frame.size.width / 2    }}그리고나서 해보면?let button1 = UIButton(frame: CGRect(x:0, y:0, width: 50, height: 50))button1.backgroundColor = .redbutton1.makeCircular()잘된다!이렇게 extension은 프로토콜을 확장 할 수 있고,extension SomeProtocol {    // Define default behavior}저번에 조류를 예로 들었던것을 가져왔다.protocol CanFly {    func fly()}extension CanFly {    func fly() {        print(\"The object takes off into the air\")    }}struct Airplane: CanFly {}프로토콜에서는 함수의 내용을 정의 할 수 없었다.즉 우리가 다른 클래스에서 해당 function을 추가하면서 내용을 정의를 했는데,extension을 사용하면, 프로토콜의 내용을 정의하면서 프로토콜의 function을 default로 사용 할 수가 있다.airplane에 Canfly 프로토콜을 추가해도 이젠 에러가 발생하지 않는다.이렇게 입력하는순간 바로 사용가능하게 뜬다!실제로 작동해보면The object takes off into the air결과값도 잘 나오는걸 확인 할 수있다.그래서 WeatherViewController 에서class WeatherViewController: UIViewController, UITextFieldDelegate,이렇게 UITextFieldDelegate 프로토콜을 가져왔음에도 불구하고함수를 만들지 않아도 에러가 발생하지 않았던 것이다.extension은 모든 데이터 유형에 대해 다른 프로토콜을 적용 할 수도 있다.extension SomeType : SomeProtocol {    // add new functionality}해당내용의 예시는 clima(6)과 연관이 되므로 거기서 서술하도록 하겠다"
  },
  
  {
    "title": "Clima (4)",
    "url": "/posts/Clima-(4)/",
    "categories": "Udemy, Clima",
    "tags": "API, Networking",
    "date": "2024-03-08 03:21:00 +0900",
    





    
    "snippet": "날씨 정보를 파싱하여 뷰 컨트롤러에 전달우선 WeatherData로 돌아가서 이젠 우리가 다시 swift로 encoding을 해줘야 하므로Decodable, Encodable을 같이 사용하면 다음과 같은 에러가 발생한다.struct WeatherData : Decodable, Encodable {    let name : String    let ma...",
    "content": "날씨 정보를 파싱하여 뷰 컨트롤러에 전달우선 WeatherData로 돌아가서 이젠 우리가 다시 swift로 encoding을 해줘야 하므로Decodable, Encodable을 같이 사용하면 다음과 같은 에러가 발생한다.struct WeatherData : Decodable, Encodable {    let name : String    let main : Main    let weather : [Weather]}이때 우리가 사용할것이 바로 Codable 프로토콜인데,Decodable과 Encodable프로토콜을 합친것이 바로 Codable 프로토콜이다.그래서 모든 WeatherData.swift에 있는 구조체들을 모두 바꿔주자import Foundationstruct WeatherData : Codable {    let name : String    let main : Main    let weather : [Weather]}struct Main : Codable {    let temp : Double}struct Weather : Codable {    let description : String    let id : Int}그리고 parseJSON 함수에서 만들어진 값을 performRequest의if let safeData = data {    self.parseJSON(weatherData: safeData)      }이 부분에 값을 전달하려고 한다.이젠 리턴을 해야하므로 함수를 살짝 수정 해주자func parseJSON(weatherData: Data) -&gt; WeatherModel이렇게 리턴타입을 명시해준다. func parseJSON(weatherData: Data) -&gt; WeatherModel? {        let decoder = JSONDecoder()        do {             생략            return weather                        print(weather.temperatureString)        } catch {            print(error)        }            }이렇게 리턴을 하도록 했다.그런데 만약 디코딩 과정이 실패한다면??우리는 아무것도 없는걸 리턴해줘야한다. 그렇다면 아무것도 없다는게 무엇일까?바로 nil 이다!그래서 다음과 같이 nil을 리턴한다는걸 catch 구문에 적어주자catch {       print(error)       return nil        }이렇게 nil을 반환한다는건?그렇다 바로 WeatherModel의 DataType이 Optional 이어야 한다는 뜻이다.func parseJSON(weatherData: Data) -&gt; WeatherModel 이었던것에 ?를 하나 더 붙여서 옵셔널 타입으로 전환 해주자func parseJSON(weatherData: Data) -&gt; WeatherModel?완성.    func parseJSON(weatherData: Data) -&gt; WeatherModel? {        let decoder = JSONDecoder()        do {            let decodedData = try decoder.decode(WeatherData.self, from: weatherData)            let id = decodedData.weather[0].id            let temp = decodedData.main.temp            let name = decodedData.name                        let weather = WeatherModel(conditionId: id, cityName: name, temperature: temp)            return weather                        print(weather.temperatureString)        } catch {            print(error)            return nil        }            }그럼 이제 다시 performRequest로 거슬러 올라가서…우리가 parseJSON 으로 리턴하는값이 옵셔널이 되었으므로 옵셔널 바인딩을 해주어 순수한 weatherModel 타입이 리턴되도록 하자if let safeData = data {    if let weather = self.parseJSON(weatherData: safeData) {if let 한번 더 감싸준다.그리고 이 weather를 WeatherViewController로 전달해야 하므로 viewcontroller를 인스턴스화 하자.let weatherVC = WeatherViewController()그리고 그값을 받아올 함수를 하나 만들어 준다.우선 온도만 잘 받아오게끔 해본다.// WeatherViewControllerfunc didUpdateWeather(weather : WeatherModel) {        print(weather.temperature)    }그리고 다시 WeatherManager로 돌아가서,weatherVC.didUpdateWeather(weather: weather) vc에 전달할 weather값을 보낸다.우리가 여태 배웠던 delegate 나 protocol을 생각해보고, 이걸 한다면 우리는 WeatherManager를 한번만 사용하게 될것이다.마치 일회용품처럼하지만 우리는 이 프로젝트를 제한해야한다. 이후에 또 프로젝트를 할때 날씨 데이터가 필요하다면 재사용 하면 된다.그렇게 재사용 하는 방법은 다른 개체와 연결하는 특정 코드를 사용하지 않으면 된다.let weatherVC = WeatherViewController()weatherVC.didUpdateWeather(weather: weather)해당구문을 일단 지워두고 delegate를 사용하고, delegate의 data Type은 WeatherManagerDelegate?로 한다.그리고 delegate.didUpdateWeather 를 통해 값을 전달하고, 그값을 출력하게 해보자여기선 일단 프로토콜을 만들어 주어야한다.protocol WeatherManagerDelegate{    func didUpdateWeather(weather: WeatherModel)}클로져 안에 있기에 delegate 앞에 self를 붙여주었다.self.delegate?.didUpdateWeather(weather: weather)그리고 뷰컨트롤러로 돌아가 우리가 만든 프로토콜을 적용시켜주었다.class WeatherViewController: UIViewController, UITextFieldDelegate, WeatherManagerDelegate {여기까지는 내가 생각한것과 좀 비슷했다.주의해야 하는것이. 우리가 전에 UITextFieldDelegate 프로토콜을 쓸때도 viewDidLoad()에searchTextField.delegate = self 이걸 사용해주었다.이번에도 weatherManager.delegate = self 를 해줘야한다! override func viewDidLoad() {        super.viewDidLoad()                weatherManager.delegate = self        searchTextField.delegate = self    }실행해보자!잘된다.이제 이 프로젝트에서 우리는 WeatherManager를 일일이 작동 시키는 것이 아니라, 프로토콜을 사용하였고, viewdidload에서 그 프로토콜을 사용 가능하게 하였기에, 어떤 클래스와 상관없이 날씨 데이터를 받아 올 수 있게 되었다."
  },
  
  {
    "title": "208. 2016년",
    "url": "/posts/208.-2016%EB%85%84/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-07 14:38:00 +0900",
    





    
    "snippet": "func solution(_ a:Int, _ b:Int) -&gt; String {        var day = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]    var total = 0        if a != 1 {        for i in 0..&lt;a-1 {            total+=d...",
    "content": "func solution(_ a:Int, _ b:Int) -&gt; String {        var day = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]    var total = 0        if a != 1 {        for i in 0..&lt;a-1 {            total+=day[i]        }        total = total + b    } else {        total = b    }        switch total%7 {        case 1 :            return \"FRI\"        case 2 :            return \"SAT\"        case 3 :            return \"SUN\"        case 4 :            return \"MON\"        case 5 :            return \"TUE\"        case 6 :            return \"WED\"        default :            return \"THU\"    }}일단 요일을 보고 전체 일수에서 7을 나눈 나머지를 기준으로 하면 되겠다라는 판단이 섰다.그래서 day라는 배열을 만들고 각 수를 집어 넣어 줬다.그리고 for문을 사용해서 더해주는데, 저기 조건에선 1일때 에러가 발생하기 때문에, 1월이 아닐때만 for문이 돌고 1월일땐 b값만 들어가게 해주었다.그리고 7을 나눈 나머지를 사용하기 위해 switch case문을 사용하였다.1월 1일이 금요일 이므로 나머지가 1일때는 금요일이기에, 그것을 기준으로 쭉 적었고결과값을 바로 리턴하게 하였다.그리고 일어나서 문제를 복기하다가 이런 생각이 들었다.조금이라도 간소화 할수는 없을까?그래서 한달도 7로 나눈 나머지가 값으로 모두 전환 하였다.그리고나서 합을 구할때도 reduce를 사용하여 좀 더 식을 간소화 하였다.func solution(_ a:Int, _ b:Int) -&gt; String {        var day = [3, 1, 3, 2, 3, 2, 3, 3, 2, 3, 2, 3]    var total = 0    total = a != 1 ? day[0..&lt;a-1].reduce(0,+) + b : b        switch total%7 {        case 1 :            return \"FRI\"        case 2 :            return \"SAT\"        case 3 :            return \"SUN\"        case 4 :            return \"MON\"        case 5 :            return \"TUE\"        case 6 :            return \"WED\"        default :            return \"THU\"    }}그리고 switch case문 대신 배열값으로 리턴하는것도 괜찮지 않을까? 싶어서다음과 같이 했다.func solution(_ a:Int, _ b:Int) -&gt; String {        var day = [3, 1, 3, 2, 3, 2, 3, 3, 2, 3, 2, 3]    var week = [\"THU\",\"FRI\", \"SAT\", \"SUN\", \"MON\",\"TUE\",\"WED\"]    var answer = \"\"    var total = 0    total = a != 1 ? day[0..&lt;a-1].reduce(0,+) + b : b        answer = week[total%7]        return answer}팀원 발표용func solution(_ a:Int, _ b:Int) -&gt; String {        var day = [3, 1, 3, 2, 3, 2, 3, 3, 2, 3, 2, 3]    // 월별 일수를 7로 나눈 나머지 값        var week = [\"THU\",\"FRI\", \"SAT\", \"SUN\", \"MON\",\"TUE\",\"WED\"]    // 요일을 배열로 0     1      2      3      4     5     6        var answer = \"\"        var total = 0    total = a != 1 ? day[0..&lt;a-1].reduce(0,+) + b : b    //      -------- ----------------------------  ---    //    1월이 아니라면?            True             False    //                              ↓  ⠀    ⠀ ⠀     ↓    //                a월까지의 일수를 더하고 b일을 더한다   ↓    //                                      1월이면 b일만 넣어준다        answer = week[total%7]    // 결과값을 7로나눈 나머지의 값을 인덱스로 하여 그에 해당하는 요일을 리턴한다        return answer}"
  },
  
  {
    "title": "Clima (3)",
    "url": "/posts/Clima-(3)/",
    "categories": "Udemy, Clima",
    "tags": "API, Networking",
    "date": "2024-03-07 12:21:00 +0900",
    





    
    "snippet": "날씨 상태에 따른 ImageView Update우선 웹페이지를 다시 들어가서 Weather API에 관한 Docs를 읽어보자.우리가 봐야할건 오른쪽에 밑줄 친 부분이다.내용이 많아 링크를 건다.https://openweathermap.org/weather-conditions일단 샘플에서 볼 수 있듯이....   \"weather\": [\t{\t  \"id\":...",
    "content": "날씨 상태에 따른 ImageView Update우선 웹페이지를 다시 들어가서 Weather API에 관한 Docs를 읽어보자.우리가 봐야할건 오른쪽에 밑줄 친 부분이다.내용이 많아 링크를 건다.https://openweathermap.org/weather-conditions일단 샘플에서 볼 수 있듯이....   \"weather\": [\t{\t  \"id\": 500, // id에 따라 어떤 이미지를 보여주는지 알 수 있다.\t  \"main\":\"Rain\",\t  \"description\": \"light rain\",\t  \"icon\": \"10n\"\t}  ],...그래서 id 값을 추출 하기 위해 WeatherData로 가서값을 추가해준다.struct Weather : Decodable {    let description : String    let id : Int // 이녀석이다.}실제로 id가 출력되는지 확인해보자!발리의 id를 확인해보자잘나오고 있다!그렇다면 이 id값을 통해 우리가 결국 SF Symbol의 이름을 리턴해서 imageView를 바꿔야 한다.id값을 통해 저 이름을 리턴하게끔 코드를 작성해보자!func getConditionName(weatherId: Int) -&gt; String {                return \"\"    }우선 기본 틀을 작성해둔다.웹페이지를 참고하여 각 숫자 조건에 맞게 sf symbol을 리턴할 로직을 구현하였다.   func getConditionName(weatherId: Int) -&gt; String {        var conditionName = \"\"                switch weatherId {            case 200...232 : conditionName = \"cloud.bolt\"            case 300...321 : conditionName = \"cloud.drizzle\"            case 500...531 : conditionName = \"cloud.rain\"            case 600...622 : conditionName = \"cloud.snow\"            case 700...781 : conditionName = \"cloud.fog\"            case 800 : conditionName = \"sun.max\"            case 801...804 : conditionName = \"cloud.bolt\"            default : conditionName = \"cloud\"        }        return conditionName    }되는지 테스트 해보자 다시 발리를 했을때 어떻게 나오는지 해보자804가 나왔으니까 제대로 작동된다면 “cloud.bolt”가 나올것이다.굿!점점 복잡해지기 시작한다사용자 지정 타입으로 일부 데이터 그룹화하기Weather Model 파일을 하나 만들어준다.struct WeatherModel {    let conditionId : Int    let cityName : String    let temperature : Double}그리고 다음과 같이 적어주었다.저 변수들은 실제 우리가 화면에 보여줄때 필요한 값들이다.그리고 아까 적었던 함수를 Model로 옮겨준다struct WeatherModel {       let conditionId : Int    let cityName : String    let temperature : Double        func getConditionName(weatherId: Int) -&gt; String {        var conditionName = \"\"                switch weatherId {            case 200...232 : conditionName = \"cloud.bolt\"            case 300...321 : conditionName = \"cloud.drizzle\"            case 500...531 : conditionName = \"cloud.rain\"            case 600...622 : conditionName = \"cloud.snow\"            case 700...781 : conditionName = \"cloud.fog\"            case 800 : conditionName = \"sun.max\"            case 801...804 : conditionName = \"cloud.bolt\"            default : conditionName = \"cloud\"        }        return conditionName    }    }다시 Manager로 돌아가서id temp name과 관련된 변수를 만들어 준다.let id = decodedData.weather[0].idlet temp = decodedData.main.templet name = decodedData.name그리고 좀전에 만들었던 WeatherModel을 Instance화 한다.let weather = WeatherModel(conditionId: id, cityName: name, temperature: temp)그리고 함수를 지우고 다음과 같이 해주었다.struct WeatherModel {        let conditionId : Int    let cityName : String    let temperature : Double        var conditionName : String {        switch conditionId {        case 200...232 :            return \"cloud.bolt\"        case 300...321 :            return \"cloud.drizzle\"        case 500...531 :            return \"cloud.rain\"        case 600...622 :            return \"cloud.snow\"        case 700...781 :            return \"cloud.fog\"        case 800 :            return \"sun.max\"        case 801...804 :            return \"cloud.bolt\"        default :            return \"cloud\"        }    }        }이런식으로 conditionName 처럼 저렇게 하는걸 Computed Property(연산 프로퍼티) 라고 한다.그렇다면 온도를 소수점 한자리로 나타나게 해보자!var temperatureString : String {        return String(format: \"%.1f\", temperature)    }이렇게 작성해주었다.잘 나온다 😀"
  },
  
  {
    "title": "Git & Github로 협업하는 법",
    "url": "/posts/Git-%ED%98%91%EC%97%85/",
    "categories": "Tip, Git",
    "tags": "Git",
    "date": "2024-03-07 07:11:00 +0900",
    





    
    "snippet": "브랜치 활용하기 (Terminal)      수정은 하고 싶은데 원래 파일은 그대로 두고 싶은 경우.        복사본 == 브랜치 (Branch)    git branch branchName          하지만 변화가 없다.        git branch          현재 브랜치의 종류가 나온다.      현재 branch와 master ...",
    "content": "브랜치 활용하기 (Terminal)      수정은 하고 싶은데 원래 파일은 그대로 두고 싶은 경우.        복사본 == 브랜치 (Branch)    git branch branchName          하지만 변화가 없다.        git branch          현재 브랜치의 종류가 나온다.      현재 branch와 master 두개가 있다.            git switch branchName / git checkout branchName (branchName명 변경)          Branch 한번에 생성 및 이동                  git switch -c branchName          git checkout -b branchName                      브랜치 병합          git switch branchName (메인 브랜치)                  ex) git switch main                    git merge branchName (합칠 브랜치명)                  ex) git merge login                      A라는 branch에서 코드를 작성하고있었다. 이때 main branch로 돌아가면 코드는 어떻게 될까?      내가 작성한 코드는 없다.  Github에서 합치기 (Pull Request 활용)우선 pull request는 pull(merge)와 request의 합친 말이다.터미널에서 git merge를 통해 합치는경우는 거의 없다.보통은 github에서 합친다.코드 변경사항을 알 수 있고, 코드리뷰도 가능하기 때문.Sequence는 다음과 같다.      브랜치 생성 및 이동        코드 수정 및 저장        코드 업로드 및 pull request생성        깃헙에서 merge        로컬에 반영 (git pull origin ~)  협업시 문제점 및 해결책  완벽하게 기능 개발해야 merge 가능          Main Branch = 배포용                  해결책 (개발용 브랜치 생성)                          main : 배포용              develop : 테스트용              feature : 기능 개발용                                            그냥 합치면 위험하다          팀원들이 이름이 같은 변수를 만들수도 있다.                  해결책                          로컬에서 먼저 테스트                                          실전 가이드  초기 세팅          팀장 : 초기 코드 작성 및 github 업로드                  폴더 생성          간단한 코드 작성          레포지토리 등록 및 기타 작업 init, add, commit, push                      팀장 : dev(develop) 즉 개발용 브랜치 생성          git switch -c dev                  local에서 dev branch 생성                    git push origin dev                  github에 반영                          팀장 : github에서 dev branch를 default 로 설정        팀장 : 팀원추가        팀원 : git clone    기능 개발 시작          git switch -c featureBranchName      코드 작성      git add, commit, push            pull request 생성        코드 작성자 : 리뷰요청        코드 리뷰어 : 코드리뷰    합치기 전 내 로컬에서 충돌 해결 및 테스트          기능 브랜치에서 git pull origin dev      실제로 사용해보기.현재 메인으로 사용중인 맥북프로와, 서브로 사용중인 맥미니 이렇게 두대로 해보려고 한다.맥북프로 : 팀장역할맥미니 : 팀원역할이렇게 나누어 진행하였다.우선 repository를 하나 만들고, Directory도 하나 만들어 주었다.1. 프로젝트 생성 후 repository에 올리기. (팀장)이렇게 xcode프로젝트를 하나 생성하고 올렸다.2. 개발용 브랜치 생성. (팀장)  git switch -c dev  git push origin dev이렇게 dev가 branch에 생겼다.하지만 default는 아니다.3. dev branch 를 default로 변경. (팀장)해당 repository에 들어가서 상단의 settings를 누른다.그리고 Default branch에서 다음과 같이 해준다이제 dev branch가 default branch가 되었다.4. 팀원 추가collaboratos에서 추가해주자.테스트용 부계정이 이렇게 추가가 되었다.테스트용도 일부러 윈도우대신 맥환경에서 진행하였다.5. git clone (팀원)일단 프로젝트용 디렉토리를 하나 만들어 주고 그곳에 클론을 하였다.클론을 해주니 자동으로 dev branch가 main으로 되어있다.기능 별 브랜치를 만들어 주자.이제 코드를 작성을 해보도록 하자.간단하게 코드를 작성하고 push 를 해주었다.아무래도 계정을 만들고 바로 테스트를 하다보니 username과 password를 입력하라고 나왔는데 그건 패스하자.6. pull request 생성 (코드 작성자)그리고 github사이트로 들어가보자.다음과 같이 Pull request가 뜬걸 알수있다. (팀원)하지만 팀장의 화면엔?고요하다.우선 pull request를 해보도록 하자.다음과 같이 작성 하였고 생성 하였다.이렇게 Pull Request가 끝났다.7. 리뷰 요청하기 (코드 작성자)우측을 보면 이렇게 팀원과 함께 request로 요청이 뜬다.눌러보자.이렇게 바뀌었다.이제 리뷰를 요청 받은 입장으로 돌아가보자.이렇게 pull request가 1로 되어 있고 팀원이 적었던게 그대로 나온다.한번 들어가보자.이건 움짤로 만들어 보았다.근데 팀장 메일을 확인하니 다음과 같이 왔다.첫번째는 팀원이 올리고 나서 메일이 자동으로 보내진것 같다.두번째것은 리뷰를 요청하고 메일이 보내진것같다.8. 코드 리뷰하기 (코드 리뷰어)Files Changed로 가서 어떤 코드가 수정이 되었는지 확인 해보자.+ 로 커서를 갖다 대면 이렇게 나오는데 눌러보자그러면 이렇게 창이 하나 뜨는데박스안에는 사진과 같이 코멘트 혹은 변경 요청 중 하나를 선택해서 그것에 맞게 남기면 된다.그리고 다음과 같이 되는데 이젠 Finish your review를 클릭해보자각 3가지는 다음과 같다. (사실 단어에 의미가 이미 내포하고 있긴하다.)  Comment : 일반적인 코멘트  Approve : Comment와 달리 리뷰어가 승인을 하는 것으로, 머지해도 괜찮다는 의견  Request Changes : 변경을 요청하는 것으로, 승인을 거부한다는 의견일단 Approve를 했다.9. 합치기 전 내 로컬에서 충돌 해결 및 테스트그럼 저 위에있는 Merge pull request가 아른아른 거리기 시작한다. 하지만 깃에 올라가버리면 꼬이기때문에, 그전에 먼저 나의 로컬에서 테스트를 해보고 올리도록 하자.일단 여기서는 pull은 팀장 position으로 했다.지금상황에서는 뼈대만 만들고 아무거나 추가하고 했기에 코드 작성자가 pull을 안했지만, 나중에는 코드 작성자가 pull을하여 최종 확인을 해야 하지 않을까 싶다.이부분은 조금 더 테스트후 수정 및 보완을 하도록 하겠다.작동 확인결과 이상이 없다.10. Merge 하기  만약 수정사항이 있다면?          git add, commit, push를 하도록 하자.. 반복과정        수정사항이 없다면?          merge!      merge pull request를 눌러보자.마지막으로 한번 더 묻는다.Confirm 하자!다음과 같이 바뀌었다.그리고 코드도 들어가보면?바뀌었다.11. 추가 기능 개발1. 내 로컬의 dev에도 변경 사항 반영  dev branch로 이동 (git checkout dev / git switch dev)          위의 이미지는 생략.        git pull origin dev2. 다음 기능 개발      기능 브랜치 생성 및 코드 작성        git add, commit, push        pull request 생성 및 코드 리뷰        내 로컬에서 충돌 해결 및 테스트  12. 반복….Git GUI Application을 통한 history 확인.선택은 자유      git kraken        sourcetree        git desktop        github (web)  실제로 사용해보기의 11번이 쪼금 취약한 것 같아서, 코드를 좀더 적어봐야겠다."
  },
  
  {
    "title": "1주차 (8)",
    "url": "/posts/Main-campus_1st-week-8/",
    "categories": "캠프, 1주차",
    "tags": "",
    "date": "2024-03-07 02:11:00 +0900",
    





    
    "snippet": "1. Class(클래스)  클래스는 프로퍼티와 메서드로 구분 되어있다.1. Properties(프로퍼티)  프로퍼티는 클래스, 구조체, 또는 열거형 안에 있는 변수 또는 상수를 나타낸다.  클래스의 속성으로 객체의 상태를 저장하거나 제공한다. 이러한 상태는 클래스의 인스턴스가 가질 수 있는 고유한 데이터를 나타낸다.  프로퍼티는 저장 프로퍼티(Stor...",
    "content": "1. Class(클래스)  클래스는 프로퍼티와 메서드로 구분 되어있다.1. Properties(프로퍼티)  프로퍼티는 클래스, 구조체, 또는 열거형 안에 있는 변수 또는 상수를 나타낸다.  클래스의 속성으로 객체의 상태를 저장하거나 제공한다. 이러한 상태는 클래스의 인스턴스가 가질 수 있는 고유한 데이터를 나타낸다.  프로퍼티는 저장 프로퍼티(Stored Properties)와 계산 프로퍼티(Computed Properties)로 나눌 수 있따.          저장 프로퍼티: 값을 저장하고, 인스턴스의 일부로서 그 값을 유지      계산 프로퍼티: 특정한 계산을 통해 값을 반환하며, 값을 저장하지 않고 필요할 때마다 새로 계산한다.      2. 메서드(Methods)  메서드는 클래스, 구조체, 또는 열거형 안에 있는 함수를 나타낸다.  클래스의 동작을 정의하고, 클래스의 인스턴스에 대해 수행되는 특정한 작업을 수행한다.  메서드는 인스턴스 메서드(Instance Methods)와 타입 메서드(Type Methods)로 구분한다.          인스턴스 메서드: 특정 인스턴스에 속하는 동작을 정의하고, 인스턴스의 상태에 접근할 수 있다.      타입 메서드: 클래스 자체와 관련된 동작을 정의하며, 특정 인스턴스에 속하는 것이 아닌 클래스 자체에 영향을 준다.        클래스는 이니셜라이저(Initializer)를 통해 초기값을 설정할 수 있다.          프로퍼티에 기본 값이 없는 경우 이니셜라이저를 필수로 구현해야 한다. 그렇지 않을 경우 에러가 발생합니다.      즉, 클래스를 구성하고 변수를 만들때 거기에 초기값을 부여를 하지 않으면 반드시 init을 해야한다.        참조 타입          참조 타입은 변수나 상수에 할당될 때에는 값을 복사하는 것이 아니라 참조(주소)가 복사되어 같은 인스턴스를 가리키게 된다. 클래스(Class)가 참조 타입의 대표적인 예시이다.      참조 타입의 경우 변수나 상수에 할당될 때 참조가 복사되므로, 동일한 인스턴스를 공유하게 된다. 따라서 한 쪽에서 값을 변경하면 다른 쪽에서도 영향을 받게 된다.      // 참조 타입인 클래스class Person {    var name: String    init(name: String) {        self.name = name    }}var person1 = Person(name: \"Alice\")var person2 = person1 // 참조 복사person2.name = \"Bob\"print(person1.name) // 출력: Bobprint(person2.name) // 출력: Bob// 클래스 구성// 예시 1class Name {    var name: String\t\tinit(name: String) {\t\t\t\tself.name = name\t\t}        func sayMyName() {        print(\"my name is \\(name)\")    }}let song : Name = Name(name: \"song\")print(song.name) // songsong.sayMyName() // my name is songsong.name = \"kim\"song.sayMyName() // my name is kim// 예시 2class Person {    var name: String // 저장 프로퍼티        var introduction: String { // 계산 프로퍼티        return \"제 이름은 \\(name)입니다.\"    }        init(name: String) {        self.name = name    }}// Person 객체 생성let person1 = Person(name: \"Alice\")print(person1.introduction) // 출력: 제 이름은 Alice입니다.// 예시 3class Counter {    var count = 0 // 저장 프로퍼티        func increment() { // 인스턴스 메서드        count += 1    }        static func reset() { // 타입 메서드        print(\"카운터를 초기화합니다.\")    }}// Counter 객체 생성let counter1 = Counter()counter1.increment()counter1.increment()print(counter1.count) // 출력: 2// 타입메서드(Static)는 반드시 클래스를 통해 호출해야한다! Counter.reset() // 출력: 카운터를 초기화합니다.3. 상속  상속          Swift에서 상속(Inheritance)은 클래스(Class) 간에 코드 및 속성을 공유하는 메커니즘을 제공한다.      상속은 기존 클래스에서 새로운 클래스를 만들고, 기존 클래스의 특성(속성과 메서드)을 재사용하면서 새로운 기능을 추가할 수 있도록 해준다(서브 클래싱).        상속의 장점          코드 재사용성                  기존 클래스의 특성을 재사용하여 중복을 피하고 유지보수성을 높일 수 있다.                    계층 구조                  부모 클래스와 이를 상속받는 자식 클래스 간에 계층 구조를 형성하여 다양한 수준의 추상화와 분류를 가능하게한다.                      override          부모 클래스에서 상속받은 메서드, 속성 또는 서브스크립트를 자식 클래스에서 다시 정의할 때 사용.      자식 클래스에서 부모 클래스의 메서드를 재정의하여 새로운 구현을 제공할 수 있다.      메서드, 속성, 서브스크립트를 재정의하기 위해서는 override 키워드를 사용해야 한다.        super          자식 클래스에서 부모 클래스의 메서드, 속성 또는 초기화 메서드를 호출할 때 사용.      부모 클래스의 메서드를 호출하거나 부모 클래스의 초기화 메서드를 호출하는 데 사용됩니다.      super.method() 또는 super.property와 같이 사용하여 부모 클래스의 기능을 호출할 수 있다.        final          클래스, 메서드, 속성 또는 서브스크립트를 표시하여 상속이 불가능하도록 만든다.      final 키워드가 클래스에 사용되면 해당 클래스는 상속될 수 없다.      메서드, 속성, 서브스크립트에 사용될 경우, 해당 멤버들을 재정의(Override)할 수 없다.      // 부모 클래스(Person) 선언class Person {    var name: String    var age: Int    init(name: String, age: Int) {        self.name = name        self.age = age    }    func greet() {        print(\"Hello, my name is \\(name).\")    }}// Person 클래스를 상속받는 자식 클래스(Student) 선언class Student: Person {    var studentID: Int    init(name: String, age: Int, studentID: Int) {        self.studentID = studentID        super.init(name: name, age: age)    }    func study() {        print(\"\\(name) is studying.\")    }}// Student 클래스 인스턴스 생성 및 사용let john = Student(name: \"John\", age: 20, studentID: 123)john.greet() // 출력: Hello, my name is John.john.study() // 출력: John is studying.// override, super 키워드 예시class Animal {    func makeSound() {        print(\"Some generic sound\")    }}class Dog: Animal {    override func makeSound() {        super.makeSound() // 부모 클래스의 메서드 호출        print(\"Bark!\")    }}let dog = Dog()dog.makeSound()// final 키워드 예시final class Vehicle {    final var wheels: Int = 0        final func makeSound() {        print(\"Some generic sound\")    }}// Error: 'SubVehicle' cannot inherit from final class 'Vehicle' → class에 final을 붙였을 경우 발생class SubVehicle: Vehicle {    // Error: 'wheels' cannot override 'final' var from superclass → 변수에 final을 붙였을 경우 발생    // override var wheels: Int = 4        // Error: 'makeSound()' cannot override a final method → function에 final을 붙였을 경우 발생    // override func makeSound() {    //     print(\"Custom sound\")    // }}2. Struct(구조체)  구조체는 클래스와 마찬가지로 프로퍼티에 값을 저장하거나 메서드를 통해 기능을 제공하고 이걸 하나로 캡슐화할 수 있는 사용자 정의 타입이다.  생성자(initializer)를 정의하지 않으면 구조체가 자동으로 생성자(Memberwise Initializer.)를 제공한다.  init을 할 필요가 없다!  값 타입          값 타입은 변수나 상수에 할당될 때 값의 복사본이 생성되는 타입이다. 주로 구조체(Structures), 열거형(Enumerations), 기본 데이터 타입(Int, Double, Bool, 등)이 값 타입에 해당      // 값 타입인 구조체 예시struct Point {    var x: Int    var y: Int}var point1 = Point(x: 5, y: 10)var point2 = point1 // 값 복사point2.x = 15print(point1) // 출력: Point(x: 5, y: 10)print(point2) // 출력: Point(x: 15, y: 10)// class와 달리 같은 주소를 공유 하지 않아, 값이 다르다!  클래스와 달리 구조체는 상속을 할 수 없다.  클래스와 같이 인스턴스로 만들어 사용할 수 있다.struct Coffee {  var name: String?  var size: String?  func brewCoffee() -&gt; String {    if let name = self.name {      return \"\\(name) ☕️ 한 잔 나왔습니다\"    } else {      return \"오늘의 커피 ☕️ 한잔 나왔습니다\"    }  }}let americano = Coffee(name: \"아메리카노\")// 출력값: 아메리카노 ☕️ 한 잔 나왔습니다// 따로 init()을 구현하지 않아도 자동으로 생성자를 받습니다.// Memberwise Initializer 예시struct ShoppingListItem {    let name: String?    let quantity: Int    var purchased = false}let item1 = ShoppingListItem(name: \"칫솔\", quantity: 1)let item2 = ShoppingListItem(name: \"치약\", quantity: 1, purchased: true)let item3 = ShoppingListItem(name: nil, quantity: 1, purchased: true)3. num(열거형)  Enum은 관련된 값으로 이뤄진 그룹을 같은 타입으로 선언해 타입 안전성을 보장하는 방법으로 코드를 다룰 수 있게 해준다.// 간단한 열거형 선언enum CompassDirection {    case north    case south    case east    case west}// 열거형의 인스턴스 생성 및 사용var direction = CompassDirection.northvar anotherDirection = direction // 값 복사direction = .east // 값을 변경해도 anotherDirection에는 영향이 없음print(direction) // 출력: eastprint(anotherDirection) // 출력: north  Swift의 열거형(Enum)은 연관 값(Associated Values)을 가질 수 있습니다. 이는 각 case가 특정 값을 연결하여 저장할 수 있는 기능을 제공한다.// 연관 값을 가진 열거형 선언enum Trade {    case buy(stock: String, amount: Int)    case sell(stock: String, amount: Int)    case hold}// 열거형의 인스턴스 생성 및 사용let trade1 = Trade.buy(stock: \"AAPL\", amount: 100)let trade2 = Trade.sell(stock: \"GOOG\", amount: 50)let trade3 = Trade.hold// switch 문을 사용하여 연관 값 추출func processTrade(trade: Trade) {    switch trade {    case .buy(let stock, let amount):        print(\"Buy \\(amount) shares of \\(stock).\")    case .sell(let stock, let amount):        print(\"Sell \\(amount) shares of \\(stock).\")    case .hold:        print(\"Hold this position.\")    }}// 각 열거형 케이스에 따라 다른 동작 수행processTrade(trade: trade1) // 출력: Buy 100 shares of AAPL.processTrade(trade: trade2) // 출력: Sell 50 shares of GOOG.processTrade(trade: trade3) // 출력: Hold this position.  자주 사용하는 메서드```swiftenum CompassPoint {  case north  case south  case east  case west}// 한 케이스 선언 방법var directionToHead = CompassPoint.westdirectionToHead = .east// 활용 예시 1directionToHead = .southswitch directionToHead {case .north:    print(“북쪽”)case .south:    print(“남쪽”)case .east:    print(“동쪽”)case .west:    print(“서쪽”)}// 출력값: “남쪽”// allCases enum Beverage: CaseIterable {    case coffee, tea, juice}let numberOfChoices = Beverage.allCases.countprint(“(numberOfChoices) 잔 주문 가능합니다.”)// 출력값: 3잔 주문 가능합니다- Optional은 enum이다. (특강에서도 언급되었던 내용)```swift// 실제 Optional의 정의@frozen public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral {    /// The absence of a value.    ///    /// In code, the absence of a value is typically written using the `nil`    /// literal rather than the explicit `.none` enumeration case.    case none    /// The presence of a value, stored as `Wrapped`.    case some(Wrapped)print(Optional.none == nil) // true4. 정리  클래스와 구조체, 열거형 모두 메모리에 할당되고 그 생성된 대상을 인스턴스(instance)라고 한다.  스위프트에서는 클래스의 인스턴스(instance)를 특별히 객체(object)라고 한다.  메모리 저장 방식          구조체, 열거형                  값 타입(Value Type)          인스턴스 데이터를 모두 스택(Stack)에 저장          새로운 변수에 할당(값을 전달할때마다)할때마다 복사본을 생성 (다른 메모리 공간 생성)          스택(Stack)의 공간에 저장, 스택 프레임 종료시, 메모리에서 자동 제거                    클래스                  참조 타입(Reference Type)          ARC시스템을 통해 메모리 관리          인스턴스 데이터는 힙(Heap)에 저장, 해당 힙을 가르키는 변수는 스택에 저장하고 변수의 메모리 주소값이 힙을 가리킴          값을 전달하는 것이 아니고, 저장된 주소를 전달                    "
  },
  
  {
    "title": "207. 명예의 전당 (1)",
    "url": "/posts/207.-%EB%AA%85%EC%98%88%EC%9D%98-%EC%A0%84%EB%8B%B9-(1)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-06 15:33:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ k:Int, _ score:[Int]) -&gt; [Int] {        var result : [Int] = [] // 발표 점수    var halloffame : [Int] = [] // 명예의 전당        for i in score.indices {        if i &lt...",
    "content": "import Foundationfunc solution(_ k:Int, _ score:[Int]) -&gt; [Int] {        var result : [Int] = [] // 발표 점수    var halloffame : [Int] = [] // 명예의 전당        for i in score.indices {        if i &lt; k { // k일차 까지            halloffame.append(score[i]) // 먼저 해당 값을 명예의 전당으로 넣는다.            halloffame.sort(by:&lt;) // 그후 오름차순 정렬을 하고            result.append(halloffame[0]) // 그 첫번째 값을 가져온다.        } else {            if score[i] &gt; halloffame[0] { // score가 명예의 전당 보다 크면                halloffame.append(score[i]) // 명예의 전당에 해당 score등록                halloffame.sort(by:&lt;) // 오름차순                halloffame.removeFirst() // 첫번째 값 제거                result.append(halloffame[0]) // 그다음 첫번째 값 추가                            } else {                result.append(halloffame[0]) // 첫번째 값 추가            }        }            }    return result}팀원들간 코딩테스트 문제를 풀고 발표를 하면서 일단은 풀어야겠다는 생각이 들어 이해한대로 풀었다.테스트는 되어서 끝났다 싶었다. 하지만 제출을 해보니 대부분 틀려서 이게 뭔가 싶었는데처음에 k일차까지의 로직의 순서를 내가 잘못 적어서 대부분 틀리게 나왔었다.// beforeif i &lt; k {     result.append(score[0])    halloffame.append(score[i])    halloffame.sort(by:&lt;)}그래서 반례를 찾아보았다.입력값 〉 3, [100, 30, 40, 150, 300, 200, 200]기댓값 〉 [100, 30, 30, 40, 100, 150, 200] 일때 였고, 기댓값을 보자마자 내가 무슨 실수를 저질렀는지 알아차렸다.그래서 위와 같이 고쳐주었고 결과 값을 리턴하였다.코드를 이쁘게 하는건 그 다음 생각이고 일단은 푸는것에 목표를 두자.보류했던 문제도 결국 고차함수를 써보려고하다가 이상해서 넘긴것들이 많은데, 주말이나 한번 시간내서 진득하게 풀어봐야겠다.sort로 직관적으로 하던걸 조금 수정하였다.최소값으로 접근하여 풀었다.import Foundationfunc solution(_ k:Int, _ score:[Int]) -&gt; [Int] {        var result : [Int] = []    var halloffame : [Int] = []        for i in score.indices {        if i &lt; k { // 초기 k일까지.            halloffame.append(score[i]) // 명예의 전당에 해당일차의 score값을 추가.            result.append(halloffame.min()!) // 발표점수에 최하위 점수를 추가.        } else { // k일 이후            if score[i] &gt;= halloffame.min()! { // score값이 명전 최소값과 크거나 같다면?                halloffame.append(score[i]) // 명예의 전당에 해당 score값을 추가                halloffame.remove(at:halloffame.firstIndex(of:halloffame.min()!)!) // 최소값에 해당하는 위치의 값을 명예의 전당에서 삭제                result.append(halloffame.min()!) // 발표점수에 최하위 점수를 추가                            } else { // score값이 작다면?                result.append(halloffame.min()!) // 발표점수에 최하위 점수를 추가            }        }            }    return result}"
  },
  
  {
    "title": "(Deep Dive) Closure",
    "url": "/posts/(Deep-Dive)-Closure/",
    "categories": "Udemy, Deep Dive",
    "tags": "클로저",
    "date": "2024-03-06 11:11:00 +0900",
    





    
    "snippet": "1. 클로저란?  클로저는 본질적으로 이름이 없는 익명 함수이다.우리가 보통 함수를 정의 할때func functionName (parameter : parameterType) -&gt; returnType {    //code        return output}이런식으로 구현하였다.이렇게 뭔가 정제되지않은 값이 들어가면 함수를 통해 정제된 값으로 ...",
    "content": "1. 클로저란?  클로저는 본질적으로 이름이 없는 익명 함수이다.우리가 보통 함수를 정의 할때func functionName (parameter : parameterType) -&gt; returnType {    //code        return output}이런식으로 구현하였다.이렇게 뭔가 정제되지않은 값이 들어가면 함수를 통해 정제된 값으로 나오게된다.즉 함수는 패키지화 된 기능의 집합체 이다.그리고 함수에 이름을 부여하여 이후에 해당 기능이 필요하면 언제든지 이름을 호출하여 사용 할 수 있다.함수는 함수를 입력값으로 받아 출력을 할 수 있다.코드를 보자import UIKitfunc calculator (n1 : Int, n2 : Int) -&gt; Int {        return n1 + n2}calculator(n1: 2, n2: 3) // 5두값을 더하는 계산기 함수를 만들었다.그럼 이번에 저 계산기의 입력값을 함수로 받고 싶다면 어떻게 해야할까?우선 add라는 함수를 하나 더 만들어 주었다.func add (no1 : Int, no2:Int) -&gt; Int {        return no1 + no2}함수를 다른 함수의 파라미터로 넣기 위해선 이함수를 데이터타입으로 간추려야 한다.func calculator (n1 : Int, n2 : Int) -&gt; Int {        return n1 * n2}func add (no1 : Int, no2:Int) -&gt; Int {        return no1 + no2}// 곱을 구하는 함수도 추가로 생성해주었다.func multiply (no1 : Int, no2 : Int) -&gt; Int {        return no1 * no2}현재는 두 함수 모두 Int type의 파라미터를 받고, Int type으로 리턴을 하고 있다.즉 이걸 데이터 타입으로 표현을 해보면(Int, Int) -&gt; Int 인걸 알 수 있다.이걸 calculator 함수에 넣어보자.그리고 매개변수명을 operation으로 해주었다.return또한 그에 맞게 고쳐준다.func calculator (n1 : Int, n2 : Int, operation : (Int, Int) -&gt; Int) -&gt; Int {    //                                            ---  ---    //                                             n1   n2    return operation(Int, Int)}그다음 위에있는 return도 바꿔주자!return operation(n1, n2)이렇게 되면, n1과 n2가 operation을 통과하게 된다.그럼 함수를 다시 호출 해보자calculator(n1: 2, n2: 3, operation: add) // 5calculator(n1: 2, n2: 3, operation: multiply) // 6우선 n1, n2값이 calculator 함수로 가게 된다. 그리고 add 함수를 호출하게되고 그 n1, n2값이 add 함수로 전달이 된다.뭔가 이렇게 쓰니 코드가 장황 해진다. 이때 클로저를 사용하여 간략하게 표시 할 수 있다.2. 클로저 함수로 전환하는 방법다음과 같은 함수가 있다.    func sum (firstNumber : Int, secondNumber : Int) -&gt; Int {//            -------------------------------------     ---//                           Input                     output        return firstNumber + secondNumber    }우선 func와 함수의 이름을 지운다.(firstNumber : Int, secondNumber : Int) -&gt; Int {    return firstNumber + secondNumber}그리고 Arrow function 뒤에있는 대괄호({) 이걸 앞으로 옮겨준다 그리고 옮겼던 자리에 in을 적어준다{   (firstNumber : Int, secondNumber : Int) -&gt; Int in//                                                 --    return firstNumber + secondNumber}이걸 바탕으로 multiply 함수를 클로저 형식으로 바꿔보자.import UIKitfunc calculator (n1 : Int, n2 : Int, operation : (Int, Int) -&gt; Int) -&gt; Int {    return operation(n1, n2)}func add (no1 : Int, no2:Int) -&gt; Int {    return no1 + no2}func multiply(no1: Int, no2: Int) -&gt; Int {    return no1 * no2}calculator(n1: 2, n2: 3, operation: multiply)지우면 이렇게 된다.{ (no1: Int, no2: Int) -&gt; Int in    return no1 * no2}calculator(n1: 2, n2: 3, operation: )이렇게 지운걸 operation 저기에 옮겨주면서 더 줄일 수 있다!no1, no2의 데이터 타입을 지워준다.  지워줘도 swift는 리턴 타입을 통해 input의 데이터타입을 추론 할 수있다.calculator(n1: 2, n2: 3, operation:{ (no1, no2) -&gt; Int in    return no1 * no2} )그 다음엔 Arrow function과 return type과 return 키워드도 지워주자!이것 역시도 스위프트가 추론을 할 수 있기에 가능한 것이다.calculator(n1: 2, n2: 3, operation:{ (no1, no2) in no1 * no2 }) 이렇게 바뀌었다.그리고 매개변수명 역시 바꿀 수 있다.  익명 매개 변수명으로 바꾸자.          $0은 첫번째 매개변수를 의미한다.      $1은 두번째 매개변수를 의미한다.      calculator(n1: 2, n2: 3, operation:{$0 * $1}) {$0 * $1}을 트레일링 클로저라고 한다.let result = calculator(n1: 2, n2: 3, operation:{$0 * $1}) let result = calculator(n1: 2, n2: 3){$0 * $1} 이렇게 간소화가 된다.클로저사용의 장점은 코드가 간소화가 되는것이지만 그 간소화로인해 가독성이 떨어지는게 단점이다.3. 클로저의 실제 활용배열의 값에 모두 1씩 더해보자.let array = [6,2,3,9,4,1]swift는 map을 제공하는데 컬렉션 유형의 모든 항목을 변환 할 수있다.let array = [6,2,3,9,4,1]func addOne (n1:Int) -&gt; Int {        return n1 + 1}print(array.map(addOne)) // [7, 3, 4, 10, 5, 2]이걸 위의 방법으로 클로저로 만들어 보자print(array.map{$0 + 1}) // [7, 3, 4, 10, 5, 2]4. 마무리일반적인 클로저 표현은 다음과 같다.{ (parameters) -&gt; return type in    statements}  괄호로 입력 파라미터를 감싸준다.  -&gt; 를 통해 반환 유형을 명시한다.  in은 클로저 바디의 시작을 나타낸다.클로저에 관한 Docs이다 나중에 한번 읽어보자.https://docs.swift.org/swift-book/documentation/the-swift-programming-language/closures/"
  },
  
  {
    "title": "Clima (2)",
    "url": "/posts/Clima-(2)/",
    "categories": "Udemy, Clima",
    "tags": "API, Networking",
    "date": "2024-03-06 06:11:00 +0900",
    





    
    "snippet": "API 사용.  개발자들에게 일반 작업을 수행할 수있는 표준 명령을 제공해준다.      일종의 단순 계약으로 볼 수 있다. (개발자와 API공급자 간의 계약)    날씨 정보를 사용할 API : Weather API  링크https://openweathermap.org/api  API를 다루려면 Key가 필요하다.      가입하고 키를 복사해두자....",
    "content": "API 사용.  개발자들에게 일반 작업을 수행할 수있는 표준 명령을 제공해준다.      일종의 단순 계약으로 볼 수 있다. (개발자와 API공급자 간의 계약)    날씨 정보를 사용할 API : Weather API  링크https://openweathermap.org/api  API를 다루려면 Key가 필요하다.      가입하고 키를 복사해두자. (여긴 가입하고 시간이 지나야 key가 Activate가 되는듯 하다. 기다리고 해보자.)    도시이름을 이용한 날씨 API 사용  https://api.openweathermap.org/data/2.5/weather?id={city id}&amp;appid={API key} 이런식의 형태를 가진다.이런식으로 결과 값이 나오는데, json viewer를 chrome extensions에 설치 해두자.json viewer 를 통해 날씨 값을 가져왔다.키 활성화 하는데 한 20분 정도 걸린것같다.API를 사용하는 스위프트 파일 생성.  swift 파일을 하나 생성하자 (Model → WeatherManager.swift)그리고 구조체를 만들어 준다.import Foundationstruct WeatherManager {    let weatherURL = \"http://api.openweathermap.org/data/2.5/weather?appid=b5005bab606b11d2b82b3dae1b2bc221&amp;units=metric\"        func fetchWeather (cityName : String) {        let urlString = \"\\(weatherURL)&amp;q=\\(cityName)\"        print(urlString)    }}weatherURL에 실제로 테스트를 해본 URL을 적고 도시만 빼고 적는다.뷰 컨트롤러로 돌아와 도시입력을 끝마치고 url을 리턴을 하기 위해 textFieldDidEndEditing 함수를 고쳐준다.func textFieldDidEndEditing(_ textField: UITextField) {                if let city = searchTextField.text {            weatherManager.fetchWeather(cityName: city)        }                //Use searchTextField.text to get the weather for that city        searchTextField.text = \"\"    }if let을 사용한것은, 옵셔널 타입을 방지하기 위해서이다.실행을 해보자!주소가 리턴이 되는걸 알 수 있다.실제로 네트워킹을 통해 값을 가져오기.  네트워킹          우리가 만든 앱은 API를 통해 웹 서버로 데이터를 요청한다.                  이때 요청하면서 일부 쿼리를 넘긴다          여기서 쿼리에는 도시이름 같은 원하는것에 대한 쿼리이다.                    웹서버는 우리 앱에 반응해 요청한 데이터를 전송한다.        네트워킹의 4단계          URL 생성                  URL 구조체를 통해 변수 생성                      URL세션 생성                  let session = URLSession(configuration: .default)                    세션에 작업을 준다.                  let task = session.dataTask(with: url, completionHandler: &lt;#T##(Data?, URLResponse?, Error?) -&gt; Void#&gt;)                          with : url주소          completionHandler : Parameter처럼 보이지만 함수이다!                          작업이 끝나고 하는 행동이다.              여기선 새로운 함수를 만들어 주었다.                          func handle(data: Data?, response: URLResponse?, error: Error?) {  // -&gt; Void 해도되고, return Void도 가능, 아예 언급을 안해도 된다.  if error != nil { // 에러가 발생하면 출력      print(error!)      return // 여기선 return을 사용하면 함수를 빠져나가 아무것도 하지말라는 것이다  }              if let safeData = data {      let dataString = String(data: safeData, encoding: .utf8)      // Data타입은 그냥 프린트 할수 없으므로 위의 작업을 고쳐 프린트 해줘야한다.      print(dataString)      }  }                                          실제로 작업시작.                  task.resume()                    import Foundationstruct WeatherManager {    let weatherURL = \"http://api.openweathermap.org/data/2.5/weather?appid=b5005bab606b11d2b82b3dae1b2bc221&amp;units=metric\"        func fetchWeather (cityName : String) {        let urlString = \"\\(weatherURL)&amp;q=\\(cityName)\"        performRequest(urlString: urlString)    }        func performRequest(urlString : String){        // 1. Create a URL                if let url = URL(string: urlString) {                        // 2. Create a URLSession                        let session = URLSession(configuration: .default)                        // 3. Give the session a task                        let task = session.dataTask(with: url, completionHandler: handle(data:response:error:))                        // 4. Start the task                        task.resume()        }    }        func handle(data: Data?, response: URLResponse?, error: Error?) {        // -&gt; Void 해도되고, return Void도 가능, 아예 언급을 안해도 된다.        if error != nil { // 에러가 발생하면 출력            print(error!)            return // 여기선 return을 사용하면 함수를 빠져나가 아무것도 하지말라는 것이다        }                if let safeData = data {            let dataString = String(data: safeData, encoding: .utf8)            // Data타입은 그냥 프린트 할수 없으므로 위의 작업을 고쳐 프린트 해줘야한다.            print(dataString)        }    }    }일단 에러코드가 어떻게 나오는지 실행해보자! 도시를 입력하고 검색하니바로 에러가 발생한다!에러메세지는 다음과 같다.뭐 간단하게 하면 안전한 경로로 하지않았다는 것이다.http://~ 였던 주소를 https://~ 로 바꿔주자!그리고 실행을 했더니!아까 웹으로 봤을때의 그 값이 출력이 된다!즉 서로 통신이 되었다는것이다!!!다시 dataTask를 고쳐주자. with는 url그대로 적어주고다시 만들면 이렇게 회색이되는데 클릭을 하면 파란색으로 바뀌는데 이떄 엔터를 치면 트레일링 클로저로 바뀐다!여기서 엔터를 치면?이렇게 바뀐다!!그리고 handle 함수 만들었던것을 지우고 dataTask에 넣어주자.let task = session.dataTask(with: url) { (data, response, error) in    if error != nil { // 에러가 발생하면 출력        print(error!)         return // 여기선 return을 사용하면 함수를 빠져나가 아무것도 하지말라는 것이다    }                    if let safeData = data {        let dataString = String(data: safeData, encoding: .utf8)        // Data타입은 그냥 프린트 할수 없으므로 위의 작업을 고쳐 프린트 해줘야한다.        print(dataString)        }    }safeData 테스트를 통해 값을 전달 받는걸 알았다.현재 이값은 JSON 형식으로 받고있다.  JSON?      JavaScript Object Notation의 약자이다.속성-값 쌍(attribute–value pairs), 배열 자료형(array data types) 또는 기타 모든 시리얼화 가능한 값(serializable value) 또는 키-값 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷이다. 비동기 브라우저/서버 통신 (AJAX)을 위해, 넓게는 XML(AJAX가 사용)을 대체하는 주요 데이터 포맷이다. 특히 인터넷에서 자료를 주고 받을 때 그 자료를 표현하는 방법으로 알려져 있다. 자료의 종류에 큰 제한은 없으며, 특히 컴퓨터 프로그램의 변수값을 표현하는 데 적합하다JSON을 Parse할 함수를 만들어 주었다. (출처: 위키백과)  func performRequest(urlString : String){        if let url = URL(string: urlString) {            let session = URLSession(configuration: .default)            let task = session.dataTask(with: url) { (data, response, error) in                if error != nil { // 에러가 발생하면 출력                    print(error!)                    return // 여기선 return을 사용하면 함수를 빠져나가 아무것도 하지말라는 것이다                }                                if let safeData = data {                    self.parseJSON(weatherData: safeData)                }            }            task.resume()        }    }        func parseJSON(weatherData: Data) {            }새로운 파일을 하나 생성해준다Json 내용을 담을 WeatherData이다.우리가 아까 얻었던 그 여러 결과값을 담을 변수를 구조체 안에 만들어주자그전에 우리가 가져온 데이터를 디코더 할 프로토콜을 적어주자.import Foundationstruct WeatherData : Decodable{    //               ----------    let name : String    }그리고 다시 WeatherManager로 돌아가 parseJSON 함수를 수정해준다.func parseJSON(weatherData: Data) {        let decoder = JSONDecoder()        decoder.decode(WeatherData.self, from: weatherData)    }weatherData.self인 이유는 날씨 데이터 형식을 지정하려면, 그 개체에.self를 하면 전달하는 데이터 형식으로 바뀐다.하지만 여전히 에러가 발생한다.디코딩할 호출은 던질수 있으나, try로 되어있지 않아 오류를 처리할 수 없다고 한다.decode 설명을 자세히 보면 () 뒤에 throws -&gt; T where T : Decodable 이렇게 되어있다.지금 우리가 적은것엔 그내용이 없어서 에러가 뜬것이다.do {    try decoder.decode(WeatherData.self, from: weatherData)    } catch {    print(error)    }do는 일반적인 상황이고 catch가 에러가 났을때 이다.에러가나면 에러를 출력하게 했다.저걸보니 자바가 생각이 났다.디코드 출력.WeatherData 오브젝트 생성let decodedData = try decoder.decode(WeatherData.self, from: weatherData)decodedData가 우리가 만든 weatherData Type으로 되었다.다시 JSON 양식으로 돌아가서…temp의 path를 복사해보자decodedData.name 을 decodedData.main.temp 이렇게 바꾸자.당연히 없는 양식이니 에러가 발생할것이다.WeatherData로 가서 변수를 만들어주자!Main은 이하 6개의 변수를 가지고 있다.그러므로 그냥 변수를 만들게 아니라, Main이라는 이름의 구조체를 만들어 주어야한다!그리고 temp의 데이터타입은 우리가 임의대로 해서는 절대 안된다.위의 사진대로 소수점을 표시하고 있기에 소수점을 나타내는 데이터 타입을 해줘야한다!struct WeatherData : Decodable{    let name : String    let main : Main}struct Main :Decodable {    let temp : Double}weather description이 나오게 해보기.우선 path를 복사해보자.weather[0].description 다음과 같다.즉 우린 배열이 필요하다는걸 알게되었다.struct WeatherData : Decodable{    let name : String    let main : Main    let weather : [Weather]}이렇게 weather 변수를 만들고 Weather를 담을 배열을 만들었다.그리고 구조체도 만들어주자struct Weather : Decodable {    let description : String}그나저나 강의대로 하고있는데 출력이 안된다…한번 고쳐봐야겠다.어디서 부터 문제일까 해서 혹시나 하는 마음에 url주소부터 보았다.왜냐 프린트가 안된다는것은 API를 통한 네트워킹이 안된다고 생각을 하였기 때문이다.아니나 다를까…공백이 있다!?!\"https ://api.openweathermap.org/data/2.5/weather?appid=b5005bab606b11d2b82b3dae1b2bc221&amp;units=metric\"아마 http: https:의 차이를 적으면서 그렇게 된것같다…조심하자 ㅠㅠ"
  },
  
  {
    "title": "1주차 (7)",
    "url": "/posts/Main-campus_1st-week-7/",
    "categories": "캠프, 1주차",
    "tags": "배열",
    "date": "2024-03-06 01:11:00 +0900",
    





    
    "snippet": "1. 배열 (Array)  배열은 동일한 타입의 요소를 저장하는 순서가 있는 컬렉션이다.  Index는 1부터가 아닌 0부터 시작한다.  처음에 배열의 길이를 미리 정하지 않아도 된다.1. 관련 메서드1. 배열 갯수 확인 : array.countvar array1 = [1, 2, 3]array1.count // 12. 배열 요소 추가1. array.a...",
    "content": "1. 배열 (Array)  배열은 동일한 타입의 요소를 저장하는 순서가 있는 컬렉션이다.  Index는 1부터가 아닌 0부터 시작한다.  처음에 배열의 길이를 미리 정하지 않아도 된다.1. 관련 메서드1. 배열 갯수 확인 : array.countvar array1 = [1, 2, 3]array1.count // 12. 배열 요소 추가1. array.append// append : 배열의 마지막에 추가var array1 = [1, 2, 3]array1.append(4)                            // [1, 2, 3, 4]// 여러값을 한번에 추가할 때array1.append(contentsOf: [5, 6, 7])        // [1, 2, 3, 4, 5, 6, 7] 2. array.insert// insert : 배열의 중간에 추가var array2 = [1, 2, 3]array2.insert(0, at: 0)                      // [0, 1, 2, 3]array2.insert(contentsOf: [10, 100], at: 2)  // [0, 1, 10, 100, 2, 3 ]3. 배열 값 변경1. Subscript로 변경var array1 = [1, 2, 3]// 0 번째 인덱스의 값을 10으로 ㅂ꾸기array1[0] = 10                       // [10, 2, 3]// 0~2 번째 인덱스의 값을 순서대로 10,20,30으로 바꾸기array1[0...2] = [10, 20, 30]         // [10, 20, 30]// 0~2번째 인덱스의 값을 0으로 바꾸기, 즉 1,2번째 값에 대한 내용이 없으므로 빈배열로 처리가 되어 [0] 만 남게 된다.array1[0...2] = [0]                  // [0]// 0번째 인덱스의 값을 빈배열로 만들기array1[0..&lt;1] = []                   // []2. replaceSubrangearray2.replaceSubrange(0...2, with: [10, 20, 30])     // [10, 20, 30]array2.replaceSubrange(0...2, with: [0])              // [0]array2.replaceSubrange(0..&lt;1, with: [])               // []4. 배열 값 삭제1. 일반적인 삭제var array1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]// 2번째 인덱스 삭제 array1.remove(at: 2)             // [1, 2, 4, 5, 6, 7, 8, 9]// 첫번째 삭제하기 : removeFirst()array1.removeFirst()             // [2, 4, 5, 6, 7, 8, 9]// 첫번째 부터 2개의 값 삭제하기 : removeFirst(2)   array1.removeFirst(2)            // [5, 6, 7, 8, 9]// 마지막 삭제하기 : removeLast()array1.removeLast()              // [5, 6, 7, 8]// 마지막 삭제하기 : popLast()array1.popLast()                 // [5, 6, 7] // 마지막 2개의 값 삭제하기 : removeLast(2)array1.removeLast(2)             // [5]// 전부 삭제하기 : removeAll()array1.removeAll()               // [] 2. 특정 범위 삭제var array2 = [1, 2, 3, 4, 5, 6, 7, 8, 9] // Index로 1~3번까지의 인덱스 삭제 : removeSubrange(1...3) array2.removeSubrange(1...3)     // [1, 5, 6, 7, 8, 9] // 0~1 index를 [] 빈배열로 처리 함으로써 값 삭제하기array2[0..&lt;2] = []               // [6, 7, 8, 9]5. 배열 비교하기var array1 = [1, 2, 3]var array2 = [1, 2, 3]var array3 = [1, 2, 3, 4, 5,] array1 == array2                    //true// 모든 요소가 같은 값인지? : elementsEqual(Array)array1.elementsEqual(array3)        //false6. 배열 정렬하기let array1 = [1, 5, 3, 8, 6, 10, 14] // sort : 배열을 직접 \"오름차순\"으로 정렬array1.sort()// [1, 3, 5, 6, 8, 10, 14] // 1-1. sort + 클로저 : 배열을 직접 \"내림차순\"으로 정렬array1.sort(by: &gt;) // [14, 10, 8, 6, 5, 3, 1]  // 2. sorted : 원본은 그대로 두고, \"오름차순\"으로 정렬된 새로운 배열을 만들어 리턴let sortedArray = array1.sorted() // [1, 3, 5, 6, 8, 10, 14] // 2-1. sorted + 클로저 : 원본은 그대로 두고, \"내림차순\"으로 정렬된 새로운 배열을 만들어 리턴let sortedArray2 = array1.sorted(by: &gt;)// [14, 10, 8, 6, 5, 3, 1]2. 세트 (Set)  집합이다.  순서는 상관이 없고, 같은 타입의 값만 저장을 한다.  모든 값은 고유해야 하므로 중복을 허용하지 않는다.1. 자주 사용하는 메서드1. 값 추가var letters = Set&lt;String&gt;()// 값 넣기 : insert // 배열은 append 였으나 set는 다르다!letters.insert(\"Classical Music\")2. 값 업데이트// update : 삽입, 교체, 추가var set1: Set&lt;Int&gt; = [1,1,2,2,3,3]set1.update(with: 1) // 1 -&gt; 기존에 있던 요소이므로 값을 옵셔널 타입으로 리턴set1.update(with: 7) // nil -&gt; 기존에 없던 요소이므로 Set에 요소가 추가되고 nil 리턴set1.remove(1) // 1 -&gt; 삭제된 요소를 리턴set1 // [2,3,7]set1.remove(5) // nil -&gt; 존재하지 않는 요소를 삭제했을 때 에러는 발생하지 않고 nil 리턴// 전체요소 삭제set1.removeAll()set1.removeAll(keepingCapacity: true) // 요소는 제거하지만 메모리는 제거하지 않는다3. 집합let oddDigits: Set = [1, 3, 5, 7, 9]let evenDigits: Set = [0, 2, 4, 6, 8]let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]// 합집합oddDigits.union(evenDigits).sorted()// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]// 교집합oddDigits.intersection(evenDigits).sorted()// []// 차집합oddDigits.subtracting(singleDigitPrimeNumbers).sorted()// [1, 9]// 대칭 차집합oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()// [1, 2, 9]3. 딕셔너리 (Dictionary)  사전을 생각하면 된다.  순서는 상관 없고 key, value로 되어있다.          key는 중복이 불가능      모든 key는 동일한 타입이어야 한다.      모든 value 역시 동일한 타입이어야 한다.      1. 자주 사용하는 메서드var namesOfIntegers: [Int: String] = [:]namesOfIntegers[16] = \"sixteen\" // 16은 subscript가 아니라 \"키\"임// 초기화namesOfIntegers = [:]var airports: [String: String] = [\"YYZ\": \"Toronto Pearson\", \"DUB\": \"Dublin\"]airports.keys // [\"YYZ\", \"DUB\"]airports.values // [\"Toronto Pearson\", \"Dublin\"]airports.keys.sorted() // [\"DUB\", \"YYZ\"]airports.values.sorted() // [\"Dublin\", \"Toronto Pearson\"]airports[\"APL\"] = \"Apple International\"// airports = [\"YYZ\": \"Toronto Pearson\", \"DUB\": \"Dublin\", \"APL\": \"Apple International\"]// key에 매칭된 value 값 초기화airports[\"APL\"] = nil// 딕셔너리 airports에 있는 값의 수print(airports.count)// 출력값: 2// 딕셔너리 airports에 있는 모든 key들print(airports.keys)// [\"YYZ\", \"DUB\"]// 해당 key가 있다면 value를 덮어쓰고, 덮어쓰기 전 기존값울 반환// 즉 updateValue를 하게 되면 새로 생성 한변수에 기존에 있던 \"Toronto Pearson\"이 들어가게 되고,// 딕셔너리에는 [\"YYZ\" : \"Hello YYZ\"] 이렇게 바뀐다.// 다만 타입은 옵셔널로 바뀌는게, 값이 있을수도, 없을수도 있기 때문이다.let newYyz = airports.updateValue(\"Hello YYZ\", forKey: \"YYZ\")            print(newYyz) // 출력값: Optional(\"Toronto Pearson\")print(airports[\"YYZ\"]) // 출력값: Optional(\"Hello YYZ\")// 해당 key가 없다면 그 key에 해당하는 value에 값을 추가하고 nil을 반환let newApl = airports.updateValue(\"Hello APL\", forKey: \"APL\") print(newApl) // 출력값: nilprint(airports[\"APL\"]) // 출력값: Optional(\"Hello APL\")"
  },
  
  {
    "title": "(Deep Dive) Protocols and Delegates",
    "url": "/posts/(Deep-Dive)-Protocols-and-Delegates/",
    "categories": "Udemy, Deep Dive",
    "tags": "",
    "date": "2024-03-06 00:00:00 +0900",
    





    
    "snippet": "Protocol과 Delegate를 응급 구조 상황에 빗대어 코드를 작성하였다.protocol AdvancedLifeSupport {    func performCPR() // cpr을 할 수 있는 응급 구조 인증서(프로토콜)}class EmergencyCallHandler { // 응급실 콜센터 직원    var delegate : AdvancedL...",
    "content": "Protocol과 Delegate를 응급 구조 상황에 빗대어 코드를 작성하였다.protocol AdvancedLifeSupport {    func performCPR() // cpr을 할 수 있는 응급 구조 인증서(프로토콜)}class EmergencyCallHandler { // 응급실 콜센터 직원    var delegate : AdvancedLifeSupport? // 그 대리인은 응급 구조 인증서가 있는가? 있을수도 있고 ~ 없을수도 있고.        func assessSituation() { // 상황 파악        print(\"Can you tell me what happened?\")    }        func medicalEmergency(){ // 응급 상황 발생, 대리인이 cpr수행.        delegate?.performCPR()    }}struct Paramedic: AdvancedLifeSupport { // 응급구조사 구조체 생성.       init(handler: EmergencyCallHandler){ // 담당자가 누구인지        handler.delegate = self // 담당자의 대리인을 자신으로 설정.    }        func performCPR() {        print(\"The paramedic does chest compressions, 30 per second.\")    }    }class Doctor : AdvancedLifeSupport {        init(handler: EmergencyCallHandler){        handler.delegate = self    }        func performCPR() {        print(\"The doctor does chest compresssions, 30 per second.\")    }        func useStethescope() {        print(\"Listening for heart sounds\")    }}class Surgeon : Doctor {    override func performCPR() {        super.performCPR()        print(\"Sings staying alive by the BeeGees\")    }        func useElectricDrill() {        print(\"Whirr...\")    }    }let emilio = EmergencyCallHandler() // 오늘의 읍급 콜 센터 직원은 emilio//let pete = Paramedic(handler: emilio) // emilio가 통지를 해준다.let angela = Surgeon(handler: emilio)emilio.assessSituation() // 뭔가 상황이 발생하면 전화가 에밀리오에가 가고 에밀리오는 상황 파악을 한다.emilio.medicalEmergency() // 상황 파악 후 비상사태 선언// Doctor, Surgeon이 없을때의 출력, 비상상태 선언을 하니 pete가 위임받고 대신 하고 있다.// Can you tell me what happened? from emilio (EmergencyCallHandler)// The paramedic does chest compressions, 30 per second. from pete (Paramedic)// Doctor, Surgeon이 있고, angela를 통해서 선언시.// Can you tell me what happened? from emilio (EmergencyCallHandler)// The doctor does chest compresssions, 30 per second. from Doctor// Sings staying alive by the BeeGees from Surgeon얼추 감은 오지만 그래도 완벽하다고는 할 수 없다.조만간 한번더 강의를 듣고, 자료를 찾아보면서 보완을 해야 할 것 같다."
  },
  
  {
    "title": "206. 콜라 문제",
    "url": "/posts/206.-%EC%BD%9C%EB%9D%BC-%EB%AC%B8%EC%A0%9C/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-05 15:43:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ a:Int, _ b:Int, _ n:Int) -&gt; Int {        var portion : Int = 0    var mod : Int = 0    var answer : Int = 0    var N = n            while N &gt;= a {        port...",
    "content": "import Foundationfunc solution(_ a:Int, _ b:Int, _ n:Int) -&gt; Int {        var portion : Int = 0    var mod : Int = 0    var answer : Int = 0    var N = n            while N &gt;= a {        portion = (N / a) * b        mod = N % a        N = portion + mod               answer += portion         }    return answer}일단 몫, 나머지를 구분하였다.무한 반복을 통해 몫과 나머지의 합이 a 미만일때 종료하게 하였다.몫만 하게 되면 혹시라도 나머지가 남아있는 경우 그합으로 또 바꿀 수 있는 조건이 될 수도 있기 때문이다.그래서 몫 부분을 계속 더했고 그 결과 값을 리턴하였다."
  },
  
  {
    "title": "205. 푸드 파이트 대회",
    "url": "/posts/205.-%ED%91%B8%EB%93%9C-%ED%8C%8C%EC%9D%B4%ED%8A%B8-%EB%8C%80%ED%9A%8C/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-05 15:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ food:[Int]) -&gt; String {        var arr = food.map{$0%2 == 0 ? $0/2 : $0/2}    var answer : String = \"\"        var n = 0        for i in arr {        if i != 0 { ...",
    "content": "import Foundationfunc solution(_ food:[Int]) -&gt; String {        var arr = food.map{$0%2 == 0 ? $0/2 : $0/2}    var answer : String = \"\"        var n = 0        for i in arr {        if i != 0 {            for j in 0..&lt;i {                answer += String(n)            }        }        n += 1    }        answer = answer + \"0\" + answer.reversed()    return answer}요근래 swift위주로 공부하다보니 문제를 많이 못 풀었다.반성하자…처음에 문제를 잘못이해 했는데 알고보니 인덱스에 해당하는 숫자가 들어가는 것이었다.그리고 문제를 보니 절반만 구하고 나머지는 그것에 역순으로 들어가는것으로 판단하여, 절반만 구하고 0을 붙이고 reversed()를 붙이면 되겠다는 생각을 하였다.그래서 map을 통해 2로 나눴는데 정리하면서보니 애초에 삼항연산자를 쓸필요가 없었다…2로 나눈것은 절반으로 나눠야 하기때문이다. 나머지는 버리므로 홀수도 몫만 필요했다.그리고 반복문을 통해 n이 0이 아닐때 n을 계속 붙이도록했다 내부 반복문이 끝날때 마다 1씩 증가하게 하였다. 인덱스 때문이다.그리고 나온값에 0을 붙이고 reversed()한것을 붙여서 리턴하였는데, 다른 풀이들을 보니 고차함수로 끝냈다. 사실 반복문 보다 repeating을 쓰면 더 좋았을텐데, 정리하다가 생각이 나버렸다.나중에 다시 풀땐 repeating을 써봐야겠다."
  },
  
  {
    "title": "(Deep Dive) Protocols",
    "url": "/posts/(Deep-Dive)-Protocols/",
    "categories": "Udemy, Deep Dive",
    "tags": "프로토콜",
    "date": "2024-03-05 12:11:00 +0900",
    





    
    "snippet": "프로토콜 → 일종의 인증서의 개념으로 생각하면 될 것 같다.프로토콜 정의protocol Myprotocol {    //Define requirements}  프로토콜이란?      어떤 기능에 적합한 특정 메서드, 프로퍼티 및 기타 요구 사항의 청사진을 의미한다.프로토콜은 클래스, 구조체, 열거형에 의해 채택되며, 프로토콜에 정의 된 요구사항의 실제...",
    "content": "프로토콜 → 일종의 인증서의 개념으로 생각하면 될 것 같다.프로토콜 정의protocol Myprotocol {    //Define requirements}  프로토콜이란?      어떤 기능에 적합한 특정 메서드, 프로퍼티 및 기타 요구 사항의 청사진을 의미한다.프로토콜은 클래스, 구조체, 열거형에 의해 채택되며, 프로토콜에 정의 된 요구사항의 실제 구현을 제공한다.  Class, Struct, Protocol 비교비교는 코드로 대체하겠다.Bird라는 class가 있다.class Bird {        var isFemale = true        func layEgg() {        if isFemale {            print (\"The bird makes a new bird in a shell.\")        }    }        func fly () {        print(\"The bird flaps its wings and lifts off into the sky\")    }}새(조류)라는 클래스는 암컷이고, 알을 낳고, 날수있는 기능(함수)를 가지고 있다.그리고 그 조류를 상속 받은 독수리라는 클래스를 만들어 주었다.class Eagle : Bird { // 상속을 하였다.         func soar(){        print(\"The eagle glides in the air using air currents.\")    }}독수리는 Bird가 가지고있는 기능을 모두 사용 할 수 있다.그리고 조류를 상속받는 펭귄도 만들어보자class Penguin : Bird {    func swin() {        print(\"The penguin paddles through the water.\")    }}펭귄도 역시 조류가 가지고 있는 기능을 모두 사용 할 수있다그런데 상식적으로 펭귄은 날 수 없는데? fly 함수를 사용 할 수 있다.이것은 말이 안된다.그리고 조류 박물관을 하나 구조체로 만들어 주었다.조류 박물관은 조류를 상속 받을 수는 없지만 매개변수로 가져 올 수는 있다.struct FlyingMuseum {    func flyingDemo(flyingObject : Bird) {        flyingObject.fly()    }}그리고 다음과 같이 작성하였다.조류박물관이라는 구조체를 만들었고 거기에 flyingDemo라는 함수를 만들었는데 매개변수의 타입을 조류로 하였고 호출을 하면 fly를 하게끔 하였다.이런식으로도 표현을 할 수 있다.마지막으로 비행기도 해보자.class Airplane : Bird {    override func fly() {        print (\"The airplane uses its engine to lift off into the air.\")    }}비행기도 일단 조류로 넣었다(?) 근데 조류와 달리 엔진을 사용해서 하늘을 비행하니 함수를 오버라이드하여 재정의 해주었다.이렇게 클래스와 구조체를 사용해서 조류에대해 표현을 해봤는데, 상속을 받으면 그 해당기능을 다 사용가능하다.그런데 펭귄은 하늘을 날 수 없고, 비행기는 알을 낳지 못한다.하지만 클래스로 표현하면 이 모든것이 가능해진다.그렇다면, 펭귄은 조류의 클래스를 상속 받으면서 날 수는 없게하고,비행기는 조류의 클래스를 상속 받으면서 알을 낳지 못하게 할 수는 없을까?이때 필요한게 바로 프로토콜이다.프로토콜을 하나 만들어 보자날 수 있게 하기위해 Canfly로 하였다.protocol CanFly {    func fly()}이 때 프로토콜에는 함수의 body내역은 적지 않는다!이런식으로 에러가 뜬다.그리고 조류 클래스도 약간 수정을 해주자.class Bird {        var isFemale = true        func layEgg() {        if isFemale {            print (\"The bird makes a new bird in a shell.\")        }    }}이제 독수리 클래스에 Canfly 프로토콜을 적용해보자!Canfly 프로토콜을 사용했는데 fly 함수가 없어서 에러가 발생한다.그래서 fly함수를 새로 만들어 준다!class Eagle : Bird, CanFly {//           -----  ------//            상속   프로토콜    func fly() {        print(\"The bird flaps its wings and lifts off into the sky\")    }    // 프로토콜에 fly함수가 있으므로, 반드시 fly함수가 들어가야 한다!    func soar(){        print(\"The eagle glides in the air using air currents.\")    }}이젠 조류의 특성을 가지면서, 날 수 있는 함수를 별도로 만들어 주었다!그렇다면 펭귄은 어떨까?펭귄은 그대로 두었고 다만 이제는 fly 함수를 쓸 수가 없다.그리고 비행기로 넘어가자struct Airplane : CanFly {// class에서 struct로 변경하였다. 프로토콜은 구조체, 클래스 둘다 사용가능하다!    func fly() {        print (\"The airplane uses its engine to lift off into the air.\")    }}클래스였던것을 구조체로 바꾸어 주었다.그리고 재정의 했던것이 이제는 의미가 없으므로 override는 지워주었다.그리고 박물관 역시 바꿔준다. 왜냐 Bird 클래스엔 더이상 fly가 없기 때문이다!struct FlyingMuseum {    func flyingDemo(flyingObject : CanFly) {        flyingObject.fly()    }}myEagle, myPlane은 Canfly 프로토콜을 가지고 있고위에 FlyingMuseumdㅔ도 매개변수의 타입을 Canfly 프로토콜을 가진 타입으로 하였다.펭귄으로 하면 어떻게 될까?이렇게 Canfly가 없다고 나온다.이제 더이상 펭귄은 날수가 없다…이미지로 정리해보면처음에는 이렇게 모두 날 수 있었다.그러다보니 날수 없는 조류도 fly라는 기능을 가질 수 있었다.하지만 프로토콜을 적용하면서분류를 하게 된것이다.프로토콜을 새로 비유를 하여 해보았다.여러 프로토콜을 사용할때는 다음과 같이 사용하면된다.struct Mystructure: FirstProtocol, AnotherProtocol {    // code}class MyClass : SuperClass, FirstProtocol, AnotherProtocol {    //code}"
  },
  
  {
    "title": "1주차 (6)",
    "url": "/posts/Main-campus_1st-week-6/",
    "categories": "캠프, 1주차",
    "tags": "스택&큐",
    "date": "2024-03-05 06:11:00 +0900",
    





    
    "snippet": "Stack &amp; Queue  Stack과 Queue는 데이터에 대한 개념이다  Swift에서는 따로 큐와 스택을 지원하지 않으며, Array등을 사용하여 별도로 직접 구현 할 수 있다.1. Queue  First In First Out (F.I.F.O. / 선입선출)  말그대로 먼저 들어온 값을 먼저 내보내는 구조이다./*&lt;T&gt; 에 대...",
    "content": "Stack &amp; Queue  Stack과 Queue는 데이터에 대한 개념이다  Swift에서는 따로 큐와 스택을 지원하지 않으며, Array등을 사용하여 별도로 직접 구현 할 수 있다.1. Queue  First In First Out (F.I.F.O. / 선입선출)  말그대로 먼저 들어온 값을 먼저 내보내는 구조이다./*&lt;T&gt; 에 대해서는 추후 배울 예정제네릭이라는 것인데, 하나의 타입으로 국한되지 않고타입에 유연하게 코드를 작성할 수 있는 기능이다.*/struct Queue&lt;T&gt; {    private var queue: [T] = []        public var count: Int {        return queue.count    }        public var isEmpty: Bool {        return queue.isEmpty    }        public mutating func enqueue(_ element: T) {        queue.append(element)    }        public mutating func dequeue() -&gt; T? {        return isEmpty ? nil : queue.removeFirst()    }}var queue = Queue&lt;Int&gt;()queue.enqueue(10)queue.enqueue(20)queue.dequeue() // 102. Stack  Last In Fisrt Out (L.I.F.O. / 후입선출)  먼저 들어온 값을 가장 마지막에 내보내는 구조  즉 가장 마지막에 들어온 값이 먼저 내보내는 구조/*&lt;T&gt; 에 대해서는 추후 배울 예정제네릭이라는 것인데, 하나의 타입으로 국한되지 않고타입에 유연하게 코드를 작성할 수 있는 기능이다.*/struct Stack&lt;T&gt; {    private var stack: [T] = []        public var count: Int {        return stack.count    }        public var isEmpty: Bool {        return stack.isEmpty    }        public mutating func push(_ element: T) {        stack.append(element)    }        public mutating func pop() -&gt; T? {        return isEmpty ? nil : stack.popLast()    }}var stack = Stack&lt;Int&gt;()stack.push(10)stack.push(20)stack.pop() // 20"
  },
  
  {
    "title": "1주차 과제",
    "url": "/posts/Main-campus_1st-week_Arrange/",
    "categories": "캠프, 1주차",
    "tags": "계산기, 과제",
    "date": "2024-03-05 05:11:00 +0900",
    





    
    "snippet": "1주차 과제가 주어졌다.과제는 다음과 같다.1. Lv1물론 Lv1 ~ Lv4까지 있지만.Step by Step으로 하나씩 해보려고 한다.class Calculator {        func addOperation (_ x: Int, _ y: Int) -&gt; Int {        print(x+y)        return x+y    }    ...",
    "content": "1주차 과제가 주어졌다.과제는 다음과 같다.1. Lv1물론 Lv1 ~ Lv4까지 있지만.Step by Step으로 하나씩 해보려고 한다.class Calculator {        func addOperation (_ x: Int, _ y: Int) -&gt; Int {        print(x+y)        return x+y    }        func substractOperation (_ x: Int, _ y: Int) -&gt; Int {        print(x-y)        return x-y    }        func multiOperation (_ x: Int, _ y: Int) -&gt; Int {        print(x*y)        return x*y    }        func divideOperation (_ x: Int, _ y: Int) -&gt; Int {        print(x-y)        return x/y    }    }일단은 이런식으로 class안에 function을 사용하여 구현하였다.일단은 두수가 Int일때만을 고려하여 계산하였다.2. Lv2나머지를 구하게하는 기능을 추가 해보자.func modOperation (_ x: Int, _ y: Int) -&gt; Int {        print(x%y)        return x%y    }class Calculator {        func addOperation (_ x: Int, _ y: Int) -&gt; Int {        print(x+y)        return x+y    }        func substractOperation (_ x: Int, _ y: Int) -&gt; Int {        print(x-y)        return x-y    }        func multiOperation (_ x: Int, _ y: Int) -&gt; Int {        print(x*y)        return x*y    }        func divideOperation (_ x: Int, _ y: Int) -&gt; Int {        print(x-y)        return x/y    }        func modOperation (_ x: Int, _ y: Int) -&gt; Int {        print(x%y)        return x%y    }    }위의 코드를 추가하였고 결과는 다음과 같다.3. Lv3지금은 각각의 기능이 Class안에 함수로 구현이 되어있는데 이걸이제는 각각의 클래스로 나누어 표현을 해야한다.class Calculator {   }class AddOperation  {   }class SubstractOperation {    }class MutiplyOperation {}class DivideOperation  {}class ModOperation {}우선 각 클래스들을 만들어 주었다.여기서 부터 뭔가 고민이 많아졌다calculator 클래스를 초기화 하면서 내가 원하는 숫자를 미리 calculator(no1 : Int, no2 : Int) 이런식으로 할 건지calculator.~ 이런식으로 나아가서 해결할지. 생각이 많아졌다.일단은 이렇게 구현했다보완// MARK: - 계산기 본체class Calculator {        let add = AddOperation()    let substract = SubstractOperation()    let multiply = MutiplyOperation()    let divide = DivideOperation()    let mod = ModOperation()}// MARK: - 덧셈class AddOperation  {    func operation (first : Int, second : Int) {        print(first + second)    }}// MARK: - 뺄셈class SubstractOperation {    func operation (first : Int, second : Int) {        print(first - second)    }}// MARK: - 곱셈class MutiplyOperation {    func operation (first : Int, second : Int) {        print(first * second)    }}// MARK: - 나눗셈class DivideOperation  {    func operation (first : Int, second : Int) {        print(first / second)    }}// MARK: - 나머지class ModOperation {    func operation (first : Int, second : Int) {        print(first % second)    }}// MARK: - Testlet calculator = Calculator()// MARK: - 계산기 본체class Calculator {        let add = AddOperation()    let substract = SubstractOperation()    let multiply = MutiplyOperation()    let divide = DivideOperation()    let mod = ModOperation()}// MARK: - 덧셈class AddOperation  {    func operation (first : Int, second : Int) {        print(first + second)    }    func operation (first : Int, second : Double) {        print(Double(first) + second)    }    func operation (first : Double, second : Int) {        print(first + Double(second))    }    func operation (first : Double, second : Double) {        print(first + second)    }}// MARK: - 뺄셈class SubstractOperation {    func operation (first : Int, second : Int) {        print(first - second)    }    func operation (first : Int, second : Double) {        print(Double(first) - second)    }    func operation (first : Double, second : Int) {        print(first - Double(second))    }    func operation (first : Double, second : Double) {        print(first - second)    }}// MARK: - 곱셈class MutiplyOperation {    func operation (first : Int, second : Int) {        print(first * second)    }    func operation (first : Int, second : Double) {        print(Double(first) * second)    }    func operation (first : Double, second : Int) {        print(first * Double(second))    }    func operation (first : Double, second : Double) {        print(first * second)    }}// MARK: - 나눗셈class DivideOperation  {    func operation (first : Int, second : Int) {        print(first / second)    }    func operation (first : Int, second : Double) {        print(Double(first) / second)    }    func operation (first : Double, second : Int) {        print(first / Double(second))    }    func operation (first : Double, second : Double) {        print(first / second)    }}// MARK: - 나머지class ModOperation {    func operation (first : Int, second : Int) {        print(first % second)    }    func operation (first : Int, second : Double) {        print(second.truncatingRemainder(dividingBy: Double(first)))    }    func operation (first : Double, second : Int) {        print(first.truncatingRemainder(dividingBy: Double(second)))    }    func operation (first : Double, second : Double) {        print(first.truncatingRemainder(dividingBy: second))    }}"
  },
  
  {
    "title": "1주차 (5)",
    "url": "/posts/Main-campus_1st-week-5/",
    "categories": "캠프, 1주차",
    "tags": "옵셔널",
    "date": "2024-03-05 05:11:00 +0900",
    





    
    "snippet": "Optional1. Optional과 nil1. Optional  값이 없을 수 있는 상황에서 Optional을 사용한다.  옵셔널은 ? 로 나타낸다.  다음 두 가지 가능성을 나타낸다.          값이 있고 옵셔널로 래핑해놓은 값을 언래핑 하여 해다 ㅇ값에 엑세스 할 수 있다.      값이 전혀 없다.        옵셔널 타입끼리의 연산은 불...",
    "content": "Optional1. Optional과 nil1. Optional  값이 없을 수 있는 상황에서 Optional을 사용한다.  옵셔널은 ? 로 나타낸다.  다음 두 가지 가능성을 나타낸다.          값이 있고 옵셔널로 래핑해놓은 값을 언래핑 하여 해다 ㅇ값에 엑세스 할 수 있다.      값이 전혀 없다.        옵셔널 타입끼리의 연산은 불가능하다.// 축약 타입 표현var serverResponseCode: Int? = 404 // 정식 타입 표현var myPetName: Optional&lt;String&gt; = \"멍멍이\"func pay(with card: String?) {   // 구현 코드}// 옵셔널 타입끼리의 연산은 불가능var num1: Int? = 4var num2: Int? = 2num1 + num2 // 에러 발생!let optionalString1: String? = \"Hello, \"let optionalString2: String? = \"world!\"// 옵셔널 String 값들을 연결하려는 시도let result = optionalString1 + optionalString2 // 에러 발생!  참고 자료https://developer.apple.com/documentation/swift/optional/https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics/#Optionals2. nil  변수에 nil을 할당함으로써 값이 없는 상태의 옵셔널 프로퍼티를 만들 수 있다.var serverResponseCode: Int? = 404serverResponseCode = nilvar surveyAnswer: String?// surveyAnswer 는 자동으로 nil 로 설정된다.  참고 자료https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics/#nil2. Optional Binding  옵셔널 값이 빈값인지(nil) 존재하는지 검사한 후, 존재하는 경우 그 값은 다른 변수에 대입시켜 바인딩함.  빈 값을 체크하고 옵셔널 값을 언래핑 해주는 것이 강제로 언래핑(!) 하는 것보다 훨씬 안전하다.  if let , if var, guard let, guard var 를 사용하여 옵셔널 값을 추출해 새로운 변수에 바인딩 한다.          if let vs guard let                  if let은 if문의 코드 구현부 내 ({ code })에서만 사용 가능하다. (지역변수)          guard let은 guard문을 통과한 상수를 guard문 밖에서도 사용이 가능하다. (전역변수)                    if let &lt;#상수 이름#&gt; = &lt;#옵셔널 값#&gt; {   // 구현 코드}let roommateNumbers: Int? = nilif let roommates = roommateNumbers {    print (roommates)}// 출력값 없음let ticketCounts: Int? = 3if let ticket = ticketCounts {    print (ticket)}// 출력값: 3// 옵셔널 바인딩 할 변수가 여러 개인 경우let boyName : String?let girlName : String?boyName = \"하늘\"girlName = \"나연\"// , 콤마로 나열한다if let boy = boyName,   let girl = girlName {    print(boy, girl)}// 출력값: 하늘 나연let x : Int? = 10let y : Int? = nilfunc opbinding() {    guard let x = x else { return }    print(x)    guard let y = y else { return } // y는 nil 이므로 여기서 return     print(y) // 위에서 return 하였기 때문에 이 코드 라인은 실행되지 않음}opbinding()// 출력값: 103. Optional Force Unwrapping  강제 언래핑은 !를 사용하여 강제로 옵셔널을 추출한다.          다만 변수 앞에 !를 붙이는건 not 의미이다.        강제 언래핑을 잘못 사용할 경우 프로그램이 비정상적으로 종료될 수도 있으므로 반드시 nil이 아닌 것이 확실한 상황에서 사용해야한다.          가급적이면 사용하지 않는것이 좋다.      let number = Int(\"42\")!// String값을 Int로 변환하는 함수는 return값으로 옵셔널 값을 반환한다.print(number)// 출력값: 42// 강제 언래핑이 실패한 경우let address: String? = nilprint(address!)// 에러🚨 메시지: Unexpectedly found nil while unwrapping an Optional value4. Nil Coalescing Operator  값이 nil일 경우를 위해 기본값을 설정 할 수있따(nil-coalescing)          ?? 을 사용하여 기본 값을 사용할 수 있는데, ??을 사용하여 기본값을 부여한 변수는 옵셔널 타입이 아니다      let(var) a = b ?? c 형태로 이루어진다                  b가 nil일 경우 a에 c가 대입된다.          b가 nil이 아닐경우엔 a에 옵셔널을 제거한 값이 대입된다.          b → Optional Type          c → Optional Type (X)                    var optNumber: Int? = 3let number = optNumber ?? 5print(number) // 출력값 : 3//number는 Int? 타입이 아니라 Int 타입optNumber = nillet number2 = optNumber ?? 5print(number) // 출력값 : 5//number는 Int? 타입이 아니라 Int 타입print(heartPath)// imagePaths[\"heart\"]가 nil일 때 // 출력값: \"/images/default.png\"5. Optional Chaining  옵셔널을 연쇄적으로 사용하는 것을 말한다.  .을 통해 내부 프로퍼티나 메서드에 연속적으로 접근할 때 옵셔널 값이 있으면 옵셔널 체이닝으로 접근할 수 있다.struct Person {\tvar name: String\tvar address: Address}struct Address {\tvar city: String\tvar street: String\tvar detail: String}let sam: Person? = Person(name: \"Sam\", address: Address(city: \"서울\", street: \"신논현로\", detail: \"100\"))print(sam.address.city) // 에러 🚨. 에러 메시지: Chain the optional using '?' to access member 'address' only for non-'nil' base valuessam?.address.city  // ✅// 출력값: 서울  참고 자료https://developer.apple.com/documentation/swift/optional/https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics/#Optionals"
  },
  
  {
    "title": "1주차 (4)",
    "url": "/posts/Main-campus_1st-week-4/",
    "categories": "캠프, 1주차",
    "tags": "연산자와반복문",
    "date": "2024-03-05 04:11:00 +0900",
    





    
    "snippet": "연산자1. 산술 연산자  덧셈          +      +=        뺄셈          -      +=        곱셈          *        나눗셈          /        나머지          %      var result = 1 + 2print(result)// 출력값: 3result += 5// result =...",
    "content": "연산자1. 산술 연산자  덧셈          +      +=        뺄셈          -      +=        곱셈          *        나눗셈          /        나머지          %      var result = 1 + 2print(result)// 출력값: 3result += 5// result = result + 5print(result)// 출력값: 8result = 10 - 6print(result)// 출력값: 4result -= 3// result = result - 3print(result)// 출력값: 1result = 8 * 2print(result)// 출력값: 16result = 12 / 5print(result)// 출력값: 2result = 10 % 3print(result)// 출력값: 1// result는 10을 3으로 나눈 후 나머지 이므로 12. 비교 연산자  비교한 값을 true or false로 반환한다.  같다 / 같지 않다          a == b      a != b        크다 / 작다          a &gt; b      a &lt; b        크거나 같다 / 작거나 같다          a &gt;= b      a &lt;= b      var result = (1 == 2)print(result)// 출력값: falseresult = (1 != 2)print(result)// 출력값: trueresult = (1 &gt; 2)print(result)// 출력값: falseresult = (1 &lt; 2)print(result)// 출력값: trueresult = (1 &gt;= 2)print(result)// 출력값: falseresult = (2 &lt;= 2)print(result)// 출력값: true3. 논리 연산자  비교한 값을 true or false로 반환한다.  논리 부정 NOT          !a                  true라면 false를 return          false라면 true를 return                      논리 곱 AND          a&amp;&amp;b                  두 값이 모두 true일때 true를 리턴          두 값중 하나라도 false이면 false를 리턴                      논리 합 OR                                                      a                             b                                                둘 중 하나라도 true면 true를 리턴                    var allowedEntry = falseallowedEntry = !allowedEntryprint(allowedEntry)// 출력값: truelet enteredDoorCode = truelet passedRetinaScan = falselet permittedAccess = enteredDoorCode &amp;&amp; passedRetinaScanprint(permittedAccess)// 출력값: falselet enter = allowedEntry || permittedAccessprint(enter)// 출력값: true4. 범위 연산자  (a…b)          a 이상 b 이하        (a..&lt;b)          a 이상 b 미만        a… …a          범위의 시작 또는 끝만 지정하여 사용      a는 포함시킨다.      (1...5)// 1, 2, 3, 4, 5(1..&lt;5)// 1, 2, 3, 4(3...)// 3, 4, 5, 6, 7 ...let names = [\"안나\", \"알렉스\", \"오드리\", \"잭\"]for name in names[2...] {    print(name)}// 출력값: // 오드리// 잭for name in names[...2] {    print(name)}// 출력값: // 안나// 알렉스// 오드리for name in names[..&lt;2] {    print(name)}// 출력값: // 안나// 알렉스5. 삼항 연산자  a ? n : c          question ? answer1 : answer2      question의 답이 true이면 answer1, false이면 answer2      if-else문의 간략화한 버전      let height = 150var nickname = (height &gt; 185) ? \"Daddy Long Legs\" : \"TomTom\"print(nickname)// 출력값: TomTom// 이를 if-else 문으로 표현하면var nickname2 = \"\"if height &gt; 185 {\tnickname = \"Daddy Long Legs\"} else {\tnickname = \"TomTom\"}6. 주의 사항  ※ Swift는 띄어쓰기도 신경써야 하는 언어이다.예를들어a - b 와 a -b는 완전히 다른 의미 a - b는 a에서 b를 빼는 수식이고 a -b 는 a와 -b를 의미  참고 자료https://docs.swift.org/swift-book/documentation/the-swift-programming-language/basicoperators조건문1. if 문  조건을 확인하는 문법  if문에 작성한 조건이 true일때만 구현 부 코드를 실행// if 뒤 \"조건\"은 Bool 타입 즉 true 혹은 false 이어야 한다if &lt;#조건#&gt; {  // 구현부 코드}var temperature = 17if temperature &lt;= 13 {    print(\"쌀쌀한 날씨가 지속되겠습니다.\")} else if temperature &gt;= 22 {    print(\"해가 떠오르는 낮부터는 더위 예상됩니다.\")} else {    print(\"밤낮으로 선선한 날씨가 예상됩니다.\")}// 출력값: 밤낮으로 선선한 날씨가 예상됩니다.if true {\t\tprint(\"항상 실행됩니다\")}// 출력값: 항상 실행됩니다if false {\t\tprint(\"항상 실행됩니다\")}// 출력값: (없음) - if 뒤 조건문이 false이므로 중괄호 내부 코드가 실행되지 않음 2. Swift - case 문  switch 문은 가능한 여러 개의 일치하는 케이스와 값을 비교한다. 그런 다음 일치하는 첫 번째 케이스를 기반으로 구현부 코드 블록을 실행한다.  switch 문은 여러 잠재적 케이스에 대응하기 위해 if 문을 대신 사용할 수 있다.  열거형(enum)과 함께 자주 사용된다.  모든 케이스가 적용되지 않는 경우 default 에 구현된 코드가 실행되며, default는 항상 마지막에 표시되어야 한다.  특정 케이스에 실행 구문이 없을 경우  break 키워드를 반드시 사용해야 한다.  특정 케이스에 해당되어 실행 구문이 실행된 이후에 다음 케이스 블럭을 실행하려면 fallthrough 키워드를 사용한다.if &lt;#조건#&gt; {  // 구현부 코드}switch &lt;#조건#&gt; {case &lt;#값 1#&gt;:    // 구현부 코드case &lt;#값 2#&gt;,    &lt;#값 3#&gt;:    // 구현부 코드default:    // 모든 케이스가 적용되지 않는 경우    // 구현부 코드}let cookieCount = 62let message: Stringswitch cookieCount {case 0:    message = \"🍪 없음 🙅‍♂️\"case 1..&lt;5:    message = \"🍪 아주 조금 있음\"case 5..&lt;12:    message = \"🍪 조금 있음\"case 12..&lt;100:    message = \"🍪 꽤 있음 🍪\"case 100..&lt;1000:    message = \"🍪🍪 많음 🍪🍪\"default:    message = \"🍪🍪🍪엄청 많음🍪🍪🍪\"}print(message)// 출력값: \"🍪 꽤 있음 🍪\"let species = \"시츄\"switch species {case \"말티즈\" :\tprint(\"말티즈입니다\")case \"시츄\":\tbreak // 실행 구문이 없을때는 반드시 break를 써주어야 함default: \tprint(\"강아지입니다\")}var number = 5switch number {case ..&lt;5:    print(\"under 5\")            fallthroughcase 5:    print(\"5\")    fallthrough // 해당 케이스의 구문이 실행된 이후에도 무조건 다음블럭을 실행함default:    print(\"default\")}// 출력 결과 // 5// default// default를 사용하지 않는 예시enum Day { //switch - case와 좋은 콤비     case monday, tuesday, wednesday, thursday, friday, saturday, sunday}func activities(for day: Day) {    switch day {    case .monday:        print(\"월요일: 회사 회의\")    case .tuesday:        print(\"화요일: 운동 가기\")    case .wednesday:        print(\"수요일: 책 읽기\")    case .thursday:        print(\"목요일: 친구와 만나기\")    case .friday:        print(\"금요일: 영화 보기\")    case .saturday:        print(\"토요일: 쇼핑하기\")    case .sunday:        print(\"일요일: 가족과 시간 보내기\")    }}activities(for: .monday)activities(for: .friday)  참고 자료https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow#Conditional-Statements반복문1. for 문- 순회 할 수 있는 타입(배열, 딕셔너리 등)을 순회 하거나 특정 횟수만큼 로직을 반복할 때 주로 사용for 각 value의 변수 이름 in 순회할 수 있는 타입 {     // 내부 로직}let alphabets: [String] = [\"a\", \"b\", \"c\", \"d\"]for character in alphabet {  print(character)}// 출력값: // a// b// c// dlet students = [\"Tom\": 2, \"Harry\": 4, \"Sarah\": 1]for (name, grade) in students {  print(\"\\(name) 은 \\(grade) 학년이야\")}// 출력값: // Tom 은 2 학년이야// Harry 은 4 학년이야// Sarah 은 1 학년이야2. while 문  while문은 특정 조건이 만족하는 동안 내부로직을 계속해서 실행한다.  종결 조건을 정해주지 않으면 무한루프가 생길 위험성이 있다.  while문은 반복문의 각 패스가 시작할 때 조건을 평가한다.// while 뒤의 \"조건\"은 Bool 타입, 즉 true 혹은 false이고, true일때 중괄호 내부 코드 실행while &lt;#조건#&gt; {   // 구현 코드}let lastName : [String] = [\"송\", \"김\", \"박\", \"정\" ]var index : Int = 0while index &lt; 4 {    print(\"옆집 \\(lastName[index]) 씨네 \\(index)번째 결혼식\")    index += 1}// 출력값:// 옆집 송 씨네 0번째 결혼식// 옆집 김 씨네 1번째 결혼식// 옆집 박 씨네 2번째 결혼식// 옆집 정 씨네 3번째 결혼식while true {\t\tprint(\"Hello\") // Hello 가 계속 출력됨}  참고 자료https://docs.swift.org/swift-book/documentation/the-swift-programming-language/controlflow"
  },
  
  {
    "title": "1주차 (3)",
    "url": "/posts/Main-campus_1st-week-3/",
    "categories": "캠프, 1주차",
    "tags": "데이터타입",
    "date": "2024-03-05 02:11:00 +0900",
    





    
    "snippet": "데이터 타입1. 숫자1. Int  정수를 표현하는 데이터 타입  -2,147,483,648 ~ 2,147,483,647 사이 숫자를 표현할 수 있다.var age: Int = 18 // Int 타입  참고 링크https://docs.swift.org/swift-book/documentation/the-swift-programming-language/t...",
    "content": "데이터 타입1. 숫자1. Int  정수를 표현하는 데이터 타입  -2,147,483,648 ~ 2,147,483,647 사이 숫자를 표현할 수 있다.var age: Int = 18 // Int 타입  참고 링크https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics/#Integers2. Float  소수점을 표현하는 데이터 타입으로 32비트 부동 소수를 표현할 수 있다.  Float의 정밀도는 소수점 이하 6자리까지 가능하다.var interestRate: Float = 1.2345678910 // Float 타입print(\"이자율은 \\(interestRate) % 입니다\")// 출력값: 이자율은 1.2345679 % 입니다  참고 링크https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics/#Floating-Point-Numbers3. Double  소수점을 표현하는 데이터 타입으로 64비트 부동소수를 표현할 수 있다.  Double의 정밀도는 소수점 이하 15자리 이상 가능하다.  두 유형 모두 적합한 상황에서는 Double을 사용하는 것이 좋다. (출처: 공식 문서)var interestRate: Double = 1.2345678910123456789 // Double 타입print(\"이자율은 \\(interestRate) % 입니다\")// 출력값: 이자율은 1.2345678910123457 % 입니다  참고 링크https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics/#Floating-Point-Numbers2. 참 또는 거짓1. Bool  참 true와 거짓 false 을 표현할 수 있는 데이터 타입.```swift// Bool 변수 선언 및 초기화var isOpen: Bool = truevar isLogged: Bool = false// 조건문에서 Bool 값 사용if isOpen {    print(“문이 열려 있습니다.”)} else {    print(“문이 닫혀 있습니다.”)}// Bool 값을 반환하는 함수func checkLoginStatus(isLogged: Bool) {    if isLogged {        print(“로그인되었습니다.”)    } else {        print(“로그인되지 않았습니다.”)    }}// 함수 호출checkLoginStatus(isLogged: isLogged)- 참고 링크&lt;https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics/#Booleans&gt;## 3. 문자### 1. String- 문자열을 표현하는 데이터 타입으로 텍스트를 표현할 수 있다.```swiftvar emptyString: String = \"\" var anotherEmptyString = String()  var variableString = \"Mom\"variableString += \" and Dad\"print(variableString)// 출력값: \"Mom and Dad\"  참고 링크https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters/#String-Literals2. Character  하나의 문자를 표현하는 데이터 타입let catCharacters: [Character] = [\"C\", \"a\", \"t\", \"!\", \"🐱\"]let catString = String(catCharacters)print(catString)// Prints \"Cat!🐱\"  참고 링크https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters/#Working-with-Characters4. 다양한 값의 묶음1. Tuple  튜플은 여러 값을 하나로 그룹화한 값.  Tuple은 관련 값의 단순한 그룹에 유용하다. 복잡한 데이터 구조를 만드는 데는 적합하지 않다.let http404Error: (Int, String) = (404, \"Not Found\")let (justTheStatusCode, _): (Int, String) = http404Error // _ 는 사용하지 않겠다는 의미.print(\"The status code is \\(justTheStatusCode)\")// 출력값: \"The status code is 404\"// 튜플 값에 접근하려면 순서를 알고 있어야 한다.print(\"The status code is \\(http404Error.0)\")// 출력값: \"The status code is 404\"print(\"The status message is \\(http404Error.1)\")// 출력값: \"The status message is Not Found\"// 각 엘레먼트에 이름을 붙일 수 있습니다.let http200Status: (Int, String) = (statusCode: 200, description: \"OK\")// 많은 데이터를 담는 데는 적합하지 않다 - 사용하는 쪽에서 또 매핑(Mapping)을 해야 함let myInfo: (String, Int, Int, Int, String, String) = (name: \"peter\", registrationNumber: 970212, height: 185, weight: 75, job: \"developer\", hobby: \"soccer\")  참고 링크https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics/#Tuples5. 모든 타입1. Any  Any는 다양한 데이터 타입의 값을 수용할 수 있다.  Any 배열을 만들면 특정 타입의 배열이 아니라 여러 타입을 담을 수 있다.  하지만 Any 데이터 형을 대입하려면 반드시 형 변환이 필요하다.var anyArray: [Any] = [1,\"Hi\", true]var anyValue: Any = 1000anyValue = \"어떤 타입도 수용 가능\"anyValue = 12345.67// 컴파일 에러let doubleValue: Double = anyValue  // 🚨 에러 메시지: Cannot convert value of type 'Any' to specified type 'Double'// Any 타입에 Double 값을 넣는 것은 가능하지만// Any는 Double 과 엄연히 다른 타입이 때문에// Double 타입의 값에 Any 타입의 값을 할당할 때에는 명시적으로 타입을 변환해 주어야 한다.6. Swift의 Type  Swift에서의 타입(Type)은 변수 또는 상수에 저장될 데이터의 종류를 정의하는 것이다.  모든 변수, 상수, 함수 매개변수, 함수 반환 값 등은 모두 특정한 타입을 가지고 있다.  Swift는 강력한 타입 추론(Type Inference)을 지원하여 코드를 작성할 때 타입을 명시적으로 지정하지 않아도 컴파일러가 타입을 유추할 수 있는 경우가 많다.Swift의 타입은 크게 두 가지로 나뉜다.1. 기본 데이터 타입 (Built-in Data Types)  Swift는 기본적인 데이터 타입들을 제공한다.  이들은 구조체로 구현되어 있으며, 각각의 타입에 해당하는 값이 메모리에 직접 저장된다.      주요한 기본 데이터 타입에는 다음과 같은 것들이 있다.          Int: 정수 타입 (Int8, Int16, Int32, Int64 등)      UInt: 부호 없는 정수 타입      Float: 단정도 부동 소수점 숫자 타입      Double: 배정도 부동 소수점 숫자 타입      Bool: 불리언 타입 (true 또는 false)      String: 문자열 타입      Character: 단일 문자 타입      그 외 다양한 기본 데이터 타입들이 있습니다.      2. 사용자 정의 데이터 타입 (Custom Data Types)  Swift에서는 개발자가 직접 타입을 정의할 수 있는 능력을 제공한다.      이러한 사용자 정의 데이터 타입에는 다음과 같은 것들이 있다          구조체(Structures): 멤버 변수와 메서드를 포함하는 타입      클래스(Classes): 객체 지향 프로그래밍을 위한 참조 타입      열거형(Enumerations): 관련된 값들의 그룹을 정의하는 타입      프로토콜(Protocols): 특정 작업 또는 기능에 대한 메서드, 속성 및 요구 사항을 정의하는 타입      사용자 정의 데이터 타입은 프로그램에서 특정한 목적을 위해 데이터를 묶고 구조화하는 데 사용된다.이러한 타입들을 사용하여 코드를 조직화하고 데이터 모델을 만들어 유연하고 확장 가능한 앱을 개발하는 데 도움이 된다.타입은 Swift 언어의 핵심 요소 중 하나이며, 안정성과 코드의 가독성을 높이는 데 중요한 역할을 한다.1. 타입 추론  타입을 지정하지 않아도 컴파일러가 타입을 유추해주어 지정(변수명 위에 option버튼 누르고 마우스 클릭하면 타입을 볼 수 있음)      컴파일러란?    Swift 컴파일러는 Swift 프로그램을 작성한 코드를 컴퓨터가 이해할 수 있는 실행 가능한 형태로 변환해주는 프로그램이다. 이 변환 과정은 크게 소스 코드를 분석하고, 그것을 기계어로 번역하는 단계로 이루어진다.          소스 코드 분석:                  Swift 컴파일러는 코드를 읽고 문법적인 구조로 분해한다. 이 때, 코드의 토큰(Token) 단위로 나누어짐.          그리고 이 토큰들을 이용하여 코드의 구조를 이해하고 추상적인 트리 모양의 구조를 생성.                    의미 분석:                  코드의 의미와 상호 작용을 이해하고 검증한다. 변수 선언, 함수 호출 등이 올바르게 이루어졌는지 확인.          이 과정에서 타입 체크(Type Checking)와 같은 작업이 이루어져 코드의 안정성을 확인한다.                    코드 최적화:                  코드를 실행할 때 속도를 향상시키고 메모리를 효율적으로 사용하기 위해 최적화 작업을 수행.          이 최적화는 코드 실행 성능을 높이고, 실행 파일의 크기를 줄이는 데 도움이 된다.                    코드 생성:                  최종적으로 최적화된 코드를 목표 플랫폼(예: iOS, macOS 등)에서 실행할 수 있는 기계어로 변환.          이렇게 생성된 실행 파일은 해당 플랫폼에서 실행되어 우리가 작성한 Swift 프로그램을 실행한다.                    Swift 컴파일러는 이러한 과정을 거쳐 우리가 작성한 코드를 실행 가능한 형태로 만들어주는 역할을 한다. 이는 우리가 Swift로 작성한 프로그램을 컴퓨터에서 실행할 수 있도록 해준다.var weight = 90type(of: weight) // Int.Typevar language = \"Swift\"type(of: language) // String.Type2. 타입 안정성  데이터 타입을 명확하게 사용하고, 다른 타입끼리의 연산이 불가능하다var integer = 5var double = 3.1integer = double -&gt; 불가능integer + double -&gt; 불가능3. 타입 형변환  형변환이 가능하다.let integerString = \"321\"let number = Int(integerString)print(number) // 321let doubleString = \"321.2\"let number2 = Int(doubleString)print(number2) // nil -&gt; 추후 학습 예정. 값이 없음을 표현"
  },
  
  {
    "title": "1주차 (2)",
    "url": "/posts/Main-campus_1stweek-2/",
    "categories": "캠프, 1주차",
    "tags": "문법",
    "date": "2024-03-04 08:11:00 +0900",
    





    
    "snippet": "프로퍼티와 출력1. 할당 연산자 (=)  A = B          B값을 A에 할당한다.      ※ 이때 방향을 잘 확인하도록 하자!      let color = \"purple\"print(color) // 출력값: purplevar foodName = \"사과\"var fruitName = \"포도\"foodName = fruitNameprint(foo...",
    "content": "프로퍼티와 출력1. 할당 연산자 (=)  A = B          B값을 A에 할당한다.      ※ 이때 방향을 잘 확인하도록 하자!      let color = \"purple\"print(color) // 출력값: purplevar foodName = \"사과\"var fruitName = \"포도\"foodName = fruitNameprint(foodName) // 출력값 : 포도// 변수 여러개를 한번에 선언하고 값을 할당하는 방법var a = 1, b = 2, c = 3 2. 저장 프로퍼티  let          변경할 수 없는 상수를 선언할 때 사용한다.      let name = \"철수\"name = \"영희\" // 🚨Error: Change 'let' to 'var' to make it mutable  var          변경할 수 있는 변수를 선언할 때 사용한다.      var age = 10age = 503. 연산 프로퍼티  var          연산 프로퍼티는 그 때 그 때 계산한 값을 알려주기에, 값이 변하는 변수를 나타내는 var를 사용한다.                  let은 당연히 사용할 수 없다.                    매번 계산하기에 값을 저장하지 않는다.      var x = 10var y = 20var z = 0// 👇🏻 sum이 연산 프로퍼티var sum: Int {    get { // Get이 우리가 변수를 선언하고 일상적으로 쓰는 문법이다. 단지 평상시에 쓸때는 생략이 될뿐.        return x + y    }    set { // 더한값을 특정한 변수(여기선 z)에 넣는다.        z = x + y    }}print(sum)// 출력값: 30print(z) // 30// get, set 중 get만 필요한 경우에는 키워드 생략 가능var sum1: Int {\t\treturn x + y}// 아래와 같이 더 축약 가능var sum2: Int {\t\tx + y}4. Print()  Console에 출력한다.  보통 값을 확인하기위해 중간중간에 print를 넣어 값이 잘 전달되는지 확인할때도 사용한다.print(\"Hello World 🌍\") // 출력값: Hello World 🌍5. 한 줄 텍스트  ” 내용 “ 을 사용하여 표현한다.var greeting = \"Hello World 🌍\"6. 여러 줄 텍스트  ””” 내용 “”” 을 사용하여 표현한다.var greeting = \"\"\"\t\tHello \t\tWorld \t\t🌍 \t \t\"\"\"7. 문자 보간법  String Interpolation(보간법)  \\() 을 사용하여 표현.  변수 또는 상수 등의 값을 문자열 내에 나타내고 싶을 때 사용한다.let name = \"정종\"var greeting = \"Hello \\(name) 🌍\" // 출력값: Hello 정종 🌍let height = 185let myInfo = \"My height is \\(height) 🌍\"  // 출력값: My height is 185 🌍8. 한 줄 주석  // 내용 을 사용하여 표현// 한 줄 주석9. 멀티라인 주석  /* */ 을 사용하여 표현/*여러줄주석입니다*/ 함수함수  기능의 수행:          함수는 특정 작업이나 기능을 수행하는 코드의 블록이다.      이 코드 블록은 호출될 때 실행되며, 함수 내에 정의된 코드들이 순차적으로 실행된다.        재사용성:          함수는 코드를 모듈화하고, 같은 기능을 반복하여 사용할 수 있도록 한다.      이는 코드의 중복을 피하고, 유지보수를 용이하게 만들어준다.        매개변수(Parameter):          함수는 입력값을 받을 수 있다.      이러한 입력값은 함수의 매개변수에 의해 받아들여진다.      이 매개변수들은 함수 내부에서 사용되어 특정한 작업을 수행하는 데 활용된다.        반환값(Return Value):          함수는 어떤 값을 반환할 수도 있다.      반환값은 함수가 실행되고 작업이 완료된 후에 호출 지점으로 반환된다.        함수 타입:          Swift에서는 함수도 하나의 타입으로 취급될 수 있다.      이는 함수를 다른 함수의 매개변수로 전달하거나 함수를 다른 함수의 반환값으로 사용할 수 있음을 의미한다.      이를 통해 함수를 동적으로 조작하고 조합할 수 있다.      func 함수_이름(아규먼트_레이블: 파라미터_타입) -&gt; 리턴_타입 {  // ... 코드}// 네이밍 컨벤션으로 카멜케이스를 사용 (ex- methodName 🙆🏻‍♀️ / method_name 🙅🏻‍♀️)func sayHi(friend: String) {  print(\"Hi~ \\(friend)!\")}sayHi(friend: \"영호\")func sayHi(to friend: String) {  print(\"Hi~ \\(friend)!\")}sayHi(to: \"영호\")func sayHi(_ friend: String) -&gt; String {  return (\"Hi~ \\(friend)!\")}print(sayHi(\"영호\"))// 출력값: Hi~ 영호!메서드  정의와 소속성:          함수는 독립적으로 정의되어 있으며, 특정한 객체나 타입에 속해 있지 않다. 일반적으로 전역 범위에서 정의되거나 특정 범위 내에 내장된다.      메서드는 클래스, 구조체, 열거형 등의 특정한 타입에 속해 있다. 객체 지향 프로그래밍에서 해당 객체의 특정한 기능을 수행하기 위해 사용된다.        호출 방식:          함수는 직접적으로 호출된다. 예를 들어, addNumbers(5, 3)와 같이 함수 이름 뒤에 괄호를 사용하여 호출한다.      메서드는 해당하는 객체 또는 타입에 대해 호출된다. 예를 들어, myObject.increment()와 같이 객체 또는 타입 인스턴스 뒤에 메서드 이름을 호출한다.        소속성:          함수는 특정한 객체의 속성이나 상태에 접근할 수 없다. 함수는 주어진 매개변수를 받아들여 작업을 수행하고 값을 반환하는데 집중된다.      메서드는 객체 또는 타입의 속성에 직접적으로 접근할 수 있다. 이는 메서드가 해당 객체의 상태를 변경하거나 속성에 접근하여 작업을 수행하는 데 사용된다.      정리간단히 말해, 함수는 특정한 타입에 속하지 않으며 독립적으로 정의되고 호출된다. 반면에 메서드는 특정한 타입에 속해 있으며, 해당 타입의 인스턴스에 대해 작동하고 상태를 변경할 수 있는 함수이다."
  },
  
  {
    "title": "1주차 (1)",
    "url": "/posts/Main-campus_1stweek-1/",
    "categories": "캠프, 1주차",
    "tags": "",
    "date": "2024-03-04 08:11:00 +0900",
    





    
    "snippet": "Swift 언어의 특징  안전성(Safe)          Swift는 타입에 엄격한 프로그래밍 언어이다 (Type Safe한 언어)              문자열 배열에 다른 타입인 숫자 타입의 값을 담을 수 없다.      타입 안정성을 위해 타입 체크를 해야한다.    - Swift는 nil에 엄격한 프로그래밍 언어이다.      Swift Co...",
    "content": "Swift 언어의 특징  안전성(Safe)          Swift는 타입에 엄격한 프로그래밍 언어이다 (Type Safe한 언어)              문자열 배열에 다른 타입인 숫자 타입의 값을 담을 수 없다.      타입 안정성을 위해 타입 체크를 해야한다.    - Swift는 nil에 엄격한 프로그래밍 언어이다.      Swift Compiler는 Compile시 문제가 발생할 수 있는 nil 객체를 만들거나 사용할 수 없도록 한다.      nil을 사용할 경우 ? 모양의 옵셔널을 이용하여 표시해줘야한다.        표현성(Expressive)          표현성을 고려한 프로그래밍이다.      다중패러다임 프로그래밍 언어 지원              명령형 프로그래밍 패러다임, 객체 지향 프로그래밍 패러다임, 함수형 프로그래밍 패러다임, 프로토콜 지향 패러다임을 지원한다.        Swift, iOS 자료          Apple Developer Documentation      https://developer.apple.com/documentation/  Swift Programming Language Guide (ENG)https://docs.swift.org/swift-book/documentation/the-swift-programming-language/  The Swift Programming Language (Kor)https://bbiguduk.gitbook.io/swift/  Swift API Design Guidelineshttps://www.swift.org/documentation/api-design-guidelines/  Apple Developer WWDC Videoshttps://developer.apple.com/videos/all-videos/  iOS App Dev Tutorialshttps://developer.apple.com/tutorials/app-dev-training"
  },
  
  {
    "title": "README",
    "url": "/posts/Read-Me/",
    "categories": "캠프, README",
    "tags": "",
    "date": "2024-03-04 02:11:00 +0900",
    





    
    "snippet": "본캠프가 시작되면서 강의와함께 같이 공부하는 자료가 주어지는데,해당 글은 강의 내용을 옮겨둔 자료이어서, 강의기간이 끝나고도다시 해당 글로 리마인드 하기위해 올려둔다.",
    "content": "본캠프가 시작되면서 강의와함께 같이 공부하는 자료가 주어지는데,해당 글은 강의 내용을 옮겨둔 자료이어서, 강의기간이 끝나고도다시 해당 글로 리마인드 하기위해 올려둔다."
  },
  
  {
    "title": "Tip Calculator 만들기",
    "url": "/posts/Making-Tip-Calculator/",
    "categories": "Udemy, BMI Calculator",
    "tags": "",
    "date": "2024-03-04 00:00:00 +0900",
    





    
    "snippet": "위와 같이 팁을 계산하는 Tip Calculator 를 만들어 보도록 하자.디자인 부분은 생략하기 위해, 클론을 하였다.1. IBOutlets, IBAction 링크하기이렇게 주어졌기에, 위와 같이 작성을 하자.import UIKitclass ViewController: UIViewController {       @IBOutlet weak var b...",
    "content": "위와 같이 팁을 계산하는 Tip Calculator 를 만들어 보도록 하자.디자인 부분은 생략하기 위해, 클론을 하였다.1. IBOutlets, IBAction 링크하기이렇게 주어졌기에, 위와 같이 작성을 하자.import UIKitclass ViewController: UIViewController {       @IBOutlet weak var billTextField: UITextField!        @IBOutlet weak var zeroPctButton: UIButton!            @IBOutlet weak var tenPctButton: UIButton!        @IBOutlet weak var twentyPctButton: UIButton!        @IBOutlet weak var splitNumberLabel: UILabel!            @IBAction func tipChanged(_ sender: UIButton) {    }            @IBAction func stepperValueChanged(_ sender: UIStepper) {    }        @IBAction func calculatePressed(_ sender: UIButton) {        print(sender.titleLabel)    }    }이렇게 링크가 끝났다.그리고 뷰컨트롤러 명칭도 변경을 해주었다.ViewController → CalculatorViewController2. 새로운 뷰컨트롤러 생성 및 링크 해주기.뷰컨트롤러를 만들때는 코코아터치 클래스로 만드는걸 잊지말자.이렇게 이어주었다.그리고 여기도 역시 IBaction, IBoutlet을 링크 해주었다.import UIKitclass ResultsViewController: UIViewController {    @IBOutlet weak var totalLabel: UILabel!            @IBOutlet weak var settingsLabel: UILabel!        override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.    }            @IBAction func recalculatePressed(_ sender: UIButton) {    }    }3, 퍼센트 버튼 기능 구현하기.우선 퍼센트 버튼을 누르고 Calculate버튼을 눌렀을때,각각의 퍼센트가 나오게 기능을 구현해보자.버튼이 선택되는건 isSelected로 구현한다.isSelected = true 일때 선택 false일땐 비활성화.버튼쪽은 일단 이렇게 구현했다.@IBAction func tipChanged(_ sender: UIButton) {        zeroPctButton.isSelected = false        tenPctButton.isSelected = false        twentyPctButton.isSelected = false        sender.isSelected = true    } 처음에 전부 선택이 안된상태로 두고 내가 누른것만 선택되게 한다.그리고 if문을 추가하였다. if sender.currentTitle! == \"0%\" {            percent = 0.0        } else if sender.currentTitle! == \"10%\" {            percent = 0.1        } else {            percent = 0.2        }현재 내가 누른 타이틀이 0% 일경우 percent에 0.0을 리턴하는 식으로 하였다.물론 퍼센트에 대한 변수는 선언해두었다.그리고나서@IBAction func calculatePressed(_ sender: UIButton) {        print(percent)    }percent가 프린트 되게 하였고, 잘된다.4. 증감 버튼 기능 구현하기.@IBAction func stepperValueChanged(_ sender: UIStepper) {        splitNumberLabel.text = String(Int(sender.value))        person = Int(sender.value)    }Docs를 찾아보니 value에 access를 할때는 value를 그대로 쓴다고하여 sender.value를 해보았고,그값이 제대로 리턴이 되는지 확인하기위해 calculate 버튼에 print를 해보았다.잘넘어갔다.5. 숫자 입력 구현하기billTextField.endEditing(true) 단순히 TextField만 true로 해주면 입력이된다.입력 값을 넘겨 받아야하기에 변수를 만들었고 다음과 같이 적었다.value = billTextField.text ?? \"123.56\" nil일때를 대비해 e.g. 123.56을 그대로 리턴하게 하였다.6. 계산 기능 구현하기이제 계산했을때 제대로 된 값이 계산이 되게끔 구현한다.@IBAction func tipChanged(_ sender: UIButton) {                billTextField.endEditing(true)                value = billTextField.text ?? \"123.56\"                        zeroPctButton.isSelected = false        tenPctButton.isSelected = false        twentyPctButton.isSelected = false        sender.isSelected = true        if sender.currentTitle! == \"0%\" {            percent = 1.0        } else if sender.currentTitle! == \"10%\" {            percent = 1.1        } else {            percent = 1.2        }    }@IBAction func calculatePressed(_ sender: UIButton) {        let total = Float(value)        split = (total ?? 123.56) / Float(person) * percent        print(split)    }퍼센티지를 수정했다. 그전에는 Discount의 값이었다면, 실제로는 그만큼 더 받아야 하는 의미이므로 1.0을 다 더해주었다.7. 계산값을 다른 컨트롤러로 넘기기.1. Segue 만들어주기.스토리 보드에서 세그를 연결해주었다.그리고 Identifier에 goToResult로 명명했다.그리고 performSegue 메서드를 통해 명명한 세그로 화면 전달이 되게끔 했다.recalculate를 눌렀을때 다시 원래 화면이 되도록 아래와 같이 적었다. @IBAction func recalculatePressed(_ sender: UIButton) {        self.dismiss(animated: true, completion: nil)    }2. 값 전달하기.    @IBAction func calculatePressed(_ sender: UIButton) {        let total = Float(value)        split = (total ?? 123.56) / Float(person) * percent        self.performSegue(withIdentifier: \"goToResult\", sender: self)    }        override func prepare(for segue: UIStoryboardSegue, sender: Any?) {        if segue.identifier == \"goToResult\" {            destinationVC = segue.destination as! ResultsViewController            destinationVC.result = split        }    }다음과 같이 적었다.8. 코드 수정 및 보완일단 기능 구현자체는 끝났는데, nil값에 대한 처리가 많이 미흡하다.해당부분을 좀 고쳐야겠다.우선 변수선언부터 맘에 들지 않는다.// CalculatorViewController    var percent : Float = 0.0    var person : Int = 0    var value : String = \"0.0\"    var split : Float = 0.0습관이 되어버려서 모두 초기값을 부여했다.이걸 모두 ? 로 바꾸어 옵셔널로 한다.그리고 해당 변수와 관련있는 코드 역시 바꿔주었다 @IBAction func calculatePressed(_ sender: UIButton) {        let total = Float(value ?? \"123.56\")        split = String(format:\"%.2f\", (total ?? 123.56) / Float(person ?? 2) * (percent ?? 1.1))        self.performSegue(withIdentifier: \"goToResult\", sender: self)    }    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {        if segue.identifier == \"goToResult\" {            destinationVC = segue.destination as! ResultsViewController            destinationVC.result = split        }    }잘 된다.혼자 리마인드 해본결과. 세그쪽을 좀 더 리마인드하면 좋을것같다."
  },
  
  {
    "title": "Clima (1)",
    "url": "/posts/Clima-(1)/",
    "categories": "Udemy, Clima",
    "tags": "",
    "date": "2024-03-04 00:00:00 +0900",
    





    
    "snippet": "Main Storyboard를 보게되면 날씨 아이콘이 있는데 SF Symbol 이다.iOS13에서 새로 추가 되었다.관련 링크https://developer.apple.com/sf-symbols/SF Symbol어플을 설치하면 여러 심볼들을 확인 할 수 있다.보통 목록에 엄청나게 많은 이미지들이 있기 때문에, 우리가 미리 어플을 통해 확인하고 입력해서...",
    "content": "Main Storyboard를 보게되면 날씨 아이콘이 있는데 SF Symbol 이다.iOS13에서 새로 추가 되었다.관련 링크https://developer.apple.com/sf-symbols/SF Symbol어플을 설치하면 여러 심볼들을 확인 할 수 있다.보통 목록에 엄청나게 많은 이미지들이 있기 때문에, 우리가 미리 어플을 통해 확인하고 입력해서 쉽게 찾을 수 있다.우리가 다크모드를 사용할때 custom을 하게 되면 색이 바뀌지 않지만,System Color를 사용하면 다크모드 지원이 된다.그렇다면 내가 원하는 색상을 하고 다크모드를 지원하게 하려면 어떻게 해야할까?다크모드 지원하는 색상 만들기Assets.xcassets를 선택하고 아래 +를 클릭하여 이미지를 추가할 준비를 하자.그리고 우측에 Insector tap을 가면이렇게 선택할 수 있다.그러면 우리가 light, dark 모드에 대한 색상을 정의를 할 수있게 된다.내가 원하는 색상으로 하고싶다면 custom에서 palette를 통해 색상을 따오거나, 아니면 만들고 그다음 드래그를 하여 추가하자.그리고 다시 Assets로 돌아와서 내가 원하는 색으로 바꿔두고 이렇게 네이밍을 할 수 있다.그리고 다시 스토리보드로 돌아가서 색상을 고르면?이렇게 내가 설정한 색상을 선택 할 수 있게된다.바뀌지 않던 색상이이렇게 다크모드로 해도 바뀌게 된다!참고로 다크모드 변환은 아래에 있다.다크모드에 따른 배경을 변경하기여태 png, jpg같은 이미지 파일로 했는데, 이미지만을 가지고있는 pdf파일 역시 호환이 된다.pdf파일을 사용할때는 드래그를 해두고, 벡터 이미지로 사용하기위해 해당 부분을 체크해주고 scale역시 single scale로 해준다.  벡터 이미지란?      점과 점을 연결해 수학적 원리로 그림을 그려 표현하는 방식,특성상 이미지의 크기를 늘리고 줄여도 손상되지 않는다.다만 사진과 같은 복잡한 그림을 표현하려면 컴퓨터에 엄청난 부담을 주기에 웹에서는 잘 사용 하지 않는다.  이렇게 설정을 해주었다.single scale로 해두어서 2x 3x 에 대한 이미지는 설정할 필요가 없어졌다.UITextField 사용하기text로만 검색해도 바로 나온다.기본적으로 UITextField는 다크모드를 지원한다.여기서 여러 기능을 설정 할 수 있다.  Content Type          텍스트 필드 안에 들어갈 내용의 타입을 선택한다.      코드 작성field.textContentType = .creditcardnumber        Capitalization                  알파벳 문자열을 입력할 시 첫 글자를 자동으로 대문자로 처리하는 기능, 총 3가지 기능이 있으며            None : 대문자로 변환 X      Words : 각 단어의 첫글자만      Sentences : 문장의 첫글자만      Characters : 전체를 대문자로     - 코드 작성field.autocapitalizationType = .words        Correction          자동 입력 기능      코드 작성 (독특하게 yes/no)field.autocorrectionType = .no        Smart Dashes          -를 여러번 이어 썼을때 하나의 줄로 만들어줌.      코드 작성 (이것도 yes/no)field.smartDashesTypes = .yes        Smart Insert          복사 붙여넣기를 했을때 왼쪽에 한칸이 자동으로 공백이 생기는 기능      코드 작성field.smartInsertDeleteType = .yes        Smart Quotes          ’ “ 이게 따옴표와 (아포스트로피) 로 바뀜field.smarteQuotesType = .no`        Spell Checking          내장된 사전을 바탕으로 스펠링을 체크해주는 기능      코드 작성field.spellCheckingType = .yes        Keyboard Type          원하는 입력 양식에 맞춰 나오게하는 키보드      흔히 우리가 카드번호를 입력한다고하면 숫자만 뜨는 넘패드도 여기서 설정한다.      코드 작성field.keyboardType = .numberPad        Keyboard Look          라이트 / 다크모드        Return Key          리턴키의 스타일을 정할 수 있다.        Secure Text Entry          암호처럼 보안이 필요한 글자를 입력할시 ** 이런식으로 가려지는 기능      PlaceHolder는 우리가 입력하기전 희미하게 어떤 text를 입력할지 간략하게 보여주는 기능을 한다.코드내에서 TextField는@IBAction func searchPressed(_ sender: UIButton) {        print(searchTextField.text)    }여기서 text는 디스플레이에 보여지는 그 텍스트이다실행해보자만약 textField를 눌렀는데 키보드가 나오지 않는다면 Command + K 를 하거나,시뮬레이터에서 I/O → Keyboard → Toggle Software Keyboard 를 하면 된다/현재 키보드에 단어를 입력하고 돋보기를 누르면 print가 된다.하지만 return키를 누르면 프린트가 되지 않는다.return을 눌러도 작동되게 만들기class 다음에 UITextField (protocol) 를 추가한다.class WeatherViewController: UIViewController, UITextFieldDelegate {  UITextFieldDelegate 란?      키보드 입력 및 전반적인 TextField 편집과 관련된 기능을 수행하는 프로토콜이다.  그리고 viewDidload에 다음을 추가한다.override func viewDidLoad() {        super.viewDidLoad()                searchTextField.delegate = self    }이것은 TextField가 viewController 에게 유져가 타이핑을 시작했다는 전달의 의미로 받아들이면 되겠다.self는 뷰컨트롤러를 참조한다.그리고 다음과 같은 함수를 만든다.이 함수들은 UITextFieldDelegate 프로토콜이 가지고 있는 함수들이다.바로 유져가 리턴버튼을 눌렀을때에 대한 처리를 이 함수에서 한다.실제로 작동하는지 다음과 같이 적었다. func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool {        print(searchTextField.text!)        return true    }테스트 결과 아주 잘 나온다.하지만 키보드가 사라지지 않는다.검색버튼이나, return을 눌렀을때 키보드가 사라지게 하기.searchTextField.endEditing(true) 이걸 추가하자.입력을 다했을때 키보드를 사라지게 해준다.searchPressed, textFieldShouldReturn 두 함수에 추가해주자.입력후 버튼을 눌렀을때 text를 Reset시키기위의 이미지만 보아도 입력해도 textField에는 그대로 남아있다.검색이나 리턴을 누른 후, 글자가 모두 초기화 되게 만들어보자 func textFieldDidEndEditing(_ textField: UITextField) {        searchTextField.text = \"\"    }이 함수는 뷰컨트롤러에게 유져가 입력을 끝마쳤다는 신호를 전달하고, 그때 “” 함으로써, text값을 초기화 하는것이다.이렇게 버튼을 누르면 textField의 값이 사라지게 되었다.마지막으로 유용한 Delegate 방법이 있다.바로 textFieldShouldEndEditing 이다.return type은 bool이다.이 함수는 유져가 타이핑을 하지 않고 버튼을 누르게 되었을때 즉 텍스트 필드가 “” 인 상태에서 어떠한 안내를 해줄 수 있는 장치이다.지금은 placeholder의 내용을 바꿔 주었다.func textFieldShouldEndEditing(_ textField: UITextField) -&gt; Bool {        if textField.text != \"\" {            return true        } else {            textField.placeholder = \"Type something Here\"            return false        }    }그렇다면 textField는 도대체 어디서 온걸까?우선 should가 들어간 함수들은 delegate에게 물어본다.shouldReturn은 리턴을 눌렀을때 어떻게 할지 물어본다.shouldEndEditing은 텍스트 필드에 대한 입력이 중단되었을때 중단할지 물어본다."
  },
  
  {
    "title": "BMI Calculator (5)",
    "url": "/posts/BMI-Calculator-(5)/",
    "categories": "Udemy, BMI Calculator",
    "tags": "",
    "date": "2024-03-03 00:00:00 +0900",
    





    
    "snippet": "NIL값 처리하기전에 했던것에 이어서, if문을 사용해 bmi값이 nil일 경우를 대비하자.첫번째 방법func getBMIValue() -&gt; String {        if bmi != nil {            let bmiTo1DecimalPlace = String(format: \"%.1f\", bmi!)            return ...",
    "content": "NIL값 처리하기전에 했던것에 이어서, if문을 사용해 bmi값이 nil일 경우를 대비하자.첫번째 방법func getBMIValue() -&gt; String {        if bmi != nil {            let bmiTo1DecimalPlace = String(format: \"%.1f\", bmi!)            return bmiTo1DecimalPlace        } else {            return \"0.0\"        }    }두번째 방법func getBMIValue() -&gt; String {        if let safeBMI = bmi {            let bmiTo1DecimalPlace = String(format: \"%.1f\", safeBMI)            return bmiTo1DecimalPlace        } else {            return \"0.0\"        }    }세번째 방법func getBMIValue() -&gt; String {               let bmiTo1DecimalPlace = String(format: \"%.1f\", bmi ?? 0.0)            return bmiTo1DecimalPlace            }이렇게 nil값에 대해 어떻게 처리할지 코드를 작성 했다면,bmi수치에따른 권고 사항을 만들 새로운 파일을 만들자새로운 모델파일 생성BMI라는 swift file을 만들고다음과 같이 필요한걸 적어주었다.import UIKitstruct BMI {    let value : Float    let advice : String    let color : UIColor}CalculatorBrain 모델 수정이젠 BMI라는 구조체를 만들었으니, 그에 맞게 모델파일을 수정해보자.import Foundationstruct CalculatorBrain {        var bmi : BMI?            func getBMIValue() -&gt; String {                let bmiTo1DecimalPlace = String(format: \"%.1f\", bmi?.value ?? 0.0)        return bmiTo1DecimalPlace            }        mutating func calculateBMI(height : Float, weight : Float){        bmi?.value = weight / (height * height)    }       }그런데 다음과 같이 에러가 발생하였다.구조체에는 let으로 되어있기 때문에, 값이 계속 변하는 특성상 맞지않는것이다.그래서 let bmiValue = weight / (height * height) 로 기존을 유지 하되, 아래에 다음과 같이 적어 초기화를 해줄것이다.bmi = BMI(value: &lt;#T##Float#&gt;, advice: &lt;#T##String#&gt;, color: &lt;#T##UIColor#&gt;)그전에,다음 조건을 참고 하여 bmivalue를 분류해보자.mutating func calculateBMI(height : Float, weight : Float){        let bmiValue = weight / (height * height)                if bmiValue &lt; 18.5 {            print(\"underweight\")                    } else if bmiValue &lt; 24.9 {        //else if bmiValue &gt;= 18.5 &amp;&amp; bmiValue &lt;= 24.9 { // 굳이 이렇게 적을 필요가 없다.            print(\"normal\")        } else {            print(\"overweight\")        }                //bmi = BMI(value: &lt;#T##Float#&gt;, advice: &lt;#T##String#&gt;, color: &lt;#T##UIColor#&gt;)    }이젠 위의 사진 표를 보고 색상도 추가를 해보자!bmi = BMI(value: bmiValue, advice: \"Eat more pies\", color: UIColor.blue) 보통 이렇게 UIColor.blue 로 색을 정할텐데,Color Literal을 통해 색상을 고를 수도 있다.#colorLiteral() 을 사용하면 되는데 난 왜 수치로 보이는지 모르겠다.밖에서 쓰니 된다. 왜이러는지 잘 모르겠다.그래서 그냥 외부에 원하는 색을 선택하고 cut &amp; paste로 했다.아래와 같이 두 코드가 적용이 되도록 코드를 추가해보자.// calculateViewController destinationVC.advice = calculatorBrain.getAdvice() destinationVC.color = calculatorBrain.getColor()내 코드// CalculatorBrainfunc getAdvice() -&gt; String {        let advice = bmi?.advice ?? \"\"        return advice    }    func getColor() -&gt; UIColor {        let color = bmi?.color ?? UIColor.red        return color    }우선 다음과 같이 값을 얻어오게 하는 함수를 구현하였다.그다음 destinationVC로 값을 전달하는데 그게 어떤 형태로 갈것인가를 생각을 해보았고,//ResultViewControllervar advice : String?var color : UIColor?이렇게 넘겨 받아서 전달할 변수를 만들어 주었다.override func viewDidLoad() {        super.viewDidLoad()        adviceLabel.text = advice        bmiLabel.text = bmiValue    }그리고 배경색을 해야하는데 생각해봐도 color를 받아서 처리할 변수가 없었다.그래서 storyboard를 보았다. 아니나 다를까 Background인 ImageView가 있어서@IBOutlet weak var background: UIImageView! 다음과 같이 링크 해주었고.background.backgroundColor = color를 추가해주었다.잘된다.강의에서의 차이점이라면 딱하나나는 background imageview를 만들었는데강의에서는 만들지 않고 view로 해결하였다.// ResultViewControlleroverride func viewDidLoad() {        super.viewDidLoad()        view.backgroundColor = color        adviceLabel.text = advice        bmiLabel.text = bmiValue    }또 이렇게 하나 배워간다."
  },
  
  {
    "title": "(Deep Dive) Optional",
    "url": "/posts/(Deep-Dive)-Optional/",
    "categories": "Udemy, Deep Dive",
    "tags": "옵셔널",
    "date": "2024-03-03 00:00:00 +0900",
    





    
    "snippet": "옵셔널은 왜 사용할까?옵셔널은 값이 있을 수도 있고 없을 수도 있다보통 우리가 어떤 로직을 짤때, 보통 초기값을 부여하곤 하지만, 값이 없을 수도 있을 상황이 있을 수도 있다.옵셔널은 보통 nil값이 들어갈 수 있는 변수 뒤에 ? 를 붙여 사용한다.우선 코드를 작성해보았다.let myOptional : String? // Optional String ...",
    "content": "옵셔널은 왜 사용할까?옵셔널은 값이 있을 수도 있고 없을 수도 있다보통 우리가 어떤 로직을 짤때, 보통 초기값을 부여하곤 하지만, 값이 없을 수도 있을 상황이 있을 수도 있다.옵셔널은 보통 nil값이 들어갈 수 있는 변수 뒤에 ? 를 붙여 사용한다.우선 코드를 작성해보았다.let myOptional : String? // Optional String Type 변수 생성 뒤에 ?myOptional = \"Harold\"let text : String = myOptional // Error 발생에러가 발생한다myOptional에는 Data Type이 Optional String이고text는 String이기 때문에 안되는 것이다.let myOptional : String? // Optional String Type 변수 생성 뒤에 ?myOptional = \"Harold\"let text : String = myOptional! // ! 를 붙여 Force Unwrapping 해주었다,1. Force Unwrapping!를 사용하여 강제로 Unwrapping해주는 것이다.하지만 사용할때 아주 신중하게 해야한다. nil값이 저장되는 경우도 고려해야하기 때문,myOptional의 값을 “Harold”에서 nil로 변경을 해보자.이렇게 에러가 발생하는 것이다.그러므로 !를 사용할때는 신중해야 한다는 것!2. Check for nil Value  기본 형태    if optional != nil {  optional!}      이런 형태를 띈다.즉 옵셔널이 아니면 unwrapping 하여 그값을 이용한다는 것이다.그리고 nil이라면? else를 통해 예외처리를 해준다.앱구동시 충돌을 이렇게 방지를 할 수 있다.하지만 한가지 문제가 있다.내가 이미 옵셔널인지 아닌지 if문을 통해 확인을 했지만…그래도 !를 써서 unwrapping을 해줘야 한다는 것이다.그리고 여러번 사용을 하게되면? 그때마다 계속 !를 사용해야한다.예를들어 아래와 같이 또 옵셔널로 정의 된 변수를 사용을 해야할때let myOptional : String?myOptional = nilif myOptional != nil {    let text : String = myOptional!    let text2 : String = myOptional! // !를 또 붙어야한다.} else {    print(\"myOptional was found to be nil.\")}이렇게 또 !를 붙여야 사용을 할 수 있는것이다.3. Optional Binding하지만 Swift에는 이걸 처리할 수 있는 내장된 기능이 있다.바로 OptionBinding이다.if let을 사용하는 방법이다.  기본 형태if let safeOptional = optional {    safeOptional}이런 형태로 작성을 한다.어떤 변수의 값이 nil이 아닐경우 새로운 변수로 담아 if문을 통해 코드를 진행하는 방식이다.myOptional의 값을 nil에서 Harold로 변경하였다.그리고 text에 safeOptional값을 넣고 출력을 해보았다.잘나온다이렇게 !를 통해 강제로 언래핑 하지않고 옵셔널 바인딩을 통해 nil값을 처리 할 수 있다.그렇다면 myOptional = nil인 상태일때 기본 값을 부여하고 싶다면 어떻게 해야할까?4. Nil Coalescing Operator (nil 병합 연산자)  기본 형태optional ?? defaultvalue만약 nil이 아닐경우엔 그 값을 사용하고 nil일 경우에는 defaultvalue를 사용한다.이런식으로 nil일때 ?? 뒤에 있는 그 값이 myOptional에 들어가는 것이다.이걸 if로 표현해본다면if myOptional != nil {    let text = myOptional} else {    myOptional = \"I am the default value\"}이런식으로 표현이 된다.그런데 Optional 대신 Optional struct나 class가 들어간다면??다음과 같이 코드를 작성하였다.근데 에러가 발생했다.현재 MyOptional이라는 구조체 안에 property가 옵셔널타입이 아니더라도, 구조체가 옵셔널타입이기때문에 unwrapping하지 않으면 사용할 수 없다.! 를 사용하여 unwrapping 해주면 리스크가 크다만약 myOptional = nil 이라면?이렇게 에러가 발생하기 때문이다.그럼 이 코드를 안전하게 실행하려면 어떻게 해야할까?5. Optional Chainingoptional?.propertyoptional?.method(). 을 사용하여 일부 속성이나 메서드에 접근을 할때 Optional 다음에 ? 를 붙여 접근을 한다.이때 optional이 nil이 아니면 property에 접근을 한다.(method도 마찬가지.)struct MyOptional {    var property = 123    func method() {        print(\"I am the struct's method\")    }}let myOptional : MyOptional?myOptional = nilprint(myOptional?.property)현재 MyOptional 구조체의 property에는 123이 있지만, 우리가 구조체를 nil이라고 값을 부여했기에 property에 엑세스를 해도 이렇게 nil이 출력되는걸 알 수 있다.반대로 myOptional = MyOptional() 로 초기화를 해주어 출력을 하면?결과값이 optional Int type으로 출력된다.표현법만 정리1. Force Unwrapping  optional!2. nil값인지 확인      if optional!= nil {optional!}      3. 옵셔널 바인딩      if let safeOptional = optional{safeOptional}      4. nil병합 연산자  optional ?? defaultValue5. 옵셔널 체이닝  optional?.property  optional?.method()연습 해보기아래 컴파일러를 통해 연습을 해보자."
  },
  
  {
    "title": "204. k의 개수",
    "url": "/posts/204.-k%EC%9D%98-%EA%B0%9C%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-03-03 00:00:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ i:Int, _ j:Int, _ k:Int) -&gt; Int {        var arr = (i...j).filter{String($0).contains(String(k))}.map{String($0)}        var string = arr.joined()        var ans...",
    "content": "import Foundationfunc solution(_ i:Int, _ j:Int, _ k:Int) -&gt; Int {        var arr = (i...j).filter{String($0).contains(String(k))}.map{String($0)}        var string = arr.joined()        var answer = string.map{$0}.filter{String($0).contains(String(k))}.count    return answer}뭔가 너무 장황하게 아닌건가 싶기도 하다.일단 i~j까지 의 숫자에 k를 포함하는 수를 걸러 내었고, 그걸 join으로 하나의 문자열로 만들었다.그리고 다시 map을 사용했다 왜냐하면 11같이 1이 두번들어가는건 위에서 contains를 써보니 하나로 걸러졌기 때문이다.그리고 다시 filter를 사용해 카운트하여 답을 리턴하였다."
  },
  
  {
    "title": "BMI Calculator (4)",
    "url": "/posts/BMI-Calculator-(4)/",
    "categories": "Udemy, BMI Calculator",
    "tags": "Segue",
    "date": "2024-03-02 00:00:00 +0900",
    





    
    "snippet": "Model 만들기먼저 파일을 만들어 준다.CalculatorBrains으로 만들어 주었다.일단은 struct만 만들어 주었다.struct CalculatorBrain {}ViewController에 초기화 및 내용 수정이전에 Viewcontroller에 실제로 사용하던 변수들을 이제 structure에 넣으면서 하나씩 바꿀 예정이다.// Calcula...",
    "content": "Model 만들기먼저 파일을 만들어 준다.CalculatorBrains으로 만들어 주었다.일단은 struct만 만들어 주었다.struct CalculatorBrain {}ViewController에 초기화 및 내용 수정이전에 Viewcontroller에 실제로 사용하던 변수들을 이제 structure에 넣으면서 하나씩 바꿀 예정이다.// CalculatorViewControllervar calculatorBrain = CalculatorBrain()이렇게 초기화를 해주고,// CalculatorViewController, calculatePressedcalculatorBrain.calculateBMI(height: height, weight: weight)// preparedestinationVC.bmiValue = calculatorBrain.getBMIValue()이렇게 해주었다.structure에 어떤 값이 들어갈지 내부값을 하나씩 변경해주면서 디자인을 해보자Model 내용 추가현재 calculateBMI, getBMIValue라는 함수를 추가해주고 기존 값을 지웠다. 즉 우리는 저 함수를 structure에 추가 해주면 되겠다.일단 다음과 같이 작성을 하였다.struct CalculatorBrain {       var calculatedBMIValue : String = \"\"        mutating func calculateBMI(height : Float, weight : Float) -&gt; String{        calculatedBMIValue = String(format: \"%.1f\", (weight / (height * height)))                return calculatedBMIValue    }        func getBMIValue() -&gt; String {            return calculatedBMIValue}}CalculateViewController에 다음과 같은 창이 경고가 뜬다, 저번에 Quizzler때도 그랬다.리턴을 하지말고 계산만 하게 해볼까? 라는 생각이 들어mutating func calculateBMI(height : Float, weight : Float){        calculatedBMIValue = String(format: \"%.1f\", (weight / (height * height)))            }리턴을 하지않고 계산만 하게 해보았다.잘된다.그래서 내가 쓴 코드는 다음과 같다.import Foundationstruct CalculatorBrain {        var calculatedBMIValue : String = \"\"        mutating func calculateBMI(height : Float, weight : Float){        calculatedBMIValue = String(format: \"%.1f\", (weight / (height * height)))            }        func getBMIValue() -&gt; String {                return calculatedBMIValue    }}그냥 calculateBMIValue는 계산만하게 해도 되는건데 굳이 리턴을 하려고 하니 warning 이떴던 것이었다.어차피 structure에서 value를 getBMIValue로 받으니 리턴이 필요없다.강의에선 다음과 같이 하였다.struct CalculatorBrain {        var bmi : Float = 0.0        mutating func calculateBMI(height : Float, weight : Float){        bmi = weight / (height * height)    }        func getBMIValue() -&gt; String {        let bmiTo1DecimalPlace = String(format: \"%.1f\", bmi)        return bmiTo1DecimalPlace    }}structure 에서 initialization을 하지않은 이유.struct CalculatorBrain에서bmi : Float = 0.0 //강의calculateBMIValue : String = \"\" //나이런식으로 먼저 값을 적고 했다.그 이유는 우리가 그냥bmi : Float calculateBMIValue : String  //나이런식으로 표현을 하게 될경우calculate 뷰 컨트롤러에서는var calculatorBrain = CalculatorBrain( )여기 괄호안에 우리가 매개변수를 넣어줘야한다.하지만 굳이 우리가 여기 컨트롤러에서 값을 초기화 해줄 필요가 전혀 없다.구조체에서 이미 값을 계산을 하고, 가져 올 수 있기 때문이다.그렇다면.bmi : Float = nilcalculateBMIValue : String = nil이렇게 nil일 경우를 생각해서bmi : Float?calculateBMIValue : String?옵셔널을 한다면??func getBMIValue() -&gt; String {        let bmiTo1DecimalPlace = String(format: \"%.1f\", bmi!)        }이렇게 ! 를 여태 붙이듯이 해야할것이다.그렇게 했을때 실행을 하면 어떻게 될까?앱을 실행하자마자 nil값을 얻기 위해calculate뷰 컨트롤러의 코드를 잠깐 수정한다.override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.        calculatorBrain.getBMIValue()    }바로 작동하자마자 bmivalue를 얻게 해보았다.다음과 같이 시작하자마자 팅기면서 에러가 발생한다.viewDidLoad()를 통해 앱이 구동되자마자 getBMIValue를 하게되는데 nil값을 가져오기 때문이다.다음 글에서 계속 서술하도록 하겠다."
  },
  
  {
    "title": "BMI Calculator (3)",
    "url": "/posts/BMI-Calculator-(3)/",
    "categories": "Udemy, BMI Calculator",
    "tags": "Segue",
    "date": "2024-03-01 16:19:00 +0900",
    





    
    "snippet": "지난 글에서 코드로 label, frame 등 코드로 수작업을 해보았다.확실히 수작업을 해보니 너무나도 불편했다. storyboard가 그리울줄이야..그래서 여기서는 코드로 UserInterface를 작성하지 않고, 디자인 된 storyboard를 다른 view컨트롤러로 연결 하여 사용하는 것을 해보려한다.우선 기존의 secondViewControll...",
    "content": "지난 글에서 코드로 label, frame 등 코드로 수작업을 해보았다.확실히 수작업을 해보니 너무나도 불편했다. storyboard가 그리울줄이야..그래서 여기서는 코드로 UserInterface를 작성하지 않고, 디자인 된 storyboard를 다른 view컨트롤러로 연결 하여 사용하는 것을 해보려한다.우선 기존의 secondViewController는 이제 사용하지 않을것이다. (지워도 그만 아니어도 그만.)난 그대로 냅둘 생각이다.새로운 class file 생성여태 우리는 file을 새로 만들때 Swift File을 선택하였다.하지만 이번에는 Cocoa Touch Class를 선택하여 만든다.습관이 무섭다고. 막 엔터치지말고 확인하면서 만들자.  CocoaTouch class ?      Apple이 만든 UIkit을 포함한 Framework이다.  아래 밑줄 친 곳에 우리가 naming을 해주면 된다.이렇게 자동으로 만들어준다.import UIKitclass ResultViewController: UIViewController {    override func viewDidLoad() {        super.viewDidLoad()    }}Contoller와 StoryBoard 연결하기만들어진 controller와 디자인된 storyboard를 연결하려면2가지 방법이 있다. (단지 클릭의 차이)  먼저 storyboard로가서 디자인된 storyboard를 클릭빨갛게 박스한 부분을 클릭다음과 같이 Inspector Tab에서 네모로 표시한부분을 클릭그리고 만들어진 컨트롤러 면을 적어준다. 그러면 링크 끝  왼쪽의 목록에서 viewController 선택이후 inspector tap에서 똑같이 하면 된다.그리고 Asistant view를 눌러보면 연결되어있는걸 볼 수 있다.IBAction IBOutlet 연결해주기설명은 생략하겠다.import UIKitclass ResultViewController: UIViewController {    @IBOutlet weak var bmiLabel: UILabel!        @IBOutlet weak var adviceLabel: UILabel!            override func viewDidLoad() {        super.viewDidLoad()    }    @IBAction func recalculatePressed(_ sender: UIButton) {    }}혹시라도 이름을 변경하고 싶다면?이름을 명명한 부분을 우클릭하고 rename을 클릭해준다.그러면 새로운 창으로 전환되는데 여기서 이름을 바꿔주면된다.일반적으로 file의 이름이 그 기능의 전반적인걸 표시하게 하는 경우도 있으니 이름을 변경해보자viewController → CalculateViewController로 변경.변경이 잘 되었다.Segue를 통한 viewController 초기화전에 secondViewController를 viewController에서 사용할때 var secondVC = secondViewController() 이런식으로 초기화를 해서 사용하였다.하지만 그렇게 하지않아도 된다.다음과 같이 해주면된다먼저 아까처럼 컨트롤러를 선택해준다. 위에서 1 이나 2의 방식으로.그리고 IBOutlet, IBAction을 만들듯이 Control을 누른 상태로 드래그 해주자.그리고 present modally를 선택해 주었다. (개취)아래처럼 저렇게 해도 상관없다.그 결과세그웨이가 생성되었다.insector tap을 통해 어떻게 애니메이션을 할지 설정 할 수 있다.세그웨이에도 네이밍을 해주자.identifier에 이름을 정해주면된다.Segue를 사용하여 연결하기우리는 CalulatorViewController에서 ResultViewController로 넘어가기에perfromSegue메서드를 사용할 것이다.self.performSegue(withIdentifier: \"goToResult\", sender: self)  withIdentifier : 세그웨이의 이름  sender : 일종의 전달자세그를 사용하여 연결했으니 한번 작동 테스트를 해보자.전환이 잘된다.하지만 아직 계산값은 넘어가지 않는다.BMI 값 전달하기ResultViewController에서 전달값을 받을 변수 생성해주기아래와 같이 생성했다.String으로 한건 값을 소수점표현하기 위해서이다.var bmiValue : String?그리고 다시 Calculate로 돌아와서prepare 메서드를 생성해준다.  세그를 실행하기전 재정의 해야하는 override method이다.보통 해당내용이 우리가 새로운 뷰컨트롤러를 만들게 되면 viewdidload 밑에 주석으로 처리되어있는 그 내용이다.segue.identifier 가 goToResult일때 세그가 작동하게 하였다.왜냐 우리가 viewContoller를 여러개 만들 수 있으니까.그리고 destination을 설정해주어야 하는데.destination은 기본적으로 UIViewController 형식이다말그대로 도착지를 이야기 하는것이다.그리고 그 도착지의 viewcontroller에 있는 bmiValue를 연결해준다.그런데 에러가 난다?UIViewController는 bmiValue가 없다고한다.위의 적어놓은대로 UIViewController이지 우리가 원한 ResultViewController가 아니었던것이다.그 상위 개념을 담아버렸다….이럴땐 다운 캐스팅을 해주어 정확하게 지정해주자.as를 사용한다.as!를 사용하면서 강제로 다운캐스팅을 진행한다.override func prepare(for segue: UIStoryboardSegue, sender: Any?) {        if segue.identifier == \"goToResult\" {            let destinationVC = segue.destination as! ResultViewController            destinationVC.bmiValue = \"0.0\"        }    }그렇다면 이제 calculated에있는 값을 result로 넘겨보자난 이렇게 하였다.일단 bmi를 새로 변수를 만들어 주었다.weight, height를 서로 반대로 적어두고 계속 0.0 나와서 뭔가 싶었는데 저걸 잘못적어서 얼타버렸다…//CalculateViewControlleroverride func prepare(for segue: UIStoryboardSegue, sender: Any?) {        let bmi = weightSlider.value / pow(heightSlider.value,2)        print(bmi)        if segue.identifier == \"goToResult\" {            let destinationVC = segue.destination as! ResultViewController            destinationVC.bmiValue = String(format: \"%.1f\", bmi)        }    }//ResultViewControlleroverride func viewDidLoad() {        super.viewDidLoad()                                bmiLabel.text = bmiValue    }넘어온 값을 받아 보여주는 코드를 작성하였다.강의에선 어떻게 했을까?//CalculateViewControllervar bmiValue = \"0.0\"@IBAction func calculatePressed(_ sender: UIButton) {        let height = heightSlider.value        let weight = weightSlider.value        let bmi = weight / (height * height)                bmiValue = String(format: \"%.1f\", bmi)                self.performSegue(withIdentifier: \"goToResult\", sender: self)    }override func prepare(for segue: UIStoryboardSegue, sender: Any?) {        if segue.identifier == \"goToResult\" {            let destinationVC = segue.destination as! ResultViewController            destinationVC.bmiValue = bmiValue        }    }//ResultViewControlleroverride func viewDidLoad() {        super.viewDidLoad()                                bmiLabel.text = bmiValue    }이렇게 하였다.실행화면Segue를 다시 전환시키기dismiss 메서드를 통해 다시 이전 view로 돌아갈 수 있다.위의 실행화면은 수동으로 내렸지만, 이제는 버튼으로 가능해졌다.@IBAction func recalculatePressed(_ sender: UIButton) {        self.dismiss(animated: true, completion: nil)    }실행화면UI를 3D로 볼 수도있다.3D구현화면은 생략하겠다. 드래그로도 돌려 볼수있으니 나중에 시간 되면 해보는걸 추천한다."
  },
  
  {
    "title": "Markdown 정리 및 글 작성법",
    "url": "/posts/Markdown-%EC%A0%95%EB%A6%AC-%EB%B0%8F-%EA%B8%80-%EC%9E%91%EC%84%B1%EB%B2%95/",
    "categories": "Tip, Markdown",
    "tags": "Markdown",
    "date": "2024-03-01 13:19:00 +0900",
    





    
    "snippet": "깃 블로그를 작성하다보니 뭔가 기존에 블로그와 사용하는법이 좀 달라서 이참에 정리한다.한 페이지로 그냥 다 집어넣을 생각.우선 우리가 일반적으로 글작성과는 달리 GitBlog는 정적인 방식이어서 내가 먼저 pc에 글을 작성하고 해당 글을 commit하여 올려서 deploy되기에 아무래도 글을 관리하는 측면에서는 좀 더 좋은 것 같다.공부하면서 나의 공...",
    "content": "깃 블로그를 작성하다보니 뭔가 기존에 블로그와 사용하는법이 좀 달라서 이참에 정리한다.한 페이지로 그냥 다 집어넣을 생각.우선 우리가 일반적으로 글작성과는 달리 GitBlog는 정적인 방식이어서 내가 먼저 pc에 글을 작성하고 해당 글을 commit하여 올려서 deploy되기에 아무래도 글을 관리하는 측면에서는 좀 더 좋은 것 같다.공부하면서 나의 공부내역을 여기다 적는 것이지만, 나름 이렇게 글을 작성하니 재밌다.각설하고, 현재 내가 사용하는 글작성은 틀은 다음과 같다파일 생성우선 글을 작성을 하려면 파일을 생성해준다.나의 경우 블로그용 글을 작성할때는 vscode를 사용한다.파일을 만들고 (날짜-title.md) 이런식으로 만들면된다.그렇다면 당연히 지금 이글의 파일명은2024-03-01-Markdown 정리 및 글 작성법.md 가 되겠네?글 작성시아무것도 없는내용에 글만 떡하니 작성한다고 되는게 아니다.아래와 같은 폼을 먼저 작성해 주어야 한다.부득이하게 소스코드에 적어둔다.---title: // 글 제목writer: // 작성자date: // 작성일시 날짜만 적어도되고 시간도 적어도 된다. 다만 시간은 +0800 이렇기에 현재 한국 시간에서 -8시간 해준 시간을 적으면 되는듯last_modified_at: // 최종 수정 날짜 date와 같은 형식으로 작성한다categories: // 카테고리영역tags: // 태그 영역toc: true // 목차 (클릭시 이동가능 보통 헤더로 작성한(#) 내역을 목차로 보여준다.)toc_sticky: true // 스크롤 해도 우측 상단에 고정된다.---복사용.---title: writer: date:last_modified_at:  categories: []tags: []toc: truetoc_sticky: true---last_modified_at:은 optional이다.이게 보통 글을 작성할때의 기본 Form이다.마크다운 문법너무 많아 인터넷을 보고 믹스하여 정리한다…1. Header (#)제목을 나타내며, 헤더를 이용하여 작성하면 toc를 통해 좀 더 쉽게 볼 수 있게 정리가 가능하다.Header는 H1 ~ H6 까지 있으며숫자가 클수록 글씨는 작다. (작은 고추가 맵다.)  작성법# H1## H2### H3#### H4##### H5###### H6결과는 다음과 같다.사진으로 대체한다.2. 줄 바꾸기텍스트 단락에서 줄을 바꿀때는 엔터를 두번 해주어 빈 줄을 하나 넣어준다.안그러면 한줄에 글이 쭉 작성이 되어 보기가 좋지않다.♦︎ before안녕하세요 테스트용 글입니다. 지금 작성중인데 뭐라고 적어야할지 모르겠는데 잘 부탁드립니다.♦︎ after안녕하세요 테스트용 글입니다.지금 작성중인데 뭐라고 적어야할지 모르겠는데 잘 부탁드립니다.난 분명히 아래 사진처럼 띄웠지만 결과는 다르게 나온다!3. 가로줄가로줄을 만드는 방법은 여러가지가 있다.1. ---2. ---------- // 10개3. - - - 4. ***5. ********** // 10개6. * * *다음과 같이 나온다 이미지로 대체한다.4. 순서가 있는 목록지금 헤더로 작성하는 것처럼 숫자를 부여하여 순서로 만드려면 아래와 같이 한다.1.2.3.4.그러면 순서를 잘못넣으면?1.3.5.4.2.그래도 보정이 되어 잘 나온다.그래도 실수하지는 말자5. 순서가 없는 목록내가 순서를 매기지 않고 그냥 목록화 하고 싶다면?+ 안녕- こんにちは* Hello물론 하위 목록화도 가능하다 탭을 눌러 거리를 주고 +, -, *를 입력하자+ 안녕    + 난 한국인- こんにちは    - 私は日本人です* Hello    * I'm American6. 텍스트 강조글을 적고있을때 뭔가 강조를 하고 싶을때 사용한다.기울임 : *안녕* _안녕_굵게 : **안녕하세요** __안녕하세요__굵은상태에서 기울임 : ***Hi*** ___Hi___취소선 : ~~안녕~~은 반말이고 안녕하세요.안녕 안녕안녕하세요 안녕하세요Hi Hi안녕은 반말이고 안녕하세요.7. 인용뭔가 인용문을 삽입할때 쓴다.나같은경우엔 뭔가 글이 이뻐지지 않아서 잘안쓰게 된다.&gt; 자 인용해볼까요&gt;&gt; 네 인용합니다.&gt;&gt;&gt; 줄이 이쁘지가 않네요.8. 소스코드 사용사실 깃블로그를 사용하게 되면 소스코드를 많이 쓰게 된다. 물론 지금도 예시를 소스코드로 쓸만 큼 많이 사용하게된다.// ``` 사용하고자 하는 언어// ````var secondVC = SecondViewController()`// 중간에 텍스트적으면서 코드를 적을때이상하게 보여서 저렇게 했는데 `를 3개쓰고 시작해서 또 3개 써서 마무리 지으면 된다.이렇게 텍스트 중간에 적으면 된다.9. 링크1. &lt;링크주소&gt;2. [링크텍스트](링크주소)3. [링크텍스트](링크주소, \"부가설명\")다만. 이미지를 띄울때는 ![](이미지주소) 이런식으로 표현하면된다사이즈를 줄이고 싶다면 {: width=”50%” height=”50%”} 이걸 사용하자.여기까지 추가로 필요한게 있다면 더 수정하도록 하겠다."
  },
  
  {
    "title": "BMI Calculator (2)",
    "url": "/posts/BMI-Calculator-(2)/",
    "categories": "Udemy, BMI Calculator",
    "tags": "",
    "date": "2024-03-01 09:19:00 +0900",
    





    
    "snippet": "어제 포스팅을 해야했으나 velog에서 git blog로 전환 및 내용을 전부 이관하면서 공부를 거의 하지못했다 ㅠ근데 깃블로그 맘에든다. 넘어가길 잘한듯?각설하고 이어서 계속 작성해보도록 하자.새로운 ViewController 생성하기.우선 현재 위와 같이 2개의 viewController가 있지만,우리는 현재 viewController가 하나이므로...",
    "content": "어제 포스팅을 해야했으나 velog에서 git blog로 전환 및 내용을 전부 이관하면서 공부를 거의 하지못했다 ㅠ근데 깃블로그 맘에든다. 넘어가길 잘한듯?각설하고 이어서 계속 작성해보도록 하자.새로운 ViewController 생성하기.우선 현재 위와 같이 2개의 viewController가 있지만,우리는 현재 viewController가 하나이므로 추가로 하나 더 생성해주자.이름은 SecondViewController로 해주었다.만들어진 viewcontroller에 class를 만들어주자!class 입력하고 나오는 recommendation중 subclass를 누르면 다음과 같이 나온다.Swift에서는 클래스를 만들때 클래스 그자체와 같은 이름을 가진 파일의 이름을 정하는 것이 규칙이다즉, 위에 name부를 SecondViewController로 해주자.그리고 super class는 우리가 일반적으로 viewcontroller를 보게되면class ViewController:UIViewController{ }위와 같이 되어있다.그러므로 우리가 만든 클래스 역시 super class는 UIViewContoller로 해주면 되겠다!그랬더니 다음과 같이 에러가 발생한다!그렇다 UIViewController class를 사용하기 위해선위의 권고처럼 import UIKit를 해줘야한다.UI로 시작하는것들은 대부분 UIKit에서 오기때문에 UIKit가 있는지 확인후, 없으면 import를 해주도록 하자처음에 생성된 Foundation은 어차피 UIkit에 포함이 되어있으므로 Foundation → UIKit으로 변경하자.그리고 기본적으로 Project를 만들게 되면, ViewController에 viewDidLoad 메서드가 있는데 우리가 새롭게 만들게 되면 없다.그래서 viewDidLoad도 작성을 해주자.swift는 help에 가면 documentaion을 볼 수있으므로, 참고해두자새로 생성한 ViewController 빌드하기.기존에는 우리가 Storyboard에서 ViewController로 드래그를 하면서 UILabel을 만들고 했는데 이번에는 그러지 않고, 온전히 ViewController내부에서 작업하여 만들어 보도록 하겠다.먼저 label을 생성해준다.label = UILabel() 이렇게 함으로써 label을 초기화 해줄 수 있다.class SecondViewController: UIViewController {        override func viewDidLoad() {                let label = UILabel()        label.text = \"Hello\"        label.frame = CGRect(x: 0, y: 0, width: 100, height: 50)        // (x,y)좌표에 가로 세로가 100, 50 인 프레임 생성        view.addSubview(label) // 우리가 알고 있는 controller를 만들었을때의 전체를 덮고 있는 view가 addsubview앞에 있는 그 view이다.    }    }그리고 label의 frame을 위와같이 코드를 작성하여 만들어준다.Rect는 흔히 우리가 아는 Rectangular의 Abbreviation이라고 생각하면 좋을것 같다. 이렇게 우리가 코드로 프레임도 만들어 줄 수있다.addSubview의 괄호 안에는 UIView의 DataType을 가지고있는 변수가 들어와야하는데, label들어와도 문제가 없다?왜냐하면 아래와 같이 UILabel은 UIView의 상속을 받기 때문에 문제가 없는것이다! 호환이 된다!우리가 새로운 컨트롤러에 새로운 뷰를 생성하게 되면 그 뷰는 투명하게 되어있다.  즉 우리가 배경색을 설정해주어야 한다!view.backgroundColor = UIColor.redview.backgroundColor = .red두개의 코드는 서로 같다. .을써도 문제가 없다? 이게 무슨 말일까?swift는 이미 우리가 배경색을 바꾸려고할때 UIColor가 나올것을 알고있기에 . 으로 그냥 넘어가도 상관이 없다.이것도 잘 알아두도록하자. (그렇다고 막써보지는 말자…)첫번째 viewcontroller의 calculate 버튼을 눌렀을때 새로 만든 viewcontroller로 전환이 되도록 설정을 해보자.viewcontroller 서로 연결 해보기.secondVC라는 것을 만들어주고 초기화를 해준다.let secondVC = SecondViewController() // InitializesecondVC라는 매개변수가 생겼고, 이를 통해 우리는 이제 secondViewController 를 보여줄수 있게 되었다.하지만 다른 viewcontroller를 보여주려면 현재의 viewcontroller가 필요하다.이렇게 현재 뷰컨트롤러 그 자신이 필요하기에 self 메서드를 통해서 코드를 작성하면 된다.  parameter          parameter에는 우리가 보여줄 viewcontroller      animated 컨트롤러 전환시 효과를 주는가?      애니메이션과 프레젠테이션이 끝나면 무엇을 할건지?              여기선 우리는 할게 없으므로 nil을 해준다.      그래서 아래와 같이 첫번째 view controller에서 작성을 해준다@IBAction func calculatePressed(_ sender: UIButton) {        let height = heightSlider.value        let weight = weightSlider.value        //let bmi = weight / (height * height)        let bmi = weight / pow(height,2)        print(bmi)                // 새롭게 추가 버튼을 눌렀을때 다음 뷰 컨트롤러로 전환 하기 위해 작성.        let secondVC = SecondViewController()        self.present(secondVC, animated: true, completion: nil)    }그럼 이제 제대로 돌아가는지 작동 테스트를 해보도록하자.아주 잘된다.그렇다면 animated를 false를 하면 어떻게 될까?이렇게 효과 없이 그냥 떡하니 바뀌는 걸 알 수 있다.BMI 결과 값을 다른 ViewController에 전달하기화면 전환까지 되는것을 확인했다.이제는 우리가 첫번째 뷰컨트롤러에서 키와 무게를 설정하고 calculate를 눌렀을때 현재는 console에 출력이 되었지만, 이제는 이 결과값을 다른 ViewController에 넘겨보도록 하자.우선 bmi값을 담을 변수를 하나 생성해주자.그리고 해당변수를 label.text가 받게 해주자var bmiValue = \"0.0\" // 변수생성        override func viewDidLoad() {                // view.backgroundColor = UIColor.red        view.backgroundColor = .red                let label = UILabel()        label.text = bmiValue // 변수를 표시하게!        label.frame = CGRect(x: 0, y: 0, width: 100, height: 50)        // (x,y)좌표에 가로 세로가 100, 50 인 프레임 생성        view.addSubview(label) // 우리가 알고 있는 controller를 만들었을때의 전체를 덮고 있는 view가 addsubview앞에 있는 그 view이다.    }다시 첫번째 Viewcontroller로 넘어가서우리는 이제 아까 만들어둔 secondVC를 통해 두번째 컨트롤러에 있는 매개변수에도 접근이 가능해졌다.그래서 두번째 컨트롤러에 있는 bmiValue에 첫번째 컨트롤러에서 나오는 결과값을 전달 해주도록 하자.let bmi = weight / pow(height,2)// 우리가 bmi값의 데이터형을 Float형태로 해두었기에 String으로 형변환을 해주었다.// 그리고 소수점 첫번재자리까지 표시하기위해서 format을 설정해주었다.secondVC.bmiValue = String(format: \"%.1f\", bmi)전달이 잘 되는것을 확인 할 수 있다."
  },
  
  {
    "title": "Git 으로 협업시 Tip",
    "url": "/posts/git%ED%98%91%EC%97%85%EC%8B%9C%ED%8C%81/",
    "categories": "Tip, Git",
    "tags": "Git",
    "date": "2024-03-01 08:33:00 +0900",
    





    
    "snippet": "며칠전 수업을 받으며 Git에 대한 내용을 특강형식으로 받았는데, 협업시 어떻게 진행이 되는지 간략하게 배웠기에 그것을 정리 해보려고 한다.진행Flow는 Markdown 작성 순이다.협력자(팀원) 등록 - 팀장만      팀장은 우선 협업을 할 Project를 담을 Repository를 만든다.        만들어진 Repository에 들어가서 se...",
    "content": "며칠전 수업을 받으며 Git에 대한 내용을 특강형식으로 받았는데, 협업시 어떻게 진행이 되는지 간략하게 배웠기에 그것을 정리 해보려고 한다.진행Flow는 Markdown 작성 순이다.협력자(팀원) 등록 - 팀장만      팀장은 우선 협업을 할 Project를 담을 Repository를 만든다.        만들어진 Repository에 들어가서 setting → collaborators 등록 (팀원추가)        Add people을 눌러 팀원의 username or email로 추가  코드 복사하기      팀원은 해당 repository 에 들어가서 주소를 복사 후 git clone을 사용한다.        git clone “주소” .          이렇게 주소 뒤에 . 을 찍지 않으면 새로운 디렉토리가 생성이 되니, 본인이 디렉토리를 이미 만들었고, 거기에 작업을 할것이라면 반드시 주소 뒤에 . 을 찍자.      코드 작업 및 수정  add, commit, push를 반복…팀원이 변경한 코드를 내 프로젝트에 가져오기  git pull          다른 변경된 file을 먼저 가져온다.      위에 코드 작업 및 수정이라고 적었는데, git push를 할때 erorr가 발생한다면, git pull을 먼저 해주도록 하자.      혹시나 git pull할때 아래와 같은 에러가 발생한다? (첫 pull할때 보통 발생한다.)      그때는 위에 image를 보면 힌트에 git config pull.rebase false 를 해준다.      이후 다시 pull을 해주면 upload가 된다.      충돌(conflict) 해결하기  혹시나 git pull을 했을때 에러가 발생한다?  우선 발생한 파일을 확인해보고 커밋을 다시 해보자  보통 충돌이 일어날때는 같은 파일 내에 같은 line의 코드가 변경이 되었을때 발생한다.          코드의 충돌이 발생하였다!        예시          이렇게 아래와 같이 코드 변경을 하였다면?       그리고 git 명령어를 사용하면?      이런 상황이 발생하므로 아무것도 모르는 Git은 어리둥절        그렇다면 어떻게 해결을 해야할까?          아래와 같이 서로가 겹친부분을 삭제를 하고 팀원간 협의하에 원하는 코드로 수정을 해서 올린다.      일단 이렇게 특강내용을 정리해보았다. 추후 서술할게 생긴다면 더 수정을 하도록 하겠다."
  },
  
  {
    "title": "Git 간단한 정리",
    "url": "/posts/Git-%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%A0%95%EB%A6%AC/",
    "categories": "Tip, Git",
    "tags": "Git",
    "date": "2024-02-29 15:25:00 +0900",
    





    
    "snippet": "오래간만에 깃을 쓰니 헷갈려서 정리한다.현재 쓰고 있는 키보드이다이글도 이 키보드로 작성중이다.깃 너란녀석…다시 본론으로 들어가자.깃이란?우리가 프로그래밍을 공부할때 깃이라는 단어를 수없이 듣게 된다.그렇다면 깃은 도대체 어떤녀석이길래 모두가 깃을 쓰는걸까?나무위키에는 다음과 같이되어있다  리누스 토르발스가 개발한 분산형 버전 관리 시스템.분산형 버전...",
    "content": "오래간만에 깃을 쓰니 헷갈려서 정리한다.현재 쓰고 있는 키보드이다이글도 이 키보드로 작성중이다.깃 너란녀석…다시 본론으로 들어가자.깃이란?우리가 프로그래밍을 공부할때 깃이라는 단어를 수없이 듣게 된다.그렇다면 깃은 도대체 어떤녀석이길래 모두가 깃을 쓰는걸까?나무위키에는 다음과 같이되어있다  리누스 토르발스가 개발한 분산형 버전 관리 시스템.분산형 버전관리 시스템이란?분산형 버전관리 시스템 (Version Control System)은 간단하게, 문서나 설계도 또는 코스 코드등의 변경점을 관리해주는 소프트 웨어이다.우리가 보통 업무를 하거나, 과제를 하다보면 어떠한 작업물을 만들고, 이것을 한번에 완성본으로 하지 않는다.보통 여러번의 수정을 걸쳐 만들게 된다.나의 경험은 파일명 뒤에 (rev.1) (rev.2) 이런 식으로 어떤 것을 만들었을때 기존에 있던것과 새롭게 추가한것을 비교하기 위해 새롭게 파일을 저장하는 편이다.이런경우가 버전 관리 없이 문서를 작성하는 경우이다.아마 모두가 해봤을 경험이다.하지만 분산형 버전관리 시스템을 사용하게되면 다음과 같이 관리가 가능해진다.      변경점 관리          어떤 내용을 누가 작성 했고 어느 시점에 했는지를 확인 할 수 있다.            버전 관리                  특정 시점에 Tag를 달아 버전을 표시해주고, Branch 등으로 동시에 여러 버전을 개발할 수 있게 한다.                    Branch란?                              소스 버전을 관리하기 위한 개념으로, 복사본의 개념으로 생각하면 된다 우리가 Branch의 의미 그대로 받아들이면된다.                                보통 뜻으로는 나뭇가지가 있지만, 지점이라는 의미도 있기에, 여기서는 하나의 지점으로 관리를 한다라고 이해하면 더 받아들이기 쉬워 보인다.                                    백업 &amp; 복구          무언가 잘못되었을때 다시 특정시점으로 복구가 가능하고, 데이터가 날아가더라도 복원이 가능하다.            협업          같이 일하는 사람에게 변경점을 쉽게 공유를 할 수 있다.      자주 사용하는 명령어git init깃을 시작하는 명령어.init 말그대로 Initialization으로 초기화를 해주는 개념이다 .git 이라는 숨김 폴더가 만들어진다.여기에 우리가 폴더에서 변경한 모든 내용들이 저장된다.만약 이 .git 숨김폴더를 지우면 깃으로 변경사항을 추적할 수 없다!git statusstatus말그대로 현재 상태를 확인 할 때 쓴다.git add나 git commit을 하지않으면 untracked 상태로 된다.git add수정한 파일을 스테이징 할때 쓴다.git commit -m “msg”파일을 로컬저장소에 저장 및 메시지 입력.커밋 전에 반드시 add 명령어로 스테이지 상태를 거쳐야 비로소 커밋을 만들 수 있다.git commit 까지만 쓰면 vi가 open이 되면서 commit 내역을 더 자세하게 쓸 수 있다.(나갈땐 :q)git commit -am 을 쓰면 add와 commit, 즉 스테이징과 커밋단계를 한번에 할 수 있다이전 커밋에 변경사항을 추가하고 싶을 때는 git commit –amend 명령을 사용한다.주의 할점이 이전 커밋에 현재의 변경 내용을 추가하는 것이다 nothing to commit 되면 okgit status의 변화git add 하기 전 git status -&gt; redgit add 한 후 git status -&gt;  greengit commit 후 git status -&gt; nothing to commit(바로 클론으로 가져오고나서 status 한 상태)git log이때까지 commit된 작업들을 볼 수 있다.맨 위가 가장 최근에 한 작업이다git log –graph 도 한번 써보자.git show커밋에 변경 내용이 반영되었는지 확인git remote add origin Repository 주소우리가 만든 레파지토리를 origin이라는 이름으로 원격저장소 주소를 등록, git remote는 원격저장소를 관리하는 명령이다.-&gt; git remote -v를 통해 잘 연결되었는지 확인한다.git remote remove origin원격저장소를 지움.git branch내 브랜치를 확인.git branch name main기준이 되는 main 브랜치에 새로운 브랜치 name을 생성하는 명령git checkout 브랜치명브랜치를 이동하는 명령.처음에는 기준이 되는 master 또는 main 브랜치로 자동으로 설정이 되어있다.위에서 브랜치를 새로 만든후 git checkout 명령으로 만든 브랜치 명을 써주면 그 브랜치로 이동가능!git branch 명령을 쓰면 *표시가 우리가 만든 브랜치 앞에 찍힌것을 볼수 있다.만들고 바로 그 브랜치로 이동하고 싶다면 git checkout -b 브랜치명 하면 된다git branch -M main브랜치를 main으로 바꿈.가끔 git init을 하게되면 branch가 master로 되어있는 경우가 있다. 나의 경우엔 main으로 사용하는게 익숙해져있어서 main으로 바꿔준다.예전에는 master - slave 구조로 사용을 하였는데, 이제는 slave자체가 노예라는 어감자체가 좋은 단어는 아니기에 master에서 main으로 넘어가고 있다.(이미 다 넘어갔을지도?)git clone Repository 주소원격저장소를 자신의 컴퓨터에 복제하게 된다.이때 주소 뒤에 . 을 붙이면 현재 터미널에서 사용중인 디렉토리에 설치가 되고, . 을 붙이지 않으면 현재 사용중인 디렉토리에서 디렉토리를 하나 더 생성하고 그안에 복제가 된다.git push origin 브랜치명원격저장소(origin)에 해당 브랜치에 있는것들을 집어넣는다.git pull origin master원격 저장소에서 파일을 내려받는다..gitignore추적하지 않을 파일들의 명단을 적어놓은 것.괜히 여기에 아무것도모르고 이그노어 했다가 공부한게 올라가지 않았다.나의 경우엔 git init이 되어있는 디렉토리에서 touch .gitignore 를 하여먼저 .gitignore file을 생성해준다.명령어는 아래와 같다.touch .gitignore터미널에서 touch file명을 해주면 0kb의 아무내용도 없는 file 하나가 만들어진다.그다음 vim 이나 다른 editor를 통해서 gitnore할 내용을 작업한다.이렇게 .gitignore 안에 내용이 들어가게되면 add / commit / push할때 해당 내용은 제외 하고 올라간다.이름 그대로 ignore해주는 것이다. 아래 사진은 vscode를 통해 깃블로그에 ignore할 내용을 추가한것이다.git reset –hard commitnumber일종의 원복 개념으로 이해하면 된다. (도르마무)우선 commitnumber를 알려면 git log를 해야한다.그리고 내가 원하는 시점의 commitnumber를 복사하여붙여넣고 실행하면 돌아간다.그리고 udemy특성상 깃에서 clone하여 수업이 진행되기때문에 다시 add하고 commit push를 할때 에러가 발생한다. 반드시 그 디렉토리 안에 있는 .git파일을 제거해줘야한다.(clone하자마자 해줘야겠다…)  해당 디렉토리를 들어가서  rm -rf .git 을하여 .git 파일를 제거하고  git rm –cached . -rf스테이지도 제거해준다.그리고 혹시나 여러 디렉토리를 같은 작업하였다면.git add -A를 하여 모든 디렉토리를 스테이징 해주고commit후 git push orgin main을 하여 올려주면 된다.혹시나 깃 계정에 대해 재설정을 Terminal에서 해야하는 경우git config –global user.email이메일을 설정git config –local user.name유저의 이름을 설정push를 하게되면 유져명과 비밀번호를 입력하라고 뜨는데,비밀번호는 깃비밀번호가 아닌 토큰값이다."
  },
  
  {
    "title": "연산자 정리",
    "url": "/posts/%EC%97%B0%EC%82%B0%EC%9E%90%EC%A0%95%EB%A6%AC/",
    "categories": "Deep Dive",
    "tags": "",
    "date": "2024-02-29 15:21:00 +0900",
    





    
    "snippet": "출처 (https://proofroto.tistory.com/15)연산자 정리산술 연산자 정리.A + B // A와 B를 더한 값을 반환A - B // A와 B를 뺀 값을 반환A * B // A와 B를 곱한 값을 반환A / B // A와 B를 나눈 값을 반환A % B // A와 B를 나눈 나머지의 값을 반환비교 연산자 정리.A = B // A에 B의 ...",
    "content": "출처 (https://proofroto.tistory.com/15)연산자 정리산술 연산자 정리.A + B // A와 B를 더한 값을 반환A - B // A와 B를 뺀 값을 반환A * B // A와 B를 곱한 값을 반환A / B // A와 B를 나눈 값을 반환A % B // A와 B를 나눈 나머지의 값을 반환비교 연산자 정리.A = B // A에 B의 값을 할당한다. A == B // A와 B가 같으면 true, 다르다면 false를 반환.A != B // A와 B가 다르면 true, 같다면 false를 반환.A &lt;= B // A가 B보다 작거나 같다면 ture, 다르면 false를 반환.이하 연산자는 생략범위 연산자 정리A...B // A이상 B이하A..&lt;B // A이상 B 미만A... // A이상...A // A이하..&lt;A // A미만비트연산자 정리.~A // NOT 비트 연산자: 비트 반전A &amp; B // AND 비트 연산자 : AND 논리 연산A | B // OR 비트 연산자 : OR 논리 연산A ^ B // XOR 비트 연산자 : XOR 논리 연산A &gt;&gt; B // shift 연산자 ( &gt; 쪽으로 ) A(정수) &gt;&gt; B(만큼) 시프트연산A &lt;&lt; B // shift 연산자 ( &lt; 쪽으로 ) A(정수) &lt;&lt; B(만큼) 시프트연산ex)var A = 5 // 0 1 0 1var B = 2 // 0 0 1 0~A // -6~B // -3A|B // 7A^B // 7A &gt;&gt; B // 1A &lt;&lt; B // 20참고 비트연산자 계산 방법(출처 : https://tcpschool.com/c/c_operator_bitwise)##비트 연산자(bitwise operator)비트 연산자는 비트(bit) 단위로 논리 연산을 할 때 사용하는 연산자이다.또한, 비트 단위로 전체 비트를 왼쪽이나 오른쪽으로 이동시킬 때도 사용한다.ANDAND의 경우 두 비트가 모두 1일때만 1을 반환하며, 다른 경우에는 모두 0을 반환한다.OROR의 경우 두 비트 중 하나라도 1이면 1을 반환, 두 비트가 모두 0일 때만 0을 반환한다.XORXOR의 경우 대응되는 두 비트가 서로 다르면 1을 반환, 서로 같으면 0을 반환한다.NOTNOT의 경우 해당 비트가 1이면 0을 반환, 0이면 1을 반환한다.비트 shift왼쪽으로 가면 2배씩 값이 증가하고, 오른쪽으로 가면 절반씩 값이 줄어든다.NOT 계산5의경우 8비트로 표현하면.0 0 0 0 0 1 0 1제일 처음의 0은 부호를 나타냄. 0이면 양수 1이면 음수~5 는 NOT 5이고 표현하면1 1 1 1 1 0 1 0 이된다.음수의 경우 0을 기준으로 한 값에 1을 더하고 부호만 -로 바꾸어 계산한다.기타 연산자.추후 옵셔널에서 사용함.A ?? B // A가 nil이 아니면 A를 반환하고, nil이면 B를 반환한다.A! // (옵셔널) A를 강제 추출A? // (옵셔널) A를 안전하게 추출 하거나, A가 옵셔널임을 표시오버플로 방지&amp;+ // 오버플로를 대비한 덧셈 연산&amp;- // 오버플로를 대비한 뺄셈 연산&amp;* // 오버플로를 대비한 곱셈 연산"
  },
  
  {
    "title": "삼항연산자",
    "url": "/posts/%EC%82%BC%ED%95%AD%EC%97%B0%EC%82%B0%EC%9E%90/",
    "categories": "Deep Dive",
    "tags": "",
    "date": "2024-02-29 15:19:00 +0900",
    





    
    "snippet": "사실 이걸 딥다이브에 넣어야 하나 고민이 었는데, 카테고리나 태그를 무분별하게 많이 만드는 것보다는 내가 모르는 것이거나, 기억이 나지 않아 재정리 하는 공간의 개념으로 사용하는것도 괜찮을 것 같아 여기에 글을 적는다.삼항연산자를 이용하여 if, else문을 간략하게 표현 할 수있다.? 뒤에 표현식1 : 표현식2 이런식으로 적는다.만약 조건이 참이라면...",
    "content": "사실 이걸 딥다이브에 넣어야 하나 고민이 었는데, 카테고리나 태그를 무분별하게 많이 만드는 것보다는 내가 모르는 것이거나, 기억이 나지 않아 재정리 하는 공간의 개념으로 사용하는것도 괜찮을 것 같아 여기에 글을 적는다.삼항연산자를 이용하여 if, else문을 간략하게 표현 할 수있다.? 뒤에 표현식1 : 표현식2 이런식으로 적는다.만약 조건이 참이라면  :를 기준으로 왼쪽인 표현식1의 값을 리턴할 것이고, 거짓이라면 오른쪽인 표현식2를 리턴한다.var isDarkMode : Bool = falsevar title : String = isDarkMode == true ? \"다크모드 입니다\" : \"다크모드가 아닙니다\"var title : String = isDarkMode = ? \"다크모드 입니다\" : \"다크모드가 아닙니다\"// 위와 아래는 모두 같은 표현이다.// false이므로 \"다크모드가 아닙니다\" 가 나올것이다."
  },
  
  {
    "title": "Array 명령어",
    "url": "/posts/Array-Commands/",
    "categories": "Deep Dive",
    "tags": "코딩테스트",
    "date": "2024-02-29 14:56:00 +0900",
    





    
    "snippet": "배열에 대해서 정리를 해보자.이것도 추가로 필요한게 있다면 지속적으로 수정 할 예정초기화 및 선언  배열은 가지는 요소에 타입에 따라 자동으로 타입 추론이 가능하다.      선언과 동시에 초기화 할 때는 요소에 값이 들어있다면 자동으로 타입 추론이 이루어지기 때문에 타입을 명시해주지 않아도 된다.    예시    var intNumbers = [1,...",
    "content": "배열에 대해서 정리를 해보자.이것도 추가로 필요한게 있다면 지속적으로 수정 할 예정초기화 및 선언  배열은 가지는 요소에 타입에 따라 자동으로 타입 추론이 가능하다.      선언과 동시에 초기화 할 때는 요소에 값이 들어있다면 자동으로 타입 추론이 이루어지기 때문에 타입을 명시해주지 않아도 된다.    예시    var intNumbers = [1,2,3,4,5] // 'Int' 요소를 갖는 배열var strings = [\"A\", \"BC\", \"DEF\"] // 'String' 요소를 갖는 배열        단, 빈 배열을 선언할 때는 타입을 명시해주지 않으면 에러가 발생예시```swiftvar emptyDoubles: [Double] = []var emptyStrings = Stringvar emptyFloats: Array = Array()var emptyArray = [] // [!] Empty collection literal requires an explicit type- Int 타입 배열은 연속된 숫자 배열을 쉽게 선언할 수 있다```swiftvar intArray = Array&lt;Int&gt;(1...10) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  한 배열에 여러 자료형 요소를 넣고싶으면 Any 타입을 사용하면 된다.    let anyArray: [Any] = [1, 2, \"a\", \"b\"]          모든 요소를 반복되는 값으로 초기화  특정 값만 반복적으로 가지는 배열일 경우 Array(repeating:count:)를 사용한다.```swiftvar digitCounts = Array(repeating: 0, count: 10) print(digitCounts) // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]var stringCounts = [String](repeating: “”, count: 10) print(stringCounts) // [””, “”, “”, “”, “”, “”, “”, “”, “”, “”]- 여기서 repeating에 들어가는 값이 클래스의 인스턴스일 경우, 반복되는 모든 요소가 동일한 인스턴스를 참조하게 되므로 주의 해야함. (요소 하나의 속성만 변경해도 모든 값이 변경됨)```swiftclass Person: CustomStringConvertible {    var name: String        init(name: String) {        self.name = name    }        var description: String {        return \"Person(\\(self.name))\"    }}var persons = Array(repeating: Person(name: \"홍길동\"), count: 3)print(persons)  // [Person(\"홍길동\"), Person(\"홍길동\"), Person(\"홍길동\")]persons[0].name = \"이순신\"print(persons)  // [Person(\"이순신\"), Person(\"이순신\"), Person(\"이순신\")]배열 출력  print()를 사용하면 된다.    var array = [\"A\",\"B\",\"C\"]print(array) // [\"A\", \"B\", \"C\"]            값 접근    배열에서 요소의 위치(인덱스) 값으로 요소를 찾아올 수 있다. 인덱스 범위를 사용해도 된다.    var array = [\"A\",\"B\",\"C\"]print(array[0]) // \"A\"print(array[1..&lt;3]) // [\"B\", \"C\"]        빈 배열의 경우, 값을 참조하려고 할 때 없는 인덱스를 참조하는 것이므로 런타임 에러(Index out of range)가 발생    var EmptyDoubles: [Double] = []print(emptyDoubles[0]) // [!] Triggers runtime error: Index out of range            값 변경    변경하고 싶은 요소의 위치에 다른 값을 넣을 수 있다.  let으로 선언된 배열에는 변경할 수 없다.```swiftvar array = [“A”,”B”,”C”]array[0] = “Apple”array[1] = “Banana”array[2] = “Carrot”print(array) // [“Apple”, “Banana”, “Carrot”]let intArray = [1,2,3]intArray[0] = 100 // [!] Cannot assign through subscript: ‘intArray’ is a ‘let’ constant---## 값 추가- 배열의 맨 뒤에 값을 추가하는 방법으로는 append(_:)를 사용한다.```swiftvar numbers = [1,2,3,4]numbers.append(5)print(numbers) // [1, 2, 3, 4, 5]  배열 뒤에 여러 요소들을 한꺼번에 추가 하고 싶을 때는 append(contentsOf:)를 사용한다. (또는 += 연산자를 사용할 수도 있다.)```swiftvar numbers = [1,2,3,4]var moreNumbers = [5, 6, 7]numbers.append(contentsOf: moreNumbers)print(numbers) // [1, 2, 3, 4, 5, 6, 7]numbers += [8,9,10]print(numbers) // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]- 배열의 특정 위치에 값을 삽입하고 싶을 경우에는 insert(_:at:)을 사용한다.\t    - 앞의 인자에는 넣고 싶은 값을 입력한다.    - 뒤의 인자 at에는 넣을 위치(인덱스)를 입력한다.    - 이 메소드를 사용하면 값을 삽입한 위치 뒤의 요소들은 한 칸씩 뒤로 밀리게되고, 배열의 크기는 1 증가한다.```swiftvar numbers = [1,2,3,4,5]numbers.insert(0, at: 0)print(numbers) // [0, 1, 2, 3, 4, 5]  insert(contentsOf:at:)을 사용하여 특정 위치에 여러 요소를 한꺼번에 삽입할 수 있다.    var numbers = [1,2,3,4,5]numbers.insert(contentsOf: [1,2,3], at: 3)print(numbers) // [1, 2, 3, 1, 2, 3, 4, 5]            값 제거    값을 제거할때는 remove(at:)에 제거하고 싶은 값의 인덱스를 입력하면 된다.    var numbers = [1,2,3]numbers.remove(at: 1) // 인덱스 1에 있는 2를 제거한다.print(numbers) // [1,3]            첫번째 값을 제거하고 싶을 때는 removeFirst(), 마지막 값을 제거하고 싶을때는 removeLast()를 사용한다.          제거한 값을 반환하기 때문에, 빈 배열일 경우 에러가 발생        var numbers = [1,2,3]numbers.removeFirst() // numbers.remove(at: 0)와 같은 표현numbers.removeLast()  // numbers.remove(at: numbers.count-1)와 같은 표현print(numbers) // [2]                          removeFirst()와 removeLast()에 인자값으로 점프할 인덱스 값을 넣을 수 있다.          배열의 맨 앞 또는 맨 뒤에서부터 몇 칸 띄운 값을 지우겠다는 의미.        var numbers = [1,2,3,4,5]numbers.removeFirst(2) // numbers.remove(at: 2)와 같은 표현 =&gt; 3 삭제numbers.removeLast(1)  // numbers.remove(at: numbers.count-2)와 같은 표현 =&gt; 4 삭제print(numbers) // [1,2,5]                          마지막 값을 제거하는 방법으로는 popLast()도 있다.          마지막 값(Optional)을 반환하면서 제거한다.      빈 배열일 경우 nil을 반환하고 에러가 발생하지 않는다.        var numbers = [1,2,3]print(numbers.popLast()) // Optional(3)print(numbers) // [1,2]                      모든 요소를 제거하여 빈 배열로 만들고 싶을 경우에는 removeAll()을 사용한다.    var numbers = [1,2,3]numbers.removeAll()print(numbers) // []        일부 구간을 제거하고 싶을 때는 removeSubrange(_:)에 제거하고 싶은 인덱스 범위를 입력한다.var numbers = [1,2,3,4,5,6]numbers.removeSubrange(1..&lt;4) // 인덱스 1,2,3 범위의 값을 제거한다.print(numbers) // [1,5,6]  dropFirst(:), dropLast(:)를 사용하면 기존 배열은 그대로두고, 기존 배열에서 앞 또는 뒤에서 몇개의 값을 제거한 새로운 배열을 반환```swiftlet numbers = [1, 2, 3, 4, 5]print(numbers.dropFirst(2))\t// [3, 4, 5] : 앞에서부터 2개 제거한 새로운 배열 반환print(numbers.dropFirst(10))\t// [] : 앞에서부터 10개 제거한 새로운 배열 반환print(numbers) // [1, 2, 3, 4, 5] : 기존 배열은 그대로let numbers = [1, 2, 3, 4, 5]print(numbers.dropLast(2))\t// [1, 2, 3] : 뒤에서부터 2개 제거한 새로운 배열 반환print(numbers.dropLast(10))\t// [] : 뒤에서부터 10개 제거한 새로운 배열 반환print(numbers) // [1, 2, 3, 4, 5] : 기존 배열은 그대로---## 값의 인덱스 찾기- 배열에서 원하는 값의 인덱스를 찾고 싶을 때는 firstIndex(of:)를 사용한다. Optional Int 형태를 반환한다.- 배열에서 찾고자 하는 값이 여러개일 경우, 가장 앞에 있는 값의 인덱스를 반환한다.\t    - 해당하는 값이 없을 때는 nil을 반환한다.```swiftvar numbers = [1,2,3,4,4,3,2,1]print(numbers.firstIndex(of: 3)) // Optional(2)print(numbers.firstIndex(of: 5)) // nil  반환값이 Optional 이므로 Unwrapping하여 사용한다.    var fruits = [\"Apple\", \"Banana\", \"Carrot\"]if let i = fruits.firstIndex(of: \"Banana\") {  fruits[i] = \"Beetroot\"}print(fruits) // [\"Apple\", \"Beetroot\", \"Carrot\"]            원하는 값의 마지막 인덱스를 찾고 싶을때는 lastIndex(of:)를 사용한다.    특정 값 포함    특정 요소가 있는지 판단하기 위해서는 firstIndex(of:)를 사용 했을때 반환값이 nil이 아닌지를 검사해도 된다.      하지만 단순히 포함 여부만 알고싶다면 contains() 메소드를 사용한다          Bool값을 반환한다.        var numbers = [1,2,3,4]print(numbers.contains(4)) // trueprint(numbers.contains(5)) // false                        배열의 크기              배열에 요소가 몇 개 있는지 알고 싶으면 count를 사용한다.    var empty = [Int]()print(empty.count) // 0        배열을 처음에 선언하면, 배열의 크기와 별개로 내용을 보관하기 위한 메모리를 예약하게 된다.      배열에 예약된 메모리 크기는 capacity 속성을 사용해서 알 수 있다.          capacity속성은 새 스토리지를 할당하지 않고 배열에 포함될 수 있는 총 요소수 이다.        요소를 추가하다가 배열의 capacity를 초과하게 되면 배열은 더 큰 메모리를 할당하여 새 공간에 요소들을 복사한다.  이 때 할당되는 새로운 배열의 용량은 기존 크기의 배수이다.  요소를 많이 추가하게 될 수록, 점점 재할당 발생 빈도가 낮아지게 된다.var numbers = [1,2,3,4]print(numbers.count)    // 4print(numbers.capacity) // 4numbers.append(5)print(numbers.count)    // 5print(numbers.capacity) // 8  만약 배열에 요소가 얼마나 저장될 지 대략 예상할 수 있으면 미리 capacity를 설정하여 재할당을 방지할 수 있다.  capacity를 설정하는 방법은 reserveCapacity(_:)를 사용하면 된다.numbers.reverseCapacity(10) print(numbers.capacity) // 10빈 배열 여부  빈 배열인지 알고 싶으면 count를 사용하여 요소의 개수가 0개인지 판단하면 된다.    var empty = [Int]()print(empty.count == 0) //true        요소의 개수가 아니라 단순히 빈 배열인지만 알고싶으면, isEmpty를 사용하면 된다.    var empty = [Int]()print(empty.isEmpty) //true                  배열 뒤집기        기존 배열의 순서를 거꾸로 뒤집는 방법으로는 reverse()를 사용하면 된다.    var array = [1,3,5,2,4,6]array.reverse()print(array) // [6, 4, 2, 5, 3, 1]        reserved()는 기존 배열은 그대로 두고 순서가 뒤집어진 새로운 배열을 리턴한다.    var array = [1,3,5,2,4,6]array.reversed() // [6, 4, 2, 5, 3, 1]print(array) // [1, 3, 5, 2, 4, 6]        빠른 수행시간을 위해 reserved()를 사용하는걸 추천한다.배열 정렬하기  정렬을 하기 위해서는 요소가 Comparable 프로토콜을 준수하고 있는 타입이어야 한다.  Comparable은 비교연산자(&lt;)에 대한 오버로딩이 구현되어야 하기 때문에 값의 대소 비교가 가능해진다.      Swift에서 기본 제공하는 숫자 타입이나 String 타입은 모두 Comparable을 준수하고 있고, 커스텀 객체라도 Comparable을 준수하도록 구현하면 sort() 메소드를 사용할 수 있다.    배열을 오름 차순으로 정렬하고 싶으면 sort()를 사용한다. 기존 배열 자체의 순서를 정렬하게 된다.    var array = [1,3,5,2,4,6]array.sort()print(array) // [1, 2, 3, 4, 5, 6]        내림 차순으로 정렬하고 싶을땐, sort()와 reverse()를 함께 사용하거나 sort(by:&gt;)를 사용하면 된다.```swiftvar array = [1,3,5,2,4,6]array.sort()array.reverse()print(array) // [6, 5, 4, 3, 2, 1]var array = [1,3,5,2,4,6]array.sort(by: &gt;)print(array) // [6, 5, 4, 3, 2, 1]- sort()는 기존 배열은 그대로 두고 정렬된 새로운 배열을 리턴한다.- 오름차순 정렬은 sorted(), 또는 sorted(by:&lt;), 내림차순정렬은 sorted(by:&gt;)```swiftvar array = [1,3,5,2,4,6]array.sorted() //  [1, 2, 3, 4, 5, 6]print(array) // [1, 3, 5, 2, 4, 6]var array = [1,3,5,2,4,6]array.sorted(by: &gt;) // [6, 5, 4, 3, 2, 1]print(array) // [1, 3, 5, 2, 4, 6]최대 최소값 찾기      max(), min()메소드를 활용하여 최대, 최소값을 찾을 수 있다.          반환값은 Optional이므로 Unwrapping해서 사용하면 된다.            comparable 프로토콜을 준수하지 않는 요소일 경우 컴파일 에러를 발생하며, 빈 배열에서 사용하면 nil을 반환한다.  var numbers = [1,2,3]print(numbers.min()) // Optional(1)print(numbers.max()) // Optional(3)var numbers = [Int]()print(numbers.min()) // nilprint(numbers.max()) // nilvar objects = [CustomClass]()print(objects.min()) // [!] Compile Errorprint(objects.max()) // [!] Compile Error인덱스 관련  배열의 첫번째 인덱스는 0, 마지막 인덱스는 count-1과 같다.      startIndex, endIndex를 사용하여 구할 수도 있다.          startIndex는 항상 0이고, endIndex는 count값과 같다.      var numbers = [1,2,3,4,5]print(numbers.startIndex) // 0print(numbers.endIndex) // 5var numbers = []print(numbers.startIndex) // 0print(numbers.endIndex) // 0  부분 배열의 범위를 지정할 때 유용하게 사용 가능하다.    let numbers = [10, 20, 30, 40, 50]if let i = numbers.firstIndex(of: 30) {  print(numbers[i ..&lt; numbers.endIndex]) // [30, 40, 50]}        index(after:), index(before:)를 활용할 수도 있다.```swiftvar numbers = [1,2,3,4,5]print(numbers[numbers.startIndex]) // 1 - 첫번째 값print(numbers[numbers.index(after: numbers.startIndex]) // 2 - 2번째 값print(numbers[numbers.index(before: numbers.endIndex]) // 5 - 마지막 값print(nubmers[numbers.endIndex]) // [!] Runtime Error - Index out of range---## 첫번째, 마지막 값 찾기- array[0], array[array.count-1]을 사용하거나, numbers[numbers.startIndex], numbers[numbers.endIndex]를 사용하는 방법이 있다.- 하지만 first, last를 사용하면 Optional요소를 반환하며 빈 배열일 경우 nil을 반환한다.\t    - Index out of range 에러를 발생시키지 않고 안전하게 찾을 수 있다.```swiftvar numbers = [1,2,3,4,5]print(numbers.first) // Optional(1)print(numbers.first) // Optional(5)var numbers = [Int]()print(numbers.first) // nilprint(numbers.last) // nil"
  },
  
  {
    "title": "String Index",
    "url": "/posts/String-Index/",
    "categories": "Deep Dive",
    "tags": "코딩테스트",
    "date": "2024-02-29 11:52:00 +0900",
    





    
    "snippet": "코딩테스트 문제를 풀다보면 String Index에 관한 문제가 많이 나와 정리한다.추가로 더 서술해야할게 있다면 지속적으로 수정을 할 예정String.Index  Int를 리턴한다.  String.Index의 구조체 내용이 나온다.    var string : String = \"abcdefg\"print(string.startIndex) //Index...",
    "content": "코딩테스트 문제를 풀다보면 String Index에 관한 문제가 많이 나와 정리한다.추가로 더 서술해야할게 있다면 지속적으로 수정을 할 예정String.Index  Int를 리턴한다.  String.Index의 구조체 내용이 나온다.    var string : String = \"abcdefg\"print(string.startIndex) //Index(_rawBits: 15)          String.distance(from:to:)  Int를 리턴한다  from : string.startIndex  to : 변환할 String.Indexlet distance = string.distance(from: string.startIndex, to: 변환할 String.Index)StartIndex (첫글자 구하기)      문자열의 시작 인덱스를 알 수 있다.        startIndex를 String의 Subscript로 전달 하면 해당 인덱스의 문자를 알 수 있다.  let string: String = \"abcdefg\"let first = string.startIndexprint(string[first]) //aprefix(_:)  0~n번째까지의 Substring을 구할 수 있다.    let first = string.prefix(2)print(first) //ab      index(after:)  n번째 글자를 구할 수 있다.let first = string.startIndex//index(after:)은 매개변수로 String.Index를 받고 전달받은 String.Index의 다음 String.Index를 구할 수 있다.let second = string.index(after: first)print(string[second]) //bString.Index(endcodedOffset:)      String.Index를 생성할 때 encodedOffset 프로퍼티를 설정하면 n 번째 String.Index를 생성할 수 있다.    - 인덱스는 0부터 시작이니 3은 네 번째 문자가 된다.      print(string[String.Index(encodedOffset: 3)]) //dindex(_:offsetBy:)  offsetBy에 정수 n을 입력하면 Index에서 n만큼 이동한 String.Index를 구할 수 있다.let start = string.startIndexprint(string[string.index(start, offsetBy: 0)]) //aprint(string[string.index(start, offsetBy: 2)]) //c// offsetBy는 음수도 전달할 수 있다.let index = String.Index(encodedOffset: 3)print(string[string.index(index, offsetBy: -2)]) //b//3에서 -2를 한 1 번째 글자인 b가 출력된다.//주의할 점은 string 범위를 벗어날 경우 런타임 에러가 발생//startIndex에서 -1을 하면 string의 범위를 벗어나기 때문.endIndex (문자열의 마지막 문자 구하기)  그냥 endIndex를 하면 런타임 에러가 발생함          빈 공간을 가리키기 때문.      아래와 같이 사용한다.      print(string[string.index(before: string.endIndex)]) //gsuffix(_:)  뒤에서 부터 n개의 Substring을 구할 수 있다.    print(string.suffix(3)) //efg            firstIndex(of:)    특정 문자의 인덱스를 구할 때 쓴다.    print(string.firstIndex(of: \"d\")) //d의 String.Indexprint(string.firstIndex(of: \"h\")) //nil        firstIndex는 문자가 가장 먼저 나오는 String.Index를 반환하기 때문에 일치하는 문자가 여러 개면 가장 먼저 나오는 글자의 인덱스를 리턴한다.let string = \"aaaaa\"let distance = string.distance(from: string.startIndex, to: string.firstIndex(of: \"a\")!)print(distance) //0  index(of:) 도 같은 기능을 수행한다.lastIndex(of:)  마지막으로 나오는 String.Index를 반환.  일치하지 않는다면 nil을 반환    let string = \"aaaaa\"let distance = string.distance(from: string.startIndex, to: string.lastIndex(of: \"a\")!)print(distance) //4      "
  },
  
  {
    "title": "(Deep Dive) Array",
    "url": "/posts/(Deep-Dive)-Array/",
    "categories": "Udemy, Deep Dive",
    "tags": "배열",
    "date": "2024-02-29 11:19:00 +0900",
    





    
    "snippet": "Array (배열)  아이템들의 컬렉션이라고 할 수 있다.  변수에서 배열이란 단일 데이터와 연관되어있다.  배열의 생성          기본적으로 [ ] 대괄호를 사용한다.      대괄호 안에 데이터를 , 를 붙여 적어준다.        [1, 2, 3, \"apple\"][X]                뒤에 있는 또 다른 대괄호 안의 X는 배열에서...",
    "content": "Array (배열)  아이템들의 컬렉션이라고 할 수 있다.  변수에서 배열이란 단일 데이터와 연관되어있다.  배열의 생성          기본적으로 [ ] 대괄호를 사용한다.      대괄호 안에 데이터를 , 를 붙여 적어준다.        [1, 2, 3, \"apple\"][X]                뒤에 있는 또 다른 대괄호 안의 X는 배열에서 검색하고자 하는 항목의 위치 즉 Index를 가르킨다.            Q : 그렇다면 1은 첫번째니까 X 는 1부터 시작하는가?A : 안타깝지만 답은 X이다. 우리는 인덱스의 시작을 0으로 정의를 하므로 까먹지 말자.  또한 배열 앞에 변수를 선언 할 수 있다.```swiftvar fruits = [“apple”, “banana”, “grape”, “orange”]// 변수 뒤에 인덱스를 표현해보자fruits[0]fruits[1]```이번에도 아래 컴파일러를 통해 간단히 연습해보자."
  },
  
  {
    "title": "(Deep Dive) Variables",
    "url": "/posts/(Deep-Dive)-Variables/",
    "categories": "Udemy, Deep Dive",
    "tags": "변수",
    "date": "2024-02-29 11:13:00 +0900",
    





    
    "snippet": "생각해보니 Deep Dive는 내가 알고있던것들은 그냥 넘어갔는데, 이참에 그냥 내가 알고있는것들도 정리하는게 좋을 것 같아, Deep Dive로 하여 정리를 하고자 한다.어떤 데이터가 있다8907218937이런 데이터에 우리는 이름을 붙일 수 있다.Number = 8907218937이런식으로 이름을 붙일 수 있다.하지만 이걸로는 부족하다 조금 더 작...",
    "content": "생각해보니 Deep Dive는 내가 알고있던것들은 그냥 넘어갔는데, 이참에 그냥 내가 알고있는것들도 정리하는게 좋을 것 같아, Deep Dive로 하여 정리를 하고자 한다.어떤 데이터가 있다8907218937이런 데이터에 우리는 이름을 붙일 수 있다.Number = 8907218937이런식으로 이름을 붙일 수 있다.하지만 이걸로는 부족하다 조금 더 작성을 해주어야한다.var 라는 키워드가 필요하다.우리가 변수를 생성하고 있다고 알려주는 것이다.그래서 다시 한번 적어보면,var Number = 8907218937이렇게 되겠다.그럼 코드를 한번 작성해보자.a와 b라는 변수가 있다. 각각 5,8이라는 값을 주고 이것을 프린트 해보자var a = 5var b = 8print(\"a\") // aprint(b) // 8괄호 안에 “a” 이렇게 적어버리면 우리가 원하는 5가 아닌 a를 출력한다.그래서 어떤 변수를 출력할때는 괄호안에 그 변수명만 적어두도록 하자.Q : “ “ 안에는 변수를 넣지 못하는 걸까?A : 아니다, 가능하다.출력을 할때 \\ ()를 사용하게 되면 변수를 담을 수 있다.var a = 5var b = 8print(\"The value of a is \\(a)\") // the value of a is 5print(\"The value of a is \\(b)\") // the value of a is 8아래 간단한 연습을 할 수있는 컴파일러가 있다. 한번 연습 해보도록 하자."
  },
  
  {
    "title": "203. 크기가 작은 부분 문자열",
    "url": "/posts/203.-_%ED%81%AC%EA%B8%B0%EA%B0%80-%EC%9E%91%EC%9D%80-%EB%B6%80%EB%B6%84-%EB%AC%B8%EC%9E%90%EC%97%B4/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ t:String, _ p:String) -&gt; Int {        var arr : [String] = []    var answer : [String] = []    var string : String = \"\"    var intanswer : Int = 0        arr = t...",
    "content": "import Foundationfunc solution(_ t:String, _ p:String) -&gt; Int {        var arr : [String] = []    var answer : [String] = []    var string : String = \"\"    var intanswer : Int = 0        arr = t.map{String($0)}        if Int(p)! &gt; 1 {        for i in 0 ... arr.count-p.count {            string = \"\"                for j in i ..&lt; i + (p.count) {                    string += arr[j]                }                answer.append(string)            }             } else {        answer = arr    }    intanswer = answer.filter{Int(String($0))! &lt;= Int(p)!}.count    return intanswer}뭔가 Stylish하게 하고싶었는데 그러지 못했다.일단 t에대해 각각의 원소를 담는 배열로 만들었다.그리고나서 p가 1일때는 map그대로 쓰면 되기에 if조건을 달아서 1보다 클때를 기준으로 나눴다.그리고서 반복문을 사용했는데string은 계속 initializing해주었고, 그하위 반복문을 통해 t의 길이만큼 slicing하였다.처음에는 생각없이 for i에서 in 0..&lt;arr.count를 하는바람에 그다음 for문에서 i+p.count가 i를 벗어나서 out of range에러가 났다. 그래서 확인해보니, for 문에서 t.count만큼 빼주어야하는데 그러질 못했다.그렇게 새로 만들어둔 배열 answer에 p의 갯수만큼 슬라이싱한 값을 넣었다.그리고 filter를 통해 p의 값보다 같거나 작은 갯수를 리턴하였다.문제는 풀었으나 썩 맘에 들진않는다."
  },
  
  {
    "title": "202. 삼총사 (ing)",
    "url": "/posts/202.-%EC%82%BC%EC%B4%9D%EC%82%AC/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "201. 이상한 문자 만들기",
    "url": "/posts/201.-%EC%9D%B4%EC%83%81%ED%95%9C-%EB%AC%B8%EC%9E%90-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "func solution(_ s:String) -&gt; String {        var answer : String = \"\"    var index = 0        for string in s {        if string ==  \" \" {            index = 0            answer += \" \"        } ...",
    "content": "func solution(_ s:String) -&gt; String {        var answer : String = \"\"    var index = 0        for string in s {        if string ==  \" \" {            index = 0            answer += \" \"        } else if index % 2 == 0 {            answer += string.uppercased()            index += 1        } else {            answer += string.lowercased()            index -= 1        }    }        print(answer)        return answer}enumerated로 하려고했는데 나는 실패했는데components로 안하고 split으로 한게 문제였던것일까….결국 인덱스값으로 만들었다….이것도 처음에 enumerated()를 사용하여 offset,element로 구분하여 offset의 값을 initializing하면서 하고 싶었는데, 의도대로 되지 않았다. 상수이기 때문이었다..그래서 간략하게 index라는 변수를 만들었고 그 변수를 0 부터 시작하고 1씩 증가하되, “ “을 만나면 제로세팅 하도록 하여 해결하였다.다른 코드를 보니 거의 근접하게 했던거같은데 뒷심이 부족했던거같다.다른코드import Foundationfunc solution(_ s:String) -&gt; String {    let a = s.components(separatedBy: \" \").map { $0.enumerated().map { $0.offset % 2 == 0 ? $0.element.uppercased() : $0.element.lowercased() } }    return a.map{ $0.map { $0 }.joined() }.joined(separator: \" \")}"
  },
  
  {
    "title": "200. 3진법 뒤집기",
    "url": "/posts/200.-3%EC%A7%84%EB%B2%95-%EB%92%A4%EC%A7%91%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var arr : [Int] = []    var N : Int = 0    var answer : Int = 0    N = n        while N != 0 {        arr.append(N%3)        N = N/3    } ...",
    "content": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var arr : [Int] = []    var N : Int = 0    var answer : Int = 0    N = n        while N != 0 {        arr.append(N%3)        N = N/3    }        arr = arr.reversed()        for i in arr.indices{        answer += arr[i] * Int(pow(Double(3),Double(i)))    }        print(answer)        return answer}우선 3으로 나눈 값의 나머지를 배열에 담았다.그리고 배열을 반대로 바꾸어 주었다. 왜냐하면 인덱스로 접근하기 위해서였다.그렇게 하고 배열의 값을 pow를 사용해서 곱하여 더했다.전에 찾아보니 radix를 사용하면 쉽게 진수변환이 가능하다는걸 알았다. 여기에 별도로 적어둔다.var sample : Int = 125var conversion : String = \"\"conversion = String(sample, radix: 3)print(conversion) //11122기본적으로 string이지만 int로 바꿔 unwrapping해주면 된다."
  },
  
  {
    "title": "199. 최대공약수와 최소공배수",
    "url": "/posts/199.-%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "func solution(_ n:Int, _ m:Int) -&gt; [Int] {    var N = n    var M = m    var arr : [Int] = []    var gcd : Int = 0    var lcm : Int = 0    var temp : Int = 0    if N &lt; M {        temp = N     ...",
    "content": "func solution(_ n:Int, _ m:Int) -&gt; [Int] {    var N = n    var M = m    var arr : [Int] = []    var gcd : Int = 0    var lcm : Int = 0    var temp : Int = 0    if N &lt; M {        temp = N        N = M        M = temp    }    while M != 0 {        temp = N%M        N=M        M=temp    }    gcd = N    lcm = gcd == 1 ? n * m : (n/gcd) * (m/gcd) * gcd    arr.append(gcd)    arr.append(lcm)    return arr}최대공약수 최소공배수를 너무 오래간만에 해서 숫자를 보면 바로 계산이 되었지만 이걸 어떻게 코드로 풀어나가야할지 고민이 많이 되었다.그래서 최대공약수를 어떻게 구하는지를 먼저 찾아보고그것을 코드로 구현을 했다.코드로 구현을 하고나서 찾아보니 내가 한방식이 틀리지 않았다는걸 알았지만, 한편으로는 뭔가 더 간편하게 할수있는 방법이 있지않을까라는 생각을 좀 하게된다.최소공배수는 직접 계산을 해보고 그에 따른걸 코드로 표현을 하였고 그리고 삼항연산자로 표현이 가능할 것 같아 이렇게 표현을 하게되었다.뭔가 풀고나서도 조금 찝찝한 문제로 느껴진다."
  },
  
  {
    "title": "198. 직사각형 별찍기",
    "url": "/posts/198.-%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95-%EB%B3%84%EC%B0%8D%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "import Foundationlet n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! }let (a, b) = (n[0], n[1])var row = Array(repeating: \"*\",count:a).joined()for i in 0..&lt;b {    print(row)}repeat...",
    "content": "import Foundationlet n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! }let (a, b) = (n[0], n[1])var row = Array(repeating: \"*\",count:a).joined()for i in 0..&lt;b {    print(row)}repeating을 사용하여 행을 만들었고 그다음 for문을 통해 반복출력하였다."
  },
  
  {
    "title": "197. 행렬의 덧셈",
    "url": "/posts/197.-%ED%96%89%EB%A0%AC%EC%9D%98-%EB%8D%A7%EC%85%88/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "func solution(_ arr1:[[Int]], _ arr2:[[Int]]) -&gt; [[Int]] {        var answer : [[Int]] = []    answer = zip(arr1,arr2).map{zip($0,$1).map{$0+$1}}        return answer}zip을 사용해보려고 아래와 같이 이것저것 해보았...",
    "content": "func solution(_ arr1:[[Int]], _ arr2:[[Int]]) -&gt; [[Int]] {        var answer : [[Int]] = []    answer = zip(arr1,arr2).map{zip($0,$1).map{$0+$1}}        return answer}zip을 사용해보려고 아래와 같이 이것저것 해보았다.여기서 예시는 아래와 같다var arr1 : [[Int]]= [[1, 2], [2, 3]]var arr2: [[Int]]= [[3, 4], [5, 6]]첫번째는 zip을 하였을때 합이 아닌 이어 붙이기와 같은 효과가 되어버렸다print(zip(arr1,arr2).map{$0+$1}) //[[1, 2, 3, 4], [2, 3, 5, 6]]print(zip(arr1,arr2).map{($0+$1).reduce(0,+)})//[10, 16]그래서 zip으로 먼저 arr1,arr2를 해서 확인해보면 다음과 같이나온다print(zip(arr1,arr2))//Zip2Sequence&lt;Array&lt;Array&lt;Int&gt;&gt;, Array&lt;Array&lt;Int&gt;&gt;&gt;(_sequence1: [[1, 2], [2, 3]], _sequence2: [[3, 4], [5, 6]])Dictionary와 같이 되어버리기에 map으로 $0,$1을 더하면 배열 합치기의 개념으로 되어버린다.let myFriends = [\"Fuu\", \"Emma\", \"Jason\"]let otherFriends = [\"Mike\", \"Luck\", \"Paul\"]let totalFriends = myFriends + otherFriendsprint(totalFriends) // [\"Fuu\", \"Emma\", \"Jason\", \"Mike\", \"Luck\", \"Paul\"]다만 다른건 arr1+arr2를 하면print(arr1+arr2)// [[1, 2], [2, 3], [3, 4], [5, 6]]2차원 배열은 유지하되, 큰틀의 껍데기에 [3,4],[5,6] 만 추가가 된다.그래서 zip.map{zip}을 다시 해주게 되면 아래와 같다.[Swift.Zip2Sequence&lt;Swift.Array&lt;Swift.Int&gt;, Swift.Array&lt;Swift.Int&gt;&gt;(_sequence1: [1, 2], _sequence2: [3, 4]), Swift.Zip2Sequence&lt;Swift.Array&lt;Swift.Int&gt;, Swift.Array&lt;Swift.Int&gt;&gt;(_sequence1: [2, 3], _sequence2: [5, 6])]첫번째 zip과는 달리 sequence1이 1차배열로 되어있다. 즉 zip-&gt;map-&gt;zip을 이용하여 1차배열로 전환해주는 것이다. 그리고나서 다시 map을 하게되면 클로저들끼리 이어붙여지므로 원하는 결과값이 나온다."
  },
  
  {
    "title": "196. 문자열 다루기 기본",
    "url": "/posts/196.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EA%B8%B0%EB%B3%B8/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "func solution(_ s:String) -&gt; Bool {        var answer : Bool = true        answer =  s.count == 4 || s.count == 6 ? (s.map{$0.isNumber}.contains(false) ? false : true) : false         return ans...",
    "content": "func solution(_ s:String) -&gt; Bool {        var answer : Bool = true        answer =  s.count == 4 || s.count == 6 ? (s.map{$0.isNumber}.contains(false) ? false : true) : false         return answer}정수인지 아닌지를 판단하는 isNumber 메서드를 이용하여 풀었다.하지만 처음에는 단순히 변환만 하고 filter를 사용하여 false만 걸러내려고 했는데, 오답이 많이 나와서 이유를 생각해보니, 문자가 여러개 있을때는 filter 를 하게되면 false가 여러개 나와서 [false] 하나로 보기엔 논리적으로 오류가 있었다.그래서 map과 isNumber를 함께 사용하여 true, false를 함께 나타내는 배열에서 false의 갯수와 상관없이 하나라도 포함을 하면 되는것이라고 생각하여 contains를 사용하였다.그리고나서 바로 돌려본 결과 오답이 줄긴했지만 완전한 정답이 아니어서 조건을 다시보니 s.count = 4 와 6일때만 해당 조건식이 성립이 되고 나머지는 false가 되어야 한다고 생각해서 추가로 조건을 더하여 풀었다.처음에는 단순히 s.isNumber로 하려고했는데 에러가 나서 map으로 하게되었다.다른 코드들을 보니 그냥 s를 Int로 감쌌을때 nil인지 아닌지를 이용하여 풀었다.너무 복잡하게 생각을 했던것같다."
  },
  
  {
    "title": "195. 부족한 금액 계산하기",
    "url": "/posts/195.-%EB%B6%80%EC%A1%B1%ED%95%9C-%EA%B8%88%EC%95%A1-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ price:Int, _ money:Int, _ count:Int) -&gt; Int64{    var answer:Int64 = -1        var Price : Int = 0        Price = (1...count).map{$0}.reduce(0, +) * price       ...",
    "content": "import Foundationfunc solution(_ price:Int, _ money:Int, _ count:Int) -&gt; Int64{    var answer:Int64 = -1        var Price : Int = 0        Price = (1...count).map{$0}.reduce(0, +) * price        answer = money &gt; Price ? 0 : Int64(Price-money)            return answer}단순 범위를 이용하여 map으로 배열을만들고 reduce를 함으로써 간단하게 범위의 합을 구할 수 있어서 1부터 카운트 까지 합을 구하였다.이유는 입출력의 예를 보고 이용금액이 (3+6+9+12) 라는것은 3(1+2+3+4) 이고즉 price * count까지의 누적합이기 때문이었다.그렇게 총 이용금액을 구해두고 삼항연산자를 통해 return 하였다."
  },
  
  {
    "title": "194. 문자열 내림차순으로 배치하기",
    "url": "/posts/194.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "func solution(_ s:String) -&gt; String {        var string : String = \"\"        string = s.map{String($0)}.sorted(by:&gt;).joined()    return string}배열로 변환하여 내림차순으로 한뒤 다시 join으로 하면서 문자열을 하나로 맞추었다.",
    "content": "func solution(_ s:String) -&gt; String {        var string : String = \"\"        string = s.map{String($0)}.sorted(by:&gt;).joined()    return string}배열로 변환하여 내림차순으로 한뒤 다시 join으로 하면서 문자열을 하나로 맞추었다."
  },
  
  {
    "title": "193. 약수의 개수와 덧셈",
    "url": "/posts/193.-%EC%95%BD%EC%88%98%EC%9D%98-%EA%B0%9C%EC%88%98%EC%99%80-%EB%8D%A7%EC%85%88/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ left:Int, _ right:Int) -&gt; Int {        var n : Int = 0    var num : Int = 0    var answer : Int = 0        for i in left ... right {        n = 1        num = 0 ...",
    "content": "import Foundationfunc solution(_ left:Int, _ right:Int) -&gt; Int {        var n : Int = 0    var num : Int = 0    var answer : Int = 0        for i in left ... right {        n = 1        num = 0        while i &gt;= n {            if i % n == 0 {                num += 1            }            n+=1        }        if num % 2 == 0 {            answer += i        } else {            answer -= i        }           }           return answer}for 문과 while문을 통해 약수를 구하고 while이 끝난 다음 if문을 통해 해당 약수의 개수가 짝수 또는 홀수일때를 판별하여 처리하였다.다른코드func solution(_ left: Int, _ right: Int) -&gt; Int {    return (left...right).map { i in (1...i).filter { i % $0 == 0 }.count % 2 == 0 ? i : -i }.reduce(0, +)}"
  },
  
  {
    "title": "192. 내적",
    "url": "/posts/192.-%EB%82%B4%EC%A0%81/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ a:[Int], _ b:[Int]) -&gt; Int {    var answer : Int = 0    for i in a.indices{        answer += a[i]*b[i]    }    return answer}for문을 사용해서 해결했는데 다른코드들을 보니 zip이 있었다....",
    "content": "import Foundationfunc solution(_ a:[Int], _ b:[Int]) -&gt; Int {    var answer : Int = 0    for i in a.indices{        answer += a[i]*b[i]    }    return answer}for문을 사용해서 해결했는데 다른코드들을 보니 zip이 있었다.다른코드import Foundationfunc solution(_ a:[Int], _ b:[Int]) -&gt; Int {    return zip(a, b).map(*).reduce(0, +)}zip  2개 이상의 시퀀스를 조합하여 하나의 새로운 시퀀스를 생성한다.  zip함수를 사용하면 여러 시퀀스들을 병렬로 순회하며 요소들을 조합 할 수 있다.  zip은 각 시퀀스에서 동일한 인덱스의 요소들을 묶어 새로운 튜플 시퀀스로 반환한다.zip(sequence1, sequence2, sequence3, ...)let numbers = [1, 2, 3, 4, 5]let strings = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"]let zipped = zip(numbers, strings)for (number, string) in zipped {    print(\"\\(number) is \\(string)\")}"
  },
  
  {
    "title": "191. 수박수박수박수박수박수?",
    "url": "/posts/191.-%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98%EB%B0%95%EC%88%98_/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "func solution(_ n:Int) -&gt; String {        var answer : String = \"\"    var sent : String = \"\"        sent = String(repeating: \"수박\", count:5000)        answer = String(sent.prefix(n))            r...",
    "content": "func solution(_ n:Int) -&gt; String {        var answer : String = \"\"    var sent : String = \"\"        sent = String(repeating: \"수박\", count:5000)        answer = String(sent.prefix(n))            return answer}suffix : 시작 기준으로 지정한 문자 개수 출력prefix : 종료 기준으로 지정한 문자 개수 출력요새 자주 까먹는다 기억 잘 해두자.수박수박~ 이렇게 이어져가야해서 repeating을 통해 예문을 만들고그것을 n의 범위까지 추출하는 방식으로 풀었다다른 코드들을 보니 너무 복잡하게 생각을 했나 싶기도 하다.오히려 내가 짠 코드가 생각을 해보면 예문을 만들어야해서 메모리를 더 잡아먹을것이다.다른코드func solution(_ n:Int) -&gt; String {    return \"\\(String(repeating: \"수박\", count: n / 2))\\(n % 2 == 0 ? \"\" : \"수\")\"}//func solution(_ n:Int) -&gt; String {    return (0..&lt;n).map{($0%2==0 ? \"수\":\"박\")}.reduce(\"\", +)}"
  },
  
  {
    "title": "190. 가운데 글자 가져오기",
    "url": "/posts/190.-%EA%B0%80%EC%9A%B4%EB%8D%B0-%EA%B8%80%EC%9E%90-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "func solution(_ s:String) -&gt; String {    var answer : String = \"\"    var S : String = \"\"    var n : Int = 0    S = s    n = S.count    answer = n % 2 == 0 ? String(S[String.Index(encodedOffset:(...",
    "content": "func solution(_ s:String) -&gt; String {    var answer : String = \"\"    var S : String = \"\"    var n : Int = 0    S = s    n = S.count    answer = n % 2 == 0 ? String(S[String.Index(encodedOffset:(n/2)-1)]) + String(S[String.Index(encodedOffset:n/2)]) : String(S[String.Index(encodedOffset:n/2)])    return answer}아래코드와 거의 비슷하나 나는 Index 범위를 생각을 하긴했지만 적용을 하질 못해서 무식하게 그냥 더해서 했다.좀 더 공부해야겠다.다른코드func solution(_ s:String) -&gt; String {    return String(s[String.Index(encodedOffset: (s.count-1)/2)...String.Index(encodedOffset: s.count/2)])}"
  },
  
  {
    "title": "189. 제일 작은 수 제거하기",
    "url": "/posts/189.-%EC%A0%9C%EC%9D%BC-%EC%9E%91%EC%9D%80-%EC%88%98-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "func solution(_ arr:[Int]) -&gt; [Int] {        var answer : [Int] = []        answer = arr        if answer.count &gt; 1 {                answer.remove(at:answer.firstIndex(of:arr.min()!)!)       ...",
    "content": "func solution(_ arr:[Int]) -&gt; [Int] {        var answer : [Int] = []        answer = arr        if answer.count &gt; 1 {                answer.remove(at:answer.firstIndex(of:arr.min()!)!)                return answer            } else {                return [-1]            }}firstIndex, min 모두 optional 가능성이 있기에 unwrapping을 해줘야하는데 min에만 꽂혀서 거기만 unwrapping하고 생각하다가. of:뒤에 숫자를 넣고 테스트를 해보니 firstIndex역시 unwrapping이 필요했다."
  },
  
  {
    "title": "188. 없는 숫자 더하기",
    "url": "/posts/188.-%EC%97%86%EB%8A%94-%EC%88%AB%EC%9E%90-%EB%8D%94%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ numbers:[Int]) -&gt; Int {        var answer : Int = 0        answer = (0...9).map{$0}.reduce(0, +) - numbers.reduce(0,+)        return answer}없는 숫자를 더한다고해서 처음에 con...",
    "content": "import Foundationfunc solution(_ numbers:[Int]) -&gt; Int {        var answer : Int = 0        answer = (0...9).map{$0}.reduce(0, +) - numbers.reduce(0,+)        return answer}없는 숫자를 더한다고해서 처음에 contains를 써야하나 고민을 하다가 생각해보니 0~9까지 더한 숫자에서 현재 배열에 가지고 있는 숫자를 더한값을 빼면 그게 없는 숫자의 총합이라는것을 알게되었고, reduce를 사용하여 간략하게 해보려고 하였다."
  },
  
  {
    "title": "187. 핸드폰 번호 가리기",
    "url": "/posts/187.-%ED%95%B8%EB%93%9C%ED%8F%B0-%EB%B2%88%ED%98%B8-%EA%B0%80%EB%A6%AC%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "func solution(_ phone_number:String) -&gt; String {        var answer : String = \"\"    var arr : [String] = []        arr = phone_number.map{String($0)}        if arr.count &gt; 4 {        for i in...",
    "content": "func solution(_ phone_number:String) -&gt; String {        var answer : String = \"\"    var arr : [String] = []        arr = phone_number.map{String($0)}        if arr.count &gt; 4 {        for i in 0...arr.count-5 {            arr[i] = \"*\"        }        answer = arr.joined()    } else {        answer = phone_number    }    return answer}우선 배열로 만들었다. 그리고 count -5를하여 뒤의 4자리만 살리게 하려고 하였다.그대로 제출을 하니 count 가 4일때 즉 길이가 4일때는 에러가 발생하였다.그래서 if 문을 걸어서 길이가 4일때는 문자열 그대로 출력하게 하였다.suffix, prefix를 알고있었으나 적용을 할수가 없었다. 지식이 부족했다.repeating을 사용하여 *을 반복적으로 생성하게 하였다.다른코드func solution(_ phone_number:String) -&gt; String {    return String(\"\\(String(repeating: \"*\", count: phone_number.count - 4))\\(phone_number.suffix(4))\")}"
  },
  
  {
    "title": "186. 음양 더하기",
    "url": "/posts/186.-%EC%9D%8C%EC%96%91-%EB%8D%94%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ absolutes:[Int], _ signs:[Bool]) -&gt; Int {        var answer : Int = 0        for (index, value) in signs.enumerated() {        if value == true {           ...",
    "content": "나의 코드import Foundationfunc solution(_ absolutes:[Int], _ signs:[Bool]) -&gt; Int {        var answer : Int = 0        for (index, value) in signs.enumerated() {        if value == true {                answer += absolutes[index]                    } else {                        answer -= absolutes[index]                    }    }        return answer}이렇게 생각한 이유.처음에는 단순한 signs 배열에서 index에 접근해서 하려고 했으나 되지 않았다. (for 문에 count대신, 배열 그자체로 접근해서 안되었다.)알고보니 dictionary type으로 쓸 수있는 enumerated를 사용하는 방법이 있어서 해당 방법으로 문제를 풀었다.역시 처음에 보고 생각했던 map 같은 고차함수를 사용한 풀이를 보았다.나도 생각은 했지만 오래걸릴것 같아 구현하지 못했는데, 추후에 다시 복습할때는 써봐야겠다.      enumerated          array값에 enumerated()함수를 사용하면, (index, value) 튜플형식으로 구현된 리스트형이 리턴      let arr = [\"one\", \"two\", \"three\"]print(arr.enumerated()) // EnumeratedSequence&lt;Array&lt;String&gt;&gt;(_base: [\"one\", \"two\", \"three\"])    for (index, number) in arr.enumerated() {        print(\"\\(index), \\(number)\")}/* 0, one 1, two 2, three */다른코드import Foundationfunc solution(_ absolutes:[Int], _ signs:[Bool]) -&gt; Int {    return (0..&lt;absolutes.count).map { signs[$0] ? absolutes[$0] : -absolutes[$0] }.reduce(0, +)}//mport Foundationfunc solution(_ absolutes:[Int], _ signs:[Bool]) -&gt; Int {    zip(absolutes, signs)        .map { $1 ? $0 : -$0 }        .reduce(0, +)}//import Foundationfunc solution(_ absolutes:[Int], _ signs:[Bool]) -&gt; Int {    var answer = 0    for i in 0..&lt;signs.count {        answer += signs[i] == true ? absolutes[i] : -absolutes[i]    }    return answer}//import Foundationfunc solution(_ absolutes:[Int], _ signs:[Bool]) -&gt; Int {    let n :Int = absolutes.count    var sum: Int = 0    for i in 0..&lt;n {        if signs[i] == true {            sum += absolutes[i]        } else {            sum -= absolutes[i]        }    }    return sum}"
  },
  
  {
    "title": "185. 나누어 떨어지는 숫자",
    "url": "/posts/185.-%EB%82%98%EB%88%84%EC%96%B4-%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94-%EC%88%AB%EC%9E%90/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드func solution(_ arr:[Int], _ divisor:Int) -&gt; [Int] {        var answer : [Int] = []    for i in arr {        if i % divisor == 0 {            answer.append(i)        }    }        if answer...",
    "content": "나의 코드func solution(_ arr:[Int], _ divisor:Int) -&gt; [Int] {        var answer : [Int] = []    for i in arr {        if i % divisor == 0 {            answer.append(i)        }    }        if answer.count == 0 {        answer.append(-1)    }        answer.sort()        return answer}이렇게 생각한 이유.어제 문제풀고 깜빡하고 올리지 않아서 오늘 올린다.일단 배열에 접근하여 divisor로 나머지가 0 즉 나누어 떨어지는 값을 answer라는 새로운 배열에 담았다.그리고 하나도 없다는 조건이 있으므로 새로운 if문을 만들어서 추가를 하였다.문제에서 오름차순으로 정렬을 하라고 했기에.sorted를 쓸까 하다가 배열 자체를 바꾸는 sort를 통하여 그냥 answer를 리턴하였다."
  },
  
  {
    "title": "184. 서울에서 김서방 찾기",
    "url": "/posts/184.-%EC%84%9C%EC%9A%B8%EC%97%90%EC%84%9C-%EA%B9%80%EC%84%9C%EB%B0%A9-%EC%B0%BE%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드func solution(_ seoul:[String]) -&gt; String {        var answer : String = \"\"        answer=\"김서방은 \\(seoul.firstIndex(of:\"Kim\")!)에 있다\"        return answer}이렇게 생각한 이유.처음에는 for 문을 통해 배열에 접근하여 반...",
    "content": "나의 코드func solution(_ seoul:[String]) -&gt; String {        var answer : String = \"\"        answer=\"김서방은 \\(seoul.firstIndex(of:\"Kim\")!)에 있다\"        return answer}이렇게 생각한 이유.처음에는 for 문을 통해 배열에 접근하여 반복문을 돌리면서 “Kim”과 일치할때의 i값을 찾아 i를 리턴하여 출력을 하려고 하였다.하지만 비효율적이라는것을 알았고, 배열에 직접 접근하는 키워드를 통하여 코드를 간략화 하였다.그리고 firstIndex를 사용하여 일단 내용부터 프린트를 해보니 optional(1)로 나와서 unwrapping을 해주고 출력하였다."
  },
  
  {
    "title": "183. 콜라츠 추측",
    "url": "/posts/183.-%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%B6%94%EC%B8%A1/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드func solution(_ num:Int) -&gt; Int {        var Num : Int = 0    var answer : Int = 0        Num = num        while Num != 1 {                if Num % 2 == 0 {                        Num = Num...",
    "content": "나의 코드func solution(_ num:Int) -&gt; Int {        var Num : Int = 0    var answer : Int = 0        Num = num        while Num != 1 {                if Num % 2 == 0 {                        Num = Num / 2            answer += 1                    } else {                        Num = (Num * 3) + 1            answer += 1                    }                if answer &gt;= 500{            answer = -1            break        }            }         print(Num)    print(answer)        return answer}이렇게 생각한 이유.우선 제한사항의 수를 넣는것을 깜빡하였다.항상 if로해서 넣었는데 이번에는 깜빡하였고, 다음에는 이런 실수를 하지 않기 위해 코드를 수정하지 않았다.while문에서 깜빡하고, 1이 아닐때 계속 돌게 해야하는데 그걸 반대로 생각을 하는 바람에 코드를 다 작성해두고도 while Num == 1로 해서 코드가 한번도 안돌고 나오는 참사를 맞이 했다.오래간만에 했다고 쳐도 이런 실수를 바로 캐치를 못했기에 다시 복습을 해야할것 같다."
  },
  
  {
    "title": "182. 두 정수 사이의 합",
    "url": "/posts/182.-%EB%91%90-%EC%A0%95%EC%88%98-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%95%A9/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드func solution(_ a:Int, _ b:Int) -&gt; Int64 {        var answer = 0        if a &gt;= -10000000 &amp;&amp; a &lt;= 10000000 &amp;&amp; b &gt;= -10000000 &amp;&amp; b &lt;= 10000000 {        if...",
    "content": "나의 코드func solution(_ a:Int, _ b:Int) -&gt; Int64 {        var answer = 0        if a &gt;= -10000000 &amp;&amp; a &lt;= 10000000 &amp;&amp; b &gt;= -10000000 &amp;&amp; b &lt;= 10000000 {        if a != b {                        if a&gt;b {                for i in b ... a {                                        answer += i                                    }            }                        else {                for i in a ... b {                                        answer += i                }            }                            } else {                answer = a            return Int64(answer)                    }            }        return Int64(answer)}이렇게 생각한 이유.그냥 기본적인 생각에 입각하여 작성하였다.이것도 다른 풀이를 보니. 최댓값 최솟값 부터 시작해서, 이것도 역시 reduce를 통해 해결하였다.나도 reduce를 생각하였으나 오래걸릴것같아 하지 못했는데, 나중에 시간날때 해봐야겠다."
  },
  
  {
    "title": "181. 하샤드 수",
    "url": "/posts/181.-%ED%95%98%EC%83%A4%EB%93%9C-%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드func solution(_ x:Int) -&gt; Bool {        var answer : Bool  = true            answer = x % String(x).compactMap{Int(String($0))}.reduce(0, +) == 0  ? true : false        return answer}이렇게 작성...",
    "content": "나의 코드func solution(_ x:Int) -&gt; Bool {        var answer : Bool  = true            answer = x % String(x).compactMap{Int(String($0))}.reduce(0, +) == 0  ? true : false        return answer}이렇게 작성한 이유.이번에는 고차함수와 삼항연산자를 모두 써보려고 노력을 했다.그러다보니 더 오랜시간이 걸렸고, 정리를 했으나 아직까지 내것으로 만들지 못했다는 생각이 들었다.확실히 작성을 해두니, 코드가 엄청 깔끔하다는 생각은 든다.다른코드를 보니 reduce를 이용해서도 만들었는데 nil을 처리하기위해 옵셔널 바인딩인 !를 처리한걸 볼 수 있었다. 나는 nil을 처리할 수 있는 compactMap을 이용했다.하지만 뒤의 매개변수를 아직 깔끔하게 하지는 못했다.조금 더 복습과 공부를 하면서 내것으로 만들어야 겠다.reduce를 쓰려고하니 확실히 막힌다.많이 부족함을 느낀다.다른코드String(x).reduce(0, {$0+Int(String($1))!}) == 0더 공부를 해야겠다."
  },
  
  {
    "title": "180. 정수 내림차순으로 배치하기",
    "url": "/posts/180.-%EC%A0%95%EC%88%98-%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드func solution(_ n:Int64) -&gt; Int64 {            var N : Int64 = 0    var answer : Int64 = 0    var arr : [Int] = []               if n &gt;= 1 &amp;&amp; n &lt;= 8000000000 {                ...",
    "content": "나의 코드func solution(_ n:Int64) -&gt; Int64 {            var N : Int64 = 0    var answer : Int64 = 0    var arr : [Int] = []               if n &gt;= 1 &amp;&amp; n &lt;= 8000000000 {                N = n                for i in 1 ... n {                        arr.append(Int(N%10))                        N = N/10                        if N &lt; 1 {                break            }        }                   }        var arr1 : [Int] = arr.sorted(by:&gt;)        var answer1 = arr1.map(String.init).joined()        print(answer1)        answer = Int64(answer1)!        return answer}이렇게 생각한 이유.솔직히 좀 방식이 무식하게 했다고 생각한다. 일단 각 자릿수를 반환하기 위해서 배열을 만들고 나머지값을 append를 통해 하나씩 넣었다.그 이후에, 정렬하는 sort함수를 이용해 내림차순 정리를 하였다.하지만 그 이후가 문제였다. 배열에 있는 숫자를 꺼내서 하나로 합쳐야 했기 때문이다.여기서 하나로 합친다는 것은 인덱스 순으로 꺼내어 그냥 이어 붙인다는 의미.그래서 내 생각선에서는 도저히 안되어서 구글링을 하였고, 배열의 정수값을 문자열로 리턴하는 함수를 찾았다.요근래 정리해야했던 고차함수의 응용부분이었다 (map,reduce,filter) 그래서 이왕 이렇게 된거 아래쪽에다가 정리를 하려고한다.(내용이 너무 길어 새로 페이지를 작성한다.)sort / sorted  sort          기존의 배열을 재 정렬한다.      원본이 사라진다.        sorted          기존의 배열은 그대로 두고, 새로운 copy본을 만들어 정렬한다.      원본은 그대로 남아있는다.            내림차순과 오름차순          기본적으로 오름차순이다 (), ()안에 by:&lt; 를 넣어도 된다.      ()안에 by:&gt; 를 넣게 되면 내림차순이 된다      예시var arr = [2, 24, 45, 36, 9]// 오름차순 정렬arr.sort()print(arr) // [2, 9, 24, 36, 45]// 내림차순 정렬arr.sort(by:&gt;) print(arr) // [45, 36, 24, 9, 2]"
  },
  
  {
    "title": "179. 정수 제곱근 판별",
    "url": "/posts/179.-%EC%A0%95%EC%88%98-%EC%A0%9C%EA%B3%B1%EA%B7%BC-%ED%8C%90%EB%B3%84/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ n:Int64) -&gt; Int64 {        var N : Double = 0    var answer : Int64 = 0        N = Double(n)        if n &gt;= 1 &amp;&amp; n &lt;= 50000000000000 {        ...",
    "content": "나의 코드import Foundationfunc solution(_ n:Int64) -&gt; Int64 {        var N : Double = 0    var answer : Int64 = 0        N = Double(n)        if n &gt;= 1 &amp;&amp; n &lt;= 50000000000000 {                if pow(sqrt(N),2.0) ==  N {                        answer = Int64(pow(sqrt(N)+1.0, 2.0))                    } else {                        answer = -1        }                    } else {                return 0            }        return answer}이렇게 생각한 이유.처음에는 어떻게 할지 몰라서 계속 생가하다가 결구 구글링을 하게 되었다, 다른사람의 코드를 직접적으로 본것은 아니지만, 해당글을 통해 아이디어를 얻었고 위와 같이 코드를 작성하였다.하지만 101이이라는 예외의 수가 존재하였고, 제출하였으나 오답이 되었다.그래서 print를 통해 그 답을 찍어보니 101의 경우 -1이 나와야 했으나, 122이라는 엉뚱한 답이 도출이 되었다.그래서 해당부분을 바꾸기위해 int로 돌리려고 하였으나 pow가 지원하는 데이터형식에 맞지 않았다.그래서 해당부분에대해 고전을 하였다.그러다가 이것저것 자료를 더 찾아봐야겠다 싶어서 swift의 소수점에 관한 내용을 찾아보았다.Swift에서의 소수점 다루기.  반올림(round)예시    round(5.55) // 6.0round(5.3) // 5.0        올림(ceil)예시    ceil(5.55) // 6.0ceil(5.4) // 6.0        내림(floor)예시    floor(5.4) // 5.0floor(5.55) // 5.0floor(-3.44) // -4.0floor(-3.677) // -4.0        버림(trunc)예시    trunc(5.6) // 5.0trunc(5.3) // 5.0trunc(-3.44) // -3.0trucn(-3.66) // -3.0          수정한 코드import Foundationfunc solution(_ n:Int64) -&gt; Int64 {        var N : Double = 0    var answer : Int64 = 0        N = Double(n)        if n &gt;= 1 &amp;&amp; n &lt;= 50000000000000 {                if pow(floor(sqrt(N)),2.0) ==  N {                        answer = Int64(pow(sqrt(N)+1.0, 2.0))                    } else {                        answer = -1        }                    } else {                return 0            }        return answer}연산과 관련된 것도 정리해야겠다는 생각이든다."
  },
  
  {
    "title": "178. 문자열을 정수로 바꾸기",
    "url": "/posts/178.-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%EC%A0%95%EC%88%98%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ n_str:String) -&gt; Int {        var answer : Int = 0        answer = Int(n_str)!        return answer}이렇게 생각한 이유.일단 일차원적으로 생각을 했다. 단순히 문자열에 인트를 감싼 일차적인 변환.아니나...",
    "content": "나의 코드import Foundationfunc solution(_ n_str:String) -&gt; Int {        var answer : Int = 0        answer = Int(n_str)!        return answer}이렇게 생각한 이유.일단 일차원적으로 생각을 했다. 단순히 문자열에 인트를 감싼 일차적인 변환.아니나 다를까 역시 데이터형이 맞지않다는 에러가 발생하였다.그러다 문득 자바에서 쓰던 parseInt와 비슷한게 있나 싶어 구글링을 하게 되었다.알고보니 처음에 생각한 방법이 맞았으나, swift에서는 옵셔널 타입이 존재함으로 그걸로 인해서 에러가 났다는것을 알았다.Optional Int -&gt; 문자열에 다른 숫자이외 다른 문자가 포함이되어 변환을 할 수 없는 경우. nil이 리턴이 되는 경우.ex)var string : String = \"1234a\"// 이런경우 옵셔널 인트 타입이 된다.에러는 아래와 같다.간단하게 에러의 의미를 보자면      옵셔널 타입의 인트?는 반드시 인트의 밸류 값에서 언래핑 되어야 한다.        (참고) 옵션 값에 ‘nil’가 포함된 경우 기본값을 제공하기 위해 ‘?’를 사용하여 합친다.        (참고) 옵션 값에 ‘nil’가 포함된 경우 실행을 중단하려면 ‘!’을 사용하여 강제로 랩을 해제합니다.  그래서 옵셔널을 강제로 해제하는 !를 사용하여 문제를 풀었다.물론 예외조건일때는 어떻게 처리하라 라는 문제가 더 있었다면 또 코드를 추가해서 했을것같다."
  },
  
  {
    "title": "177. 자연수 뒤집어 배열로 만들기",
    "url": "/posts/177.-%EC%9E%90%EC%97%B0%EC%88%98-%EB%92%A4%EC%A7%91%EC%96%B4-%EB%B0%B0%EC%97%B4%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "func solution(_ n:Int64) -&gt; [Int] {        var answer : [Int] = []    var N : Int64 = n        if N &gt; 0 &amp;&amp; N &lt;= 10000000000 {                for i in 1 ... n {                     ...",
    "content": "func solution(_ n:Int64) -&gt; [Int] {        var answer : [Int] = []    var N : Int64 = n        if N &gt; 0 &amp;&amp; N &lt;= 10000000000 {                for i in 1 ... n {                        answer.append((Int(N%10)))                        N = N/10                        if N &lt; 1 {                break            }        }                    }        return answer}이렇게 생각한 이유.15,16과 마찬가지로 append를 하여 배열에 입력을 하고자하였다.그리고 최근에 풀었던 각 자리수의 합을 떠올려 나머지값으로 배열에 집어넣었다.왜냐하면 제일 마지막수부터 인덱스의 첫번째 값으로 들어간다는건 10으로 나누었을때 나머지랑 같은 의미이기 때문이다.그래서 N이 즉 10으로 계속 나누다가 소수점이 되었을때, 즉 더이상 나누지 않아도 될때 break를 통해 반복문을 빠져 나오게 했다.처음에는 그냥 나머지값이 1보다 작을때 즉 위의 if문 과 비슷하게 했는데, 테스트문제는 통과하였으나, 실제로 제출했을떼 오답이길래 생각을 해보니, 실제로 중간에 0이 들어간 수에서는 break가 된다는것을 알았고, 그래서 if문에 나머지값 조건대신 실제로 나눠야하는 값을 조건문에 넣어서 해결하였다.오늘은 속이 너무 좋지않아서 코드 문제위주로 적었다.이번주는 좀 공부위주로 정리를 해야겠다.그전에 건강부터"
  },
  
  {
    "title": "176. x만큼 간격이 있는 n개의 숫자",
    "url": "/posts/176.-x%EB%A7%8C%ED%81%BC-%EA%B0%84%EA%B2%A9%EC%9D%B4-%EC%9E%88%EB%8A%94-n%EA%B0%9C%EC%9D%98-%EC%88%AB%EC%9E%90/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드func solution(_ x:Int, _ n:Int) -&gt; [Int64] {        var answer : [Int64] = []        if x &gt;= -10000000 &amp;&amp; x &lt;= 10000000 {        if n &gt; 0 &amp;&amp; n &lt;= 1000{          ...",
    "content": "나의 코드func solution(_ x:Int, _ n:Int) -&gt; [Int64] {        var answer : [Int64] = []        if x &gt;= -10000000 &amp;&amp; x &lt;= 10000000 {        if n &gt; 0 &amp;&amp; n &lt;= 1000{                         for i in 1 ... n {                     answer.append((Int64(x*i)))                         }                    }    }        return answer}이렇게 생각한 이유.입력값인 x의 배수로 n개를 출력하면 되기에, x*i를 하였고 데이터형을 일치시켜주었다."
  },
  
  {
    "title": "175. 나머지가 1이 되는 수 찾기",
    "url": "/posts/175.-%EB%82%98%EB%A8%B8%EC%A7%80%EA%B0%80-1%EC%9D%B4-%EB%90%98%EB%8A%94-%EC%88%98-%EC%B0%BE%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer : Int = 0    var arr : [Int] = []        for i in 1 ... n {                if n % i == 1 {                        arr.appe...",
    "content": "나의 코드import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer : Int = 0    var arr : [Int] = []        for i in 1 ... n {                if n % i == 1 {                        arr.append(i)                }                }        answer = arr[0]        return answer    }이렇게 생각한 이유.처음에는 단순히 나머지가 1이 나오게해서 반복문을 하여반복문 사이에서 숫자를 비교하게할까 했었다.하지만 그렇게 했을때 더 꼬일것같아서 배열을 추가해서 넣는 방안으로 선회를 하였다.(물론 숫자를 비교해서 하려고 노력을 하였으나 나의 지식의 부족으로 안된것도 있다.)그래서 배열을 하나 만들고 배열에 append를 사용해서 집어넣게하였고, 최소값이기에 index가 0인 값을 리턴하여서 답을 구해내었다."
  },
  
  {
    "title": "174. 약수의 합",
    "url": "/posts/174.-%EC%95%BD%EC%88%98%EC%9D%98-%ED%95%A9/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "func solution(_ n:Int) -&gt; Int {    var answer = 0    if n &gt;= 0 &amp;&amp; n &lt;= 3000 {        if n == 0 {            answer = 0        } else {            for i in 1 ... n {        \t\tif n %...",
    "content": "func solution(_ n:Int) -&gt; Int {    var answer = 0    if n &gt;= 0 &amp;&amp; n &lt;= 3000 {        if n == 0 {            answer = 0        } else {            for i in 1 ... n {        \t\tif n % i == 0 {            \t\tanswer += i        \t\t}     \t\t}         }    }    return answer}이렇게 작성한 이유처음에 코드를 n == 0인 조건을 하지않고 작성하고 제출을 하니 에러가 났다. 생각해보니 n = 0일때는 for문이 1부터 시작이라 논리적으로 맞지 않다는것을 확인했다.그래서 n = 0일때 결과값이 0이라는걸 미리 설정하고 그다음에 else를 걸어서 1이상의 값을 계산하게 만들었다.다른 풀이를 보니이번에는 filter와 reduce를 통하여 더 심플하게 적은 것을 보았다.공부할것이 또 생겼다.다른코드func solution(_ n:Int) -&gt; Int {    return n != 0 ? (1...n).filter{n % $0 == 0}.reduce(0){$0 + $1} : 0}"
  },
  
  {
    "title": "173. 자릿수 더하기",
    "url": "/posts/173.-%EC%9E%90%EB%A6%BF%EC%88%98-%EB%8D%94%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ n:Int) -&gt; Int{        var answer:Int = 0        var N = 0            if n &gt; 0 &amp;&amp; n &lt;= 100000000 {                N = n                while  N...",
    "content": "나의 코드import Foundationfunc solution(_ n:Int) -&gt; Int{        var answer:Int = 0        var N = 0            if n &gt; 0 &amp;&amp; n &lt;= 100000000 {                N = n                while  N &gt;= 1 {                    answer += N % 10                N = N / 10                }    }        return answer}이렇게 생각한 이유.처음에 자릿수를 어떻게 해야할까 고민을 하면서 배열을 써볼까 어떻게 할까 이런저런 고민을 많이 했다.그러다 문득 계속 10을 나누게 되면 그 값의 나머지가 자릿수를 의미한다는것을 깨달았고 10을 계속 나눈 값을 answer 변수에 계속 넣었다. 그러면서 입력값 n을 대체할 또 다른 변수 N을 대입하면서 그 N 값이 소수가 될때 해당 조건을 그만하게 실행하였다.이거 역시도 reduce로 구한 코드를 보았다.확실히 reduce를 마스터를 해야겠다는 생각이든다.다른코드import Foundationfunc solution(_ n:Int) -&gt; Int{    return String(n).reduce(0, {$0+Int(String($1))!});}코드가 두개의 방식이 존재하는 것 같다.고차함수는 감이 오지만 미흡한 부분이 좀 보인다.다른코드var answer : Int = 0answer = String(N).compactMap{Int(String($0))}.reduce(0, +)"
  },
  
  {
    "title": "172. 평균 구하기",
    "url": "/posts/172.-%ED%8F%89%EA%B7%A0-%EA%B5%AC%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드func solution(_ arr:[Int]) -&gt; Double {        var sum = 0        var answer : Double = 0.0        if arr.count &gt;= 1 &amp;&amp; arr.count &lt;= 100 {        if arr[0] &gt;= -10000 &amp;&a...",
    "content": "나의 코드func solution(_ arr:[Int]) -&gt; Double {        var sum = 0        var answer : Double = 0.0        if arr.count &gt;= 1 &amp;&amp; arr.count &lt;= 100 {        if arr[0] &gt;= -10000 &amp;&amp; arr[arr.count-1] &lt;= 10000 {                        for i in 0 ..&lt; arr.count {                                sum += arr[i]                            }                    }               } else {              answer = 0    }         answer = Double(sum) / Double(arr.count)            return answer}이렇게 작성한 이유.최근에도 비슷한 문제가 있었는데 그때는 in 0 … arr.count-1 로 했었던 걸로 기억한다.그래서 이번에는 … 이 아닌 ..&lt; 을 사용을 해보았다.후기.제출 후 다른 사람들은 어떻게 작성을 했을까 보던 중reduce를 통해서 코드를 아주 심플하게 작성한것을 보았다.코드는 아래와 같다.다른코드func solution(_ arr:[Int]) -&gt; Double {    return Double(arr.reduce(0,+))/Double(arr.count)}뭔가 코드를 보고 공부를 하지않은 상태에서 추론을 해본다면 reduce문이 처음인자부터 시작해서 누적으로 더한다는것을 의미하는 것 같다.즉 for문을 심플하게 사용하는것일까. reduce문을 공부를 해봐야겠다는 생각이 들었다.조만간 여기에도 정리를 해봐야겠다.      추가다른걸 보던 중, for 문은 굳이 0 부터 안하고 배열 자체로 접근을 할 수 있다라고 정리를 했었는데, 해당 부분을 사용을 하질 못했다. 아니 생각을 하질 못했다. 다음번에 비슷한 문제가 나오면 일단은 for 문을 배열로 바로 접근하게 코드를 작성하고 그다음 또 비슷한 문제가 나왔을때 reduce로 해보던가 아니면 두개를 그냥 같이 작성을 해봐야겠다.        24.2.2 추가  오늘 하샤드 수 문제를 풀다가 reduce개념이 안잡힌거 같아 그전에 고차함수를 써야했던 문제를 풀던중해당 문제는 배열의 평균값 문제와 거의 똑같으므로 그 코드에서 정답에 맞춰 수정한다.다른코드import Foundationfunc solution(_ arr:[Int]) -&gt; Double {        var sum : Double = 0.0        var answer : Double = 0.0        answer = Double(arr.reduce(0){$0 + $1}) / Double(arr.count)        return answer}"
  },
  
  {
    "title": "171. 짝수와 홀수",
    "url": "/posts/171.-%EC%A7%9D%EC%88%98%EC%99%80-%ED%99%80%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드func solution(_ num:Int) -&gt; String {        var answer : String = num%2 == 0 ? \"Even\" : \"Odd\"        return answer}이렇게 작성한 이유.어제 삼항연산자를 정리했기 때문에, if문을 쓰지않고 삼항연산자를 이용해서 해결을 하려고 하였다.처음에 에러가나서...",
    "content": "나의 코드func solution(_ num:Int) -&gt; String {        var answer : String = num%2 == 0 ? \"Even\" : \"Odd\"        return answer}이렇게 작성한 이유.어제 삼항연산자를 정리했기 때문에, if문을 쓰지않고 삼항연산자를 이용해서 해결을 하려고 하였다.처음에 에러가나서 보니 num%2 == 0 이 부분을 num%2 = 0 이라고 표기를 해서 에러가 났다.조건문이었기에 ==를 했어야 했는데 아무리 다시 생각해봐도 코드상 문제가 없어서 다시 생각해보니 저부분이 문제였다.간단한 조건문 문제라면 if대신 삼항연산자를 써서 해결을 해봐야겠다. 물론 조건이 if else 이렇게 한개만 될때 해야된다는걸 잊지말자."
  },
  
  {
    "title": "170. 배열의 평균값",
    "url": "/posts/170.-%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%8F%89%EA%B7%A0%EA%B0%92/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드 (24.1.24)import Foundationfunc solution(_ numbers:[Int]) -&gt; Double {        var sum : Double = 0.0        var answer : Double = 0.0        if numbers[0] &gt;= 0 &amp;&amp; numbers[numbers....",
    "content": "나의 코드 (24.1.24)import Foundationfunc solution(_ numbers:[Int]) -&gt; Double {        var sum : Double = 0.0        var answer : Double = 0.0        if numbers[0] &gt;= 0 &amp;&amp; numbers[numbers.count-1] &lt;= 1000 {                if numbers.count &gt;= 1 &amp;&amp; numbers.count &lt;= 100 {                         for i in 0...numbers.count-1 {                            sum += Double(numbers[i])                        }                           }    }        answer = sum / Double(numbers.count)        return answer}이렇게 생각한 이유.우선 배열이 주어지기 때문에 배열의 값을 누적하여 더할 변수 sum과 정답을 반환할 answer두개의 변수를 만들었다.이때 두 변수의 자료형을 double로 한 것은 입출력의 예를 보면 답이 소수를 띄기 때문에 미리 자료형을 Int가 아닌 double로 해두었다 (평균값이 정수만 나온다는 보장도 없기때문에)그 다음 배열의 원소에 접근하려면 0부터 시작하므로 반복문의 시작을 0 ~ 배열.count -1로 하였는데배열.count로 하게되면 에러가 나기때문이다. (0부터 시작하기 때문)배열.count는 배열의 길이 즉, 배열이 가지고있는 데이터가 몇개인지 알 때 쓴다.배열은 다음글에서 다시 서술 할 예정.다시 넘어와서, sum의 데이터형이 double이므로, number[i]에 double로 감싸서 데이터형을 일치시켰다. 마지막 answer도 같은이유.  24.2.2 코드 추가고차함수 reduce를 이용하여 위의 코드를 간략화 하였다.두가지 reduce를 적어보았다.import Foundationvar arr : [Int] = [1,2,3,4]                   var answer : Double = 0.0answer = Double(arr.reduce(0){$0 + $1}) / Double(arr.count)    var answer1 : Double = 0.0answer1 = Double(arr.reduce(0, +)) / Double(arr.count)    print(answer);print(answer1)"
  },
  
  {
    "title": "161. 두수의 차",
    "url": "/posts/169.-%EC%A7%9D%EC%88%98%EC%9D%98-%ED%95%A9/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer = 0        if n &gt; 0 &amp;&amp; n &lt;= 1000 {        for i in 1...n where i%2 == 0 {                answer += i            }...",
    "content": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer = 0        if n &gt; 0 &amp;&amp; n &lt;= 1000 {        for i in 1...n where i%2 == 0 {                answer += i            }    }        return answer}이렇게 한 이유.swift의 for문은 자바와 다른 부분이 있어서 검색을 하던 중 for문에 조건문을 달수 있는것을 발견하여 for문에 where 조건을 달아서 코드를 작성하였다.% 은 나머지를 구할때 사용한다.2를 나누었을때 0이 된다는것은 즉 짝수를 의미하므로+=를 통해 answer에 누적으로 더하게끔 작성하였다.반복문은 다음글에서 별도로 정리를 하겠다."
  },
  
  {
    "title": "168. 각도기",
    "url": "/posts/168.-%EA%B0%81%EB%8F%84%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ angle:Int) -&gt; Int {        var answer = 0        if angle &gt; 0 &amp;&amp; angle &lt; 90 {        answer = 1    } else if angle == 90 {        answer = 2  ...",
    "content": "나의 코드import Foundationfunc solution(_ angle:Int) -&gt; Int {        var answer = 0        if angle &gt; 0 &amp;&amp; angle &lt; 90 {        answer = 1    } else if angle == 90 {        answer = 2    } else if angle &gt; 90 &amp;&amp; angle &lt; 180 {        answer = 3    } else {        answer = 4     }    return answer}이렇게 생각한 이유.다중if문을 통해 범위를 지정함으로써, 예각, 직각, 둔각, 평각을 구현하였다.if말고 switch-case 문을 통해서도 가능하다."
  },
  
  {
    "title": "167. 두 수의 나눗셈",
    "url": "/posts/167.-%EB%91%90-%EC%88%98%EC%9D%98-%EB%82%98%EB%88%97%EC%85%88/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드 (24.1.24)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        var answer = 0        if num1 &gt; 0 &amp;&amp; num1 &lt;= 100 {                if num2 &gt; 0 &amp;&amp; nu...",
    "content": "나의 코드 (24.1.24)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        var answer = 0        if num1 &gt; 0 &amp;&amp; num1 &lt;= 100 {                if num2 &gt; 0 &amp;&amp; num2 &lt;= 100 {                        answer = Int(Double(num1) / Double(num2) * 1000)                     }    }        return answer}처음에 막힌 이유.형변환인데 처음에는 Double로 num1/num2를 전체로 단순하게 감싸서 계산을 하면 될것같다는 안일한 생각을 하였다. 실제로 답이 틀려서 playground를 통해 실제로 나눈값을 출력을 해보니 3/2 = 1 이 나왔다.그래서 전체를 감싸는 것이 아닌, num1, num2를 개별로 Double로 형변환을 한뒤에 나누니 1.5로 잘 나오는 것을 확인하였다.하지만 answer의 형태는 Int 이므로 아무리 뒤에 1000을 곱하여도 우측의 자료형은 현재 Double 이므로 answer와 자료형을 일치시키기 위해 또다시 전체를 Int로 감싸주었다."
  },
  
  {
    "title": "166. 두수의 합",
    "url": "/posts/166.-%EB%91%90%EC%88%98%EC%9D%98-%ED%95%A9/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드 (24.1.24)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        var answer = 0        if num1 &gt;= -50000 &amp;&amp; num1 &lt;= 50000 {        if num2 &gt;= -50000 &amp;&a...",
    "content": "나의 코드 (24.1.24)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        var answer = 0        if num1 &gt;= -50000 &amp;&amp; num1 &lt;= 50000 {        if num2 &gt;= -50000 &amp;&amp; num2 &lt;= 50000 {            answer = num1 + num2        }    }    return answer}이렇게 생각한 이유.단순히 합을 구하는 것이므로 정답을 담을 변수를 하나 생성 한 후 제한조건에 맞게 설정한 뒤 변수에 두수의 합을 담아서 리턴하였다."
  },
  
  {
    "title": "165. 숫자 비교하기",
    "url": "/posts/165.-%EC%88%AB%EC%9E%90-%EB%B9%84%EA%B5%90%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드 (24.1.19)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        var answer = 0        if num1 &gt;= 0 &amp;&amp; num1 &lt;= 10000 &amp;&amp; num2 &gt;= 0 &amp;&amp; num2 &l...",
    "content": "나의 코드 (24.1.19)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        var answer = 0        if num1 &gt;= 0 &amp;&amp; num1 &lt;= 10000 &amp;&amp; num2 &gt;= 0 &amp;&amp; num2 &lt;= 10000 {        if num1 &gt; num2 || num2 &gt; num1 {                        answer = -1                    } else {                        answer = 1        }    }        return answer}이렇게 생각한 이유.단순히 숫자를 비교하기 위해서 코드를 적었고 or조건을 추가하였다.자체 피드백 (24.1.24)코드를 적고나서 문득 생각이 들었던 것은 굳이 이렇게 or 조건을 하는게 아니라 애초에 서로 값이 다르면 -1 같으면 1을 리턴을 하는것이기 때문에 if조건에 두 값이 같다면으로 하였다면, 더 코드가 깔끔했을 것이다.내가 개선한 코드 (24.1.24)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        var answer = 0        if num1 &gt;= 0 &amp;&amp; num1 &lt;= 10000 &amp;&amp; num2 &gt;= 0 &amp;&amp; num2 &lt;= 10000 {        if num1 == num2 {                        answer = 1                    } else {                        answer = -1        }    }        return answer}"
  },
  
  {
    "title": "164. 나이 출력",
    "url": "/posts/164.-%EB%82%98%EC%9D%B4-%EC%B6%9C%EB%A0%A5/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드 (24.1.18)import Foundationfunc solution(_ age:Int) -&gt; Int {    var answer = 0        if age &gt; 0 &amp;&amp; age &lt;= 120{                answer = 2023 - age            } else {         ...",
    "content": "나의 코드 (24.1.18)import Foundationfunc solution(_ age:Int) -&gt; Int {    var answer = 0        if age &gt; 0 &amp;&amp; age &lt;= 120{                answer = 2023 - age            } else {                return 0    }         return answer}이렇게 생각한 이유.입출력 예를 들었을때 40살을 넣었을때 1983이 출력 된다는것은 2022년을 기준으로 하였을때 한국은 0살이 아닌 1살을 기준으로 하므로 2022-age가 아닌 2023-age로 하였다."
  },
  
  {
    "title": "163. 몫 구하기",
    "url": "/posts/163.-%EB%AA%AB-%EA%B5%AC%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드 (24.1.19)import Foundationvar answer = 0func solution(_ num1:Int, _ num2:Int) -&gt; Int {        if 0 &lt; num1 &amp;&amp; num1 &lt;= 100 {        if 0 &lt; num2 &amp;&amp; num2 &lt;= 100 {  ...",
    "content": "나의 코드 (24.1.19)import Foundationvar answer = 0func solution(_ num1:Int, _ num2:Int) -&gt; Int {        if 0 &lt; num1 &amp;&amp; num1 &lt;= 100 {        if 0 &lt; num2 &amp;&amp; num2 &lt;= 100 {            answer = num1 / num2                    }    }        return answer}이렇게 생각한 이유.제한사항을 반영하여 코드를 작성하기 시작하였고, 몫을 구하는 것이기 때문에 단순 연산자인 / 을 사용하여 몫을 구했다.해당코드는 추후에 더 공부하여 개선점을 찾아 수정할 예정이다.여러 연산자정리는 다음글에서."
  },
  
  {
    "title": "162. 두수의 곱",
    "url": "/posts/162.-%EB%91%90%EC%88%98%EC%9D%98-%EA%B3%B1/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "나의 코드 (24.1.18)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        var result = num1 * num2        return result}이렇게 생각한 이유.  17일에 작성했던 코드와 동일하게, 곱 부분만 생각해서 대입하였음.변화점.  17일과는 ...",
    "content": "나의 코드 (24.1.18)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        var result = num1 * num2        return result}이렇게 생각한 이유.  17일에 작성했던 코드와 동일하게, 곱 부분만 생각해서 대입하였음.변화점.  17일과는 달리 answer라는 변수를 만들면서 해당 변수에 결과값을 넣어 return하는 방식으로 변화를 주었음.내가 생각한 코드 개선 ver.1 (24.1.23)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        var result = 0        if num1 &gt;= 0 &amp;&amp; num1&lt;=100 {                if num2 &gt;= 0 &amp;&amp; num2&lt;=100 {                result = num1 * num2                    }    }        return result}17일자와 같이 제한사항을 충족시키기 위해 if문을 작성하였음."
  },
  
  {
    "title": "161. 두수의 차",
    "url": "/posts/161.-%EB%91%90%EC%88%98%EC%9D%98-%EC%B0%A8/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-29 05:13:00 +0900",
    





    
    "snippet": "블로그 하나로 통합 도중 문제를 푸는걸 두개로 나누었기에 하나로 태그를 통합한다.나의 코드 (24.1.17)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        return num1 - num2}이렇게 생각한 이유.처음에 아무런 생각 없이 그냥 단순히 차로 생각하여제한사항을...",
    "content": "블로그 하나로 통합 도중 문제를 푸는걸 두개로 나누었기에 하나로 태그를 통합한다.나의 코드 (24.1.17)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        return num1 - num2}이렇게 생각한 이유.처음에 아무런 생각 없이 그냥 단순히 차로 생각하여제한사항을 고려하지 않고 num1-num2를 바로 return하였음.개선한다면?  제한사항을 먼저 고려하여 코드를 작성한다.  return값을 바로 하지않고 또다른 변수를 하나 만들어서 사용한다.내가 생각한 코드 개선 ver.1 (24.1.23)import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {           var answer = 0        if num1 &gt;= -50000 &amp;&amp; num1 &lt;= 50000 {        if num2 &gt;= -50000 &amp;&amp; num2 &lt;= 50000 {            answer = num1 - num2        }    }        return answer}약간 코드가 길어지긴 했지만, 주어진 조건에서는 모두 충족한 코드라고 생각함.예외조건에 대한 서술이 없었으므로 if문 조건 뒤에 else로 예외조건에 대한 return값은 따로 서술하지 않았음.아직 swift가 처음이므로. 추후에 새로운 문법을 알게되면 새롭게 코드 개선을 적을 예정."
  },
  
  {
    "title": "고차함수",
    "url": "/posts/High-order-function/",
    "categories": "Deep Dive",
    "tags": "코딩테스트",
    "date": "2024-02-29 00:00:00 +0900",
    





    
    "snippet": "고차함수 정리.map  컬렉션 내부의 데이터를 가공하여 새로운 컬렉션을 생성한다.      map 메서드는 인자로 클로저를 받아 컨테이너 내부에 들어있는 요소들의 값을 어떻게 바꿀 것인지를 결정한다.    선언    func map&lt;T&gt;(_ transform: (Element) throws -&gt; T) rethrows -&gt; [T] ...",
    "content": "고차함수 정리.map  컬렉션 내부의 데이터를 가공하여 새로운 컬렉션을 생성한다.      map 메서드는 인자로 클로저를 받아 컨테이너 내부에 들어있는 요소들의 값을 어떻게 바꿀 것인지를 결정한다.    선언    func map&lt;T&gt;(_ transform: (Element) throws -&gt; T) rethrows -&gt; [T]                      매개변수   \t- transform : 매핑 클로저로, 이 컨테이너의 요소를 매개변수로 받아들이고 정의한 클로저의 형태에 맞게 변환된 값을 반환한다.                    리턴타입 : 이 컨테이너의 변환된 요소를 포함하는 배열을 반환.              예시 (For문을 사용했을 때)// numbers의 각 요소에 9 곱하기let Numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]var multiplyArray: [Int] = []for number in Numbers {    multiplyArray.append(number * 9)}print(multiplyArray)// [9, 18, 27, 36, 45, 54, 63, 72, 81]  예시 (map을 사용했을 때)// numbers의 각 요소에 9 곱하기let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]let multiplyArray: [Int] = numbers.map { $0 * 9 }print(multiplyArray)// [9, 18, 27, 36, 45, 54, 63, 72, 81]reduce  컬렉션 내부에서 조건에 맞는 데이터들만 골라 새로운 컬렉션을 생성한다.      filter 메서드는 클로저를 인자로 받고, 이 클로저 내부에는 어떤 데이터를 포함시킬지 그 조건을 정의한다.    선언```swiftfunc reduce(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -&gt; Result) rethrows -&gt; Result- 매개변수    - initialResult : 초기값으로 사용할 값을 넣으면 클로저가 처음 실행될 때, nextPartialResult에 전달된다.    - nextPartialResult : 컨테이너 요소를 새로운 누적값으로 결합하는 클로저이다.        - 리턴타입 : 최종 누적 값이 반환되며, 컨테이너 요소가 없다면 initialResult의 값이 반환된다.- 예시 (for문을 사용 했을 때)```swift// 각 요소의 합 구하기let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]var sum = 0for number in numbers {    sum += number}print(sum)// 55  예시 (reduce를 사용했을 때)```swift// 각 요소의 합 구하기 (1)let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]let sum = numbers.reduce(0, +)print(sum)// 55// 각 요소의 합 구하기 (2)let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]let sum = numbers.reduce(0) { $0 + $1 }print(sum)// 55- 예시 (for문을 사용 했을 때)```swift// 각 요소의 곱셈 결과 구하기let numbers = [1, 2, 3, 4, 5]var sum = 1for number in numbers {    sum *= number}print(sum)// 120  예시 (reduce를 사용했을 때)```swift// 각 요소의 곱셈 결과 구하기 (1)let numbers = [1, 2, 3, 4, 5]let sum = numbers.reduce(1, *)print(sum)// 120// 각 요소의 곱셈 결과 구하기 (2)let numbers = [1, 2, 3, 4, 5]let sum = numbers.reduce(1) { $0 * $1 }print(sum)// 120## filter- 컬렉션 내부의 데이터들을 하나로 통합시킨다- 다른 고차함수들과는 다르게 reduce는 두 개의 인자를 받는다.    \t     - 첫번째 인자는 통합할 데이터의 초기 값이다.     - 두번째 인자는 클로저인데, 클로저에서는 어떻게 값을 통합할 것인지를 정의한다.     - 이때 사용되는 두 파라미터 중 첫번째는 바로 이전값에 대한 통합된 데이터를 의미하고, 두번째는 이번에 새로 통합할 데이터를 의미한다. - 선언```swiftfunc filter(_ isIncluded: (Self.Element) throws -&gt; Bool) rethrows -&gt; [Self.Element]  매개변수                  isIncluded : 컨테이너의 요소를 인수로 취하고, 요소가 반환된 배열에 포함되어야 하는지 여부를 Bool 값으로 반환하는 클로저.                    리턴 타입 : inIncluded 에 맞게 true로 반환되는 값만 리턴한다.              예시 (일반적인 For문을 사용 했을 때)```swift// numbers에서 짝수만 추출하기let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]var evenNumbers: [Int] = []for number in numbers {    if number % 2 == 0 {        evenNumbers.append(number)    }}print(evenNumbers)// [2, 4, 6, 8]- 예시 (filter를 사용했을 때)```swift// numbers에서 짝수만 추출하기let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]let evenNumbers = numbers.filter { $0 % 2 == 0 }print(evenNumbers)// [2, 4, 6, 8]다른 고차함수들CompactMap      옵셔널 바인딩을 지원한다.        예시```swiftlet students : [String?] = [“Mike”, “Jane”, nil, “John”, nil]// nil이 섞여 있는 컬렉션에서 존재하는 모든 이름앞에 “Boost2021-“ 키워드를 붙여주자.  // 1. map을 이용한 코드let boostStudents = students.map({“BoostCamp2021” + $0})// 에러가 발생한다 nil이 있기 때문.// 2. compactMap을 이용한 코드let students : [String?] = [“Mike”, “Jane”, nil, “John”, nil]let boostStudents = students.compactMap({ $0 }).map( {“BoostCamp2021-“ + $0})print(boostStudents) // [“BoostCamp2021-Mike”, “BoostCamp2021-Jane”, “BoostCamp2021-John”## FlatMap\t- 2차원 배열에 나누어져있는 데이터들을 1차원 배열로 합쳐주는 기능이 포함되어있다.예시```swiftlet students = [[\"Mike\", nil], [nil, nil, \"Jane\"], [\"John\"]]// 먼저 위와 같은 배열을 1차원으로 만들때 사용한다.let goodStudents = students.flatMap({$0})print(goodStudents) // [Optional(\"Mike\"), nil, nil, nil, Optional(\"Jane\"), Optional(\"John\")]//아직은 옵셔널 바인딩이 안되어 있고 nil이 포함되어 있습니다. 이때 실제 이름 값만 추출하고 싶다면 위의 compactmap을 추가로 쓸 수 있다.let goodStudents = students.flatMap({$0}).compactMap({ $0 })print(goodStudents) // [\"Mike\", \"Jane\", \"John\"]ForEach  for - in 구문처럼 컬렉션의 각 요소들을 뽑아낼 수 있다.  for - in 과는 다르게 고차함수에 포함되어 있기에 글로벌 스코프에서 사용했을 때도 return을 통해 현재 반복을 종료하고 다음 반복으로 이어나갈 수 있다 (continue와 비슷하게 동작)      다른 고차함수처럼 새로운 컬렉션이나 데이터를 반환하지 않기 때문에 단순한 순회의 용도로 사용하기에 적합하다.    예시let numbers = [1, 2, 3, 4, 5]numbers.forEach({    print($0)}) //1//2//3//4//5"
  },
  
  {
    "title": "BMI Calculator (1)",
    "url": "/posts/BMI-Calculator-(1)/",
    "categories": "Udemy, BMI Calculator",
    "tags": "",
    "date": "2024-02-28 08:13:00 +0900",
    





    
    "snippet": "UI Slider의 값을 미리 설정 해줄 수 있다.slider가 움직일때 console에서 값이 변하도록 만들어 보자.먼저 IBAction을 만들어 준다.var maximum : Double = 0.0var minimum : Double = 0.0    var currentValue : Double = 0.0        @IBAction func h...",
    "content": "UI Slider의 값을 미리 설정 해줄 수 있다.slider가 움직일때 console에서 값이 변하도록 만들어 보자.먼저 IBAction을 만들어 준다.var maximum : Double = 0.0var minimum : Double = 0.0    var currentValue : Double = 0.0        @IBAction func heightSliderChanged(_ sender: UISlider) {        currentValue = Double(sender.value)        print(currentValue)    }            @IBAction func weightSliderChanged(_ sender: UISlider) {        currentValue = Double(sender.value)        print(currentValue)    }    이렇게 코드를 작성하였다.계속 프린트가 되는 건데 내가한것과는 다르다..코드차이는 없었다 그냥 창이 어떻게 보여지느냐의 차이였다.그렇다면 소숫점을 둘째자리까지만 나오게 해보자.@IBAction func heightSliderChanged(_ sender: UISlider) {        currentValue = Double(sender.value)        print(String(format:\"%.2f\", currentValue))    }        @IBAction func weightSliderChanged(_ sender: UISlider) {        currentValue = Double(sender.value)        print(String(format:\"%.2f\", currentValue))    }소수점이 안나오게하기위해 Int를 씌웠다. @IBAction func weightSliderChanged(_ sender: UISlider) {        currentValue = Double(sender.value)        print(Int(currentValue))    }값을 변할때 console이 아닌 label에 값이 표시가 되게 구현해보자@IBAction func heightSliderChanged(_ sender: UISlider) {        currentValue = Double(sender.value)                heightLabel.text = String(format:\"%.2f\", currentValue)        //print(String(format:\"%.2f\", currentValue))    }    @IBAction func weightSliderChanged(_ sender: UISlider) {        currentValue = Double(sender.value)                weightLabel.text = String(Int(currentValue))        //print(Int(currentValue))    }뭐 이정도는 가볍지.위와 아래 통일성을 주기위해 수정을 해보자(String(format:”%.2f”, currentValue))(String(Int(currentValue))-&gt; (String(format:”%.0f”, currentValue))하지만 처음에는 m / kg같은 단위가 있는데수치만 나온다.단위도 나오게 수정을 해보자. @IBAction func heightSliderChanged(_ sender: UISlider) {        currentValue = Double(sender.value)                heightLabel.text = \"\\(String(format:\"%.2f\", currentValue))m\"        //print(String(format:\"%.2f\", currentValue))    }    @IBAction func weightSliderChanged(_ sender: UISlider) {        currentValue = Double(sender.value)                weightLabel.text = \"\\(String(format:\"%.0f\", currentValue))Kg\"        //print(Int(currentValue))    }끝.현재 slider들을 움직이고 calculate버튼을 누르면 현재 위치한 슬라이더의 값이 나오게 해보자.가장 쉬운 방법은 slider들의 IBoutlet을 생성해주고 그 value를 바로 찍어내면 된다. @IBAction func calculatePressed(_ sender: UIButton) {        print(heightSlider.value)        print(weightSlider.value)    }위에 주어진 식을 이용하여 BMI를 출력해보자.let bmi = weight / (height * height)let bmi = weight / pow(height,2)둘은 같은 표현이다."
  },
  
  {
    "title": "Destini Review",
    "url": "/posts/Destini/",
    "categories": "Udemy, Quizzler",
    "tags": "",
    "date": "2024-02-28 05:13:00 +0900",
    





    
    "snippet": "이제 self review를 해보도록하자.  Story.swift 비교.import Foundationstruct Story {    let title : String    let choice1 : String    let choice1Destination : Int    let choice2 : String    let choice2Destinati...",
    "content": "이제 self review를 해보도록하자.  Story.swift 비교.import Foundationstruct Story {    let title : String    let choice1 : String    let choice1Destination : Int    let choice2 : String    let choice2Destination : Int        init (title : String, choice1: String, choice1Destination : Int, choice2: String,  choice2Destination : Int) {        self.title = title        self.choice1 = choice1        self.choice1Destination = choice1Destination        self.choice2 = choice2        self.choice2Destination = choice2Destination    }}//import Foundationstruct Story {    let title: String    let choice1: String    let choice1Destination: Int    let choice2: String    let choice2Destination: Int}위에있는게 내가쓴것, 아래가 강의코드 이렇게 해두고 비교를 해볼까 한다.우선 init을 사용하여 작업을 했다.뭐 이거 말곤 차이가 없어서 pass…  StoryBrain```swift var destination = 0func getTitle () -&gt; String {    return story[destination].title}func getChoice () -&gt; Story {    let choice = story[destination]        return choice}func getChoice1 () -&gt; String {        return story[destination].choice1    }func getChoice2 () -&gt; String {        return story[destination].choice2    }mutating func selectDestination (_ choice : String) -&gt; Int {    if choice == getChoice().choice1 {                destination = getChoice().choice1Destination                return destination            } else {                destination = getChoice().choice2Destination                return  destination            }}func getDestination () -&gt; Int {    return destination}//var storyNumber = 0func getStoryTitle() -&gt; String {            return stories[storyNumber].title        }func getChoice1() -&gt; String {            return stories[storyNumber].choice1        }func getChoice2() -&gt; String {            return stories[storyNumber].choice2        }mutating func nextStory(userChoice: String) {        let currentStory = stories[storyNumber]        if userChoice == currentStory.choice1 {            storyNumber = currentStory.choice1Destination        } else if userChoice == currentStory.choice2 {            storyNumber = currentStory.choice2Destination        }    } ``` 뭔가 내가 더 많이 작성을 하였따.. nextStory에 내가 각각의 세분화로 나누었던걸 모두 담아낸것처럼 보인다.  viewController    var storyBrain = StoryBrain()     override func viewDidLoad() {     super.viewDidLoad()             updateUI() // As soon as we launch this app, this trigger will be operated }             @IBAction func buttonPressed(_ sender: UIButton) {             let userChoice = sender.currentTitle!                 storyBrain.selectDestination(userChoice)     updateUI()         } func updateUI () {     storyLabel.text = storyBrain.getTitle()             let getchoice1 = storyBrain.getChoice1()     let getchoice2 = storyBrain.getChoice2()         choice1Button.setTitle(getchoice1, for: .normal)     choice2Button.setTitle(getchoice2, for: .normal) }//var storyBrain = StoryBrain()     override func viewDidLoad() {     super.viewDidLoad()             updateUI() } @IBAction func choiceMade(_ sender: UIButton) {             storyBrain.nextStory(userChoice: sender.currentTitle!)             updateUI()      }     func updateUI() {     storyLabel.text = storyBrain.getStoryTitle()     choice1Button.setTitle(storyBrain.getChoice1(), for: .normal)     choice2Button.setTitle(storyBrain.getChoice2(), for: .normal) }      뭔가 비슷하면서 묘하게 달랐다 하지만 Ibaction에 updateUI가 들어간건 같다.하지만 변수선언 없이 했는데 되었다.어제는 안되었는데 차이가 뭘까…"
  },
  
  {
    "title": "Destini",
    "url": "/posts/Destini-Review/",
    "categories": "Udemy, Quizzler",
    "tags": "",
    "date": "2024-02-28 05:13:00 +0900",
    





    
    "snippet": "Quizzler를 했던것을 기반으로 스스로 만들어보자.완성 화면은 위와 같다.start!  우선 어떤 기능인지에 대해 먼저 파악을 해보자.          quizzler와 거의 같은 형태의 App이다.      즉, 코드의 전개는 거의 비슷할 것이다.      하지만 버튼들을 보면 뭔가 문제에 대한 정답보다는 현재 진행되는 스토리에 따라 내가 어떤 ...",
    "content": "Quizzler를 했던것을 기반으로 스스로 만들어보자.완성 화면은 위와 같다.start!  우선 어떤 기능인지에 대해 먼저 파악을 해보자.          quizzler와 거의 같은 형태의 App이다.      즉, 코드의 전개는 거의 비슷할 것이다.      하지만 버튼들을 보면 뭔가 문제에 대한 정답보다는 현재 진행되는 스토리에 따라 내가 어떤 답을 하면 그에 따라 다른 스토리가 진행되는 그런 방식의 App으로 보인다.        ui설정을 해주자.우선Story(\t\ttitle: \"Your car has blown a tire on a winding road in the middle of nowhere with no cell phone reception. You decide to hitchhike. A rusty pickup truck rumbles to a stop next to you. A man with a wide brimmed hat with soulless eyes opens the passenger door for you and asks: 'Need a ride, boy?'.\",        choice1: \"I'll hop in. Thanks for the help!\",         choice1Destination: 2,        choice2: \"Better ask him if he's a murderer first.\",         choice2Destination: 1    )이런식으로 값이 들어간다.그러므로 Model의 Story.swift에 다음과 같이 넣어준다.import Foundationstruct Story {    let title : String    let choice1 : String    let choice1Destination : Int    let choice2 : String    let choice2Destination : Int        init (title : String, choice1: String, choice1Destination : Int, choice2: String,  choice2Destination : Int) {        self.title = title        self.choice1 = choice1        self.choice1Destination = choice1Destination        self.choice2 = choice2        self.choice2Destination = choice2Destination    }}우선 Story.swift에 들어갈 뼈대는 만들어진것같다.StoryBrain.swift에 내용을 넣었을때 Error가 발생하지는 않았다.일단 structure를 구성하면서 내 나름대로 매개변수가 어떤것을 의미하는지 정리 해보았다.  title : 현재 진행되는 story를 보여주는 문장.  choice1 : 이지선다에서 선택해야하는 text  choice2 : 이지선다에서 선택해야하는 text  choice1Destination : 첫번째 text를 선택했을때 가게되는 index  choice2Destination : 두번째 text를 선택했을때 가게되는 index  필요한걸 하나씩 추가하면서 기능 구현을 해보도록 하자.우리가 실제로 기능을 구현할 함수를 적는곳은 viewController가아닌, StoryBrain.swift가 될것이다.의식의 흐름대로 코드를 짜보기로 했다.우선 StoryLabel에 story가 나와야하니 그것을 가져올 함수를 구현해보자.func getTitle () -&gt; String {                var title = story[destination].title                return title    }playground로 제대로 출력이 되는지test를 해보자.okay 일단 출력은 된다!그리고 각 choice1 / 2에 담을 text를 가져올 함수도 구현해 주었다func getChoice1 () -&gt; String {                var choice1 = story[destination].choice1                return choice1    }    func getChoice2 () -&gt; String {                var choice2 = story[destination].choice2                return choice2    }그리고 여태까지 만든 함수들을 적용할 viewcontroller에서 updateUI 함수를 새로 만들었고 기능을 넣어주었다. func updateUI () {        storyLabel.text = StoryBrain().getTitle()                var getchoice1 = StoryBrain().getChoice1()        var getchoice2 = StoryBrain().getChoice2()        choice1Button.setTitle(getchoice1, for: .normal)        choice2Button.setTitle(getchoice2, for: .normal)    }그리고 실행해 보았다. 중간점검!내가 의도한대로 현재까진 잘 되었다.빈 깡통이라 초기화면에대한 구성만 되었고 되진 않는다.  깡통 구성이 되었으니 이젠 버튼에 대한 코드를 작성해보도록 하자.작성전, 버튼에서 뭘 필요로 하는지를 다시한번 생각해보자.► 버튼을 눌렀을때 기존에는 1씩 증가하는 방식으로 이루어 졌지만 이번에는 버튼을 눌렀을때 답과 일치하는것이 아닌, 1번에 관련있는 인덱스값을 보내줘야한다.이젠 buttonpressed를 건드릴때다.생각을 해보니 choice1 / choice1Destination은 story안에 별도로 나뉘어진 매개변수이다.buttonpressed 하나로 ibaction을 했을때 구분이 가능할까 라는 생각을 해보았는데, 현재 내가 가진 지식으로는 안될것 같다라는 판단이 들어서IBaction을 하나더 만들기로 결정하였다.일단은 내방식대로 만들고 비교를 해보는걸로.(나중에 git에 올라가있는 completed code를 확인해야할거같다)@IBAction func choice1Pressed(_ sender: UIButton) {    }    @IBAction func choice2Pressed(_ sender: UIButton) {    }하나였던 Ibaction을 2개로 만들었다.코드를 작성을 해보다가 갑자기 1개로도 되지않을까 싶어 다시 1개로 만든다…코드를 적으면서 생각을 해보던중destination을 선택하는건 이렇게 적어보았다.mutating func selectDestination (_ choice : String) {                        if choice == getChoice().choice1 {            destination = getChoice().choice1Destination        } else {            destination = getChoice().choice2Destination        }    }    고민을 하던중.. 버튼을 눌렀을때 어떤 액션도 없다는걸 테스트 하면서 알게되었다…@IBAction func buttonPressed(_ sender: UIButton) {                let userChoice = sender.currentTitle!                    let userDestination = storyBrain.selectDestination(userChoice)        updateUI()     \t----------       }그래서 버튼을 눌렀을때 트리거를 작동하게 구현하였다.그랬더니 작동했다.뭔가 썩 맘에 들진 않지만 작동은한다하지만 변수로 선언한게 돌아가진 않는다. 강의해서 노란색뜨는건 무시하라고 한거같은데 이건가..코드는 깃에 그냥 저장해야겠다."
  },
  
  {
    "title": "Quizzler (6) Advanced",
    "url": "/posts/Quizzler-(6)-Advanced/",
    "categories": "Udemy, Quizzler",
    "tags": "",
    "date": "2024-02-27 05:13:00 +0900",
    





    
    "snippet": "이어서 내부 코드를 수정해보도록 하자.  코드 수정.위에서부터 아래로 내려가면서 고쳐보려고한다.일단 title을 0,1,2로 하면서 sender.title을 가져올때 주석과같이 0,1,2로 리턴하게 하였다.하지만 0,1,2가 어떤타입으로 리턴이 되는지 모르기에 일단print(type(of:userAnswer))이걸 적으면서 어떤 타입으로 값이 리턴이 ...",
    "content": "이어서 내부 코드를 수정해보도록 하자.  코드 수정.위에서부터 아래로 내려가면서 고쳐보려고한다.일단 title을 0,1,2로 하면서 sender.title을 가져올때 주석과같이 0,1,2로 리턴하게 하였다.하지만 0,1,2가 어떤타입으로 리턴이 되는지 모르기에 일단print(type(of:userAnswer))이걸 적으면서 어떤 타입으로 값이 리턴이 되는지 알아보기로 했다. 하지만 아직 확인 할 수는 없다.UI와 structure를 고치고 있기에 그와 관련된 코드들이 모두 터지고 말았다…하나씩 수정하면서 가보자위에서 아래로 흐름을 따라 코드를 보던 중// if user's answer is correctlet userGotItRight = quizBrain.checkAnswer(userAnswer)mutating func checkAnswer(_ userAnswer: String) -&gt; Bool {        if userAnswer == quiz[questionNumber].answer {            score += 1            return true        } else {            return false        }    }function에서 에러가 났다. 저 부분을 수정해보자.mutating func checkAnswer(_ userAnswer: String) -&gt; Bool {        if userAnswer == quiz[questionNumber].correctAnswer {//                                            -------------            score += 1            return true        } else {            return false        }    }저 밑줄친 부분을 수정 하였다.userAnswer가 실제 정답일때? 를 조건으로 해야하므로quiz내에 correctAnswer를 사용했다.이제 true/falsebutton에 관한 error이다.왜냐하면 우리는 true/false버튼을 없애고 0,1,2 이런식으로 버튼을 바꿨기에 없는것이 당연하다.@objc func updateUI() {        questionLabel.text = quizBrain.getQuestionText()        progresBar.progress = quizBrain.getProgress()        scoreLabel.text = \"Score: \\(quizBrain.getScore())\"        zeroButton.backgroundColor = UIColor.clear        firstButton.backgroundColor = UIColor.clear        secondButton.backgroundColor = UIColor.clear    }각각의 버튼을 zero / first / second로 바꿔 주었다.작동해보자.켜자마자 문제를 찾았다…문제에 대한 3지선다인데 그 3지선다를할 내용이 표시가 되지않았다….그리고 print를 사용해서 title의 type을 보니 string이었다.그리고 문제도 다음문제로 넘어갔고…저 button의 title을 3지선다에 있는 선택지로 바꿔준다면 해결이 될것같다!우선 그부분과 관련된 코드쪽을 찾아보자.일단 의심스러운 곳은 여기이다.updateUI에는 우리가 문제, 진행률, 스코어, 버튼 이렇게 계속 트리거를 해주는걸 알수있다.즉 저부분에 button에 관해 text를 넣어주면 될것같다!혹시 몰라 우선 ui에 0,1,2로 적었던것을 모두 지웠다.그리고 아래와 같이 적었다그럼 이제 structure에가서 관련된 함수를 한번 만들어 보도록 하자!일단은 각각의 버튼을 통제할 함수를 만들어 주었다.그리고 updateUI도 수정을 해주었다.@objc func updateUI() {        questionLabel.text = quizBrain.getQuestionText()        zeroButton.titleLabel?.text = quizBrain.getAnswerText0()        firstButton.titleLabel?.text = quizBrain.getAnswerText1()        secondButton.titleLabel?.text = quizBrain.getAnswerText2()        progresBar.progress = quizBrain.getProgress()        scoreLabel.text = \"Score: \\(quizBrain.getScore())\"        zeroButton.backgroundColor = UIColor.clear        firstButton.backgroundColor = UIColor.clear        secondButton.backgroundColor = UIColor.clear    }처음에 그냥 titleLabel만 하면되는줄 알았는데 안되어서 다시보니 text가 필요하여 변경해주었다.작동을 해보자!.돌리자마자 이상하다. 버튼 내용은 어디갔지?그리고 버튼을 눌러보니 error가 바로 발생한다.optional value?생각해보니 ui에서 버튼내용을 다 지웠기도 했지만, updateui에서 내가 새롭게 작성한 그 함수가 제대로 작동을 하지 않는것 같다.문제는 잘나오는걸로 봐선zeroButton.titleLabel?.text = quizBrain.getAnswerText0()firstButton.titleLabel?.text = quizBrain.getAnswerText1()secondButton.titleLabel?.text = quizBrain.getAnswerText2()    이부분에 문제가있는것 같다.func getAnswerText0 () -&gt; String {        return quiz[questionNumber].answer[0]    }혹시 이게 값을 못가져오는게 아닐까?playground로 테스트를 해봐야겠다.확인결과 아주 잘나온다…그럼 0,1,2를 넣고 다시 테스트를 해보자!아주 잠깐이지만 값이 나왔다가 0, 1, 2로 덮어버려진다.강의에서 챌린지때 화면을 다시 보았다.![])https://velog.velcdn.com/images/haroldfromk/post/da8b7562-192c-456c-b783-021bd8a068ee/image.png){: width=”50%” height=”50%”}choice1 choice2 이런식으로 해뒀다..하지만 나와의 차이점이라면나는 초기에 해둔 title이 계속 덮어씌워진다는 것이다. viewdidload에서 혹시 건드려야하는걸까 updateui에서 뭘 더 해야하는걸까 좀 더 생각해보자.zeroButton.setTitle(QuizBrain().getAnswerText0(), for: .normal)firstButton.setTitle(QuizBrain().getAnswerText1(), for: .normal)secondButton.setTitle(QuizBrain().getAnswerText2(), for: .normal)이걸써보니 choice에서 바뀌었다!하지만 그대로였다. 즉 setTitle을 사용하니 문제는 바뀌는데 버튼의 텍스트가 바뀌지않는다는건setTitle은 초기에 보여지는 화면의 text를 설정해주는것 같다.그러면 이걸 viewcontroller에 적고 원래 있던 그대로 해보자.혹시나 했는데 역시 안된다 viewcontroller 자체에는 안되나보다강의 코드를 살짝 보니 이건 내가 모르는 부분이었다.. //Need to fetch the answers and update the button titles using the setTitle method.         let answerChoices = quizBrain.getAnswers()choice1.setTitle(answerChoices[0], for: .normal)choice2.setTitle(answerChoices[1], for: .normal)choice3.setTitle(answerChoices[2], for: .normal)update를 하려면 변수를 만들고 설정을 해줘야하나보다. 저걸수정하니 된다…func getAnswerText () -&gt; [String] {        return quiz[questionNumber].answer    }    zeroButton.setTitle(getAnswer[0], for: .normal)firstButton.setTitle(getAnswer[1], for: .normal)secondButton.setTitle(getAnswer[2], for: .normal)    그럼 원래 내가하려고했던것도 될것같다…일단 titleLable?.text는 되지않기에 pass!setTitle을 하고 실행해보았다.잘된다…그래도 이거 하나만 집어넣었더니 잘되어서 다행이다 :)오늘 가장 큰 수확!setTitle을 사용할때는 그냥 structure에서 가져와서 쓰는게 아니라 이렇게 변수를 만들고 집어넣자..그래야 갱신이 된다!-&gt; 문제를 보여주는 label하고는 다른 개념이다.before (wrong way!)after"
  },
  
  {
    "title": "Quizzler (5) Advanced",
    "url": "/posts/Quizzler-(5)-Advanced/",
    "categories": "Udemy, Quizzler",
    "tags": "",
    "date": "2024-02-27 05:13:00 +0900",
    





    
    "snippet": "위의 사진 처럼 여태해온 2지선다가 아닌 3지선다로 UI와 code 모두 수정해보자.  주어진 문제는 3지선다이고, 정답도 따로있다.우선 주어진 문제는 아래와 같다q: “Which is the largest organ in the human body?”,a: [“Heart”, “Skin”, “Large Intestine”], correctAnswer:...",
    "content": "위의 사진 처럼 여태해온 2지선다가 아닌 3지선다로 UI와 code 모두 수정해보자.  주어진 문제는 3지선다이고, 정답도 따로있다.우선 주어진 문제는 아래와 같다q: “Which is the largest organ in the human body?”,a: [“Heart”, “Skin”, “Large Intestine”], correctAnswer: “Skin”q: / a: / correcntAnswer :이런 형식으로 되어있다.Structure를 바꿔보도록하자.//beforeimport Foundationstruct Question {    let text : String    let answer : String            init(q: String, a: String) {        text = q        answer = a    }}//afterimport Foundationstruct Question {    let text : String    let answer : [String]    let correctAnswer : String            init(q: String, a: [String], correctAnswer : String) {        text = q        answer = a        self.correctAnswer = correctAnswer    }}새로운 매개변수 correctAnswer를 만들어주었고, answer가 string이었던것을 배열로 바꿔 주었다.그리고 init()안의 parameter도 추가를 해주었다.처음에 init parameter를 생각지 못해서분명히 안에 코드를 다 적었는데 왜 에러가 나나 잠깐 고민을 했다.안에 correctAnswer로 내부 파라미터가 들어갔기에self.를 적지않으면 error가 발생한다.그렇게 내부 parameter까지 수정을 하면서 structure 부분을 끝냈다정확히말하면 Question.swift 파일을 끝냈다.  UI 수정.2지선다가 아닌 3지선다를 하기위해 버튼을 추가 해주었다.Title name이 현재 True로 되어있다.배열이름을 바꿔보자name -&gt; 0, 1, 2 이런식으로 했다배열안에 답을 골라야 할것 같아서 배열 index에 해당하는 title을 꺼내오기위해 네이밍을 저렇게 했다.그리고기존에 작업하였던 uibutton은 현재 view controller에 연결이 되어있으므로 끊어주자!그냥 해당 버튼을 우클릭하고 빨갛게 표시한 저 x 버튼만 눌러주면 main과 controller의 연결이 끊어진다.아주 잘 끊어졌다.그렇게 버튼에 현재 연결되어있던것을 끊어주었다.(기존에 있던 프로젝트를 수정하는것이므로)그리고 새로운 연결을 해주었다.나는 zero / first / second Button으로 해주었다.이렇게 모두 연결이 되었다!그리고 IBaction도 새로 만들어주어야 하는데 이것은 생략하겠다. 방식은 같다.(나는 기존의 작성되어있는것을 그대로 두고 내부 코드만 바꿔보려고한다.)이제부터가 진짜 시작이다. 어떻게 보면 기존의 코드를 수정하는것이지만 새로운 버튼이 추가되었기에 그부분도 테스트를 하면서 계속 코드를 작성 그리고 디버깅을 해야할 것 같다. 이부분은 꽤 길어질것같아 다음글에서 서술 하도록 하겠다."
  },
  
  {
    "title": "Quizzler (4)",
    "url": "/posts/Quizzler-(4)/",
    "categories": "Udemy, Quizzler",
    "tags": "",
    "date": "2024-02-27 05:13:00 +0900",
    





    
    "snippet": "이어서…quizBrain.swift에서 function checkAnswer를Bool type으로 하고 정답일때 true/ 틀렸을때 false return하게 하였다.func checkAnswer(_ userAnswer: String) -&gt; Bool {        if userAnswer == quiz[questionNumber].answer ...",
    "content": "이어서…quizBrain.swift에서 function checkAnswer를Bool type으로 하고 정답일때 true/ 틀렸을때 false return하게 하였다.func checkAnswer(_ userAnswer: String) -&gt; Bool {        if userAnswer == quiz[questionNumber].answer {            return true        } else {            return false        }    }그리고 다시 viewController로 돌아가서위와 같이 수정하였다.이걸 다르게 또 보는사람이 쉽게 하기위해 표현이 가능할까?이렇게 직관적으로 보이게도 할 수 있다.Challenge!그렇다면. 현재 아래 code는 quizBrain.swift에 관련 코드를 넣지 않고 입력한 상태이다.아래코드가 작동하게 하려면 quizBrain에 어떤 code를 작성해야할지 한번 try해보자!before@objc func updateUI() {        questionLabel.text = quiz[questionNumber].text        trueButton.backgroundColor = UIColor.clear        falseButton.backgroundColor = UIColor.clear        progresBar.progress = Float(questionNumber + 1 ) / Float(quiz.count)after@objc func updateUI() {        questionLabel.text = quizBrain.getQuestionText()        trueButton.backgroundColor = UIColor.clear        falseButton.backgroundColor = UIColor.clear        progresBar.progress = quizBrain.getProgress()    }quizBrain.swift내가한것func getQuestionText () -&gt; String {        var quiz : String = quiz[questionNumber].text                return quiz    }        func getProgress() -&gt; Float {                var progress : Float = Float(questionNumber + 1) / Float(quiz.count)                return progress    }강의에서의 코드func getQuestionText () -&gt; String {        return quiz[questionNumber].text    }        func getProgress() -&gt; Float {                let progress = Float(questionNumber + 1) / Float(quiz.count)        return progress    }뭐 또이또이하다 다만 차이라면 progress를 나는 var로 하였고 강의에서는 let으로 하였다.그리고 questionNumber를 1씩 증가해주던 부분을함수화 하여 quizBrain에 넣어주었다func nextQuestion() {        if questionNumber + 1 &lt; quiz.count {            questionNumber += 1        } else {            questionNumber = 0        }    }그랬더니 immutable즉 변할 수 없는 값이라고 에러가 뜬다.어떻게 해야할까?여기서 immutable이란??  불변성을 이야기한다.우선 Struct = Blueprint 라고 볼 수 있다.즉, 우리가 어떤 코드를 짤때에 있어 청사진을 그리는것이라고 이해하면 될 것 같다.그리고 그 청사진을 그린것을 실체화하는걸 initializing이라고 보면 되겠다.Blueprint -&gt; actualizationvar -&gt; variable / mutablelet -&gt; immutablestruct Town {    let name : String    var citizens : [String]    var resources : [String : Int]        init (name : String, citizens : [String], resources : [String : Int]){        self.name = name        self.citizens = citizens        self.resources = resources    }        func fortify() {        print(\"Defences increased!\")    }        //func harvestRice()}var anotherTown = Town(name: \"Nameless Island\", citizens: [\"Tom Hanks\"], resources: [\"Coconuts\" : 100])var myTown = Town(name: \"Harold Island\", citizens: [\"Harold\", \"Timothy\"], resources: [\"Wool\" : 75])myTown.citizens.append(\"Keanu Reeves\")anotherTown.citizens.append(\"Wilson\")print(anotherTown.citizens)이렇게 되어있는 코드에 sturcture 내부에 값을 한번 넣어보자!func harvestRice() {        resources[\"Rice\"] = 100    }structure 내부에 function을 만들어, resources에 Rice라는 항목을 만들고 100이라는 값을 넣었다. 즉 [“Rice” : 100] 의 형태로 넣었다.하지만 아래와 같이 에러가 발생한다.우리가 위에 정의한 self는 기본적으로 immutable 즉, 변할 수 없는 값이기 때문이다.  let 과 함께 정의된다고 생각하면 된다.Q: Self가 없는데 어디있는건가?A: 우리가 적은resources[\"Rice\"] = 100 이것은 사실self.resources[\"Rice\"] = 100 의 줄임 표현이다.Q: 그렇다면 structure에서는 값을 변경할 수 없나?A: 아니다 아래와 같이 func 앞에 mutating을 추가해주면 된다.mutating func harvestRice() {--------        resources[\"Rice\"] = 100    }그럼 함수를 호출하고 출력을 해보자.이렇게 추가된걸 볼 수 있다.myTown.harvestRice()함수를 호출하지않으면, 아래와 같다.함수 앞에 mutating을 붙이면 self는 var와 같은 역할을 수행하게 되고, 우리는 우리의 struct안에서 값을 자유롭게 바꿀 수 있다.즉 struct는  값이 변할 수 없는 struct  값이 변하는 struct이렇게 두개로 나눌 수 있다.Q: 우리가 현재 myTown을 let아닌 var로 정의 했는데, let를 사용하면 harvestRice 함수를 호출을 할수 있을까?var myTown = Town(name: \"Harold Island\", citizens: [\"Harold\", \"Timothy\"], resources: [\"Wool\" : 75])// --- var를 let으로let myTown = Town(name: \"Harold Island\", citizens: [\"Harold\", \"Timothy\"], resources: [\"Wool\" : 75])A: Nope! 왜냐면 let은 바꿀수없는 상수이므로, 값을 변화시켜주는 harvestRice 함수를 호출 할 수없다.그리고 let을 사용해서 매개변수를 정의를 하면, structure내의 모든 Properties들은 immutable이 되고, 또한 harvestRice 함수 앞에 적어둔 mutating또한 작동을 하지 않는다!!!다시 내용으로 들어와서…immutable즉 변할 수 없는 값이라고 에러가 뜬다.이부분에 대해 다시 이야기를 해보자.structure내부에서 questionNumber가 1씩 증가를 하거나 0으로 돌린다는건데 immutable이라 바꾸질 못한다. 그래서 func 앞에 mutating을 적어주었다.mutating func nextQuestion() {        if questionNumber + 1 &lt; quiz.count {            questionNumber += 1        } else {            questionNumber = 0        }    }잘 작동한다.challenge!정답을 맞추면 score가 올라가게 해보자!Let’s think!  로직은 어떻게 짜여야 할까?          우선 생각해본 Logic flow는 정답일때 score가1씩 증가, 오답일때는 값이 그대로, 그리고 마지막문제에서 첫번째 문제로 돌아갈때 score 를 0으로 한다.        먼저 무엇을 해야할까?          QuizBrain.swift에 함수를 정의한다.      func getScore ~        함수를 정의를 했다. 그다음에는 어떻게 해야할까?          우선 var score = 0 이라는 매개변수를 하나 만들어 주었다.        그 변수를 어디에 쓸건지?          우선 로직 플로우 그대로```swiftmutating func checkAnswer(_ userAnswer: String) -&gt; Bool {   if userAnswer == quiz[questionNumber].answer {       score += 1 // updated!       return true   } else {       return false   } }      mutating func nextQuestion() {        if questionNumber + 1 &lt; quiz.count {            questionNumber += 1        } else {            questionNumber = 0            score = 0 // updated!        }    }```처음에 내가 생각한게 맞나싶어서 했고 테스트만 안하고 확신이 없어서 완성한 코드를 더 꼬아버렸다.그러다 도저히 안되어서 강의를 봤는데 내가생각하고 작성한게 맞았다. 확신을 좀 가지자…무튼 완성!"
  },
  
  {
    "title": "Quizzler (3)",
    "url": "/posts/Quizzler-(3)/",
    "categories": "Udemy, Quizzler",
    "tags": "",
    "date": "2024-02-27 05:13:00 +0900",
    





    
    "snippet": "MVC Pattern의 image화MVC Pattern은 별도로 정리를 해두는게 좋아보인다.Quizzler(2)까지 했던 작업내역을 바탕으로 MVC패턴으로 Conversion해보자.먼저 새로운 디렉토리를 만들어주자MVC에 해당하는 총 3개의 디렉토리를 생성해주었다.그리고 Model 디렉토리에 QuizBrain.swift파일을 하나 더 만들어 주었다.Q...",
    "content": "MVC Pattern의 image화MVC Pattern은 별도로 정리를 해두는게 좋아보인다.Quizzler(2)까지 했던 작업내역을 바탕으로 MVC패턴으로 Conversion해보자.먼저 새로운 디렉토리를 만들어주자MVC에 해당하는 총 3개의 디렉토리를 생성해주었다.그리고 Model 디렉토리에 QuizBrain.swift파일을 하나 더 만들어 주었다.QuizBrain.swift File에 다음과 같이 quiz Array를 옮겨주었다.이미 값을 넣었기에, Initialize는 필요가없다.questionNumber또한 옮겨 주었다.import Foundationstruct QuizBrain {    let quiz = [        Question(q: \"A slug's blood is green.\", a: \"True\"),        Question(q: \"Approximately one quarter of human bones are in the feet.\", a: \"True\"),        Question(q: \"The total surface area of two human lungs is approximately 70 square metres.\", a: \"True\"),        Question(q: \"In West Virginia, USA, if you accidentally hit an animal with your car, you are free to take it home to eat.\", a: \"True\"),        Question(q: \"In London, UK, if you happen to die in the House of Parliament, you are technically entitled to a state funeral, because the building is considered too sacred a place.\", a: \"False\"),        Question(q: \"It is illegal to pee in the Ocean in Portugal.\", a: \"True\"),        Question(q: \"You can lead a cow down stairs but not up stairs.\", a: \"False\"),        Question(q: \"Google was originally called 'Backrub'.\", a: \"True\"),        Question(q: \"Buzz Aldrin's mother's maiden name was 'Moon'.\", a: \"True\"),        Question(q: \"The loudest sound produced by any animal is 188 decibels. That animal is the African Elephant.\", a: \"False\"),        Question(q: \"No piece of square dry paper can be folded in half more than 7 times.\", a: \"False\"),        Question(q: \"Chocolate affects a dog's heart and nervous system; a few ounces are enough to kill a small dog.\", a: \"True\")    ]        var questionNumber = 0    }그 이후 view Controller의 code를 아래와 같이 수정한다.// beforelet actualAnswer = quiz[questionNumber].answer// change code// afterquizBrain.checkAnswer(userAnswer: userAnswer)quizBrain.checkAnswer(userAnswer)checkAnswer의 경우 parameter를 표시하기 위해 userAnswer : ~~ 이렇게 표시를 하지만 보통은 parameter를 안보이고 그냥 매개변수만 넣는다.다시 quizBrain.swift로 돌아와서,func checkAnswer(_ userAnswer: String) {        if userAnswer == quiz[questionNumber].answer {            // User got it Right        } else {            // user got it Wrong        }            }function checkAnswer에 관한 code를 위와 같이 수정해준다.그렇다면 Viewcontroller에서if userAnswer == actualAnswer {            sender.backgroundColor = UIColor.green        } else {            sender.backgroundColor = UIColor.red        }위와 같이 답을 맞추었을때 background color를 바꾸었는데. 지금 관련된 code를 quizBrain으로 옮기고있다.바로 위에있는 저 quizBrain에 backgroundcolor 변경에 관한 코드를 넣으려면 어떻게 해야할까?"
  },
  
  {
    "title": "160. A로 B 만들기",
    "url": "/posts/160.-A%EB%A1%9C-B-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-27 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ before:String, _ after:String) -&gt; Int {        var answer = 0    var A = String(before).map{$0}.sorted()    var B = String(after).map{$0}.sorted()        answer ...",
    "content": "import Foundationfunc solution(_ before:String, _ after:String) -&gt; Int {        var answer = 0    var A = String(before).map{$0}.sorted()    var B = String(after).map{$0}.sorted()        answer = A == B ? 1 : 0        return answer}처음에는 각각의 같은 값을 포함해야하는지 생각해서contains를 써보려고했는데 그렇게 했을때는 하나씩 돌다보니 결국 아예 다르지 않고서는 답이 1로만 나오게 되었다.그래서 생각해보니 두개의 값을 모두 하나의 기준으로 정렬을 하고 비교를 해보면 되지않을까 해서 정렬을 하고 그 값을 같을때는 1 아닐땐 0으로 해서 리턴을 하였다.다른코드를 보니 대부분 이런 발상으로 했다."
  },
  
  {
    "title": "159. 숫자 찾기",
    "url": "/posts/159.-%EC%88%AB%EC%9E%90-%EC%B0%BE%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-27 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num:Int, _ k:Int) -&gt; Int {        var answer : Int = 0    var arr = String(num).map{$0}    var arr1 = arr.enumerated().map{$0}    arr1 = arr1.filter{$0.1 == Char...",
    "content": "import Foundationfunc solution(_ num:Int, _ k:Int) -&gt; Int {        var answer : Int = 0    var arr = String(num).map{$0}    var arr1 = arr.enumerated().map{$0}    arr1 = arr1.filter{$0.1 == Character(String(k))}    answer = arr1.count &gt; 0 ? arr1[0].offset + 1 : -1     return answer}처음에는 filter와 firstIndex를 써서 하려고했는데 이상하게 막혀버려서 결국 다른 방법을 사용하였다.우선 num을 배열화 하였고. enumerated를 사용하여 만들어진 배열에 인덱스 값을 추가하였다.그이후 filter를 사용해 k값과 일치하는 원소만 추출하였고여러값이 나왔다면 초기값을 리턴하면 되기에 arr1[0]을 리턴하였다.하지만 우리가 생각하는 인덱스와 문제에서 결과값에 대한 인덱스값은 달라서 +1을 해주었다.다른코드를 보니 앞에 array를 씌워야 했는데 나는 씌우지않고 그대로해서 string index가 나와 해결을 하지 못했다… 거의다한건데 나중에 다시 해봐야겠다.다른코드unc solution(_ num: Int, _ k: Int) -&gt; Int { Array(\"-\\(num)\").firstIndex(of: Character(String(k))) ?? -1 }//import Foundationfunc solution(_ num:Int, _ k:Int) -&gt; Int {    let s = String(num).map{ Int(String($0))! }    return (s.firstIndex(of: k) ?? -2) + 1}//import Foundationfunc solution(_ num:Int, _ k:Int) -&gt; Int {    return String(num).contains(Character(String(k))) ? Array(String(num)).firstIndex(of: Character(String(k)))! + 1 : -1}"
  },
  
  {
    "title": "Quizzler (2)",
    "url": "/posts/Quizzler-(2)/",
    "categories": "Udemy, Quizzler",
    "tags": "",
    "date": "2024-02-26 05:13:00 +0900",
    





    
    "snippet": "해당 강의 내용을 정리하기전.강의에서 Structure가 필요하기에 그부분을 정리하고자한다.구조체 Structure  정의    struct Mystruct { }            구조체를 만들때는 처음부터 이름을 대문자로 표기한다          우리가 평상시 만들던 CamelCase가 아니다!      일종의 Data Type으로 생각을 하면 ...",
    "content": "해당 강의 내용을 정리하기전.강의에서 Structure가 필요하기에 그부분을 정리하고자한다.구조체 Structure  정의    struct Mystruct { }            구조체를 만들때는 처음부터 이름을 대문자로 표기한다          우리가 평상시 만들던 CamelCase가 아니다!      일종의 Data Type으로 생각을 하면 되겠다.  \t- ex) Int, Float, Double ….      Structure를 한번 만들어 보았다.struct Town {    let name = \"HaroldLand\"    var citizens = [\"Harold\", \"Angela\"]    var resources = [\"Grain\" : 100, \"Ore\" : 42, \"Wool\" : 75]        }var myTown = Town()var myTown = Town()을 통해 이제 myTown이라는 매개변수를 이용해 structure에 접근을 할 수 있게되었다.접근을할때는 매개변수 뒤에 . 을 붙이면 된다.또한 추가를 하고싶을때는 append를 사용한다struct Town {    let name = \"HaroldLand\"    var citizens = [\"Harold\", \"Angela\"]    var resources = [\"Grain\" : 100, \"Ore\" : 42, \"Wool\" : 75]        }var myTown = Town()myTown.citizens.append(\"Keanu Reeves\")print(myTown.citizensa)print(myTown.citizens.count)물론 structure안에 함수도 넣을 수 있다.struct Town {    let name = \"HaroldLand\"    var citizens = [\"Harold\", \"Angela\"]    var resources = [\"Grain\" : 100, \"Ore\" : 42, \"Wool\" : 75]        func fortify() {        print(\"Defences increased!\")    }}var myTown = Town()myTown.citizens.append(\"Keanu Reeves\")print(myTown.citizens)print(myTown.citizens.count)myTown.fortify() //호출도 가능하다.요약initialize-&gt; property를 Ininitailization 해준다struct Town {    let name : String    var citizens : [String]    var resources : [String : Int]        init (townName : String, people : [String], stats : [String : Int])![](https://velog.velcdn.com/images/haroldfromk/post/c7a728c5-3070-4ad0-a728-bd984c817beb/image.gif){        name = townName        citizens = people        resources = stats    }        func fortify() {        print(\"Defences increased!\")    }}매개변수를 같게 해보자struct Town {    let name : String    var citizens : [String]    var resources : [String : Int]        init (name : String, citizens : [String], resources : [String : Int]){        self.name = name        self.citizens = citizens        self.resources = resources    }        func fortify() {        print(\"Defences increased!\")    }}self를 붙이지않고 name = name이런식으로 하게되면에러가 발생한다.structure의 name이 상수이기때문.self를 붙이면서 해소가 되는데self는 구조체를 가리키는걸로 생각하면 쉽다.다시 강의정리로 돌아와서현재 2차원 배열로 되어있는 quiz를 파일을 새로 만들어서 거기에 별도로 넣어보자.우클릭 -&gt; New File -&gt; Swift File새로만든 파일에 구조체를 하나 만들었다.그리고 init을 적고 Initializing을 해주었다.그리고나서 문제와 답을 가지고 있는 배열을 structure에 맞게 바꿔주었다.그리고 우리가 문제를 맞췄는지 틀렸는지에 관해 console에서만 확인 할 수있던것을 버튼에 색을 주어 나타내었다.그런데 문제가 생겼다.버튼 색만 변경을 해주어서 다시 원래대로 돌아오지 않았다. func updateUI() {        questionLabel.text = quiz[questionNumber].text        trueButton.backgroundColor = UIColor.clear        falseButton.backgroundColor = UIColor.clear    }그래서 버튼의 uicolor를 clear해주었다.과연?이제는 아예 색이 보이지 않는다.다시한번 해보자.import UIKitclass ViewController: UIViewController {        @IBOutlet weak var questionLabel: UILabel!    @IBOutlet weak var progresBar: UIProgressView!    @IBOutlet weak var trueButton: UIButton!    @IBOutlet weak var falseButton: UIButton!        let quiz = [        Question(q: \"A slug's blood is green.\", a: \"True\"),        Question(q: \"Approximately one quarter of human bones are in the feet.\", a: \"True\"),        Question(q: \"The total surface area of two human lungs is approximately 70 square metres.\", a: \"True\"),        Question(q: \"In West Virginia, USA, if you accidentally hit an animal with your car, you are free to take it home to eat.\", a: \"True\"),        Question(q: \"In London, UK, if you happen to die in the House of Parliament, you are technically entitled to a state funeral, because the building is considered too sacred a place.\", a: \"False\"),        Question(q: \"It is illegal to pee in the Ocean in Portugal.\", a: \"True\"),        Question(q: \"You can lead a cow down stairs but not up stairs.\", a: \"False\"),        Question(q: \"Google was originally called 'Backrub'.\", a: \"True\"),        Question(q: \"Buzz Aldrin's mother's maiden name was 'Moon'.\", a: \"True\"),        Question(q: \"The loudest sound produced by any animal is 188 decibels. That animal is the African Elephant.\", a: \"False\"),        Question(q: \"No piece of square dry paper can be folded in half more than 7 times.\", a: \"False\"),        Question(q: \"Chocolate affects a dog's heart and nervous system; a few ounces are enough to kill a small dog.\", a: \"True\")//        Question(q: \"Four + Two is equal to Six.\", a: \"True\"),//        Question(q: \"Five - Three is greater than One.\", a: \"True\"),//        Question(q: \"Three + Eight is less than Ten.\", a: \"False\")    ]    var questionNumber = 0    var timer = Timer()        override func viewDidLoad() {        super.viewDidLoad()                updateUI()           }        @IBAction func answerButtonPressed(_ sender: UIButton) {                let userAnswer = sender.currentTitle // true or false        let actualAnswer = quiz[questionNumber].answer        //let actualQuestion = quiz[questionNumber]        //let actualAnswer = actualQuestion.answer                if userAnswer == actualAnswer {            sender.backgroundColor = UIColor.green        } else {            sender.backgroundColor = UIColor.red        }        //        if questionNumber == 2 {//            questionNumber = 0//        }//        //        questionNumber += 1                if questionNumber + 1 &lt; quiz.count {            questionNumber += 1        } else {            questionNumber = 0        }                timer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(updateUI), userInfo: nil, repeats: true)        //updateUI()    }        @objc func updateUI() {        questionLabel.text = quiz[questionNumber].text        trueButton.backgroundColor = UIColor.clear        falseButton.backgroundColor = UIColor.clear    }    }Timer를 써야할거같았는데 혹시 다른방법이 있나 했는데 결국 없었다.timer를 만들어서 selector에 updateUI를 해주었다. 이때 selecter에 updateUI가 들어가면서func updateUI~ 이랬떤 부분을@objc func updateUI로 바꾸어 주었다.selector가 objective-C에 의존하기 때문.시간의 편차가 생기긴 하지만 그래도 작동은 된다.알고보니 repeats 때문인듯하다.0.2로 바꾸어주고 repeats도 false를 해주니 잘된다.아마 시간편차는 타이머가 반복으로 되면서 꼬였던것으로 보인다.progress bar를 추가하여 문제에따른 진행률을 해보자.강의에서는 아래와 같이했다.결과는 같다.하지만 시작이 0부터인데 실제로 문제는 첫번째의 개념이므로 +1을 해주자이젠 우리가 의도하고 싶었던 대로 되었다."
  },
  
  {
    "title": "158. 369게임",
    "url": "/posts/158.-369%EA%B2%8C%EC%9E%84/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-26 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ order:Int) -&gt; Int {        var answer = String(order).map{String($0)}.filter{$0==\"3\" || $0==\"6\" || $0==\"9\"}.count        return answer}일단 order를 각각 하나로 분류하기위해 ma...",
    "content": "import Foundationfunc solution(_ order:Int) -&gt; Int {        var answer = String(order).map{String($0)}.filter{$0==\"3\" || $0==\"6\" || $0==\"9\"}.count        return answer}일단 order를 각각 하나로 분류하기위해 map을 사용하여 배열에 담았다.그리고 필터를 사용하였고 처음에는 생각없이 3으로 나눈수에 해당하는 걸 카운트로 해야하는건가 싶었는데 알고보니 3,6,9에 해당하는 내용이라or조건을 사용해서 해결하였다."
  },
  
  {
    "title": "157. 약수 구하기",
    "url": "/posts/157.-%EC%95%BD%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-25 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int) -&gt; [Int] {        var arr : [Int] = []        arr =  (1...n).map{$0}.filter{n%$0==0}        return arr}약수를 구하기 위해서 먼저 filter를 사용하려고하였다.n에서 1~n까지의 나눴을때 나머지...",
    "content": "import Foundationfunc solution(_ n:Int) -&gt; [Int] {        var arr : [Int] = []        arr =  (1...n).map{$0}.filter{n%$0==0}        return arr}약수를 구하기 위해서 먼저 filter를 사용하려고하였다.n에서 1~n까지의 나눴을때 나머지가 0이어야 하는데 순간 어떻게 해야하지라고 했다가(1…n)을 떠올리고 문제를 해결하였다.잘기억해두자.."
  },
  
  {
    "title": "156. 가장 큰 수 찾기",
    "url": "/posts/156.-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%88%98-%EC%B0%BE%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ array:[Int]) -&gt; [Int] {        var arr : [Int] = []        arr.append(array.max()!)    arr.append(array.firstIndex(of:array.max()!)!)    return arr}단순히 최댓값을 찾고, ...",
    "content": "import Foundationfunc solution(_ array:[Int]) -&gt; [Int] {        var arr : [Int] = []        arr.append(array.max()!)    arr.append(array.firstIndex(of:array.max()!)!)    return arr}단순히 최댓값을 찾고, 그것에 해당하는 인덱스를 리턴하였는데 다른 코드들을 보니 인덱스를 안쓰고 enumerated를 써서 표현하였다.하긴 그것도 좋은 방법으로 보인다.두번재는 옵셔널 체이닝으로 했는데 아직 이부분을 정리를 제대로 못한거같은데 다음에는 옵셔널 체이닝도 좀 써봐야겠다.다른코드import Foundationfunc solution(_ array:[Int]) -&gt; [Int] {    let max = array.enumerated().max(by: { $0.element &lt; $1.element })!    return [max.element, max.offset]}//func solution(_ array: [Int]) -&gt; [Int] { [array.max() ?? 0, array.firstIndex(of: array.max() ?? 0) ?? 0] }//import Foundationfunc solution(_ array:[Int]) -&gt; [Int] {    return [array.max()!, (1..&lt;array.count).filter{array[$0] == array.max()!}.first!]}"
  },
  
  {
    "title": "155. 개미군단",
    "url": "/posts/155.-%EA%B0%9C%EB%AF%B8%EA%B5%B0%EB%8B%A8/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ hp:Int) -&gt; Int {        var answer = 0        answer = hp/5 + (hp%5)/3 + ((hp%5)%3)/1        return answer}단순하게 생각을 했다.먼저 hp에서 장군개미가 얼마나 필요한지를 구하기위해 hp/5를 한다.그리고...",
    "content": "import Foundationfunc solution(_ hp:Int) -&gt; Int {        var answer = 0        answer = hp/5 + (hp%5)/3 + ((hp%5)%3)/1        return answer}단순하게 생각을 했다.먼저 hp에서 장군개미가 얼마나 필요한지를 구하기위해 hp/5를 한다.그리고 남은 나머지에서 3을 나누고그나머지에 1을 나누었다. (사실 마지막은 필요없긴한데… 깔맞춤했다)이렇게해서 합을 리턴하였다."
  },
  
  {
    "title": "154. 대문자와 소문자",
    "url": "/posts/154.-%EB%8C%80%EB%AC%B8%EC%9E%90%EC%99%80-%EC%86%8C%EB%AC%B8%EC%9E%90/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String) -&gt; String {        var answer = \"\"        answer = my_string.map{String($0) == String($0).uppercased() ? String($0).lowercased() : String($0).u...",
    "content": "import Foundationfunc solution(_ my_string:String) -&gt; String {        var answer = \"\"        answer = my_string.map{String($0) == String($0).uppercased() ? String($0).lowercased() : String($0).uppercased()}.joined()    return answer}삼항연산자를 사용했고 대문자라고 물어봤을때 대문자면 소문자로 리턴하고 아닌경우엔 대문자로 리턴하게 하였다."
  },
  
  {
    "title": "153. 암호 해독",
    "url": "/posts/153.-%EC%95%94%ED%98%B8-%ED%95%B4%EB%8F%85/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ cipher:String, _ code:Int) -&gt; String {        var answer = \"\"    var arr = cipher.map{String($0)}        answer = stride(from:code-1, to:cipher.count, by: code)....",
    "content": "import Foundationfunc solution(_ cipher:String, _ code:Int) -&gt; String {        var answer = \"\"    var arr = cipher.map{String($0)}        answer = stride(from:code-1, to:cipher.count, by: code).map{arr[$0]}.joined()    print(answer)        return \"\"}일정한 간격으로 출력해주기위해 전에썼던 stride를 이용하였다.다만 그냥stride()만 하게되면 숫자를 간격으로 하기때문에. 이걸인덱스로 가져오기위해 map을 사용하였다.다른코드func solution(_ cipher: String, _ code: Int) -&gt; String { (0..&lt;cipher.count).filter { $0 % code == code - 1 }.map { String(Array(cipher)[$0]) }.joined(separator: \"\") }//import Foundationfunc solution(_ cipher:String, _ code:Int) -&gt; String {    return cipher.enumerated().filter{ ($0.offset + 1) % code == 0 }.reduce(\"\") { $0 + String($1.element) }}"
  },
  
  {
    "title": "152. 숨어있는 숫자의 덧셈 (1) (fin)",
    "url": "/posts/152.-%EC%88%A8%EC%96%B4%EC%9E%88%EB%8A%94-%EC%88%AB%EC%9E%90%EC%9D%98-%EB%8D%A7%EC%85%88-(1)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류했던문제",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String) -&gt; Int {        var answer = my_string.map{$0}.filter{$0.isNumber}.map{Int(String($0))!}.reduce(0,+)        return answer}기존에 왜 보류를 했는지 쓰다만 코드를...",
    "content": "import Foundationfunc solution(_ my_string:String) -&gt; Int {        var answer = my_string.map{$0}.filter{$0.isNumber}.map{Int(String($0))!}.reduce(0,+)        return answer}기존에 왜 보류를 했는지 쓰다만 코드를 보았다.answer = my_string.map{String($0).isNumber ? $0 : 0}.reduce(0,+)이렇게 되어있었다.처음부터 바로 String으로 하고 정수인지 확인하고 아니면 0으로 리턴해서 reduce로 합치려고 했었다.하지만 다시 풀었을때 안되는걸 알았고 map을 사용하여 먼저 어떻게 넘어가는지 확인을 하였다.그리고나서 필터를 걸어 정수만 걸러내었고, 그것을 Int로 형변환 하기위해 다시 map을 씌우고 reduce로 더하여 결과를 리턴하였다."
  },
  
  {
    "title": "151. 모음 제거",
    "url": "/posts/151.-%EB%AA%A8%EC%9D%8C-%EC%A0%9C%EA%B1%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String) -&gt; String {        var answer : String = \"\"        answer = my_string.components(separatedBy:[\"a\",\"e\",\"i\",\"o\",\"u\"]).joined()            return ...",
    "content": "import Foundationfunc solution(_ my_string:String) -&gt; String {        var answer : String = \"\"        answer = my_string.components(separatedBy:[\"a\",\"e\",\"i\",\"o\",\"u\"]).joined()            return answer}전에 썼던걸 기억해서 components를 사용해서 풀었다. 리턴값이 배열로 나타나기에 joined를 사용하여 문자열로 나타내었다.다른코드를 보니 필터를 사용했는데, 내꺼보다 훨씬 더 아름다웠다.다른코드import Foundationfunc solution(_ my_string:String) -&gt; String {    return my_string.filter { ![\"a\", \"e\", \"i\", \"o\", \"u\"].contains($0)}}"
  },
  
  {
    "title": "150. 문자 반복 출력하기",
    "url": "/posts/150.-%EB%AC%B8%EC%9E%90-%EB%B0%98%EB%B3%B5-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {        var result : String = \"\"        for i in my_string {        result += String(repeating:i, count:n)    }       retur...",
    "content": "import Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {        var result : String = \"\"        for i in my_string {        result += String(repeating:i, count:n)    }       return result}각글자가 반복적으로 만들어져야하기에 repeating을 사용하였다.하지만 에러가 발생하였고 처음에는 내가 잘못썼나 싶어서 코드를 확인했는데 문제가 없었다 그래서 혹시나해서 i를 출력했는데 인덱스 값이 나왔다.for문을 사용했지만 보통의 i는 index값을 가져올 때썼는데 너무도 당연하게 그렇게 작성을 했기 때문이다.그래서 이번에는 in my_string그대로 사용하면서 i는 각각 글자 하나씩을 의미하게 하였고 결과 값을 리턴하였다.다른 코드를 보니 map을 사용해서 했는데 더 아름다워보인다.다른코드import Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {    guard my_string.count &gt;= 1, my_string.count &lt;= 50, n &gt;= 1 , n &lt;= 50 else {        return \"\"    }    return my_string.map( {         String(repeating: $0, count: n)    } ).joined()}"
  },
  
  {
    "title": "149. 세균 증식",
    "url": "/posts/149.-%EC%84%B8%EA%B7%A0-%EC%A6%9D%EC%8B%9D/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int, _ t:Int) -&gt; Int {        var answer : Int = 0        answer = n * Int(pow(Double(2),Double(t)))        return answer}2의 t제곱씩 수가 증가하는것을 보고 pow를 사용하여 결과 값을 ...",
    "content": "import Foundationfunc solution(_ n:Int, _ t:Int) -&gt; Int {        var answer : Int = 0        answer = n * Int(pow(Double(2),Double(t)))        return answer}2의 t제곱씩 수가 증가하는것을 보고 pow를 사용하여 결과 값을 리턴하였다.pow는 안에 들어가는 매개변수가 소수점의 형태이어야 하므로 Float or Double Type으로 해주어야한다."
  },
  
  {
    "title": "148. 순서쌍의 개수",
    "url": "/posts/148.-%EC%88%9C%EC%84%9C%EC%8C%8D%EC%9D%98-%EA%B0%9C%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer : Int = 0        for i in 1...n {        if n%i == 0 {            answer += 1        }    }        return answer}순서쌍으로 포장했지만 자세...",
    "content": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer : Int = 0        for i in 1...n {        if n%i == 0 {            answer += 1        }    }        return answer}순서쌍으로 포장했지만 자세히보면 약수의 개수를 묻는 문제였다.자연스럽게 for문을 써서 풀었는데, 저번에 비슷한문제를(1…n).filter~이런식으로도 풀려고했던기억이 있는데 너무나도 당연하게 for문을 써버렸다.코드가 아름답지 못했다."
  },
  
  {
    "title": "147. 삼각형의 완성조건 (1)",
    "url": "/posts/147.-%EC%82%BC%EA%B0%81%ED%98%95%EC%9D%98-%EC%99%84%EC%84%B1%EC%A1%B0%EA%B1%B4-(1)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ sides:[Int]) -&gt; Int {        var answer : Int = 0    var arr : [Int] = []        arr=sides.sorted(by:&gt;)        answer = arr[0] &lt; arr[1] + arr[2] ? 1 : 2   ...",
    "content": "import Foundationfunc solution(_ sides:[Int]) -&gt; Int {        var answer : Int = 0    var arr : [Int] = []        arr=sides.sorted(by:&gt;)        answer = arr[0] &lt; arr[1] + arr[2] ? 1 : 2        return answer}배열의 최댓값이 나머지의 값의 합보다 작으면 삼각형이 되는 조건이므로 순서가 뒤죽박죽인 배열을 내림차순으로 정렬하기위해 sorted(by:&gt;)를 사용하여 정렬을 해주었고, 그후에 최댓값은 [0] 나머지는 [1] [2] 이기에 삼항연산자를 사용하여 결과값을 리턴하였다."
  },
  
  {
    "title": "146. 자릿수 더하기",
    "url": "/posts/146.-%EC%9E%90%EB%A6%BF%EC%88%98-%EB%8D%94%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer : Int = 0        answer = String(n).map{Int(String($0))!}.reduce(0,+)    return answer}자릿수를 더하기위해서 map을 사용해 각각의 자릿수를 배열에 담았다.그리...",
    "content": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer : Int = 0        answer = String(n).map{Int(String($0))!}.reduce(0,+)    return answer}자릿수를 더하기위해서 map을 사용해 각각의 자릿수를 배열에 담았다.그리고 reduce를 사용하여 더했고 그값을 리턴하였다."
  },
  
  {
    "title": "145. 배열의 유사도 (ing)",
    "url": "/posts/145.-%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%9C%A0%EC%82%AC%EB%8F%84(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "144. 특정 문자 제거하기(ing)",
    "url": "/posts/144.-%ED%8A%B9%EC%A0%95-%EB%AC%B8%EC%9E%90-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "143. 짝수 홀수 개수",
    "url": "/posts/143.-%EC%A7%9D%EC%88%98-%ED%99%80%EC%88%98-%EA%B0%9C%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {        var arr : [Int] = []        arr.append(num_list.filter{$0%2 == 0}.count)    arr.append(num_list.filter{$0%2 != 0}.count)    ret...",
    "content": "import Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {        var arr : [Int] = []        arr.append(num_list.filter{$0%2 == 0}.count)    arr.append(num_list.filter{$0%2 != 0}.count)    return arr}짝수, 홀수의 개수를 새로운 배열에 담아내면 되는것이어서, filter를 사용하여 짝수, 홀수를 판별하였고 그 뒤에.count를 사용해 개수를 리턴하였다.그리고 append를 이용해서 추가를 하였다.다른코드[numList.filter { $0 % 2 == 0 }.count, numList.filter { $0 % 2 == 1 }.count] 다른코드들은 이런식으로 추가를 하였다.뭐 표현의 차이인데 뭐가 더 이뻐보이는지 모르겠다."
  },
  
  {
    "title": "142. 문자열안에 문자열",
    "url": "/posts/142.-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%95%88%EC%97%90-%EB%AC%B8%EC%9E%90%EC%97%B4/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ str1:String, _ str2:String) -&gt; Int {        var answer : Int = 0        answer = str1.contains(str2) ? 1 : 2        return answer}문자열을 포함하는지? 에 관한 문제였다.그래서 conta...",
    "content": "import Foundationfunc solution(_ str1:String, _ str2:String) -&gt; Int {        var answer : Int = 0        answer = str1.contains(str2) ? 1 : 2        return answer}문자열을 포함하는지? 에 관한 문제였다.그래서 contains를 사용하여 풀려고하였고. 삼항연산자를 사용해 결과값을 리턴하였다."
  },
  
  {
    "title": "141. 최댓값 만들기 (1)",
    "url": "/posts/141.-%EC%B5%9C%EB%8C%93%EA%B0%92-%EB%A7%8C%EB%93%A4%EA%B8%B0-(1)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ numbers:[Int]) -&gt; Int {        var arr : [Int] = []    var answer : Int = 0        arr = numbers.sorted(by:&gt;)        answer = arr[0] * arr[1]        return an...",
    "content": "import Foundationfunc solution(_ numbers:[Int]) -&gt; Int {        var arr : [Int] = []    var answer : Int = 0        arr = numbers.sorted(by:&gt;)        answer = arr[0] * arr[1]        return answer}배열에서 원소를 두개를 꺼내 그 곱의 최대값을 구하는 문제여서 우선 배열을 내림차순 정렬하여 큰수를 먼저 나오게 하였다.그리고 0, 1 번째 인덱스에 해당하는 값을 곱하여 그 값을 리턴하였다."
  },
  
  {
    "title": "140. 배열 자르기 (ing)",
    "url": "/posts/140.-%EB%B0%B0%EC%97%B4-%EC%9E%90%EB%A5%B4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "139. 배열 원소의 길이",
    "url": "/posts/139.-%EB%B0%B0%EC%97%B4-%EC%9B%90%EC%86%8C%EC%9D%98-%EA%B8%B8%EC%9D%B4/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ strlist:[String]) -&gt; [Int] {        var answer : [Int] = []        answer = strlist.map{$0.count}        return answer}이전 같았으면 for문을쓰고 막 했을텐데 확실히 문제를 많이 풀고 시행착오를...",
    "content": "import Foundationfunc solution(_ strlist:[String]) -&gt; [Int] {        var answer : [Int] = []        answer = strlist.map{$0.count}        return answer}이전 같았으면 for문을쓰고 막 했을텐데 확실히 문제를 많이 풀고 시행착오를 겪으면서 고차함수도 조금씩 적응이 되고 있는 것 같다.각 배열안에 있는 문자열의 길이를 리턴하면 되기에새로운 배열을 만들었고 map을 사용하고 클로저에 .count를 하면서 각 문자열의 길이를 담게하였다."
  },
  
  {
    "title": "138. 편지",
    "url": "/posts/138.-%ED%8E%B8%EC%A7%80/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-24 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ message:String) -&gt; Int {            var answer : Int = 0    answer = message.count * 2        return answer}result를 보니 message의 길이에 2를 곱한값이란걸 알게되었고 길이를 알기위해 coun...",
    "content": "import Foundationfunc solution(_ message:String) -&gt; Int {            var answer : Int = 0    answer = message.count * 2        return answer}result를 보니 message의 길이에 2를 곱한값이란걸 알게되었고 길이를 알기위해 count를 써서 2를 곱한값을 리턴하였다."
  },
  
  {
    "title": "Quizzler (1)",
    "url": "/posts/Quizzler-(1)/",
    "categories": "Udemy, Quizzler",
    "tags": "",
    "date": "2024-02-23 05:13:00 +0900",
    





    
    "snippet": "앱을 키자마자 위와 같이 문제가 나오게 해보자import UIKitclass ViewController: UIViewController {        @IBOutlet weak var questionLabel: UILabel!    @IBOutlet weak var progresBar: UIProgressView!    @IBOutlet weak v...",
    "content": "앱을 키자마자 위와 같이 문제가 나오게 해보자import UIKitclass ViewController: UIViewController {        @IBOutlet weak var questionLabel: UILabel!    @IBOutlet weak var progresBar: UIProgressView!    @IBOutlet weak var trueButton: UIButton!    @IBOutlet weak var falseButton: UIButton!        override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.        questionLabel.text = \"Four+Two is equal to Six\"    }    @IBAction func answerButtonPressed(_ sender: UIButton) {    }    }간단하다.override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.        questionLabel.text = \"Four+Two is equal to Six\"    }viewDidLoad()는 앱을 실행하자마자 작동을 하는 함수이므로 거기에 위와 같이 questionLabel에 관한 내용을 적어주면 된다.이번엔 위와 같이 퀴즈에 관한 문제가 배열로 주어졌다이것의 첫번째 index에 관한 문제를 띄워보자.이정도는 뭐 가볍게 끝내자.import UIKitclass ViewController: UIViewController {        @IBOutlet weak var questionLabel: UILabel!    @IBOutlet weak var progresBar: UIProgressView!    @IBOutlet weak var trueButton: UIButton!    @IBOutlet weak var falseButton: UIButton!        let quiz = [        \"Four + Two is equal to Six.\",        \"Five - Three is greater than One.\",        \"Three + Eight is less than Ten.\"    ]    var questionNumber = 0        override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.        questionLabel.text = quiz[questionNumber]    }        @IBAction func answerButtonPressed(_ sender: UIButton) {        questionNumber += 1            }    }위와 같이 버튼을 눌렀을때 문제가 바뀌도록 해보았다.하지만 아무리 눌러도 변화가없다.Q : 왜일까? 분명히 questionNumber라는 변수를 선언하였고, 버튼을 누를때마다 1씩 증가하게 했으면 배열의 인덱스가 1씩 늘어나므로 label에는 증가한 인덱스에 해당하는 문장이 나와야하는데 왜 안나올까?A : 현재 label에 관한 코드가 어느 위치에 있는지 확인을 해보자override func viewDidLoad() {        super.viewDidLoad()        questionLabel.text = quiz[questionNumber]    }해당 코드가 다시 트리거가 되어야하는데.viewdidload는 앱실행후 한번만 트리거가 되기 때문이다.즉 현재는 다시 트리거해줄 수 있는것이 없다.그래서 label을 재 트리거 해줄 함수를 새로 만들자.그러면 이제는 잘된다.하지만 문제가 3개밖에 없기에 3번째 누르는 순간 에러가 발생한다.왜냐면 questionNumber는 누를때마다 1씩 증가하는데, 배열안에 index는 2가 끝이기 때문이다.에러가났을때 바로 console쪽의 arrow를 통해 value를 볼 수 있다.에러가 났을때의 questionNumber 는 3이다.하지만 배열의 index는 0부터 시작하고 안에 3문장만 있으므로 0, 1, 2가 끝이다.그런데 해당 배열의 index=3에 해당하는 값을 가져오려고하니 에러가 발생한 것이다.이번엔 해당 문제에 관해 True or False인지를 부여해보자.현재의 quiz배열은 1차원이다.위의 image처럼 2차원 배열을 이용해 만들어 보자.바뀌었다.그럼 전에는 어떻게 되어있었을까?코드 작성을 통해 무한 반복되게 하면서 에러가 발생하지 않게 하였다import UIKitclass ViewController: UIViewController {        @IBOutlet weak var questionLabel: UILabel!    @IBOutlet weak var progresBar: UIProgressView!    @IBOutlet weak var trueButton: UIButton!    @IBOutlet weak var falseButton: UIButton!        let quiz = [        [\"Four + Two is equal to Six.\", \"True\"],        [\"Five - Three is greater than One.\", \"True\"],        [\"Three + Eight is less than Ten.\", \"False\"]    ]    var questionNumber = 0        override func viewDidLoad() {        super.viewDidLoad()                updateUI()           }        @IBAction func answerButtonPressed(_ sender: UIButton) {                let userAnswer = sender.currentTitle // true or false        let actualAnswer = quiz[questionNumber][1]                if userAnswer == actualAnswer {            print(\"Right!\")        } else {            print(\"Wrong!\")        }        //        if questionNumber == 2 {//            questionNumber = 0//        }//        //        questionNumber += 1                if questionNumber + 1 &lt; quiz.count {            questionNumber += 1        } else {            questionNumber = 0        }                updateUI()                            }        func updateUI() {        questionLabel.text = quiz[questionNumber][0]    }    }"
  },
  
  {
    "title": "EggTimer (3)",
    "url": "/posts/EggTimer-(3)/",
    "categories": "Udemy, EggTimer",
    "tags": "",
    "date": "2024-02-23 05:13:00 +0900",
    





    
    "snippet": "EggTimer에서 초가 줄어드는것을 보여주는, 즉 진행률을 보여주는 progress bar를 만들어 보자.Progressview를 통해 남은 시간을 Visualization할것이다.우선 progressview를 추가해주자.만약 이미 여러 view들을 만들어 둔 상태이고, 내가 원하는 view의 하위에 포함시키고 싶다면 그쪽으로 그냥 드래그 해주면 된...",
    "content": "EggTimer에서 초가 줄어드는것을 보여주는, 즉 진행률을 보여주는 progress bar를 만들어 보자.Progressview를 통해 남은 시간을 Visualization할것이다.우선 progressview를 추가해주자.만약 이미 여러 view들을 만들어 둔 상태이고, 내가 원하는 view의 하위에 포함시키고 싶다면 그쪽으로 그냥 드래그 해주면 된다.그리고 제약조건들을 설정해주자.그리고 잘보이게 bar type으로 바꿔주고제약조건에서 높이를 5로 올려주었다.그리고 잘보이게 색도 바꿔주었다.progress는 진행도를 알려주며 0~1까지 있다.버튼을 눌렀을때 progress bar가 1.0이 되도록 해보자.progressBar.progress = 1.0해당 코드만 추가해주면 된다!현재 코드는 버튼을 눌렀을때 어떤 모드가 선택이 되었는지를 보여주고 progressbar가 몇초가 지났는지를 보여주게끔 하였다.////  ViewController.swift//  EggTimer////  Created by Angela Yu on 08/07/2019.//  Copyright © 2019 The App Brewery. All rights reserved.//import UIKitclass ViewController: UIViewController {        let eggTimes = [\"Soft\" : 3, \"Medium\" : 4, \"Hard\" : 7]        var totalTime = 0    var secondsPassed = 0        @IBOutlet weak var progressBar: UIProgressView!        var timer = Timer()        @IBOutlet weak var titleLabel: UILabel!            @IBAction func hardnessSelected(_ sender: UIButton) {                                timer.invalidate()                let hardness = sender.currentTitle!        titleLabel.text = \"\\(hardness) selected!\"        totalTime = eggTimes[hardness]!                timer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(updateTimer), userInfo: nil, repeats: true)                progressBar.progress = 0.0        secondsPassed = 0            }        @objc func updateTimer() {        //example functionality        if secondsPassed &lt; totalTime {                        let percentageProgress : Float = Float(secondsPassed) / Float(totalTime)                        progressBar.progress = Float(percentageProgress)                                    secondsPassed += 1        } else {            timer.invalidate()            titleLabel.text = \"Done!\"            progressBar.progress = 1.0        }            }    }위와 같이 구현이 되었다.그렇다면 완료가 되었을때 소리가 나게끔 구현을 해보도록 하자. (challenge)      우선 완료가 되었을 때 이므로 그쪽에 소리를 재생하게 만드는 함수를 넣으면 될거같다.        Avplayer를 가져와야하므로stack flow에 있는 해당 코드를 차용했다.        그리고 버튼을 누를때마다 소리가 중단되었다가 재생이 되게끔 코드를 하나 더 추가했다.    player?.stop()      import AVFoundationvar player: AVAudioPlayer?func playSound() {    guard let path = Bundle.main.path(forResource: \"beep\", ofType:\"mp3\") else {        return }    let url = URL(fileURLWithPath: path)    do {        player = try AVAudioPlayer(contentsOf: url)        player?.play()            } catch let error {        print(error.localizedDescription)    }}else {            timer.invalidate()            titleLabel.text = \"Done!\"            progressBar.progress = 1.0        }여기 else문에 player가 돌아가게끔 하면 될것같아 보인다.참고자료.https://developer.apple.com/documentation/avfoundation/avplayer/https://stackoverflow.com/questions/32036146/how-to-play-a-sound-using-swift완성import UIKitimport AVFoundationclass ViewController: UIViewController {        let eggTimes = [\"Soft\" : 3, \"Medium\" : 4, \"Hard\" : 7]        var totalTime = 0    var secondsPassed = 0    var player : AVAudioPlayer?        @IBOutlet weak var progressBar: UIProgressView!        var timer = Timer()        @IBOutlet weak var titleLabel: UILabel!            @IBAction func hardnessSelected(_ sender: UIButton) {                                timer.invalidate()                let hardness = sender.currentTitle!        titleLabel.text = \"\\(hardness) selected!\"        totalTime = eggTimes[hardness]!                timer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(updateTimer), userInfo: nil, repeats: true)                progressBar.progress = 0.0        secondsPassed = 0        player?.stop()    }        func playSound() {        guard let path = Bundle.main.path(forResource: \"alarm_sound\", ofType:\"mp3\") else {            return }        let url = URL(fileURLWithPath: path)        do {            player = try AVAudioPlayer(contentsOf: url)            player?.play()                    } catch let error {            print(error.localizedDescription)        }    }        @objc func updateTimer() {        //example functionality        if secondsPassed &lt; totalTime {                        let percentageProgress : Float = Float(secondsPassed) / Float(totalTime)                        progressBar.progress = Float(percentageProgress)                                    secondsPassed += 1        } else {            timer.invalidate()            titleLabel.text = \"Done!\"            progressBar.progress = 1.0            playSound()        }            }    }강의에서의 코드////  ViewController.swift//  EggTimer////  Created by Angela Yu on 08/07/2019.//  Copyright © 2019 The App Brewery. All rights reserved.//import UIKitimport AVFoundationclass ViewController: UIViewController {        @IBOutlet weak var progressBar: UIProgressView!    @IBOutlet weak var titleLabel: UILabel!    let eggTimes = [\"Soft\": 3, \"Medium\": 4, \"Hard\": 7]    var timer = Timer()    var player: AVAudioPlayer!    var totalTime = 0    var secondsPassed = 0        @IBAction func hardnessSelected(_ sender: UIButton) {                timer.invalidate()        let hardness = sender.currentTitle!        totalTime = eggTimes[hardness]!        progressBar.progress = 0.0        secondsPassed = 0        titleLabel.text = hardness        timer = Timer.scheduledTimer(timeInterval: 1.0, target:self, selector: #selector(updateTimer), userInfo:nil, repeats: true)    }        @objc func updateTimer() {        if secondsPassed &lt; totalTime {            secondsPassed += 1            progressBar.progress = Float(secondsPassed) / Float(totalTime)            print(Float(secondsPassed) / Float(totalTime))        } else {            timer.invalidate()            titleLabel.text = \"DONE!\"                        let url = Bundle.main.url(forResource: \"alarm_sound\", withExtension: \"mp3\")            player = try! AVAudioPlayer(contentsOf: url!)            player.play()        }    }    }"
  },
  
  {
    "title": "EggTimer (2)",
    "url": "/posts/EggTimer-(2)/",
    "categories": "Udemy, EggTimer",
    "tags": "",
    "date": "2024-02-23 05:13:00 +0900",
    





    
    "snippet": "Challenge!위와 같이 버튼을 눌렀을때60부터 countdown하는 코드를 작성해보자!beforeimport UIKitclass ViewController: UIViewController {        let eggTimes = [\"Soft\" : 5, \"Medium\" : 7, \"Hard\" : 12]        //let softTime = 5...",
    "content": "Challenge!위와 같이 버튼을 눌렀을때60부터 countdown하는 코드를 작성해보자!beforeimport UIKitclass ViewController: UIViewController {        let eggTimes = [\"Soft\" : 5, \"Medium\" : 7, \"Hard\" : 12]        //let softTime = 5    //let mediumTime = 7    //let hardTime = 12        @IBAction func hardnessSelected(_ sender: UIButton) {               let hardness = sender.currentTitle!                print(eggTimes[hardness])                    //        switch hardness {//        case \"Soft\" : print(softTime)//        case \"Medium\" : print(mediumTime)//        case \"Hard\" : print(hardTime)//        default: print(\"none\")//        }                    }    }afterimport UIKitclass ViewController: UIViewController {        let eggTimes = [\"Soft\" : 5, \"Medium\" : 7, \"Hard\" : 12]        //let softTime = 5    //let mediumTime = 7    //let hardTime = 12        var counter = 60    override func viewDidLoad() {        super.viewDidLoad()        Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(updateCounter), userInfo: nil, repeats: true)    }        @IBAction func hardnessSelected(_ sender: UIButton) {               let hardness = sender.currentTitle!                print(eggTimes[hardness])                    //        switch hardness {//        case \"Soft\" : print(softTime)//        case \"Medium\" : print(mediumTime)//        case \"Hard\" : print(hardTime)//        default: print(\"none\")//        }                        }        @objc func updateCounter() {        //example functionality        if counter &gt; 0 {            print(\"\\(counter) seconds.\")            counter -= 1        }    }    }강의의 코드import UIKitclass ViewController: UIViewController {        let eggTimes = [\"Soft\" : 300, \"Medium\" : 420, \"Hard\" : 720]    var secondsRemaining = 60                @IBAction func hardnessSelected(_ sender: UIButton) {               let hardness = sender.currentTitle!                secondsRemaining = eggTimes[hardness]!                Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(updateTimer), userInfo: nil, repeats: true)        //print(eggTimes[hardness])                    //        switch hardness {//        case \"Soft\" : print(softTime)//        case \"Medium\" : print(mediumTime)//        case \"Hard\" : print(hardTime)//        default: print(\"none\")//        }                        }        @objc func updateTimer() {        //example functionality        if secondsRemaining &gt; 0 {            print(\"\\(secondsRemaining) seconds.\")            secondsRemaining -= 1        }    }    }구글링을 하여 코드를 작성하였다.굳이 viewdidload가 필요가 없었다.Timer의 매개변수는 총 5개가 있다.Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(updateTimer), userInfo: nil, repeats: true)      timeInterval : 타이머 실행 간격, Double Type        target : 함수 selector가 호출되어야 하는class instance, 보통 self        selector : 타이머가 실행될때 호출하는 함수 #selector(…) 형태        userInfo : selector에게 제공되는 데이터가 있는 dictionary, 없으면 nil        repeats: 타이머의 반복여부 Bool Type  #selector는 objective-C가 없으면 에러가 난다.현재 위와 같은 코드를 작성하게되면버튼을 여러개 누르면 타이머의 속도가 누른만큼 배로 빨라진다.그것을 방지하기위에 추가로 코드를 작성한다.import UIKitclass ViewController: UIViewController {        let eggTimes = [\"Soft\" : 3, \"Medium\" : 4, \"Hard\" : 7]    var secondsRemaining = 60    var timer = Timer()        @IBOutlet weak var titleLabel: UILabel!            @IBAction func hardnessSelected(_ sender: UIButton) {               timer.invalidate()                let hardness = sender.currentTitle!                secondsRemaining = eggTimes[hardness]!                timer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(updateTimer), userInfo: nil, repeats: true)                            }추가한건 timer라는 변수를 하나 생성하였고timer라는 변수에 ibaction에 있던 메서드를 넣었다.그리고 위에 timer.invalidate()를 추가 하였다.  반복되는 타이머를 중지시킨다.즉 중첩되는 타이머를 중단하는 의미로 생각하면 될것같다.—시간이끝나면 done!이 뜨게하는 코드를 추가해보자.@objc func updateTimer() {        //example functionality        if secondsRemaining &gt; 0 {            print(\"\\(secondsRemaining) seconds.\")            secondsRemaining -= 1        } else {            timer.invalidate()            titleLabel.text = \"Done!\"        }            }완성"
  },
  
  {
    "title": "EggTimer (1)",
    "url": "/posts/EggTimer-(1)/",
    "categories": "Udemy, EggTimer",
    "tags": "",
    "date": "2024-02-23 05:13:00 +0900",
    





    
    "snippet": "현재 이 화면에서 다른 Phone model로 바꾸게 되면현재의 문장이 … 으로 생략이 될 수있다.이럴땐 어떻게 해야할까?  Line의 개수를 0으로 해주는 방법이 있다.0이라고해서 줄이 없는게 아니라 무한대로 된다는 의미다.  자동으로 글꼴의 크기를 최소화 해준다.아래의 폰트 사이즈로15~30 까지의 폰트사이즈로 조절이 된다.option을 누르고 클...",
    "content": "현재 이 화면에서 다른 Phone model로 바꾸게 되면현재의 문장이 … 으로 생략이 될 수있다.이럴땐 어떻게 해야할까?  Line의 개수를 0으로 해주는 방법이 있다.0이라고해서 줄이 없는게 아니라 무한대로 된다는 의미다.  자동으로 글꼴의 크기를 최소화 해준다.아래의 폰트 사이즈로15~30 까지의 폰트사이즈로 조절이 된다.option을 누르고 클릭을 하면 해당 메서드의 정보를 볼 수있다."
  },
  
  {
    "title": "137. 제곱수 판별하기",
    "url": "/posts/137.-%EC%A0%9C%EA%B3%B1%EC%88%98-%ED%8C%90%EB%B3%84%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-23 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer : Int = 0        answer = Int(sqrt(Double(n))) * Int(sqrt(Double(n))) == n ? 1 : 2            return answer}일단 제곱수를 판별하기위해서 sqr...",
    "content": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer : Int = 0        answer = Int(sqrt(Double(n))) * Int(sqrt(Double(n))) == n ? 1 : 2            return answer}일단 제곱수를 판별하기위해서 sqrt라는 메서드를 이용했다.sqrt는 n라는 수에 루트를 씌운 값을 나타내며 Double Type을 return한다.그래서 sqrt안에는 double을 씌운 값이 들어가야한다.밖에 다시 Int를 씌운건 위에 적었듯이 소수점의 값을 리턴하는데, 여기서 필요한건 정수부의 값이라 Int로 리턴하였다.그래서 해당수를 다시 곱했을때 원래의 n값이 나오면 되므로 삼항연산자를 사용하여 결과값을 리턴하였다."
  },
  
  {
    "title": "136. n의 배수 고르기",
    "url": "/posts/136.-n%EC%9D%98-%EB%B0%B0%EC%88%98-%EA%B3%A0%EB%A5%B4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-23 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int, _ numlist:[Int]) -&gt; [Int] {        var arr : [Int] = []        arr = numlist.filter{$0%n == 0}            return arr}n의 배수만 걸러내는 문제였으므로 n으로 나눴을때 나머지가 0이면 ...",
    "content": "import Foundationfunc solution(_ n:Int, _ numlist:[Int]) -&gt; [Int] {        var arr : [Int] = []        arr = numlist.filter{$0%n == 0}            return arr}n의 배수만 걸러내는 문제였으므로 n으로 나눴을때 나머지가 0이면 되기에 filter를 걸어 해결하였다."
  },
  
  {
    "title": "Xylophone (2)",
    "url": "/posts/Xylophone-(2)/",
    "categories": "Udemy, Xylophone",
    "tags": "",
    "date": "2024-02-22 05:13:00 +0900",
    





    
    "snippet": "Xylophone에서 각 버튼을 눌렀을때 다음과같이흐려졌다가 다시 밝아지게 해보자.그리고 눌렀을때 Console에 start가 바로 출력이 되었다가. 0.2초 후에 End가 나오게 해보자.beforeimport UIKitimport AVFoundationclass ViewController: UIViewController {        var pla...",
    "content": "Xylophone에서 각 버튼을 눌렀을때 다음과같이흐려졌다가 다시 밝아지게 해보자.그리고 눌렀을때 Console에 start가 바로 출력이 되었다가. 0.2초 후에 End가 나오게 해보자.beforeimport UIKitimport AVFoundationclass ViewController: UIViewController {        var player: AVAudioPlayer!    override func viewDidLoad() {        super.viewDidLoad()    }    @IBAction func keyPressed(_ sender: UIButton) {                //print(sender.currentTitle)                playSound(soundName: sender.currentTitle!)    }        func playSound(soundName: String) {        let url = Bundle.main.url(forResource: soundName, withExtension: \"wav\")        player = try! AVAudioPlayer(contentsOf: url!)                player.play()                    }}afterimport UIKitimport AVFoundationclass ViewController: UIViewController {        var player: AVAudioPlayer!    override func viewDidLoad() {        super.viewDidLoad()    }    @IBAction func keyPressed(_ sender: UIButton) {                //print(sender.currentTitle)                playSound(soundName: sender.currentTitle!)        print(\"Start\")        sender.alpha = 0.5        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {            print(\"End\")            sender.alpha = 1.0         }    }        func playSound(soundName: String) {        let url = Bundle.main.url(forResource: soundName, withExtension: \"wav\")        player = try! AVAudioPlayer(contentsOf: url!)        player.play()                    }        }DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {            print(\"End\")            sender.alpha = 1.0         }위와 같은 코드를 썼다. 0.2초뒤에 end를 출력하고 투명도(alpha)를 1.0으로 원복하는것이다."
  },
  
  {
    "title": "Xylophone (1)",
    "url": "/posts/Xylophone-(1)/",
    "categories": "Udemy, Xylophone",
    "tags": "",
    "date": "2024-02-22 05:13:00 +0900",
    





    
    "snippet": "      UIbutton을 만들어준다. (control &amp; drag)        그리고 버튼을 눌렀을때 소리가 나는 코드를 작성해준다. (stackflow에 있다)```swiftimport UIKitimport AVFoundation  class ViewController: UIViewController {var player: AVAudio...",
    "content": "      UIbutton을 만들어준다. (control &amp; drag)        그리고 버튼을 눌렀을때 소리가 나는 코드를 작성해준다. (stackflow에 있다)```swiftimport UIKitimport AVFoundation  class ViewController: UIViewController {var player: AVAudioPlayer!override func viewDidLoad() {    super.viewDidLoad()}@IBAction func keyPressed(_ sender: UIButton) {    playSound()}func playSound() {    let url = Bundle.main.url(forResource: \"C\", withExtension: \"wav\")    player = try! AVAudioPlayer(contentsOf: url!)    player.play()            } }여러 버튼을 하나의 IBaction으로 이을 수 있다.![](https://velog.velcdn.com/images/haroldfromk/post/e7f445e3-8dda-4544-8be4-4f7c7bb6b4cc/image.png){: width=\"50%\" height=\"50%\"}![](https://velog.velcdn.com/images/haroldfromk/post/12281840-a385-4513-8a90-55df4f43cf23/image.png)print(sender....)를 통해![](https://velog.velcdn.com/images/haroldfromk/post/3da56299-26db-4b3e-8a68-028f8998bc09/image.png){: width=\"50%\" height=\"50%\"}버튼을 눌렀을때 어떤 값 각 버튼의 title을 확인 할 수있다.---그렇다면 현재 func playsound에 forResource가 C로 되어있어 어떤 버튼을 눌러도 C.wav의 file만 재생이된다.위의 sender.currentTitle을 이용하여, 각 버튼을 눌렀을때 그에 해당하는 음의 파일이 재생되도록 만들어 보자.---before```swiftimport UIKitimport AVFoundationclass ViewController: UIViewController {        var player: AVAudioPlayer!    override func viewDidLoad() {        super.viewDidLoad()    }    @IBAction func keyPressed(_ sender: UIButton) {                print(sender.currentTitle)                playSound()    }        func playSound() {        let url = Bundle.main.url(forResource: \"C\", withExtension: \"wav\")        player = try! AVAudioPlayer(contentsOf: url!)        player.play()                    }}after (내가작성한 코드)import UIKitimport AVFoundationclass ViewController: UIViewController {        var player: AVAudioPlayer!    override func viewDidLoad() {        super.viewDidLoad()    }    @IBAction func keyPressed(_ sender: UIButton) {                //print(sender.currentTitle)                playSound(sender)    }        func playSound(_ sender: UIButton) {        let url = Bundle.main.url(forResource: sender.currentTitle, withExtension: \"wav\")        player = try! AVAudioPlayer(contentsOf: url!)        player.play()                    }}after(강의에서의 코드)import UIKitimport AVFoundationclass ViewController: UIViewController {        var player: AVAudioPlayer!    override func viewDidLoad() {        super.viewDidLoad()    }    @IBAction func keyPressed(_ sender: UIButton) {                //print(sender.currentTitle)                playSound(soundName: sender.currentTitle!)    }        func playSound(soundName: String) {        let url = Bundle.main.url(forResource: soundName, withExtension: \"wav\")        player = try! AVAudioPlayer(contentsOf: url!)        player.play()                    }}"
  },
  
  {
    "title": "Auto Layout (challenge)",
    "url": "/posts/Auto-Layout-(challenge)/",
    "categories": "Udemy, Auto Layout",
    "tags": "",
    "date": "2024-02-21 05:13:00 +0900",
    





    
    "snippet": "다음과 같이 만들어 보자.우선 해당 Project를 clone하여 가져오니 다음과 같다.내가 해야할건 위의 portrait인상태에서 landscape일때 위와 같은 형태로 보여지게 하면 되는것같다.먼저 Landscape모드를 보았다.다음과같다.constraint(제약)을 해야할것같다.view구성을 보았다.우선 Container들을 만들어야할것같다.행개...",
    "content": "다음과 같이 만들어 보자.우선 해당 Project를 clone하여 가져오니 다음과 같다.내가 해야할건 위의 portrait인상태에서 landscape일때 위와 같은 형태로 보여지게 하면 되는것같다.먼저 Landscape모드를 보았다.다음과같다.constraint(제약)을 해야할것같다.view구성을 보았다.우선 Container들을 만들어야할것같다.행개념으로 총 6개의 Container들을 만들면 될것같다.하지만 이렇게하니 실패하였다….각 button이 있는곳을 stackview를 만들어준다.그다음 전체를 다시 stackview로 만든다.(이때 0이 있는 부분을 포함)그다음 현재 vertical stackview는 가장자리로 가야하므로 제약조건을 설정해준다.그다음 fill equally를 통해 높이가 고르게 되도록 설정해준다.그리고 그 하위 stackview역시 fill equally를 해줌으로써 가로도 똑같이 맞춰준다그렇게 했을경우 마지막에 문제가된다바로 이렇게 되는데이때 (. =) 부분을 또 stack view로 만들어준다.그리고나서 다시 fill equally를 해주면 정렬이 제대로 된다.얼추 다되어 간다.하지만 상단의 0이있는 부분이 오른쪽 끝자락으로 붙어있다.이것을 해결해주기위해 view를 새롭게 만들어준다.그리고 view를 투명하게 해주고0이있는 부분에 다음과 같이 제약조건을 해준다(지금 이미지는 이미 제약조건을 모두 설정해 둔 상태이다)완성!"
  },
  
  {
    "title": "Auto Layout (2)",
    "url": "/posts/Auto-Layout-(2)/",
    "categories": "Udemy, Auto Layout",
    "tags": "",
    "date": "2024-02-21 05:13:00 +0900",
    





    
    "snippet": "Auto Layout (1)에서 했던것을 바탕으로Main의 화면도 Rotate했을때 background, image, button들이 짤리지 않고 유지하게 만들어 보자.  backgroundup / down / left / right의 제약조건을 모두 활성화 해준다.하지만 이렇게 safe area가 있으므로 그부분도 조절을 해주자.Horizontal ...",
    "content": "Auto Layout (1)에서 했던것을 바탕으로Main의 화면도 Rotate했을때 background, image, button들이 짤리지 않고 유지하게 만들어 보자.  backgroundup / down / left / right의 제약조건을 모두 활성화 해준다.하지만 이렇게 safe area가 있으므로 그부분도 조절을 해주자.Horizontal stauts일때 superview로 설정하는 것이 아닌, vertical status일때 superview로 해주자!  images하려고 시도를 해보았으나 안되었다. 이것은 container를 이용해서 만들어야한다.아래와같이 3section으로 나누어 총 3개의 container를 만들고 진행한다.상단부터 시작하면 로고가있는 자리의 superview는 purple area가 된다.Container를 만들어보자.  UIview를 만들어 주면된다.uiview를 추가하니 이렇게 된다Dices의 Logo가 가려져있는걸 알 수 있다.Logo를 보이게 한번 적용해보자.(Auto layout(1)의 마지막에 로고가 가려진걸 보여지게 하는 법을 알아야겠다고 적었는데 바로 알게 되었다.)우리의 시선이 화살표방향으로 보는것이라고 생각하면 이해하기 쉽다.하지만 지금은 우리가 원하는 view의 하위개념은 아니다.다시 드래그 해주어 하위로 넣어보자이렇게 view안에 arrow가 새로 생기고 그안에 들어가면 하위로 들어가게 된다 (생각보다 드래그로 넣는게 잘 안되었다.)몇번해보니 옆으로 평행하게 두면 잘되는것같다.  Editor - embed in 으로 uiview넣어보기.uiview안에 두개의 dices image가 들어가기때문에 두개를 command 누른채로 클릭하여 두개를 모두 선택해주고상단의 Editor -&gt; Embed In -&gt; View를 클릭하여 만들어준다.아래와 같이 하위로 자동으로 들어간것을 볼 수 있다.  하단에 있는 interface로 view 추가하기.view를 추가하는 방법에 대해 알아 보았다.세가지 방법중 편한대로 하면 될것같다.하지만 아래와 같이 View가 3개가 추가되었고 정확하게 어떤것에 대한 view인지 하위에 뭐가 있는지 보지않는이상 모른다. labeling을 해보도록 하자위와 같이 해주면 된다.Labeling이 된걸 알 수 있다.드래그로 순서를 바꿔주어도 된다.다만 주의할건 드래그하다가 하위로 들어가지 않게 조심하자!드래그를 하여 정렬을 해주었다.arrow를 보면 모두 superview의 하위로 들어간걸 알수있다.이젠 상 중 하단의 view를 모두 추가해 주었다.그러면 다시 제약조건을 추가해보자.  Dices로고의 제약조건을 추가해보자.추가하자마자 에러가 발생하였다.우리가 설정한 Container(view)에도 제약조건이 필요하다는것이다.-&gt; Container의 크기나 위치를 지정하지 않았다.-&gt; subview / container안에 제약조건을 추가해도 애매모호하다.-&gt; 어떻게 배치를 해야할지 모르기 때문이다.StackView가 필요하다.  여러 view들을 stack해준다.  여기서는 3개의 view들을 세로로 stack한다.2가지 방법이 있다.(우선 stack view할 view들을 선택해준다 (command누르고 클릭), 여기선 3개를 선택해줄것이다.)      editor - embed in - stackview        아래의 interface에서 stackview  stackview가 생성이 되었다.stackview에 대한 제약조건을 설정해준다.이때 현재 top view의 범위가 safe area를 벗어낫기 때문에 arrow를 눌렀을때 보이지 않는다.stackview의 위치를 safe area에 걸치게 조절했다.이제는 제약조건에 보이는걸 확인할 수 있다.다음과 같이 stackview에 대한 제약조건을 설정하였다.그리고 stack view bottom을 바꿔준다.다음과 같이 바꿔주었다.safe area를 남겨두었다.현재 위의 사진과 같이 vertical status인 상태이다.즉 다음과 같다.그리고 Stackview에 있는 3개지 view가 현재는 높이가 제각각인데, 이걸 균등하게 맞춰준다.Distribution에서 Fill equally를 선택한다.각 Container들의 높이가 같아졌다.그리고 에러가 사라졌다.Roll 버튼을 이제는 제약조건을 이용해 정렬을 할수 있게 되었다.middle view에 있는 주사위들이 균등하게 정렬이 되도록 해보자.  우선 두 주사위에대한 stack view를 새로만든다.  제약조건을 설정해준다 (horizontal, vertical)—spacing을 통해 각 view들의 간격을 조절 할 수있다.현재 view의 background가 모두 white인걸 알 수있다.하지만 실제로 우리는 다른 background image가 있으므로 view들의 배경색을 투명으로 바꿔주자.Roll 버튼이 제약조건에 의해 Text Size에 맞게 조절이 되어있다.위와 같이 가로 세로를 설정 해줄 수 있다.바로 warning이 나온다.우리가 이렇게 임의로 설정하게되면 혹시라도 긴 text가 나오면 text 전부 보이지 않을 것이다.세모를 눌러보면 3가지 방법을 제시해준다.두번째걸로 선택하면서 warning을 clear하였다."
  },
  
  {
    "title": "Auto Layout (1)",
    "url": "/posts/Auto-Layout-(1)/",
    "categories": "Udemy, Auto Layout",
    "tags": "",
    "date": "2024-02-21 05:13:00 +0900",
    





    
    "snippet": "Auto Layout 에서는 폰을 Rotate했을때 어플 화면이 변경되게 하는것을 공부할 예정이다.현재는 이렇게 화면을 회전할 경우 지원이 되지않는 걸 볼 수 있다.이렇게 Launch Screen에서도 Rotate했을때 로고가 짤리는 걸 알 수 있다.Q:그러면 직접 사이즈를 조절하면 되는걸까?A:안된다. 아래 이미지를 보자.Constraints라는 제...",
    "content": "Auto Layout 에서는 폰을 Rotate했을때 어플 화면이 변경되게 하는것을 공부할 예정이다.현재는 이렇게 화면을 회전할 경우 지원이 되지않는 걸 볼 수 있다.이렇게 Launch Screen에서도 Rotate했을때 로고가 짤리는 걸 알 수 있다.Q:그러면 직접 사이즈를 조절하면 되는걸까?A:안된다. 아래 이미지를 보자.Constraints라는 제약조건을 통해 화면을 rotate해도 빈공간이 안생기게끔 해볼것이다.해당 부분을 클릭하면 다음과 같이 나온다.지금 위의 이미지는 전부 0이아니다. 그렇다는건background가 폰에 정확하게 맞춰져있지 않다는것이다.우측과 아래쪽이 딱 맞지않고 여유분이 있는걸 알 수있다.조절을 하면 아래와 같이 딱 0이된다.제약 조건을 추가 해보자.아래 박스가 제약조건을 추가하기전 (반투명 점선)위쪽 박스가 제약조건을 추가한뒤의 모습이다(실선)제약조건이 추가된걸 볼 수 있다.하지만 아직 회전을 하면 좌우로 공백이 있는걸 볼 수 있다.그리고 그라데이션 또한 그대로이다.즉 rotate할 때 이미지가 틀어지는게 아니라 그냥 좌우보정만 해주는걸 알 수 있다.Safe Area.trailing / leading은 참고 이미지를 찾아보면 이해하기 쉽다.보통은 배터리정보 or signal정보 같은걸 담기위한 공간이다.하지만 배경은 저렇게 빈공간을 남기지 않고 화면 전체를 덮어줘야 하기때문에 superview가 되어야 한다.즉 safe area가 설정되는걸 원치 않는다.superview는 viewcontroller 바로 밑에 있는 view로 모든걸 포함한다. -&gt; 항상 전체 화면을 커버한다.설정해둔 제약 조건중, 우리가 바꾸고자하는 제약조건을 클릭 한 뒤 우측의 second item에서 super view로 바꿔준다. (이미지상에선 가로인 상태로 super view로 설정하는걸로 보이지만 실제로는 세로인 상태에서 superview로 설정해 주었다.)trailing/leading의 second Item을 모두 super view로 바꾸면 아래와 같이 공백이 없어진걸 알 수있다.이렇게 확인을 해볼수도 있다.로고도 똑같이 해보자.로고는 배경화면과 달리 그 옆에 있는걸 클릭하고가로 세로 모두 해야하므로 제일 밑에있는 Horizontally/Verically 2개 모두 체크해주자로고에서 30픽셀 떨어진 상태로 제약조건 걸기label을 선택하고 제약조건 추가에서 위에서 30픽셀이므로 30픽셀인지 확인하고, 옆에 삼각형을 눌러 로고로 해주자.(왜 로고가 안보이는지 이유를 모르겠다…)"
  },
  
  {
    "title": "135. 7의 개수",
    "url": "/posts/135.-7%EC%9D%98-%EA%B0%9C%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-21 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ array:[Int]) -&gt; Int {        var arr : [String] = []    var answer : Int = 0        arr = array.map{String($0)}.joined().map{String($0)}        for i in arr.indi...",
    "content": "import Foundationfunc solution(_ array:[Int]) -&gt; Int {        var arr : [String] = []    var answer : Int = 0        arr = array.map{String($0)}.joined().map{String($0)}        for i in arr.indices {        if arr[i] == \"7\" {            answer += 1        }    }    return answer}7,77,17을 문자열로 합친뒤 다시 map을 하여 7,7,7,1,7 이렇게 분류하였고for문을 통해 7일때 1씩더했다.원래 하고싶었던것은 고차함수로 끝내고 싶었는데 그것까지는 못하였다.다른 코드를 보며 뭐가 부족한지 알았다.filter를 걸고 뒤에 .count만 했으면 끝날 문제였다….array.map{String($0)}.joined().map{String($0)}.filter{$0 == \"7\"}.count"
  },
  
  {
    "title": "134. 커피 심부름",
    "url": "/posts/134.-%EC%BB%A4%ED%94%BC-%EC%8B%AC%EB%B6%80%EB%A6%84/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-21 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ order:[String]) -&gt; Int {        var arr : [Int] = []    var answer : Int = 0        answer = order.map{$0.contains(\"cafelatte\") ? 5000 : 4500}.reduce(0,+)       ...",
    "content": "import Foundationfunc solution(_ order:[String]) -&gt; Int {        var arr : [Int] = []    var answer : Int = 0        answer = order.map{$0.contains(\"cafelatte\") ? 5000 : 4500}.reduce(0,+)        return answer}처음에는 따뜻한것 차가운것 그리고 라테, 아메리카노에 따라 가격이 다른줄 알고 switch case문을 사용하려고 했다.하지만 문제를 다시 읽어보니 음료의 온도와는 상관없이 라떼와 아메리카노 가격만 나와있고 아무거나는 아메리카노로 정의한다는것을알고, map을 사용하고 라떼를 기준으로 하였다.그래야 라떼가 아닌경우엔 모두 아메리카로노로 취급하기 때문이었다(Anything의 경우가 있으므로)그래서 cafelatte가 포함되어있는지를 물어보고 맞으면 5000, 아니면 4500을 리턴하게 하였고 reduce를 통해 한번에 더한값을 리턴하였다."
  },
  
  {
    "title": "Magic 8 Balls 만들어보기",
    "url": "/posts/Try-Magic-8-Balls/",
    "categories": "Udemy, Dices",
    "tags": "",
    "date": "2024-02-20 05:13:00 +0900",
    





    
    "snippet": "      아래와같이 디자인을 한다        imageview와, button을 viewcontroller와 연결 시켜준다.        버튼을 눌렀을때 이미지가 변환이되게 코드를 짠다.```swiftimport UIKit  class ViewController: UIViewController {@IBOutlet weak var imageView:...",
    "content": "      아래와같이 디자인을 한다        imageview와, button을 viewcontroller와 연결 시켜준다.        버튼을 눌렀을때 이미지가 변환이되게 코드를 짠다.```swiftimport UIKit  class ViewController: UIViewController {@IBOutlet weak var imageView: UIImageView!let ballArray = [#imageLiteral(resourceName: \"ball1.png\"),#imageLiteral(resourceName: \"ball2.png\"),#imageLiteral(resourceName: \"ball3.png\"),#imageLiteral(resourceName: \"ball4.png\"),#imageLiteral(resourceName: \"ball5.png\")]@IBAction func askButtonPressed(_ sender: UIButton) {    imageView.image = ballArray.randomElement()}}```  작동확인!"
  },
  
  {
    "title": "Dices (3)",
    "url": "/posts/Dices-(3)/",
    "categories": "Udemy, Dices",
    "tags": "",
    "date": "2024-02-20 05:13:00 +0900",
    





    
    "snippet": "IBAction 생성하기.버튼을 눌렀을때 작동하게하는 Action을 할때는중괄호 사이의 저 부분에 둔다.IB outlet처럼 Control을 누르고 드래그 하면 된다.보통은 버튼을 드래그하면 작동을 하는 의미이므로 Action이 바로 되어있다.그리고 버튼이므로 type을 Uibutton으로 바꿔준다.아래 사진으로 대강 어떻게 돌아가는지 이해하면 좋을 ...",
    "content": "IBAction 생성하기.버튼을 눌렀을때 작동하게하는 Action을 할때는중괄호 사이의 저 부분에 둔다.IB outlet처럼 Control을 누르고 드래그 하면 된다.보통은 버튼을 드래그하면 작동을 하는 의미이므로 Action이 바로 되어있다.그리고 버튼이므로 type을 Uibutton으로 바꿔준다.아래 사진으로 대강 어떻게 돌아가는지 이해하면 좋을 것 같다.버튼을 눌렀을때 주사위의 이미지를 변경해보자import UIKitclass ViewController: UIViewController {    @IBOutlet weak var diceImageView1: UIImageView!    @IBOutlet weak var diceImageView2: UIImageView!            override func viewDidLoad() {        super.viewDidLoad()                //diceImageView1.alpha = 0.5        diceImageView1.image = #imageLiteral(resourceName: \"DiceSix\")                diceImageView2.image = #imageLiteral(resourceName: \"DiceTwo\")    }        @IBAction func rollButtonPressed(_ sender: UIButton) {        diceImageView1.image = #imageLiteral(resourceName: \"DiceFour\")        diceImageView2.image = #imageLiteral(resourceName: \"DiceFour\")    }    }문자열에 코드를 넣을때 () 을 사용print(\"The result of 3 + 5 = \\(3 + 5)\")// The result of 3 + 5 = 8이런식으로 print를 사용하면서 매개변수의 변화를 보면 어디가 문제가 있는지 진단을 할 수 있다.왼쪽 주사위는 올라가고 오른쪽 주사위는 내려가는 코드를 만들어 보자.import UIKitclass ViewController: UIViewController {    @IBOutlet weak var diceImageView1: UIImageView!    @IBOutlet weak var diceImageView2: UIImageView!        var leftDiceNumber = 0    var rightDiceNumber = 5        override func viewDidLoad() {        super.viewDidLoad()                //diceImageView1.alpha = 0.5        //diceImageView1.image = #imageLiteral(resourceName: \"DiceSix\")                //diceImageView2.image = #imageLiteral(resourceName: \"DiceTwo\")    }        @IBAction func rollButtonPressed(_ sender: UIButton) {                //leftDiceNumber = 1        print(\"leftDicenumber at beginning = \\(leftDiceNumber)\")        print(\"rightDicenumber at beginning = \\(rightDiceNumber)\")                diceImageView1.image = [ #imageLiteral(resourceName: \"DiceOne\"), #imageLiteral(resourceName: \"DiceTwo\"), #imageLiteral(resourceName: \"DiceThree\"), #imageLiteral(resourceName: \"DiceFour\"), #imageLiteral(resourceName: \"DiceFive\"), #imageLiteral(resourceName: \"DiceSix\") ][leftDiceNumber]        diceImageView2.image = [ #imageLiteral(resourceName: \"DiceOne\"), #imageLiteral(resourceName: \"DiceTwo\"), #imageLiteral(resourceName: \"DiceThree\"), #imageLiteral(resourceName: \"DiceFour\"), #imageLiteral(resourceName: \"DiceFive\"), #imageLiteral(resourceName: \"DiceSix\") ][rightDiceNumber]        leftDiceNumber = leftDiceNumber + 1        rightDiceNumber = rightDiceNumber - 1                //leftDiceNumber = 2        print(\"leftDicenumber at the end = \\(leftDiceNumber)\")        print(\"rightDicenumber at the end = \\(rightDiceNumber)\")            }    }현재 프로젝트에서는 view가 로드되고나서 코드가 필요하지 않기에 viwedidload쪽은 삭제해준다.난수를 넣어 버튼을 눌렀을때 임의의 주사위가 계속 나오게 하기import UIKitclass ViewController: UIViewController {    @IBOutlet weak var diceImageView1: UIImageView!    @IBOutlet weak var diceImageView2: UIImageView!    //    var leftDiceNumber = 0//    var rightDiceNumber = 5                @IBAction func rollButtonPressed(_ sender: UIButton) {                var diceArray = [ #imageLiteral(resourceName: \"DiceOne\"), #imageLiteral(resourceName: \"DiceTwo\"), #imageLiteral(resourceName: \"DiceThree\"), #imageLiteral(resourceName: \"DiceFour\"), #imageLiteral(resourceName: \"DiceFive\"), #imageLiteral(resourceName: \"DiceSix\") ]                diceImageView1.image = [ #imageLiteral(resourceName: \"DiceOne\"), #imageLiteral(resourceName: \"DiceTwo\"), #imageLiteral(resourceName: \"DiceThree\"), #imageLiteral(resourceName: \"DiceFour\"), #imageLiteral(resourceName: \"DiceFive\"), #imageLiteral(resourceName: \"DiceSix\") ][Int.random(in: 0...5)]        diceImageView2.image = [ #imageLiteral(resourceName: \"DiceOne\"), #imageLiteral(resourceName: \"DiceTwo\"), #imageLiteral(resourceName: \"DiceThree\"), #imageLiteral(resourceName: \"DiceFour\"), #imageLiteral(resourceName: \"DiceFive\"), #imageLiteral(resourceName: \"DiceSix\") ][Int.random(in: 0...5)]        //        leftDiceNumber += 1//        rightDiceNumber -= 1//                // 난수(random) 생성        //print(Int.random(in: 1...10)) // 1~10 까지의 난수            }    }// 난수는 아래와 같이 표현도 가능하다.diceImageView1.image = diceArray.randomElement()diceImageView2.image = diceArray.randomElement()        난수표현Int.random(in: lower … upper)소수점에대한 난수를 표현하려면 Int대신 Float나 Double을 사용하자float.random(in: lower … upper)배열에서는 임의의 인덱스를 접근하려면Array.randomElement()를 사용한다.Array.shuffle()은 배열 순서를 바꿔버린다.랜덤과는 다르다."
  },
  
  {
    "title": "Dices (2)",
    "url": "/posts/Dices-(2)/",
    "categories": "Udemy, Dices",
    "tags": "",
    "date": "2024-02-20 05:13:00 +0900",
    





    
    "snippet": "viewController는 코드 파일이자 메인이고Main은 디자인 파일이다.이전에도 서술했지만 option누르고 클릭을 하면 새로운 layout이 하나 더 생긴다아래와같이 누르면 좀 더 보기편하게 할 수 있다.IB outlet, Interface outlet만들기Control을 누르고 드래그해준다.그리고 이름을 설정해주면 다음과 같이 코드가 생긴다....",
    "content": "viewController는 코드 파일이자 메인이고Main은 디자인 파일이다.이전에도 서술했지만 option누르고 클릭을 하면 새로운 layout이 하나 더 생긴다아래와같이 누르면 좀 더 보기편하게 할 수 있다.IB outlet, Interface outlet만들기Control을 누르고 드래그해준다.그리고 이름을 설정해주면 다음과 같이 코드가 생긴다.이제 유져인터페이스 요소에 접근을 할 수 있게 되었다.보통 네이밍을 할때는 CamelCase방식을 사용한다.이름을 지정하고 내가 임의로 이름을 바꾸게 되면에러가 발생한다.왜냐하면 이미 diceImageView1으로 설정이 되어있기 때문이다.이럴때는 연결을 끊어주면 해결이 된다.연결을 끊을때는 우클릭을 하고 x를 하면 된다.그리고 다시 링크 시킬때는 main쪽에 있는 코드에 보면 원이 있는데 그걸로 이어주면 된다.만약 이름을 변경해주고 싶다면 main에서 우클릭을해주어 변경을 한다.코드를 작성하는 방식은Who.What = Value로 한다.누가 바뀌는지? (Who)누구에서의 무엇이 바뀌어야 하는지? (What)무엇으로 변경되어야 하는지? (Value)이렇게 아래에 간단하게 설명도 나오니 잘 봐두자.현재 imageLiteral은 강의와는 다르기에 새로운 방식을 적어둔다diceImageView1 = #imageLiteral() // OdiceImageView1 = imageLiteral // X그러면 아래와 같이 된다.그러면 실행전에는 첫번재 주사위가 1개이지만 실행 후에는 6개로 바뀌어있는걸 알 수 있다.첫번째 주사위가 있는 alpha(투명도)를 0.5로 code를 이용하여 바꿔보자.import UIKitclass ViewController: UIViewController {    @IBOutlet weak var diceImageView1: UIImageView!        override func viewDidLoad() {        super.viewDidLoad()                diceImageView1.alpha = 0.5 // 해당 구문을 추가해주면된다.        diceImageView1.image = #imageLiteral(resourceName: \"DiceSix\")    }}두번째 주사위도 IB outlet으로 연결해주고 실행시킬때 주사위가 두개가 나오게 해보자.////  ViewController.swift//  Dicee-iOS13////  Created by Angela Yu on 11/06/2019.//  Copyright © 2019 London App Brewery. All rights reserved.//import UIKitclass ViewController: UIViewController {    @IBOutlet weak var diceImageView1: UIImageView!        @IBOutlet weak var diceImageView2: UIImageView!    override func viewDidLoad() {        super.viewDidLoad()                // Who         What   Value        diceImageView1.alpha = 0.5        diceImageView1.image = #imageLiteral(resourceName: \"DiceSix\")                diceImageView2.image = #imageLiteral(resourceName: \"DiceTwo\")    }}"
  },
  
  {
    "title": "Dices (1)",
    "url": "/posts/Dices-(1)/",
    "categories": "Udemy, Dices",
    "tags": "",
    "date": "2024-02-20 05:13:00 +0900",
    





    
    "snippet": "Git에서 가져오기(Clone).관련file이 있는 곳으로 들어가서우측의 code를 누른다.그다음 링크를 복사한다.그리고는 두번째 clone git repository를 클릭복사한 링크를 붙여넣기한다.그리고 clone을 클릭한후 원하는 위치를 설정해주면 끝.Launch Screen은 보통 어플을 켤때 잠깐 보여주는 화면이다.보통 회사이름, 로고 등등 ...",
    "content": "Git에서 가져오기(Clone).관련file이 있는 곳으로 들어가서우측의 code를 누른다.그다음 링크를 복사한다.그리고는 두번째 clone git repository를 클릭복사한 링크를 붙여넣기한다.그리고 clone을 클릭한후 원하는 위치를 설정해주면 끝.Launch Screen은 보통 어플을 켤때 잠깐 보여주는 화면이다.보통 회사이름, 로고 등등 간단하게 보여주는 용도로 사용한다.https://github.com/dkhamsing/open-source-ios-apps 여기에 도움이 될만한 프로젝트들이 많으니 참고하자.화면전체를 배경사진으로 덮기 위해 imageview로 메인화면 전체를 지정해준다.그리고 asset에 이미지가 있다면, image를 선택해준다.하지만 이때 이미지가 화면 전체를 채워주지 않는데 이때 아래와 같이 해준다. (이중 필요한건 선택해주자)보통 사용하는 옵션은 아래와 같다image의 사이즈는 여기서 수정을 한다.똑같은걸 복사할때는 option키를 누르고 드래그하면된다."
  },
  
  {
    "title": "I Am Poor 만들어보기",
    "url": "/posts/Try-I-Am-Poor/",
    "categories": "Udemy, I Am Rich",
    "tags": "",
    "date": "2024-02-19 05:13:00 +0900",
    





    
    "snippet": "I Am Poor Project를 만들어보자!프로젝트 생성은 pass!      Label을 추가하고 I Am Poor 이라고 입력해보자.        Label -&gt; I Am Poor로 변경.    그다음 색상과, 폰트크기를 변경.  ImageView를 추가하자  ImageView에 Image를 넣어보자.이미지를 찾아 추가해준다 (appicon...",
    "content": "I Am Poor Project를 만들어보자!프로젝트 생성은 pass!      Label을 추가하고 I Am Poor 이라고 입력해보자.        Label -&gt; I Am Poor로 변경.    그다음 색상과, 폰트크기를 변경.  ImageView를 추가하자  ImageView에 Image를 넣어보자.이미지를 찾아 추가해준다 (appicon 사이트에서 2,3배 이미지 추가하여 넣어보자)  Appicon 추가하기.(이미지는 가져왔다고 치고)폴더를 그대로 옮기기.      작동해보기command + R을 눌러 작동시켜보기.        확인완료  "
  },
  
  {
    "title": "I Am Rich (3)",
    "url": "/posts/I-Am-Rich-(3)/",
    "categories": "Udemy, I Am Rich",
    "tags": "",
    "date": "2024-02-19 05:13:00 +0900",
    





    
    "snippet": "Simulation을 할 iPhone Model 선택하기.상단에 iphone15pro로 되어있는데 해당 부분을 클릭하면 이렇게 내가 원하는 폰의 모델을 설정할 수 있다.실행할때는 상단의 화살표 버튼을 누르면 시뮬레이터가 실행이 된다.실행하면 다음과 같이 뜬다.실제 내가 가지고있는 iphone에 연동시켜보기.      Xcode와 iOS버전이 매치하는지...",
    "content": "Simulation을 할 iPhone Model 선택하기.상단에 iphone15pro로 되어있는데 해당 부분을 클릭하면 이렇게 내가 원하는 폰의 모델을 설정할 수 있다.실행할때는 상단의 화살표 버튼을 누르면 시뮬레이터가 실행이 된다.실행하면 다음과 같이 뜬다.실제 내가 가지고있는 iphone에 연동시켜보기.      Xcode와 iOS버전이 매치하는지 확인한다.소수점 첫번째 자리가 일치하는지 확인한다.15.2(Xcode) / 17.2(iOS)        애플개발자 계정을 등록한다.        어플에 서명을 한다.Automatically manage signing에 체크가 되어있는지 확인 을 한 뒤에  위와 같이 team을 클릭하여 본인의 팀을 체크한다.이때 Team이 뜨지 않는다면 개발자 계정이 등록이 안된것이다.      실제 기기를 연결한다.        연결한 뒤에 기기를 신뢰하기를 한다.        실제 핸드폰에 어플을 실행해본다.  실행 모습.이때 내가 Xcode에 디자인한것과 실제로 핸드폰에 띄웠을때 비율이 다를수도 있다.아까는 위 쪽을 클릭하여 시뮬레이션할 모델을 선택했다면, 이번에는 아래쪽에 있는 모델을 선택한 뒤 가로 세로 비율을 조절하여 다시 빌드하면 정상적으로 출력이 된다.조절 한 뒤의 실행 모습. (위의 실행모습과 조금 달라진것을 알 수 있다)물론 Cable 없이 무선으로도 연결하여 빌드 할 수있다.여기를 들어간 뒤에connect via network가 체크되어있는지 확인한다.하지만 테스트할때는 유선연결을 통한 테스트를 권장한다."
  },
  
  {
    "title": "I Am Rich (2)",
    "url": "/posts/I-Am-Rich-(2)/",
    "categories": "Udemy, I Am Rich",
    "tags": "",
    "date": "2024-02-19 05:13:00 +0900",
    





    
    "snippet": "asset에 이미지 추가필요한 이미지를 asset에 추가할때는 위와 같이 그냥 드래그를 하면 된다.이미지의 크기를 나타낸다 (2x : 2배, 3x : 3배)sketch나 illustrator를 통해 2x 또는 3x의 이미지를 만들 수 있다.      만약 해당 앱을 쓸수없는 환경이라면?          https://www.appicon.co/    ...",
    "content": "asset에 이미지 추가필요한 이미지를 asset에 추가할때는 위와 같이 그냥 드래그를 하면 된다.이미지의 크기를 나타낸다 (2x : 2배, 3x : 3배)sketch나 illustrator를 통해 2x 또는 3x의 이미지를 만들 수 있다.      만약 해당 앱을 쓸수없는 환경이라면?          https://www.appicon.co/      위의 사이트를 들어가서 만들면 된다.      추출한 이미지는2배 3배 따로 옮길 필요없이한번에 옮겨도 된다.추가한 이미지를 ImageView에 넣을땐 아래와 같이 해주면 된다.이미 Asset에 저장했기때문에 Image부분을 클릭했을때 Diamond이미지가 등록이 되어있다.앱 아이콘 등록Asset -&gt; AppIcon에 여러 이미지를 Drag &amp; Drop하면 이미지가 자동으로 Sorting이 되면서 등록이된다.간단한 아이콘 만들기.http://www.canva.com 에 들어가서 맞춤형 크기를 통해 원하는 사이즈를 지정하여 간단하게 만들 수 있다.간단하게 이미지를 만든 후에 업로드를 하고 압축을 풀면다음과 같다.이때 우리가 쓰는건 Assets.xcassets에 있는 Appicon.appiconset이다.Xcode에서 appicon을 우클릭하면 다음과 같이 나온다.여기서 Show in Finder를 해주면그리고 같은 이름의 폴더를 덮어 씌우기 해주면 바뀌게 된다이때 경고 문구가뜨는데 대치를 해주면 된다.이미지가 모든 어플에 설정에 맞게 다 들어가있는걸 알 수있다. 하지만 !표로 경고표시가 뜨는데. 제일 마지막에 있는 ! 가 있는 사진을 지우면 해결된다.delete키를 눌러 지워주었다."
  },
  
  {
    "title": "132. 특별한 이차원 배열 1",
    "url": "/posts/132.-%ED%8A%B9%EB%B3%84%ED%95%9C-%EC%9D%B4%EC%B0%A8%EC%9B%90-%EB%B0%B0%EC%97%B4-1/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-19 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int) -&gt; [[Int]] {        var arr : [[Int]] = []        arr = Array(repeating: Array(repeating:0,count:n), count:n)        for i in 0..&lt;n {        for j in 0...",
    "content": "import Foundationfunc solution(_ n:Int) -&gt; [[Int]] {        var arr : [[Int]] = []        arr = Array(repeating: Array(repeating:0,count:n), count:n)        for i in 0..&lt;n {        for j in 0..&lt;n {            if i == j {                arr[i][j] = 1            }        }    }     return arr}repeating을 이용하여 n * n 의 배열을 생성하였다.그 이후 행과 열의 index가 같은 값에 대해서 1의 값으로 바꿔주었다.다른코드import Foundationfunc solution(_ n:Int) -&gt; [[Int]] {    return (1...n).map {         var arr = Array(repeating: 0, count: n)        arr[$0 - 1] = 1        return arr    }}//import Foundationfunc solution(_ n:Int) -&gt; [[Int]] {    var arr = [[Int]](repeating: [Int](repeating: 0, count: n), count: n)    (0..&lt;n).forEach { arr[$0][$0] = 1 }    return arr}//import Foundationfunc solution(_ n:Int) -&gt; [[Int]] {    return (0..&lt;n).map { i in (0..&lt;n).map { j in i==j ? 1 : 0 } }}"
  },
  
  {
    "title": "133. 날짜 비교하기",
    "url": "/posts/133.-%EB%82%A0%EC%A7%9C-%EB%B9%84%EA%B5%90%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-19 00:00:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ date1:[Int], _ date2:[Int]) -&gt; Int {        var answer : Int = 0    var d1 = Int(date1.map{String($0)}.joined())!    var d2 = Int(date2.map{String($0)}.joined())...",
    "content": "import Foundationfunc solution(_ date1:[Int], _ date2:[Int]) -&gt; Int {        var answer : Int = 0    var d1 = Int(date1.map{String($0)}.joined())!    var d2 = Int(date2.map{String($0)}.joined())!        answer = d1 == d2 ? 0 : (d1 &lt; d2 ? 1 : 0)    return answer}날짜비교라고 되어있어서 배열안에 있는 원소들을 joined를 이용하여 하나로 묶으면서 하나의 문자열로 만들었고, 그것을 Int로 형변환 해주었다.다만 값이 없을 수도 있기에 !를 사용하여 unwrapping 해주었다.!를 붙이지 않으면 에러가 발생하기 때문이다.그 이후 삼항 연산자를 이용하여 결과 값을 리턴하였다."
  },
  
  {
    "title": "131. 문자열 정수의 합",
    "url": "/posts/131.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%A0%95%EC%88%98%EC%9D%98-%ED%95%A9/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_str:String) -&gt; Int {        var answer : Int = 0        answer = num_str.map{Int(String($0))!}.reduce(0,+)    return answer}처음에 Type 에러가 나서 $0을 Int로 감싸주면 되는줄...",
    "content": "import Foundationfunc solution(_ num_str:String) -&gt; Int {        var answer : Int = 0        answer = num_str.map{Int(String($0))!}.reduce(0,+)    return answer}처음에 Type 에러가 나서 $0을 Int로 감싸주면 되는줄 알았다.알고보니 문자열이 하나씩 배열에 들어가면서 Character type이 되었기때문에바로 Int형으로 형변환이 안되는것이었다.그래서 Character -&gt; String -&gt; Int 로 형변환을 해주었다.그랬을때 Optional의 가능성이 있기에, Unwrapping을 해주면서 결과값을 리턴하였다."
  },
  
  {
    "title": "130. 주사위 게임 1",
    "url": "/posts/130.-%EC%A3%BC%EC%82%AC%EC%9C%84-%EA%B2%8C%EC%9E%84-1/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ a:Int, _ b:Int) -&gt; Int {        var answer : Int = 0        answer = a*b % 2 != 0 ? a*a + b*b : (a%2 == 0 &amp;&amp; b%2 == 0) ? abs(a-b) : 2*(a+b)              ...",
    "content": "import Foundationfunc solution(_ a:Int, _ b:Int) -&gt; Int {        var answer : Int = 0        answer = a*b % 2 != 0 ? a*a + b*b : (a%2 == 0 &amp;&amp; b%2 == 0) ? abs(a-b) : 2*(a+b)                                                                          return answer}삼항연산자를 이용하여 문제를 풀려고하였다.모두 홀수가 아닐때 즉 둘다 짝수일때 절대값을 표현해야하는데 abs()를 사용하여 절대값을 표현하였다."
  },
  
  {
    "title": "129. 꼬리 문자열",
    "url": "/posts/129.-%EA%BC%AC%EB%A6%AC-%EB%AC%B8%EC%9E%90%EC%97%B4/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ str_list:[String], _ ex:String) -&gt; String {        var answer : String = \"\"        answer = str_list.map{$0.contains(ex) ? \"\" : $0}.joined()        return answer...",
    "content": "import Foundationfunc solution(_ str_list:[String], _ ex:String) -&gt; String {        var answer : String = \"\"        answer = str_list.map{$0.contains(ex) ? \"\" : $0}.joined()        return answer}map안에 삼항문자열을 사용해 조건을 걸어서 ex의 단어를 포함할때는 ““로 아닐경우엔 $0으로 리턴하였다.제출해야하는 데이텨형이 String이므로 joined를 통해 문자열로 바꿔주었다."
  },
  
  {
    "title": "128. 공백으로 구분하기 2",
    "url": "/posts/128.-%EA%B3%B5%EB%B0%B1%EC%9C%BC%EB%A1%9C-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0-2/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String) -&gt; [String] {        var answer : [String] = []        answer = my_string.split(separator : \" \").map{String($0)}    return answer}105와 같은 문제인데 ...",
    "content": "import Foundationfunc solution(_ my_string:String) -&gt; [String] {        var answer : [String] = []        answer = my_string.split(separator : \" \").map{String($0)}    return answer}105와 같은 문제인데 왜 또있는지 모르겠다. 다만 이번에도 map을 빠뜨렸다. 주의하자"
  },
  
  {
    "title": "127. 배열의 길이에 따라 다른 연산하기 (fin)",
    "url": "/posts/127.-%EB%B0%B0%EC%97%B4%EC%9D%98-%EA%B8%B8%EC%9D%B4%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%8B%A4%EB%A5%B8-%EC%97%B0%EC%82%B0%ED%95%98%EA%B8%B0-(fin)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류했던문제",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ arr:[Int], _ n:Int) -&gt; [Int] {        var answer : [Int] = []        answer = arr.count % 2 != 0 ? arr.enumerated().map{$0.0%2 != 0 ? $0.1 : $0.1 + n} : arr.enum...",
    "content": "import Foundationfunc solution(_ arr:[Int], _ n:Int) -&gt; [Int] {        var answer : [Int] = []        answer = arr.count % 2 != 0 ? arr.enumerated().map{$0.0%2 != 0 ? $0.1 : $0.1 + n} : arr.enumerated().map{$0.0%2 == 0 ? $0.1 : $0.1 + n}        return answer}막혔던 이유. map을 사용해야할 것은 알았지만, map에서 어떻게 인덱스를 해야할지 생각이 나지 않았다.그래서 검색을 해볼 수 밖에 없었고 전에 정리했던 enumerated()를 사용해야한다라는걸 알았다.enumerated()를 보자마자 어떻게 해야하는지 알게 되었고 바로 해결을 하게 되었다.생각보다 쉬운문제였는데, 내 지식이 너무 짧았다."
  },
  
  {
    "title": "126. 배열의 원소 삭제하기 (ing)",
    "url": "/posts/126.-%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%9B%90%EC%86%8C-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "125. 부분 문자열인지 확인하기",
    "url": "/posts/125.-%EB%B6%80%EB%B6%84-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%B8%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String, _ target:String) -&gt; Int {        var answer : Int = 0        answer = my_string.contains(target) ? 1:0        return answer}123번과 같은 문제이다.",
    "content": "import Foundationfunc solution(_ my_string:String, _ target:String) -&gt; Int {        var answer : Int = 0        answer = my_string.contains(target) ? 1:0        return answer}123번과 같은 문제이다."
  },
  
  {
    "title": "124. 뒤에서 5등 위로",
    "url": "/posts/124.-%EB%92%A4%EC%97%90%EC%84%9C-5%EB%93%B1-%EC%9C%84%EB%A1%9C/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {        var answer : [Int] = []        answer = Array(num_list.sorted()[5...])        return answer}이전 문제 122번과 거의 같은 문제이다.범위만 다른 조건이기에...",
    "content": "import Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {        var answer : [Int] = []        answer = Array(num_list.sorted()[5...])        return answer}이전 문제 122번과 거의 같은 문제이다.범위만 다른 조건이기에 범위만 바꿔서 결과값을 리턴하였다."
  },
  
  {
    "title": "123. 부분 문자열",
    "url": "/posts/123.-%EB%B6%80%EB%B6%84-%EB%AC%B8%EC%9E%90%EC%97%B4/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ str1:String, _ str2:String) -&gt; Int {        var answer : Int = 0        answer = str2.contains(str1) ? 1 : 0        return answer}배열과 같이 문자열 또한 해당문자열이 포함하는지를 묻는 ...",
    "content": "import Foundationfunc solution(_ str1:String, _ str2:String) -&gt; Int {        var answer : Int = 0        answer = str2.contains(str1) ? 1 : 0        return answer}배열과 같이 문자열 또한 해당문자열이 포함하는지를 묻는 contains를 사용하였고삼항연산자를 통해 결과값을 리턴하였다."
  },
  
  {
    "title": "122. 뒤에서 5등까지",
    "url": "/posts/122.-%EB%92%A4%EC%97%90%EC%84%9C-5%EB%93%B1%EA%B9%8C%EC%A7%80/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {    var answer : [Int] = []    answer = Array(num_list.sorted()[0...4])    return answer}배열의 인덱스로 하려고해서 [0…4]로 하여 Array로 감싸주었다.sorted까지...",
    "content": "import Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {    var answer : [Int] = []    answer = Array(num_list.sorted()[0...4])    return answer}배열의 인덱스로 하려고해서 [0…4]로 하여 Array로 감싸주었다.sorted까지하고나서 해당 범위의 인덱스로 추출하는것을 까먹어서 내가 풀었떤 문제를 기반으로 검색해서 풀었다..잊지않게 잘 기억해둬야할것 같다.다른 코드들을 보니 색다르게 표현한 것도 몇개 있어서 아래 적어본다다른코드import Foundationfunc solution(_ a:[Int]) -&gt; [Int] {    a.sorted()[0..&lt;5].map{Int($0)}}//import Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {    return Array(num_list.sorted()[..&lt;5])}//import Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {    return (0..&lt;5).map { num_list.sorted()[$0] }}//func solution(_ numList: [Int]) -&gt; [Int] {    return Array(numList.sorted().prefix(5))}"
  },
  
  {
    "title": "121. 조건에 맞게 수열 변환하기 3",
    "url": "/posts/121.-%EC%A1%B0%EA%B1%B4%EC%97%90-%EB%A7%9E%EA%B2%8C-%EC%88%98%EC%97%B4-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0-3/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ arr:[Int], _ k:Int) -&gt; [Int] {        var answer : [Int] = []        answer = k%2 == 0 ? arr.map{$0 + k} : arr.map{$0 * k}        return answer}삼항연산자를 통해 간략하게 표현...",
    "content": "import Foundationfunc solution(_ arr:[Int], _ k:Int) -&gt; [Int] {        var answer : [Int] = []        answer = k%2 == 0 ? arr.map{$0 + k} : arr.map{$0 * k}        return answer}삼항연산자를 통해 간략하게 표현하고자 하였고, 해당 조건이 짝수 홀수에 따라서 배열의 값에 변화를 주어야 하기에for 문 대신 map 을 사용하여 간단하게 표현 하였다.이전에는 for 문을 써서 하나하나 변환하고자 하였을 텐데, 확실히 많이 풀다보니 간단하게 어떻게 해야하는 조금씩 감이 오는듯 하다.하지만 아직 갈길은 멀어보인다"
  },
  
  {
    "title": "120. 문자열을 정수로 변환하기",
    "url": "/posts/120.-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%84-%EC%A0%95%EC%88%98%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n_str:String) -&gt; Int {        var answer : Int = 0        answer = Int(n_str)!        return answer}문자열을 정수로 변환할때는 !를 붙여 unwrapping을 해줘야한다.그렇지않으면 컴파일 에러가 나기때문이다.",
    "content": "import Foundationfunc solution(_ n_str:String) -&gt; Int {        var answer : Int = 0        answer = Int(n_str)!        return answer}문자열을 정수로 변환할때는 !를 붙여 unwrapping을 해줘야한다.그렇지않으면 컴파일 에러가 나기때문이다."
  },
  
  {
    "title": "119. 문자열로 변환",
    "url": "/posts/119.-%EB%AC%B8%EC%9E%90%EC%97%B4%EB%A1%9C-%EB%B3%80%ED%99%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int) -&gt; String {        var answer : String = \"\"        answer = String(n)        return answer}숫자를 문자열로 변환하기 위해서 String으로 감싸서 결과값을 리턴하였다.",
    "content": "import Foundationfunc solution(_ n:Int) -&gt; String {        var answer : String = \"\"        answer = String(n)        return answer}숫자를 문자열로 변환하기 위해서 String으로 감싸서 결과값을 리턴하였다."
  },
  
  {
    "title": "118. 정수 부분",
    "url": "/posts/118.-%EC%A0%95%EC%88%98-%EB%B6%80%EB%B6%84/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ flo:Double) -&gt; Int {        var answer = 0        answer = Int(flo/1)        return answer}나누었을때 몫만 반환하는 / 을 이용하여 Int로 감싸서 결과값을 리턴하고자 하였다.",
    "content": "import Foundationfunc solution(_ flo:Double) -&gt; Int {        var answer = 0        answer = Int(flo/1)        return answer}나누었을때 몫만 반환하는 / 을 이용하여 Int로 감싸서 결과값을 리턴하고자 하였다."
  },
  
  {
    "title": "117. 정수 찾기",
    "url": "/posts/117.-%EC%A0%95%EC%88%98-%EC%B0%BE%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-17 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; Int {        var answer : Int = 0        answer = num_list.contains(n) ? 1 : 0         return answer}배열안에 특정한 값을 포함하는지 물어보는 contains를...",
    "content": "import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; Int {        var answer : Int = 0        answer = num_list.contains(n) ? 1 : 0         return answer}배열안에 특정한 값을 포함하는지 물어보는 contains를 사용하였고, 삼항연산자를 통해 결과값을 리턴하였다."
  },
  
  {
    "title": "116. 배열 비교하기",
    "url": "/posts/116.-%EB%B0%B0%EC%97%B4-%EB%B9%84%EA%B5%90%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-16 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ arr1:[Int], _ arr2:[Int]) -&gt; Int {        var answer : Int = 0        answer = arr1.count &gt; arr2.count ? 1 : (arr1.count == arr2.count ? (arr1.reduce(0,+) &gt...",
    "content": "import Foundationfunc solution(_ arr1:[Int], _ arr2:[Int]) -&gt; Int {        var answer : Int = 0        answer = arr1.count &gt; arr2.count ? 1 : (arr1.count == arr2.count ? (arr1.reduce(0,+) &gt; arr2.reduce(0,+)) ? 1 : (arr1.reduce(0,+) == (arr2.reduce(0,+)) ? 0 : -1) : -1)         return answer}if로 쓰는것도 괜찮았지만, 삼항연산자를 계속 이어나가서 표현하고 싶어서 해보았다.다만 괄호가 많아지기에 하나하나 정확하게 해서 하도록 하자."
  },
  
  {
    "title": "115. 배열의 길이를 2의 거듭제곱으로 만들기 (ing)",
    "url": "/posts/115.-%EB%B0%B0%EC%97%B4%EC%9D%98-%EA%B8%B8%EC%9D%B4%EB%A5%BC-2%EC%9D%98-%EA%B1%B0%EB%93%AD%EC%A0%9C%EA%B3%B1%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-16 05:13:00 +0900",
    





    
    "snippet": "2의 거듭제곱이라 거듭제곱을 사용할 수 있는 pow()를 사용해서 풀려고 하였다.",
    "content": "2의 거듭제곱이라 거듭제곱을 사용할 수 있는 pow()를 사용해서 풀려고 하였다."
  },
  
  {
    "title": "114. 배열 만들기 6",
    "url": "/posts/114.-%EB%B0%B0%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-6/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-16 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ arr:[Int]) -&gt; [Int] {        var stk : [Int] = []    var i : Int = 0        while i &lt; arr.count {        if stk.count == 0{            stk.append(arr[i])     ...",
    "content": "import Foundationfunc solution(_ arr:[Int]) -&gt; [Int] {        var stk : [Int] = []    var i : Int = 0        while i &lt; arr.count {        if stk.count == 0{            stk.append(arr[i])            i+=1        } else {            if stk.count != 0 &amp;&amp; stk[stk.count-1] == arr[i] {                stk.removeLast()                i+=1            } else if stk.count != 0 &amp;&amp; stk[stk.count-1] != arr[i] {                stk.append(arr[i])                i+=1            }        }            }        if stk.count == 0 {        stk = [-1]    }        return stk}무한루프인 while을 통해 문제를 해결하였다.마지막에 나온 결과가 빈배열일때를 위해 마지막에 if문을 만들어 처리하였다."
  },
  
  {
    "title": "113. 빈 배열에 추가, 삭제하기 (ing)",
    "url": "/posts/113.-%EB%B9%88-%EB%B0%B0%EC%97%B4%EC%97%90-%EC%B6%94%EA%B0%80,-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-16 05:13:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "112. 배열의 원소만큼 추가하기",
    "url": "/posts/112.-%EB%B0%B0%EC%97%B4%EC%9D%98-%EC%9B%90%EC%86%8C%EB%A7%8C%ED%81%BC-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-16 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ arr:[Int]) -&gt; [Int] {        var answer : [Int] = []        for i in arr.indices{        var n = 1        while arr[i] &gt;= n {            answer.append(arr[i])...",
    "content": "import Foundationfunc solution(_ arr:[Int]) -&gt; [Int] {        var answer : [Int] = []        for i in arr.indices{        var n = 1        while arr[i] &gt;= n {            answer.append(arr[i])            n+=1        }    }        return answer}for문과 while문을 합쳐서 배열에 arr[i]만큼 append를 반복시켜서 추가하였다."
  },
  
  {
    "title": "111. 세 개의 구분자",
    "url": "/posts/111.-%EC%84%B8-%EA%B0%9C%EC%9D%98-%EA%B5%AC%EB%B6%84%EC%9E%90/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-16 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ myStr:String) -&gt; [String] {    var arr : String = \"\"    var answer : [String] = []    var test : [String] = []    answer = myStr.components(separatedBy:[\"a\", \"b\"...",
    "content": "import Foundationfunc solution(_ myStr:String) -&gt; [String] {    var arr : String = \"\"    var answer : [String] = []    var test : [String] = []    answer = myStr.components(separatedBy:[\"a\", \"b\", \"c\"]).filter{$0 != \"\"}    answer = answer.count != 0 ? answer : [\"EMPTY\"]    return answer}split을 여러문자를 어떻게 해야하나 찾다가 component를 사용했는데 아래와 같이 하면 되는거였다. or조건을 통해서 이어 붙였다.나는 components를 사용하여 a,b,c를 포함하는 단어를 분리하였다.하지만 components는 ““를 기본적으로 포함을 하고 있다.그래서 filter를 통해 각각의 인자가 “” 이 아닌것만 걸러서 배열에 출력하였다.그리고 삼항연산자를 통해 빈배열만 남을경우엔 EMPTY를 리턴하였다.다른코드import Foundationfunc solution(_ myStr:String) -&gt; [String] {    return myStr.split { $0 == \"a\" || $0 == \"b\" || $0 == \"c\" }.map { String($0) }}"
  },
  
  {
    "title": "110. rny_string",
    "url": "/posts/110.-rny_string/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-16 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ rny_string:String) -&gt; String {        var string : String = \"\"        string = rny_string.map{String($0) == \"m\" ? \"rn\" : String($0)}.joined()            return s...",
    "content": "import Foundationfunc solution(_ rny_string:String) -&gt; String {        var string : String = \"\"        string = rny_string.map{String($0) == \"m\" ? \"rn\" : String($0)}.joined()            return string}이것역시 map안에 삼항연산자를 통하여 m일경우 rn으로 치환하고 그렇지 않은 경우엔 String($0)을 그대로 써서 해당 문자 그대로 리턴하게 표현하였다."
  },
  
  {
    "title": "109. 문자열 바꿔서 찾기",
    "url": "/posts/109.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%B0%94%EA%BF%94%EC%84%9C-%EC%B0%BE%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-16 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ myString:String, _ pat:String) -&gt; Int {            var string : String = \"\"    var answer : Int = 0        string = myString.map{String($0)==\"A\" ? \"B\" : \"A\"}.joi...",
    "content": "import Foundationfunc solution(_ myString:String, _ pat:String) -&gt; Int {            var string : String = \"\"    var answer : Int = 0        string = myString.map{String($0)==\"A\" ? \"B\" : \"A\"}.joined()        answer = string.contains(pat) ? 1 : 0    return answer}A일때 B, B일때 A로 바꿔주기에 삼항연산자를 사용하여A일때 B 그외엔 A로 바꿔주는걸로 간략하게 표현을 하였다.그다음 문자열에 포함하는지를 묻는 메서드인 contains를 이용하여 정답을 리턴하였다.contains는 기본적으로 Bool Type이어서 단순히 조건을 저렇게 표현하였다.true일때 1 false일땐 0을 리턴한다."
  },
  
  {
    "title": "108. 문자열 잘라서 정렬하기.",
    "url": "/posts/108.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%9E%98%EB%9D%BC%EC%84%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-16 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ myString:String) -&gt; [String] {        var answer : [String] = []        answer = myString.split(separator:\"x\").map{String($0)}.sorted()    return answer}문자열을 x기준...",
    "content": "import Foundationfunc solution(_ myString:String) -&gt; [String] {        var answer : [String] = []        answer = myString.split(separator:\"x\").map{String($0)}.sorted()    return answer}문자열을 x기준으로 잘라내었고 대신 omittingEmptySubsequences 이걸 쓰지 않은건true가 default이기 때문에 공백을 무시한다.그리고 해당 결과를 sorted하여 정렬해주었다"
  },
  
  {
    "title": "107. x 사이의 개수",
    "url": "/posts/107.-x-%EC%82%AC%EC%9D%B4%EC%9D%98-%EA%B0%9C%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-16 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ myString:String) -&gt; [Int] {        var answer : [Int] = []        answer = myString.split(separator: \"x\", omittingEmptySubsequences: false).map{String($0).count}...",
    "content": "import Foundationfunc solution(_ myString:String) -&gt; [Int] {        var answer : [Int] = []        answer = myString.split(separator: \"x\", omittingEmptySubsequences: false).map{String($0).count}          return answer}“x”라는 문자를 기준으로 나누기에 split을 사용하였다.다만 이 메서드는 첫번째 두번째 케이스처럼 맨앞, 맨뒤 그리고 xx가 연속으로 나올경우“ “가 필요하기에omittingEmptySubsequences 를 사용하였다.기본적으로 split은 “ “을 생략하기에 해당 메서드르 사용하였다.그리고 문자열의 개수를 리턴해야하므로 $0.count를 사용하여 바로 결과값을 내었다."
  },
  
  {
    "title": "106. 연속된 수의 합",
    "url": "/posts/106.-%EC%97%B0%EC%86%8D%EB%90%9C-%EC%88%98%EC%9D%98-%ED%95%A9/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-16 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num:Int, _ total:Int) -&gt; [Int] {        var arr : [Int] = []        var start = (total/num)-(num/2)    var end = (total/num)+(num/2)        arr = num % 2 != 0 ? ...",
    "content": "import Foundationfunc solution(_ num:Int, _ total:Int) -&gt; [Int] {        var arr : [Int] = []        var start = (total/num)-(num/2)    var end = (total/num)+(num/2)        arr = num % 2 != 0 ? ((start)...end).map{$0} : ((start+1)...end).map{$0}        return arr}우선 중간값을 이용해서 접근을 해보려고 하였다.전체합을 가진 total과 개수를 가진 num이므로 1씩 올라가는것을 활용하여total/num 이 중간 값을 의미한다.그리고 중간값을 기준으로 num을 반으로 나눈값을 빼면 좌측, 더한값은 우측 범위이므로start, end로 하여서 구했다.다만 num이 홀수일때 이것은 유효하고, 짝수일때는 중간값이 애매해 진다./는 버림을 의미하기때문에 start+1 해준값으로 범위를 정해주어 해결하였다."
  },
  
  {
    "title": "99. 배열 회전시키기",
    "url": "/posts/99.-%EB%B0%B0%EC%97%B4-%ED%9A%8C%EC%A0%84%EC%8B%9C%ED%82%A4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-15 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ numbers:[Int], _ direction:String) -&gt; [Int] {        var arr : [Int] = []    var answer : [Int] = []    arr = numbers        if direction == \"left\" {        arr....",
    "content": "import Foundationfunc solution(_ numbers:[Int], _ direction:String) -&gt; [Int] {        var arr : [Int] = []    var answer : [Int] = []    arr = numbers        if direction == \"left\" {        arr.append(arr[0])        arr.removeFirst()        return arr    } else {        arr.insert(arr[arr.count-1], at:0)        arr.removeLast()        return arr    }}한칸씩 이동한다는 것을 배열의 첫번째 인덱스와 마지막인덱스 값을 어떻게 해주느냐에 따라서 달라진다고 생각을 하였다.그래서 왼쪽으로 이동하는 경우에는 첫번째 인덱스 값을 마지막으로 가게 추가해 준뒤 첫번째 인덱스 값을 제거하는 식으로 하였고,오른쪽으로 이동하는 경우에는 마지막값을 첫번째로 들어가게 삽입을 해주고, 마지막값을 지우는 식으로 하였다.간단한 코드를 보니 한번에 처리하였다.처음에 나도 삼항연산자를 통해 한줄로 처리하고 싶었지만 능력 부족으로 하지 못했다.다른코드import Foundationfunc solution(_ numbers:[Int], _ direction:String) -&gt; [Int] {    var nums = numbers    direction == \"right\" ? nums.insert(nums.removeLast(), at: 0) : nums.append(nums.removeFirst())    return nums}"
  },
  
  {
    "title": "98. 주사위의 개수",
    "url": "/posts/98.-%EC%A3%BC%EC%82%AC%EC%9C%84%EC%9D%98-%EA%B0%9C%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-15 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ box:[Int], _ n:Int) -&gt; Int {        var answer : Int = 0    var volume : Int = 0        volume = box.reduce(1,*)        answer = volume / (n*n*n)        print(vo...",
    "content": "import Foundationfunc solution(_ box:[Int], _ n:Int) -&gt; Int {        var answer : Int = 0    var volume : Int = 0        volume = box.reduce(1,*)        answer = volume / (n*n*n)        print(volume)        return 0}처음에는 이런식으로 문제를 풀려고 했다. 하지만 2번케이스에서 실패하였다.왜 안되는지 이유를 몰라서 질문하기 케이스를 보니 질문한 사람들이 대부분 나와 같은 생각을 하고 있었다.부피의 개념으로 접근을 할때 전체 박스의 부피에서 n의 부피를 나누어서 생긴 문제였다.각각을n으로 나눈 값을 곱하면 금방 해결이 된다.하지만 일일이 n씩 나누는것보다 한번에 배열에 n을 나눈값을 리턴하면 훨씬 편할 거같아서 찾아보았다.너무 나누기에 포커스를 둬서 map을 잊고있었다…..다른코드import Foundationfunc solution(_ box:[Int], _ n:Int) -&gt; Int {        var answer : Int = 0    answer = box.map{$0/n}.reduce(1,*)    return answer}"
  },
  
  {
    "title": "97. 합성수 찾기",
    "url": "/posts/97.-%ED%95%A9%EC%84%B1%EC%88%98-%EC%B0%BE%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-15 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer : Int = 0    var i : Int = 1    var num : Int = 0        while n &gt;= i {        num = 0        for int in 1 ... i {          ...",
    "content": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer : Int = 0    var i : Int = 1    var num : Int = 0        while n &gt;= i {        num = 0        for int in 1 ... i {            if i % int == 0{                num += 1            }        }        if num &gt;= 3 {            answer += 1        }                i += 1    }        return answer}while과 for문을 사용하여 해결하였다.많이 썼던 방식이라 그런가 보자마자 바로 해결이 되었다."
  },
  
  {
    "title": "105. 공백으로 구분하기 1",
    "url": "/posts/105.-%EA%B3%B5%EB%B0%B1%EC%9C%BC%EB%A1%9C-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0-1/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-15 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String) -&gt; [String] {        var answer = my_string.split(separator: \" \").map{String($0)}           return answer}구분자를 기준으로 나눠주는 split 메서드를 사용하였다.split...",
    "content": "import Foundationfunc solution(_ my_string:String) -&gt; [String] {        var answer = my_string.split(separator: \" \").map{String($0)}           return answer}구분자를 기준으로 나눠주는 split 메서드를 사용하였다.split은 다음 글에 별도로 정리해야겠다.map을 하지않으면 데이터형이 Array&lt;Substring&gt; 으로 나와서 정답과는 다른 데이터형이기에 에러가 발생한다.그래서 map으로 한번 더 처리하여 데이터형을 일치시켜준다."
  },
  
  {
    "title": "104. 모스부호 1(ing)",
    "url": "/posts/104.-%EB%AA%A8%EC%8A%A4%EB%B6%80%ED%98%B8-1(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-15 05:13:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "102. 양꼬치",
    "url": "/posts/102.-%EC%96%91%EA%BC%AC%EC%B9%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-15 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int, _ k:Int) -&gt; Int {        var answer : Int = 0        answer = n * 12000 + (k-(n/10)) * 2000            return answer}10인분에 1개씩이므로 서비스는 n/10 의 몫으로 받는다는 것을 ...",
    "content": "import Foundationfunc solution(_ n:Int, _ k:Int) -&gt; Int {        var answer : Int = 0        answer = n * 12000 + (k-(n/10)) * 2000            return answer}10인분에 1개씩이므로 서비스는 n/10 의 몫으로 받는다는 것을 알고음료수의 갯수 - n/10 으로 계산하여 답을 구했다."
  },
  
  {
    "title": "101. 점의 위치 구하기",
    "url": "/posts/101.-%EC%A0%90%EC%9D%98-%EC%9C%84%EC%B9%98-%EA%B5%AC%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-15 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ dot:[Int]) -&gt; Int {        var answer : Int = 0        var mul : Int = 0    mul = dot.reduce(1,*)        answer = dot[0] &gt; 0 ? (mul &gt; 0 ? 1 : 4) : (mul &gt...",
    "content": "import Foundationfunc solution(_ dot:[Int]) -&gt; Int {        var answer : Int = 0        var mul : Int = 0    mul = dot.reduce(1,*)        answer = dot[0] &gt; 0 ? (mul &gt; 0 ? 1 : 4) : (mul &gt; 0 ? 3 : 2)       return answer}dot[1]을 쓸 수 있었지만 그냥 reduce를 사용 해보고 싶어서 곱으로 하였다.삼항연산자에 삼항연산자를 이어 표현하였다."
  },
  
  {
    "title": "100. 공 던지기",
    "url": "/posts/100.-%EA%B3%B5-%EB%8D%98%EC%A7%80%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-15 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ numbers:[Int], _ k:Int) -&gt; Int {    var answer : Int = 0    answer = numbers[((k-1)*2)%numbers.count]    return answer}단순히 수학적으로 생각하여 풀었다.한칸 띄우고 가고 마지막 공을 받는 사람이...",
    "content": "import Foundationfunc solution(_ numbers:[Int], _ k:Int) -&gt; Int {    var answer : Int = 0    answer = numbers[((k-1)*2)%numbers.count]    return answer}단순히 수학적으로 생각하여 풀었다.한칸 띄우고 가고 마지막 공을 받는 사람이아닌 공을 준사람이므로 k-1을 하였고 그것에 2를 곱하여 길이를 나누어서 해결하였다."
  },
  
  {
    "title": "96. 배열 두 배 만들기",
    "url": "/posts/96.-%EB%B0%B0%EC%97%B4-%EB%91%90-%EB%B0%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ numbers:[Int]) -&gt; [Int] {        var arr : [Int] = []        arr = numbers.map{$0*2}        return arr}반복문 대신 map을 사용하였다.$0으로 배열 각각의 인자에 2를 곱한 값을 리턴하여 답을 구하였다.",
    "content": "import Foundationfunc solution(_ numbers:[Int]) -&gt; [Int] {        var arr : [Int] = []        arr = numbers.map{$0*2}        return arr}반복문 대신 map을 사용하였다.$0으로 배열 각각의 인자에 2를 곱한 값을 리턴하여 답을 구하였다."
  },
  
  {
    "title": "95. 나머지 구하기",
    "url": "/posts/95.-%EB%82%98%EB%A8%B8%EC%A7%80-%EA%B5%AC%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        var answer : Int = 0        answer = num1 % num2        return answer}나머지를 구하는 % 를 사용하여 해결하였다.",
    "content": "import Foundationfunc solution(_ num1:Int, _ num2:Int) -&gt; Int {        var answer : Int = 0        answer = num1 % num2        return answer}나머지를 구하는 % 를 사용하여 해결하였다."
  },
  
  {
    "title": "94. 중앙값 구하기",
    "url": "/posts/94.-%EC%A4%91%EC%95%99%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ array:[Int]) -&gt; Int {        var answer : Int = 0        answer = Int(array.sorted()[array.count/2])    return answer}array를 먼저 오름차순으로 정리를 하고 배열의 개수를 2로 나눈 값을 인덱...",
    "content": "import Foundationfunc solution(_ array:[Int]) -&gt; Int {        var answer : Int = 0        answer = Int(array.sorted()[array.count/2])    return answer}array를 먼저 오름차순으로 정리를 하고 배열의 개수를 2로 나눈 값을 인덱스로 하여 출력하였다."
  },
  
  {
    "title": "93. 최빈값 구하기 (ing)",
    "url": "/posts/93.-%EC%B5%9C%EB%B9%88%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "92. 짝수는 싫어요",
    "url": "/posts/92.-%EC%A7%9D%EC%88%98%EB%8A%94-%EC%8B%AB%EC%96%B4%EC%9A%94/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int) -&gt; [Int] {        var answer : [Int] = []        answer = (1...n).filter{$0%2 != 0}.map{$0}         return answer}filter 와 map을 사용하였다.",
    "content": "import Foundationfunc solution(_ n:Int) -&gt; [Int] {        var answer : [Int] = []        answer = (1...n).filter{$0%2 != 0}.map{$0}         return answer}filter 와 map을 사용하였다."
  },
  
  {
    "title": "91. 피자 나눠 먹기 1",
    "url": "/posts/91.-%ED%94%BC%EC%9E%90-%EB%82%98%EB%88%A0-%EB%A8%B9%EA%B8%B0-1/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer : Int = 0        answer = n &gt; 7 ? (n%7 == 0) ? n/7 : (n/7)+1 : 1        return answer}삼항연산자를 2중으로 하여 해결하려고 하였다.",
    "content": "import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer : Int = 0        answer = n &gt; 7 ? (n%7 == 0) ? n/7 : (n/7)+1 : 1        return answer}삼항연산자를 2중으로 하여 해결하려고 하였다."
  },
  
  {
    "title": "90. 피자 나눠 먹기 2 (ing)",
    "url": "/posts/90.-%ED%94%BC%EC%9E%90-%EB%82%98%EB%88%A0-%EB%A8%B9%EA%B8%B0-2-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "89. 피자 나눠 먹기 3",
    "url": "/posts/89.-%ED%94%BC%EC%9E%90-%EB%82%98%EB%88%A0-%EB%A8%B9%EA%B8%B0-3/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ slice:Int, _ n:Int) -&gt; Int {        var answer : Int = 0        answer = n % slice == 0 ? n/slice : n/slice+1    return answer}삼항연산자를 이용하여 간략하게 표현하였다.올림을 하는 ceil...",
    "content": "import Foundationfunc solution(_ slice:Int, _ n:Int) -&gt; Int {        var answer : Int = 0        answer = n % slice == 0 ? n/slice : n/slice+1    return answer}삼항연산자를 이용하여 간략하게 표현하였다.올림을 하는 ceil을 써보고 싶었지만 그러러면 n을 소수점으로 타입변형을 해야하기에n/slice +1로 처리하였다."
  },
  
  {
    "title": "88. 옷가게 할인 받기",
    "url": "/posts/88.-%EC%98%B7%EA%B0%80%EA%B2%8C-%ED%95%A0%EC%9D%B8-%EB%B0%9B%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ price:Int) -&gt; Int {        var answer : Int = 0        switch price {        case ..&lt;100000 :             answer = price        case 100000..&lt;300000 :     ...",
    "content": "import Foundationfunc solution(_ price:Int) -&gt; Int {        var answer : Int = 0        switch price {        case ..&lt;100000 :             answer = price        case 100000..&lt;300000 :            answer = Int(Double(price) * 0.95)        case 300000..&lt;500000 :            answer = Int(Double(price) * 0.9)        case 500000... :            answer = Int(Double(price) * 0.8)        default :         answer = 0    }    return answer}switch case를 통해 범위로 조건을 잡았고 해결하였다.처음에 할인만 의식해서 몇개의 케이스가 성공을 못했는데.알고보니 10만원 미만일때는 할인을 받지않는 케이스였는데 그부분을 적용하지 못했다.import Foundationfunc solution(_ price:Int) -&gt; Int {        var answer : Int = 0        switch price {        case 100000..&lt;300000 :            answer = Int(Double(price) * 0.95)        case 300000..&lt;500000 :            answer = Int(Double(price) * 0.9)        case 500000... :            answer = Int(Double(price) * 0.8)        default :             answer = price    }    return answer}10만원 미만 조건대신 디폴트에 적용을 하였다."
  },
  
  {
    "title": "87. 아이스 아메리카노",
    "url": "/posts/87.-%EC%95%84%EC%9D%B4%EC%8A%A4-%EC%95%84%EB%A9%94%EB%A6%AC%EC%B9%B4%EB%85%B8/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ money:Int) -&gt; [Int] {    var answer : [Int] = []    answer.append(money/5500)    answer.append(money%5500)    return answer}append를 이용하여 해결하였다.다른 코드를 보니 그냥 배열안에 ...",
    "content": "import Foundationfunc solution(_ money:Int) -&gt; [Int] {    var answer : [Int] = []    answer.append(money/5500)    answer.append(money%5500)    return answer}append를 이용하여 해결하였다.다른 코드를 보니 그냥 배열안에 다이렉트로 해도 되었다.[money/5500, money%5500]이런식이었다."
  },
  
  {
    "title": "86. 배열 뒤집기",
    "url": "/posts/86.-%EB%B0%B0%EC%97%B4-%EB%92%A4%EC%A7%91%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {        var arr : [Int] = []        arr = num_list.reversed()    return arr}문자열과 같이 배열또한 reversed()를 사용하여 처리하였다.다만 형변환은 따로 필요하지 않았다.",
    "content": "import Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {        var arr : [Int] = []        arr = num_list.reversed()    return arr}문자열과 같이 배열또한 reversed()를 사용하여 처리하였다.다만 형변환은 따로 필요하지 않았다."
  },
  
  {
    "title": "85. 문자열 뒤집기",
    "url": "/posts/85.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%92%A4%EC%A7%91%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String) -&gt; String {        var answer : String = \"\"        answer = String(my_string.reversed())    return answer}바꿔주는 reversed()를 사용하여 해결하였다.그냥쓰니 type...",
    "content": "import Foundationfunc solution(_ my_string:String) -&gt; String {        var answer : String = \"\"        answer = String(my_string.reversed())    return answer}바꿔주는 reversed()를 사용하여 해결하였다.그냥쓰니 type 에러가나서 String으로 감싸주었다."
  },
  
  {
    "title": "84. 직각삼각형 출력하기",
    "url": "/posts/84.-%EC%A7%81%EA%B0%81%EC%82%BC%EA%B0%81%ED%98%95-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationlet n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! }var string = \"*\"for i in 0..&lt;n[0]{    print(string)    string += \"*\"}처음에 n을 그대로 넣으려고했는데 타입에러가나서 자세히보니 배열이어서어차피...",
    "content": "import Foundationlet n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! }var string = \"*\"for i in 0..&lt;n[0]{    print(string)    string += \"*\"}처음에 n을 그대로 넣으려고했는데 타입에러가나서 자세히보니 배열이어서어차피 하나의 수만 입력을 받기에 n[0]으로 하였다.그리고 *가 한개씩 늘어나게 하였다.다른코드 보니 for each와 map joined을 사용하여 간결하게 하였다.다른코드import Foundationlet n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! }(1...n[0]).forEach {    print((1...$0).map { _ in \"*\" }.joined())}"
  },
  
  {
    "title": "83. 중복된 숫자 개수",
    "url": "/posts/83.-%EC%A4%91%EB%B3%B5%EB%90%9C-%EC%88%AB%EC%9E%90-%EA%B0%9C%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ array:[Int], _ n:Int) -&gt; Int {        var answer : Int = 0        answer = array.filter{$0 == n}.count         return answer}해당문제가 바로 filter를 사용할 수 있어서 적용을 해보았다....",
    "content": "import Foundationfunc solution(_ array:[Int], _ n:Int) -&gt; Int {        var answer : Int = 0        answer = array.filter{$0 == n}.count         return answer}해당문제가 바로 filter를 사용할 수 있어서 적용을 해보았다.다음번엔 for where로 해봐야겠다."
  },
  
  {
    "title": "82. 머쓱이보다 키 큰 사람",
    "url": "/posts/82.-%EB%A8%B8%EC%93%B1%EC%9D%B4%EB%B3%B4%EB%8B%A4-%ED%82%A4-%ED%81%B0-%EC%82%AC%EB%9E%8C/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ array:[Int], _ height:Int) -&gt; Int {        var answer : Int = 0        for i in array.indices{        if array[i] &gt; height {            answer += 1        }  ...",
    "content": "import Foundationfunc solution(_ array:[Int], _ height:Int) -&gt; Int {        var answer : Int = 0        for i in array.indices{        if array[i] &gt; height {            answer += 1        }    }    return answer}for문과 if문을 통해 문제를 해결하였다.다른코드를 보니 filter로 하였다 다음번에 해봐야겠다.또한 for if문을 섞어 for문에 where로 했다. 예전에 해본거 같은데 다시 기억해둬야겠다.func solution(_ array: [Int], _ height: Int) -&gt; Int { array.filter { $0 &gt; height }.count }//import Foundationfunc solution(_ array:[Int], _ height:Int) -&gt; Int {    var result = 0    for h in array where h &gt; height {        result += 1    }    return result}"
  },
  
  {
    "title": "81. 특정 문자열로 끝나는 가장 긴 부분 문자열 찾기 (ing)",
    "url": "/posts/81.-%ED%8A%B9%EC%A0%95-%EB%AC%B8%EC%9E%90%EC%97%B4%EB%A1%9C-%EB%81%9D%EB%82%98%EB%8A%94-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EB%B6%80%EB%B6%84-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%B0%BE%EA%B8%B0-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-14 05:13:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "80. 특정한 문자를 대문자로 바꾸기",
    "url": "/posts/80.-%ED%8A%B9%EC%A0%95%ED%95%9C-%EB%AC%B8%EC%9E%90%EB%A5%BC-%EB%8C%80%EB%AC%B8%EC%9E%90%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String, _ alp:String) -&gt; String {        var answer : String = \"\"        var arr : [String] = []    arr = my_string.map{String($0)}        if my_string...",
    "content": "import Foundationfunc solution(_ my_string:String, _ alp:String) -&gt; String {        var answer : String = \"\"        var arr : [String] = []    arr = my_string.map{String($0)}        if my_string.contains(alp) {        for i in arr.indices{            if arr[i] == alp {                arr[i] = String(arr[i]).uppercased()            }        }        answer = arr.joined()    } else {        answer = my_string    }    return answer}처음에 아래와 같이 map 을 이용하려고 삼항연산자 까지 썼다가. 아닌경우에는 어떻게 해야하나 고민을 햇는데. 애초에 아닌경우에는 소문자로 리턴을 했으면 되는문제였는데 너무 복잡하게 생각했던것같다.map 안에 삼항연산자를 사용하여 배열을 만들 수 있는데 아직 그부분이 부족한것같다.다른코드import Foundationfunc solution(_ my_string:String, _ alp:String) -&gt; String {    return my_string.map { String($0) == alp ? $0.uppercased() : $0.lowercased() }.joined()}//"
  },
  
  {
    "title": "79. A 강조하기",
    "url": "/posts/79.-A-%EA%B0%95%EC%A1%B0%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ myString:String) -&gt; String {        var answer : String = \"\"    var arr : [String] = []        arr = myString.lowercased().map{String($0)}        for i in arr.in...",
    "content": "import Foundationfunc solution(_ myString:String) -&gt; String {        var answer : String = \"\"    var arr : [String] = []        arr = myString.lowercased().map{String($0)}        for i in arr.indices {        if arr[i] == \"a\" {            arr[i] = String(arr[i]).uppercased()        }    }        answer = arr.joined()        return answer}주어진 문자열을 우선 소문자로 만들면서 map을 사용해 배열로 만들었다.그다음 하나씩 비교하여 a일때 대문자로 바꾼뒤 join으로 문자열로 만들어 줬다.replacingOccurrences 라는 메서드를 통해 아주 간단하게 바꾸었다.나중에 한번 해당 메서드를 적용해봐야겠다.다른코드import Foundationfunc solution(_ myString:String) -&gt; String {    return myString.lowercased().replacingOccurrences(of: \"a\", with: \"A\")}"
  },
  
  {
    "title": "78. 배열에서 문자열 대소문자 변환하기",
    "url": "/posts/78.-%EB%B0%B0%EC%97%B4%EC%97%90%EC%84%9C-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8C%80%EC%86%8C%EB%AC%B8%EC%9E%90-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ strArr:[String]) -&gt; [String] {        var answer : [String] = []        answer = strArr        for i in answer.indices{        if i % 2 == 0 {            answer[...",
    "content": "import Foundationfunc solution(_ strArr:[String]) -&gt; [String] {        var answer : [String] = []        answer = strArr        for i in answer.indices{        if i % 2 == 0 {            answer[i] = answer[i].lowercased()        } else {            answer[i] = answer[i].uppercased()        }    }        return answer}enumerated와 고차함수를 사용해서 해보고 싶었으나 뒤에 조건을 어떻게 해야할지 몰라 못했는데 아래 코드를 보고 어느부분이 부족한지 알았다.삼항연산자를 쓰면 될까 생각만했는데 코드보니 내생각이 맞았다.다음번엔 시도를 해봐야겠다.다른코드import Foundationfunc solution(_ strArr:[String]) -&gt; [String] {    return strArr.enumerated().map { $0.offset % 2 != 0 ? $0.element.uppercased() : $0.element.lowercased() }}//func solution(_ strArr: [String]) -&gt; [String] { strArr.indices.map { ($0 % 2 == 0) ? strArr[$0].lowercased() : strArr[$0].uppercased() } }//import Foundationfunc solution(_ strArr:[String]) -&gt; [String] {    return strArr.enumerated().map { $0.offset % 2 == 0 ? $0.element.lowercased() : $0.element.uppercased() }}$0.offset / $0.element 를 사용했는데 저번에 정리한 $0.0 / $0.1 과 같은 표현인듯 하다."
  },
  
  {
    "title": "77. 소문자로 바꾸기",
    "url": "/posts/77.-%EC%86%8C%EB%AC%B8%EC%9E%90%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ myString:String) -&gt; String {        var answer : String = \"\"        answer = myString.lowercased()        return answer}소문자로 바꾸는 lowercased를 사용하여 해결하였다.",
    "content": "import Foundationfunc solution(_ myString:String) -&gt; String {        var answer : String = \"\"        answer = myString.lowercased()        return answer}소문자로 바꾸는 lowercased를 사용하여 해결하였다."
  },
  
  {
    "title": "76. 대문자로 바꾸기",
    "url": "/posts/76.-%EB%8C%80%EB%AC%B8%EC%9E%90%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ myString:String) -&gt; String {        var answer : String = \"\"        answer = myString.uppercased()        return answer}문자열을 대문자로 바꿔주는 uppercased를 사용하여 해결하였다.",
    "content": "import Foundationfunc solution(_ myString:String) -&gt; String {        var answer : String = \"\"        answer = myString.uppercased()        return answer}문자열을 대문자로 바꿔주는 uppercased를 사용하여 해결하였다."
  },
  
  {
    "title": "75. 원하는 문자열 찾기",
    "url": "/posts/75.-%EC%9B%90%ED%95%98%EB%8A%94-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%B0%BE%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ myString:String, _ pat:String) -&gt; Int {        var answer : Int = 0        if myString.count &gt;= pat.count {                if myString.lowercased().contains(p...",
    "content": "import Foundationfunc solution(_ myString:String, _ pat:String) -&gt; Int {        var answer : Int = 0        if myString.count &gt;= pat.count {                if myString.lowercased().contains(pat.lowercased()) {                        answer = 1                    } else {                        answer = 0                    }            } else {                answer = 0            }    return answer}문제 에서 대문자와 소문자는 구분하지 않는다고 하였기에 myString, pat 둘다 대문자, 혹은 소문자로 변환을 한뒤 contains 메서드를 이용하여 포함을 하는지를 물어보고 그에따른 결과값을 리턴을 하는걸로 방향을 잡았다."
  },
  
  {
    "title": "74. 길이에 따른 연산",
    "url": "/posts/74.-%EA%B8%B8%EC%9D%B4%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%97%B0%EC%82%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {        var answer : Int = 0        answer = 11 &lt;= num_list.count ? num_list.reduce(0,+) : num_list.reduce(1,*)        return answer}리...",
    "content": "import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {        var answer : Int = 0        answer = 11 &lt;= num_list.count ? num_list.reduce(0,+) : num_list.reduce(1,*)        return answer}리스트의 길이가 필요하므로 count를 사용하였고, 간단하게 표현하기위해 삼항연산자를 사용하였다.그리고 고차함수를 연습겸 사용함으로써 식을 한줄로 간결하게 표현하려고 하였다.고차함수도 조금씩 감이 생기는듯하다."
  },
  
  {
    "title": "73. 1로 만들기",
    "url": "/posts/73.-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {        var answer : Int = 0    var arr : [Int] = []    var n : Int = 0        arr = num_list        for i in arr.indices {        while ...",
    "content": "import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {        var answer : Int = 0    var arr : [Int] = []    var n : Int = 0        arr = num_list        for i in arr.indices {        while (arr[i] != 1) {            n = 0            if arr[i] % 2 == 0 {                arr[i] = arr[i] / 2                n+=1            } else {                arr[i] = (arr[i]-1) / 2                n+=1            }            answer += n         }    }        return answer}for 문 안에 while을 넣어서 각 원소가 1이될때까지 처리를 하게 하였다.처음에 값이 에러가 났던건은 while안에 n의 값을 0을 해서 계속 리셋을 해야했는데, while밖에 n을 넣어서 21이 계속 나왔다.좀 더 집중해야겠다."
  },
  
  {
    "title": "72. 조건에 맞게 수열 변환하기 2",
    "url": "/posts/72.-%EC%A1%B0%EA%B1%B4%EC%97%90-%EB%A7%9E%EA%B2%8C-%EC%88%98%EC%97%B4-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0-2/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ arr:[Int]) -&gt; Int {        var answer : Int = 0    var temp : [Int] = []    var Arr : [Int] = []    var j : Int = 0        Arr = arr        while Arr != temp{   ...",
    "content": "import Foundationfunc solution(_ arr:[Int]) -&gt; Int {        var answer : Int = 0    var temp : [Int] = []    var Arr : [Int] = []    var j : Int = 0        Arr = arr        while Arr != temp{        temp = Arr        for i in Arr.indices {           if Arr[i] &gt;= 50 &amp;&amp; Arr[i] % 2 == 0 {                Arr[i] = Arr[i] / 2            } else if Arr[i] &lt; 50 &amp;&amp; Arr[i] % 2 != 0 {                Arr[i] = (Arr[i] * 2) + 1            } else {                continue            }        }            j+=1    }        answer = j-1        return answer}while을 사용하여 무한 루프를 사용하였다.무한루프 1 cycle이 돌았을때 직전값을 가지고 있는 배열 temp를 만들었고 그다음 Arr=temp 일때 즉 값의 변화가 없을때 나오게끔 조건을 걸었다.그다음 그안에 for문을 하나 더 추가함으로써 1사이클 동안 배열값을 전부 처리하게 하였다.그리고 마지막에 j값이 1씩 증가하게 끔 했기때문에. 실제로 6회 돌았을때, 해당값이 멈추게된다. 그러므로 그전의 값을 리턴해야하므로 -1을 하였다."
  },
  
  {
    "title": "71. 조건에 맞게 수열 변환하기 1",
    "url": "/posts/71.-%EC%A1%B0%EA%B1%B4%EC%97%90-%EB%A7%9E%EA%B2%8C-%EC%88%98%EC%97%B4-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0-1/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ arr:[Int]) -&gt; [Int] {        var answer : [Int] = []        answer = arr        for i in answer.indices {                if answer[i] &gt;= 50 &amp;&amp; answer[...",
    "content": "import Foundationfunc solution(_ arr:[Int]) -&gt; [Int] {        var answer : [Int] = []        answer = arr        for i in answer.indices {                if answer[i] &gt;= 50 &amp;&amp; answer[i] % 2 == 0 {            answer[i] = answer[i] / 2        } else if answer[i] &lt; 50 &amp;&amp; answer[i] % 2 != 0 {            answer[i] = answer[i] * 2        } else {            continue        }            }            return answer}처음에 잘못이해하고 첫번 째 if문에 바로 else를 하여, 정답을 내려고했다그랬더니 99에서 막혔다. 생각해보니 두 조건에 해당하지 않는 숫자는 그대로 내보내야 해서, continue로 넘겼더니 해결이 되었다."
  },
  
  {
    "title": "70. 수열과 구간 쿼리1",
    "url": "/posts/70.-%EC%88%98%EC%97%B4%EA%B3%BC-%EA%B5%AC%EA%B0%84-%EC%BF%BC%EB%A6%AC1/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {        var answer : [Int] = []        answer=arr        for i in queries.indices{                for n in queries[i][0] ...",
    "content": "import Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {        var answer : [Int] = []        answer=arr        for i in queries.indices{                for n in queries[i][0] ... queries[i][1] {            answer[n] += 1        }            }        return answer}2중 반복문을 통하여 계산하였다.아래는 forEach를 통하여 계산하였다.forEach도 정리만하고 써볼생각을 못했는데다음번에는 해봐야겠다.다른코드import Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {    var arr = arr    queries.forEach { ($0[0]...$0[1]).forEach { arr[$0] += 1 } }     return arr}"
  },
  
  {
    "title": "69. n보다 커질 때 까지 더하기",
    "url": "/posts/69.-n%EB%B3%B4%EB%8B%A4-%EC%BB%A4%EC%A7%88-%EB%95%8C-%EA%B9%8C%EC%A7%80-%EB%8D%94%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ numbers:[Int], _ n:Int) -&gt; Int {        var answer : Int = 0    var i : Int = 0        while answer &lt;= n {        answer += numbers[i]        i += 1    }    r...",
    "content": "import Foundationfunc solution(_ numbers:[Int], _ n:Int) -&gt; Int {        var answer : Int = 0    var i : Int = 0        while answer &lt;= n {        answer += numbers[i]        i += 1    }    return answer}while문으로 처리하였다.reduce를 써보고 싶었는데 잘 안되어서 다른 코드를 보니 아직 공부할게 많다.다른코드import Foundationfunc solution(_ numbers:[Int], _ n:Int) -&gt; Int {    return numbers.reduce(0) { $0 &gt; n ? $0 : $0 + $1 }}//func solution(_ numbers: [Int], _ n: Int) -&gt; Int {    return numbers.reduce(0) { acc, i in n &gt;= acc ? acc + i : acc }}//"
  },
  
  {
    "title": "68. 할 일 목록",
    "url": "/posts/68.-%ED%95%A0-%EC%9D%BC-%EB%AA%A9%EB%A1%9D/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ todo_list:[String], _ finished:[Bool]) -&gt; [String] {        var answer : [String] = []        for i in todo_list.indices {        if finished[i] == false {      ...",
    "content": "import Foundationfunc solution(_ todo_list:[String], _ finished:[Bool]) -&gt; [String] {        var answer : [String] = []        for i in todo_list.indices {        if finished[i] == false {            answer.append(todo_list[i])        }    }    return answer}딕셔너리를 사용해보고 싶었으나 배열이 중복으로 생겨서 안되어서 for문을 사용해서 해결했다.다른 코드를 보니 간결하면서도 모르는게 많았다.다른코드import Foundationfunc solution(_ todo_list:[String], _ finished:[Bool]) -&gt; [String] {    return finished.enumerated().filter { !$0.element }.map { todo_list[$0.offset] }}//func solution(_ todoList: [String], _ finished: [Bool]) -&gt; [String] {    return zip(todoList, finished).filter { !$0.1 }.map { $0.0 }}//import Foundationfunc solution(_ todo_list:[String], _ finished:[Bool]) -&gt; [String] {    return finished.enumerated().filter { $0.element == false }.map { todo_list[$0.offset] }}"
  },
  
  {
    "title": "67. 5명씩",
    "url": "/posts/67.-5%EB%AA%85%EC%94%A9/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ names:[String]) -&gt; [String] {        var answer : [String] = []        answer = stride(from:0, to:names.count, by:5).map{names[$0]}                         retur...",
    "content": "import Foundationfunc solution(_ names:[String]) -&gt; [String] {        var answer : [String] = []        answer = stride(from:0, to:names.count, by:5).map{names[$0]}                         return answer}5명 간격으로 그룹짓고 그 그룹의 선두 이름을 출력한다는 것은 즉 5명간격으로 배열에 입력을 하면되는것이므로, stride를 사용하였다."
  },
  
  {
    "title": "66. 홀수 vs 짝수",
    "url": "/posts/66.-%ED%99%80%EC%88%98-vs-%EC%A7%9D%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {        var odd : Int = 0    var even : Int = 0    var answer : Int = 0        for i in num_list.indices {        if i % 2 == 0 {        ...",
    "content": "import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {        var odd : Int = 0    var even : Int = 0    var answer : Int = 0        for i in num_list.indices {        if i % 2 == 0 {            even += num_list[i]        } else {            odd += num_list[i]        }    }        answer = even &gt; odd ? even : odd            return answer}홀수 짝수 인덱스에 다라 odd, even이라는 변수에 누적해서 더하게 하였고,삼항연산자를 사용하여 리턴하였다.filter를 사용해서 인덱스로 접근해 처리해보고 싶었는데 가능한지 모르겠다.다른 코드를 보니 가능한거같다. 공부를 해봐야겠다.다른코드import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {    let even = num_list.enumerated().filter { $0.0 % 2 == 0 }.map { $0.1 }    let odd = num_list.enumerated().filter { $0.0 % 2 == 1 }.map { $0.1 }    return even.reduce(0, +) &gt;= odd.reduce(0, +) ? even.reduce(0, +) : odd.reduce(0, +)}해당 코드를 보니 enumerated를 통해 Dictionary배열로 바꾸었다 (key, value)의 형태그리고 $0.0 / $0.1 의 개념을 찾아보니 $0.0이 key/ $0.1이 value 였다.즉 key는 인덱스를 의미하니 그걸 이용하여 필터를 사용하였고, map에는 0.1 즉 value값 실제로 배열에 있었던 값을 적용하여 배열을 만들었다."
  },
  
  {
    "title": "65. n개 간격의 원소들",
    "url": "/posts/65.-n-%EA%B0%9C-%EA%B0%84%EA%B2%A9%EC%9D%98-%EC%9B%90%EC%86%8C%EB%93%A4/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {        var answer : [Int] = []    answer = stride(from:0, through:num_list.count-1, by:n).map{num_list[$0]}            return...",
    "content": "import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {        var answer : [Int] = []    answer = stride(from:0, through:num_list.count-1, by:n).map{num_list[$0]}            return answer}stride를 사용하여 간격에 따라서 출력을 하려고 하였다.num_list[] 인데 num_list{}로 하여 에러가 났었다.잘 확인해두자."
  },
  
  {
    "title": "64. n 번째 원소까지",
    "url": "/posts/64.-n-%EB%B2%88%EC%A7%B8-%EC%9B%90%EC%86%8C%EA%B9%8C%EC%A7%80/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {        var answer : [Int] = []        answer = Array(num_list[..&lt;n])        return answer}슬라이싱을 하면 되는 문제였기에 간단하게 n이 포함되지않는...",
    "content": "import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {        var answer : [Int] = []        answer = Array(num_list[..&lt;n])        return answer}슬라이싱을 하면 되는 문제였기에 간단하게 n이 포함되지않는 미만으로 범위를 설정하여 문제를 해결하였다."
  },
  
  {
    "title": "63. 왼쪽 오른쪽",
    "url": "/posts/63.-%EC%99%BC%EC%AA%BD-%EC%98%A4%EB%A5%B8%EC%AA%BD/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ str_list:[String]) -&gt; [String] {        var answer : [String] = []        for i in str_list.indices {        if str_list.count == 1 {            answer = []     ...",
    "content": "import Foundationfunc solution(_ str_list:[String]) -&gt; [String] {        var answer : [String] = []        for i in str_list.indices {        if str_list.count == 1 {            answer = []        } else {            if str_list[i] == \"l\" {                        answer = Array(str_list[..&lt;i])            break                    } else if str_list[i] == \"r\" {            answer = Array(str_list[(i+1)...])            break                    }        }                    }        return answer}이번에도 슬라이싱을 생각하였다.다만 2번째 조건일때를 잘못 생각하였고,그래서 한글자만 들어올때는 빈배열을 리턴하게 하였다."
  },
  
  {
    "title": "62. 순서 바꾸기",
    "url": "/posts/62.-%EC%88%9C%EC%84%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {        var answer : [Int] = []    answer = Array(num_list[n...]) + Array(num_list[..&lt;n])    return answer}이번에도 슬라이싱을 통해서 문...",
    "content": "import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {        var answer : [Int] = []    answer = Array(num_list[n...]) + Array(num_list[..&lt;n])    return answer}이번에도 슬라이싱을 통해서 문제를 해결하려고 하였다.n번쨰 까지에서 내가 잘못 이해했는지 … 으로 했을때는 하나를 더 포함을 해서..&lt; 으로 바꾸어 해결하였다."
  },
  
  {
    "title": "60. 배열 조각하기(ing)",
    "url": "/posts/60.-%EB%B0%B0%EC%97%B4-%EC%A1%B0%EA%B0%81%ED%95%98%EA%B8%B0(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "이렇게 한 이유.",
    "content": "이렇게 한 이유."
  },
  
  {
    "title": "59. 2의 영역 (ing)",
    "url": "/posts/59.-2%EC%9D%98-%EC%98%81%EC%97%AD-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "58. 배열 만들기 3",
    "url": "/posts/58.-%EB%B0%B0%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-3/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ arr:[Int], _ intervals:[[Int]]) -&gt; [Int] {        var answer : [Int] = []        for i in 0...intervals.count-1 {                answer += Array(arr[Int(interval...",
    "content": "import Foundationfunc solution(_ arr:[Int], _ intervals:[[Int]]) -&gt; [Int] {        var answer : [Int] = []        for i in 0...intervals.count-1 {                answer += Array(arr[Int(intervals[i][0]) ... Int(intervals[i][1])])            }            return answer}이렇게 한 이유슬라이싱과 유사하게 해보았고. 혹시나 해서 빈 배열에 +=로 누적을 해보았는데 되었다."
  },
  
  {
    "title": "57. 첫 번째로 나오는 음수",
    "url": "/posts/57.-%EC%B2%AB-%EB%B2%88%EC%A7%B8%EB%A1%9C-%EB%82%98%EC%98%A4%EB%8A%94-%EC%9D%8C%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {        var answer : Int = 0        for i in 0...num_list.count-1 {                if num_list[i] &lt; 0 {            answer = i         ...",
    "content": "import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {        var answer : Int = 0        for i in 0...num_list.count-1 {                if num_list[i] &lt; 0 {            answer = i            break        } else {            answer = -1        }        }        return answer}이렇게 한 이유반복문을 통해서 해결하였다.전에 풀었던 문제와 유사하게 해결하였다.나중에 다시 풀때는 삼항연산자를 이용해서 풀어봐야겠다.다른 코드func solution(_ numList: [Int]) -&gt; Int { numList.firstIndex(where: { $0 &lt; 0 }) ?? -1 }"
  },
  
  {
    "title": "56. 리스트 자르기",
    "url": "/posts/56.-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%9E%90%EB%A5%B4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int, _ slicer:[Int], _ num_list:[Int]) -&gt; [Int] {        var answer : [Int] = []        switch n {        case 1 :            answer = Array(num_list[0...slice...",
    "content": "import Foundationfunc solution(_ n:Int, _ slicer:[Int], _ num_list:[Int]) -&gt; [Int] {        var answer : [Int] = []        switch n {        case 1 :            answer = Array(num_list[0...slicer[1]])        case 2 :            answer = Array(num_list[slicer[0]...])        case 3 :            answer = Array(num_list[slicer[0]...slicer[1]])        case 4 :            answer = stride(from:slicer[0], to:slicer[1]+1, by:slicer[2]).map{num_list[$0]}            default : answer = []    }    return answer}이렇게 한 이유switch case를 이용해 1,2,3,4 일때의 조건을 나누었다.Array로 감싼이유는 array를 감싸지 않도 돌리니 type 에러가 났다.[]를 통해 슬라이싱을 할경우 슬라이싱을 한 배열은 ArrySlice&lt;&gt;으로 되면서 데이터 타입 에러가 났다.그래서 Array로 감싸서 데이텨형을 맞추었다.n=4일때 간격을 두고 슬라이싱을 해야해서 검색을 해야했다. stride를 통해서 할수 있다는 것을 알았고, 그다음 map을 써서 배열로 만들어야하는것을 알게 되었다.출력결과 4번에서 2,4,6이 정답인데 6이 안나와서 +1을 하여 슬라이싱 범위를 한칸 더 주었다.from: tofrom: through 의 표현에 차이가 있었다.to를 하게되면 해당 인덱스를 포함하지 않는다.through를 하게되면 해다 인덱스를 포함하게된다.다른 코드import Foundationfunc solution(_ n:Int, _ slicer:[Int], _ num_list:[Int]) -&gt; [Int] {        var answer : [Int] = []        switch n {        case 1 :            answer = Array(num_list[0...slicer[1]])        case 2 :            answer = Array(num_list[slicer[0]...])        case 3 :            answer = Array(num_list[slicer[0]...slicer[1]])        case 4 :            answer = stride(from:slicer[0], through:slicer[1], by:slicer[2]).map{num_list[$0]}            default : answer = []    }        print(answer)        return answer}"
  },
  
  {
    "title": "55. 가까운 1 찾기",
    "url": "/posts/55.-%EA%B0%80%EA%B9%8C%EC%9A%B4-1-%EC%B0%BE%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ arr:[Int], _ idx:Int) -&gt; Int {    var answer : Int = 0    for i in idx ... arr.count-1 {        if arr[i] == 1 {            answer = i            break        } ...",
    "content": "import Foundationfunc solution(_ arr:[Int], _ idx:Int) -&gt; Int {    var answer : Int = 0    for i in idx ... arr.count-1 {        if arr[i] == 1 {            answer = i            break        } else {            answer = -1        }    }    return answer}이렇게 한 이유반복문을 통하려고 하였고, 1일때의 인덱스값을 찾자마자 리턴을 시켜야 했기에, break를 써서 끊었다.그리고 그것이 해당하지 않는 케이스라면 -1을 리턴을 하여 해결하였다.다른 코드를 보니 엄청 심플하게 했다…다른 코드import Foundationfunc solution(_ arr:[Int], _ idx:Int) -&gt; Int {    return arr[idx...].firstIndex(of: 1) ?? -1}//"
  },
  
  {
    "title": "54. 카운트 다운",
    "url": "/posts/54.-%EC%B9%B4%EC%9A%B4%ED%8A%B8-%EB%8B%A4%EC%9A%B4/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ start:Int, _ end_num:Int) -&gt; [Int] {        var answer : [Int] = []          answer = (end_num ... start).map{$0}    return answer.sorted(by:&gt;)}이렇게 한 이유map을 사...",
    "content": "import Foundationfunc solution(_ start:Int, _ end_num:Int) -&gt; [Int] {        var answer : [Int] = []          answer = (end_num ... start).map{$0}    return answer.sorted(by:&gt;)}이렇게 한 이유map을 사용하여 해결하려고 하였고 end~start까지의 범위로 내림차순 정렬로 리턴하여 해결하였다."
  },
  
  {
    "title": "53. 글자 지우기 (ing)",
    "url": "/posts/53.-%EA%B8%80%EC%9E%90-%EC%A7%80%EC%9A%B0%EA%B8%B0-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "이렇게 한 이유.",
    "content": "이렇게 한 이유."
  },
  
  {
    "title": "52. 배열 만들기1",
    "url": "/posts/52.-%EB%B0%B0%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B01/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-13 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ n:Int, _ k:Int) -&gt; [Int] {        var arr : [Int] = []        arr = (1...n).map{$0}.filter{$0 % k == 0}    return arr}이렇게 한 이유.고차함수로 문제를 해결하려고 하였다.다만 그냥 수가 주어졌을때...",
    "content": "import Foundationfunc solution(_ n:Int, _ k:Int) -&gt; [Int] {        var arr : [Int] = []        arr = (1...n).map{$0}.filter{$0 % k == 0}    return arr}이렇게 한 이유.고차함수로 문제를 해결하려고 하였다.다만 그냥 수가 주어졌을때 어떻게 해야하는지 몰라 찾아보니 (1…n)을 사용하여 범위의 숫자를 적용한 뒤에 map을 사용하여 1부터 n까지의 정수 배열을 생성하였고,그뒤에 filter를 적용하여 각 인덱스에 접근하여 k로 나누었을때 나머지가 0 즉, k의 배수인 값을 따로 추려내었다.확실히 고차함수만을 사용하니 코드가 간결해졌다."
  },
  
  {
    "title": "61. n 번째 원소부터",
    "url": "/posts/61.-n-%EB%B2%88%EC%A7%B8-%EC%9B%90%EC%86%8C%EB%B6%80%ED%84%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-12 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {        var answer : [Int] = []    var N : Int = 0    N = n-1        answer = Array(num_list[N...])        return answer}이렇게 한...",
    "content": "import Foundationfunc solution(_ num_list:[Int], _ n:Int) -&gt; [Int] {        var answer : [Int] = []    var N : Int = 0    N = n-1        answer = Array(num_list[N...])        return answer}이렇게 한 이유처음에는 고차함수를 써보려고했으나, 생각해보니 슬라이싱을 하면 될것 같아서 슬라이싱을 해서 해결하였다.Array로 감싸지 않으면 데이터 에러가 나기에 Array로 감싸주었다."
  },
  
  {
    "title": "51. 문자 개수 세기 (ing)",
    "url": "/posts/51.-%EB%AC%B8%EC%9E%90-%EA%B0%9C%EC%88%98-%EC%84%B8%EA%B8%B0-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-12 05:13:00 +0900",
    





    
    "snippet": "",
    "content": ""
  },
  
  {
    "title": "50. qr code",
    "url": "/posts/50.-qr-code/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-12 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ q:Int, _ r:Int, _ code:String) -&gt; String {        var answer : String = \"\"        for i in 0 ... code.count-1 {                if (i % q) == r {                 ...",
    "content": "import Foundationfunc solution(_ q:Int, _ r:Int, _ code:String) -&gt; String {        var answer : String = \"\"        for i in 0 ... code.count-1 {                if (i % q) == r {                        answer += String(code[String.Index(encodedOffset:i)])        }          }    return answer}이렇게 한 이유.처음에는 배열을 하나 만들어서 그에 해당하는 인덱스만 꺼낼까 생각했는데, 생각해보니 문자열의 인덱스로 접근해서 그에 해당하는 것을 answer라는 매개변수에 누적시키는것으로 방향을 잡았다.다만 아직도 string 쪽에 대한 키워드를 사용하는데 있어 많이 부족해 보인다."
  },
  
  {
    "title": "49. 세로 읽기 (ing)",
    "url": "/posts/49.-%EC%84%B8%EB%A1%9C-%EC%9D%BD%EA%B8%B0-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-12 05:13:00 +0900",
    





    
    "snippet": "이렇게 한 이유",
    "content": "이렇게 한 이유"
  },
  
  {
    "title": "48. 문자열 뒤집기 (ing)",
    "url": "/posts/48.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%92%A4%EC%A7%91%EA%B8%B0-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-12 05:13:00 +0900",
    





    
    "snippet": "이렇게 한 이유",
    "content": "이렇게 한 이유"
  },
  
  {
    "title": "47. 접두사인지 확인하기",
    "url": "/posts/47.-%EC%A0%91%EB%91%90%EC%82%AC%EC%9D%B8%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-12 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String, _ is_prefix:String) -&gt; Int {    var answer : Int = 0    var arr : [String] = []    var my_String : String = \"\"    my_String = my_string    arr....",
    "content": "import Foundationfunc solution(_ my_string:String, _ is_prefix:String) -&gt; Int {    var answer : Int = 0    var arr : [String] = []    var my_String : String = \"\"    my_String = my_string    arr.append(my_String)    for i in 1 ... my_String.count-1 {        my_String.removeLast()        arr.append(my_String)    }    answer = arr.contains(is_prefix) ? 1 : 0    return answer}이렇게 한 이유배열을 추가하여 마지막것을 지우면서 하나씩 집어넣었다.그리고 contains를 이용하여 확인하였다. 저번 접미사와 코드가 같다.다른 코드를 보니 너무 심플하다.count를 써서 한 발상이 신선하다. 더 열심히 공부해야겠다.다른 코드import Foundationfunc solution(_ my_string:String, _ is_prefix:String) -&gt; Int {    return my_string.prefix(is_prefix.count) == is_prefix ? 1 : 0}"
  },
  
  {
    "title": "46. 문자열의 앞의 n글자",
    "url": "/posts/46.-%EB%AC%B8%EC%9E%90%EC%97%B4%EC%9D%98-%EC%95%9E%EC%9D%98-n%EA%B8%80%EC%9E%90/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-12 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {        var arr : [String] = []    var answer : String = \"\"        arr = my_string.map{String($0)}        answer = arr.pref...",
    "content": "import Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {        var arr : [String] = []    var answer : String = \"\"        arr = my_string.map{String($0)}        answer = arr.prefix(n).joined()            return answer}이렇게 생각한 이유append대신 map을 사용해서 해결을 해보려고 하였다. 그냥 map{$0} 을 해보니 type에러가 났다. 그래서 $0을 String으로 감싸서 해결하였다.그다음 suffix의 반대인 prefix를 사용하여 앞글자를 따오려고했고 그다음 joined를 통해 문자열로 바꾸었다."
  },
  
  {
    "title": "45. 접미사인지 확인하기",
    "url": "/posts/45.-%EC%A0%91%EB%AF%B8%EC%82%AC%EC%9D%B8%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-12 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String, _ is_suffix:String) -&gt; Int {        var arr : [String] = []    var my_String : String = \"\"    var answer : Int = 0        my_String = my_string...",
    "content": "import Foundationfunc solution(_ my_string:String, _ is_suffix:String) -&gt; Int {        var arr : [String] = []    var my_String : String = \"\"    var answer : Int = 0        my_String = my_string        arr.append(my_String)        if my_String.count &gt; 1 {            for i in 1...my_string.count-1{            my_String.removeFirst()            arr.append(my_String)        }    }         answer = arr.contains(is_suffix) ? 1 : 0            return answer}이렇게 생각한 이유44번에서 sort대신 배열에 해당 값이 있는지를 확인하는 contains 메서드를 사용하였다.삼항연산자를 통해 if문을 간단하려고 했다."
  },
  
  {
    "title": "44. 접미사 배열",
    "url": "/posts/44.-%EC%A0%91%EB%AF%B8%EC%82%AC-%EB%B0%B0%EC%97%B4/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-12 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String) -&gt; [String] {        var arr : [String] = []    var my_String : String = \"\"    var answer : [String] = []        my_String = my_string        a...",
    "content": "import Foundationfunc solution(_ my_string:String) -&gt; [String] {        var arr : [String] = []    var my_String : String = \"\"    var answer : [String] = []        my_String = my_string        arr.append(my_String)        if my_String.count &gt; 1 {            for i in 1...my_string.count-1{            my_String.removeFirst()            arr.append(my_String)        }    }             answer = arr.sorted(by:&lt;)           return answer}이렇게 생각한 이유.처음에는 마지막글자를 지우는거라고 생각을 하고 removeLast를 했더니 전혀 정답과 다른 결과 가나와서 봤더니 첫번째 글자가 사라지는 방식이었다.그래서 반복문을 통해 앞에 글자를 하나씩 지우면서 그것을 배열에 추가하였다.그전에 입력된 값도 들어가야하기에 먼저 추가해 주었다.그리고서 제출을하니 마지막값이 에러가나서 생각해보니 한글자 일때를 생각지 못해서 난 오류였다.그래서 my_string.count조건을 걸어서 해당 에러를 수정하였다."
  },
  
  {
    "title": "43. 문자열 뒤의 n글자",
    "url": "/posts/43.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%92%A4%EC%9D%98-n%EA%B8%80%EC%9E%90/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-12 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {        var answer : String = \"\"        var arr : [String] = []        var N : Int = 0        for string in my_string {    ...",
    "content": "import Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {        var answer : String = \"\"        var arr : [String] = []        var N : Int = 0        for string in my_string {                arr.append(String(string))            }        N = arr.count-1 - n        if N &gt; 0 {    arr.removeSubrange(0...N)        answer = arr.joined()    } else {        answer = arr.joined()    }    return answer}이렇게 생각한 이유.고민을 하다가 joined가 생각나서 해당 문자열을 배열로 전환하여 배열에서 인덱스의 범위 값을 제거하는 arr.removeSubrange(startindex … lastindex)를 통하여 제거를 한 뒤에, join을 써서 해결하였다.하지만 3문제가 틀렸는데 알고보니 N 이 무조건 0보다 클때 이 코드는 작동하는 것이었고, 그러지 않을때를 생각하지 못했다.그래서 if조건을 달아서 해결하였다.다른 코드를 보니 심플한것도 많았고, 내가 배열을 만든것을 map이라는 고차함수로 풀어내었다.이것까진 생각못했는데 다음번엔 적용해봐야겠다.다른 코드import Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {    let index = my_string.index(my_string.endIndex, offsetBy: -n)    return String(my_string[index...])}//import Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {    return String(my_string.suffix(n))}//import Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {    let index = my_string.index(my_string.startIndex, offsetBy: my_string.count - n)    return String(my_string[index...])}import Foundationfunc solution(_ my_string:String, _ n:Int) -&gt; String {    let count = my_string.count - n    var myArray = Array(my_string).map{String($0)}    myArray.removeFirst(count)    return myArray.joined(separator : \"\")}"
  },
  
  {
    "title": "42. 부분 문자열 이어 붙여 문자열 만들기 (ing)",
    "url": "/posts/42.-%EB%B6%80%EB%B6%84-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%9D%B4%EC%96%B4-%EB%B6%99%EC%97%AC-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-12 05:13:00 +0900",
    





    
    "snippet": "나의 코드이렇게 생각한 이유",
    "content": "나의 코드이렇게 생각한 이유"
  },
  
  {
    "title": "41. 배열 만들기 5(ing)",
    "url": "/posts/41.-%EB%B0%B0%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-5(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-12 05:13:00 +0900",
    





    
    "snippet": "나의 코드이렇게 생각한 이유",
    "content": "나의 코드이렇게 생각한 이유"
  },
  
  {
    "title": "103. 가위 바위 보",
    "url": "/posts/103.-%EA%B0%80%EC%9C%84-%EB%B0%94%EC%9C%84-%EB%B3%B4/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ rsp:String) -&gt; String {    var answer : String = \"\"    var arr : [String] = []    arr = rsp.map{String($0)}    for i in arr.indices{        switch arr[i] {      ...",
    "content": "import Foundationfunc solution(_ rsp:String) -&gt; String {    var answer : String = \"\"    var arr : [String] = []    arr = rsp.map{String($0)}    for i in arr.indices{        switch arr[i] {            case \"2\" : answer += \"0\"            case \"0\" : answer += \"5\"            case \"5\" : answer += \"2\"            default : answer = \"\"        }    }    return answer}삼항연산자 map 모두 생각했는데 시도를 안해봤다그냥 for문에 switch case로 해결을 했는데 다음엔 다르게 해봐야겠다.다른코드import Foundationfunc solution(_ rsp:String) -&gt; String {    return rsp.map{$0 == \"0\" ? \"5\" : $0 == \"2\" ? \"0\" : \"2\"}.joined()}"
  },
  
  {
    "title": "40. 문자열 여러 번 뒤집기",
    "url": "/posts/40.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%97%AC%EB%9F%AC-%EB%B2%88-%EB%92%A4%EC%A7%91%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ my_string:String, _ queries:[[Int]]) -&gt; String {        var startNum : Int = 0    var endNum : Int = 0    var my_String : String = \"\"        var substring :...",
    "content": "나의 코드import Foundationfunc solution(_ my_string:String, _ queries:[[Int]]) -&gt; String {        var startNum : Int = 0    var endNum : Int = 0    var my_String : String = \"\"        var substring : String = \"\"        my_String = my_string        for i in 0 ... queries.count-1 {        startNum = queries[i][0]        endNum = queries[i][1]        let range = my_String.index(my_String.startIndex, offsetBy: startNum) ... my_String.index(my_String.startIndex, offsetBy: endNum)        substring = String(my_String[range].reversed())        my_String.replaceSubrange(range, with:substring)    }    return my_String}이렇게 생각한 이유.reverse를 사용해서 범위의 값을 바꾸려고했다.하지만 구글의 힘을 빌릴 수 밖에 없었다.아래 코드를 도움을 받았다.let range = my_String.index(my_String.startIndex, offsetBy: startNum) ... my_String.index(my_String.startIndex, offsetBy: endNum)        substring = String(my_String[range].reversed())        my_String.replaceSubrange(range, with:substring)다른 코드를 보니 너무 간략하게 했다.더 열심히 공부해야겠다.다른코드import Foundationfunc solution(_ my_string:String, _ queries:[[Int]]) -&gt; String {    var my_string = Array(my_string)    queries.forEach {        my_string.replaceSubrange($0[0]...$0[1], with: Array(my_string[$0[0]...$0[1]].reversed()))    }    return String(my_string)}//import Foundationfunc solution(_ my_string:String, _ queries:[[Int]]) -&gt; String {    var myString = my_string.map { String($0) }    queries.forEach { q in        myString[q[0]...q[1]].reverse()    }    return myString.joined()}//func solution(_ myString: String, _ queries: [[Int]]) -&gt; String {    queries.reduce(myString) { acc, arr in        acc.prefix(arr[0]) + String(acc[acc.index(acc.startIndex, offsetBy: arr[0])...acc.index(acc.startIndex, offsetBy: arr[1])].reversed()) + acc.suffix(from: acc.index(acc.startIndex, offsetBy: arr[1] + 1))    }}import Foundationfunc solution(_ my_string:String, _ queries:[[Int]]) -&gt; String {    var s = my_string.map { $0 }    for q in queries {        let start = q[0]        let end = q[1]        let a = s[start...end].reversed().map { $0 }        s = s[0..&lt;start] + a + s[end + 1..&lt;s.endIndex]    }    return s.map { String($0) }.joined()}//import Foundationfunc solution(_ my_string:String, _ queries:[[Int]]) -&gt; String {    return queries.reduce(into: my_string.map { String($0) }) { result, query in        let arr = result        for index in query[0]...query[1] {            result[index] = arr[query[0] + query[1] - index]        }    }.joined()}"
  },
  
  {
    "title": "39. 9로 나눈 나머지",
    "url": "/posts/39.-9%EB%A1%9C-%EB%82%98%EB%88%88-%EB%82%98%EB%A8%B8%EC%A7%80/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ number:String) -&gt; Int {        var sum : Int = 0    var answer : Int = 0        for num in number {        sum += Int(String(num))!    }        answer = sum % 9 ...",
    "content": "import Foundationfunc solution(_ number:String) -&gt; Int {        var sum : Int = 0    var answer : Int = 0        for num in number {        sum += Int(String(num))!    }        answer = sum % 9        return answer}이렇게 생각한 이유처음에 num을 Int로 바로 형변환 하여 sum이라는 변수에 더하려고했다.하지만 num의 타입이 Character라 에러가 났다.그래서 String으로 형변환을 한 뒤, 다시 Int로 재변환을 시도 하였고, 형변환을 할때마다 optional에러가 나므로 !을 추가하여 unwrapping해주었다.그 이후, 나머지를 구하는 %를 통해 나머지값을 리턴하였다."
  },
  
  {
    "title": "38. 글자 이어 붙여 문자열 만들기",
    "url": "/posts/38.-%EA%B8%80%EC%9E%90-%EC%9D%B4%EC%96%B4-%EB%B6%99%EC%97%AC-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ my_string:String, _ index_list:[Int]) -&gt; String {        var answer : String = \"\"        for i in 0 ... index_list.count-1{        answer += String(my_strin...",
    "content": "나의 코드import Foundationfunc solution(_ my_string:String, _ index_list:[Int]) -&gt; String {        var answer : String = \"\"        for i in 0 ... index_list.count-1{        answer += String(my_string[String.Index(encodedOffset: index_list[i])])    }        return answer}이렇게 생각한 이유특정 index의 문자열을 추출하는 encodedOffset을 사용하여 해결하였다.String으로 감싸지 않고 돌렸더니 타입에러가 나서(character로 되어있었다) 그래서 String 으로 감싸서 해결하였다."
  },
  
  {
    "title": "37. 주사위 게임 3 (ing)",
    "url": "/posts/37.-%EC%A3%BC%EC%82%AC%EC%9C%84-%EA%B2%8C%EC%9E%84-3-(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드이렇게 생각한 이유",
    "content": "나의 코드이렇게 생각한 이유"
  },
  
  {
    "title": "36. 간단한 논리 연산",
    "url": "/posts/36.-%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%85%BC%EB%A6%AC-%EC%97%B0%EC%82%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ x1:Bool, _ x2:Bool, _ x3:Bool, _ x4:Bool) -&gt; Bool {        var answer : Bool = true        answer = (x1||x2) &amp;&amp; (x3||x4)        return answer}이렇게 생각...",
    "content": "나의 코드import Foundationfunc solution(_ x1:Bool, _ x2:Bool, _ x3:Bool, _ x4:Bool) -&gt; Bool {        var answer : Bool = true        answer = (x1||x2) &amp;&amp; (x3||x4)        return answer}이렇게 생각한 이유.진리표를 보니 ∨는 OR ∧는 AND를 표현한다는 것을 알 수 있었다.그래서 문제의 기호를 논리연산자로 표현하였다.AND : &amp;&amp;OR : ||"
  },
  
  {
    "title": "33. 카운트 업",
    "url": "/posts/33.-%EC%B9%B4%EC%9A%B4%ED%8A%B8-%EC%97%85/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ start_num:Int, _ end_num:Int) -&gt; [Int] {        var answer : [Int] = []        for i in start_num ... end_num {        answer.append(i)    }        return a...",
    "content": "나의 코드import Foundationfunc solution(_ start_num:Int, _ end_num:Int) -&gt; [Int] {        var answer : [Int] = []        for i in start_num ... end_num {        answer.append(i)    }        return answer}이렇게 생각한 이유.반복문을 통해 start~end로 범위를 잡고 그때의 i값을 append를 통해 추가하였다."
  },
  
  {
    "title": "32. 배열 만들기 2(ing)",
    "url": "/posts/32.-%EB%B0%B0%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-2(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드이렇게 생각한 이유",
    "content": "나의 코드이렇게 생각한 이유"
  },
  
  {
    "title": "31. 수열과 구간 쿼리 4(ing)",
    "url": "/posts/31.-%EC%88%98%EC%97%B4%EA%B3%BC-%EA%B5%AC%EA%B0%84-%EC%BF%BC%EB%A6%AC-4(ing)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류중",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드",
    "content": "나의 코드"
  },
  
  {
    "title": "30. 수열과 구간 쿼리 2 (fin)",
    "url": "/posts/30.-%EC%88%98%EC%97%B4%EA%B3%BC-%EA%B5%AC%EA%B0%84-%EC%BF%BC%EB%A6%AC-2-(fin)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류했던문제",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {        var answer : [Int] = []    var Arr : [Int] = []        //print(queries.count)        for i in 0 ... queries....",
    "content": "나의 코드import Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {        var answer : [Int] = []    var Arr : [Int] = []        //print(queries.count)        for i in 0 ... queries.count-1 {        answer.append(arr[queries[i][0] ... queries[i][1]].filter {             element in guard element &gt; queries[i][2] else {                 return false }                 return true }.min() ?? -1)}        return answer    }예외조건에서 잘 안되어서 결국 이것저것 검색하면서 해결하였다.다른 코드들을 보니 optional chaining을 통해서 푼것같은데.이글을 적고 바로 정리를 해야겠다.다른코드import Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {    return queries.map {         let (s, e, k) = ($0[0], $0[1], $0[2])        return Array(arr[s...e]).filter { $0 &gt; k }.min() ?? -1    }}//func solution(_ arr: [Int], _ queries: [[Int]]) -&gt; [Int] {    return queries.map { q in        let min = arr[q[0]...q[1]].filter { $0 &gt; q[2] }.min() ?? -1        return min == Int.max ? -1 : min    }}//import Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {    return queries.map { element in        arr[element[0]...element[1]].filter { $0 &gt; element[2] }.min() ?? -1    }}"
  },
  
  {
    "title": "29. 수열과 구간 쿼리 3",
    "url": "/posts/29.-%EC%88%98%EC%97%B4%EA%B3%BC-%EA%B5%AC%EA%B0%84-%EC%BF%BC%EB%A6%AC-3/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {        var temp : Int = 0    var Arr : [Int] = []        Arr = arr        for i in 0 ... queries.count-1 {        t...",
    "content": "나의 코드import Foundationfunc solution(_ arr:[Int], _ queries:[[Int]]) -&gt; [Int] {        var temp : Int = 0    var Arr : [Int] = []        Arr = arr        for i in 0 ... queries.count-1 {        temp = Arr[queries[i][0]]        Arr[queries[i][0]] = Arr[queries[i][1]]        Arr[queries[i][1]] = temp    }        return Arr}이렇게 생각한 이유.2차원 배열의 길이만큼 반복을 하기에 2차원 배열의 길이를 구했으며, 그 다음 값을 서로 바꿔치기를 해야하므로 하나의 값을 잠시 담아둘 변수 temp를 만들었다.그리고나서 2차원 배열의 행은 움직이고 열은 0,1 두개밖에 없으므로 i를 하나만 했고, 위치를 바꿔 가며 배열을 변화를 주었다."
  },
  
  {
    "title": "28. 수 조작하기 2",
    "url": "/posts/28.-%EC%88%98-%EC%A1%B0%EC%9E%91%ED%95%98%EA%B8%B0-2/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ numLog:[Int]) -&gt; String {        var answer : String = \"\"        for i in 0 ... numLog.count-2 {                switch numLog[i+1] - numLog[i] {            ...",
    "content": "나의 코드import Foundationfunc solution(_ numLog:[Int]) -&gt; String {        var answer : String = \"\"        for i in 0 ... numLog.count-2 {                switch numLog[i+1] - numLog[i] {            case 1 :                answer += \"w\"            case -1 :                answer += \"s\"            case 10 :                answer += \"d\"            case -10 :                answer += \"a\"            default :            \"\"        }    }        return answer}이렇게 생각한 이유.수 조작하기 1의 역으로 된 문제여서 비슷하게 풀었다.다만 numLog.count-2를 한 이유는 인덱스를 i로 하면 i+1 - i 로 해야하기때문에 실제 배열길이로 하게되면 out of range에러가 나기에 count-2로 해결하였다."
  },
  
  {
    "title": "27. 수 조작하기 1",
    "url": "/posts/27.-%EC%88%98-%EC%A1%B0%EC%9E%91%ED%95%98%EA%B8%B0-1/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ n:Int, _ control:String) -&gt; Int {        var N : Int = 0    N = n        for i in control {                switch i {                        case \"w\" :     ...",
    "content": "나의 코드import Foundationfunc solution(_ n:Int, _ control:String) -&gt; Int {        var N : Int = 0    N = n        for i in control {                switch i {                        case \"w\" :                N = N+1            case \"a\" :                N = N-10            case \"s\" :                N = N-1            case \"d\" :                N = N+10            default :                 \"\"         }            }    return N}이렇게 생각한 이유.wasd의 조건을 보고 해당 문제는 if보다는 switch case문이 더 잘어울릴것이라고 판단했다.그래서 switch 문만 쓰고 돌리려고하니 틀려서 생각해보니 control은 문자열이었다.그래서 반복문을 통해서 문자열을 분해하지않고 i로 하나씩 돌려서 값을 처리하였다."
  },
  
  {
    "title": "26. 마지막 두 원소",
    "url": "/posts/26.-%EB%A7%88%EC%A7%80%EB%A7%89-%EB%91%90-%EC%9B%90%EC%86%8C/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {        var `count` : Int = 0    var answer : [Int] = []        answer = num_list        count = answer.count-1        if answer[c...",
    "content": "나의 코드import Foundationfunc solution(_ num_list:[Int]) -&gt; [Int] {        var `count` : Int = 0    var answer : [Int] = []        answer = num_list        count = answer.count-1        if answer[count] &gt; answer[count-1] {                answer.append(answer[count] - answer[count-1])            } else {        answer.append(answer[count]*2)    }        return answer    }이렇게 생각한 이유.count메서드를 이용하여 배열의 길이를 알아내고 그것의 -1을 한값이 배열의 마지막 값이므로, count라는 변수를 만들었다.이때 `` 백틱을 사용하면 키워드 그대로 변수를 사용 할수있기에 이것을 써보려고 그대로 했다.그래서 마지막 값을 접근했고 변수 count-1이 마지막의 전 인덱스이므로 if문을 통해 값을 비교하였고 append를 사용하여 배열에 값을 추가하였다."
  },
  
  {
    "title": "25. 이어 붙인 수",
    "url": "/posts/25.-%EC%9D%B4%EC%96%B4-%EB%B6%99%EC%9D%B8-%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {        var answer : Int = 0    var sum1 : String = \"\"    var sum2 : String = \"\"        var even = num_list.filter{$0 % 2 == 0}    v...",
    "content": "나의 코드import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {        var answer : Int = 0    var sum1 : String = \"\"    var sum2 : String = \"\"        var even = num_list.filter{$0 % 2 == 0}    var odd = num_list.filter{$0 % 2 != 0}        for i in 0 ... even.count-1 {        sum1 += String(even[i])    }        for i in 0 ... odd.count-1 {        sum2 += String(odd[i])    }        answer = Int(sum1)! + Int(sum2)!        return answer}이렇게 생각한 이유.홀수를 나타내는 odd, 짝수를 나타내는 even이라는 배열을 만들어서 고차함수인 filter를 사용해 num_list안에 있는 value값이 짝수, 홀수인지를 구분하여 각각 담기게 하였다.그다음으로 생각을 했떤부분이 이것을 문자열로 변환하여 하나로 붙이는것인데. 현재 나의 지식으로는 for문을 통해 각각의 value를 String으로 더하여 합쳤다.그리고나서 다시 Int형변환을 하여 해결하였다.이때 옵셔널 컴파일 에러가 떠서 unwrapping해주어 답을 도출하였다.다른 코드를 보니 joined라는 메서드를 이용하여 간단하게 구했다.import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {    let even = Int(num_list.filter { $0 % 2 == 0 }.map { String($0) }.joined())!    let odd = Int(num_list.filter { $0 % 2 != 0 }.map { String($0) }.joined())!    return even + odd}배열에서 문자열로 하나로 만들때 joined를 사용한다.joined(separator:) 사용let arr = [\"A\", \"B\", \"C\", \"D\"]let result = arr.joined(separator: \" \")print(result) // \"A B C D\"가독성 면에서도 좋고, separator를 직접 지정할 수 있다.또한, 문자열 끝에 원치 않는 whitespace가 생기는 것도 방지할 수 있다."
  },
  
  {
    "title": "24. 원소들의 곱과 합",
    "url": "/posts/24.-%EC%9B%90%EC%86%8C%EB%93%A4%EC%9D%98-%EA%B3%B1%EA%B3%BC-%ED%95%A9/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {        var sum : Int = 0    var summul : Int = 0    var mul : Int = 0    var answer : Int = 0        sum = num_list.reduce(0,+)    ...",
    "content": "나의 코드import Foundationfunc solution(_ num_list:[Int]) -&gt; Int {        var sum : Int = 0    var summul : Int = 0    var mul : Int = 0    var answer : Int = 0        sum = num_list.reduce(0,+)    summul = sum * sum    mul = num_list.reduce(1,*)        answer = mul &lt; summul ? 1 : 0        return answer}이렇게 생각한 이유.합을 고차함수인 reduce를 써서 한번 해보았다.굳이 반복문을 하지않기에 간략하게 표현이 가능했다.다만 곱을 표현할때 합처럼 ()안에 0으로 해보니 곱이 계속 0이 나와서 확인해보니 괄호안의 첫번째 parameter가 0이어서 계속 0을 곱하기에 답이 계속 0이 나왔던것이었다.에러를 해결하고나서 삼항연산자를 씀으로써 if문 또한 간략하게 표현했다.이렇게 해보면서 reduce는 조금씩 감이 오는것같다.다음에는 reduce의 다른 표현으로 해봐야겠다."
  },
  
  {
    "title": "23. 주사위 게임 2",
    "url": "/posts/23.-%EC%A3%BC%EC%82%AC%EC%9C%84-%EA%B2%8C%EC%9E%84-2/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ a:Int, _ b:Int, _ c:Int) -&gt; Int {        var answer : Int = 0        if a != b &amp;&amp; b != c &amp;&amp; c != a {                answer = a + b + c      ...",
    "content": "나의 코드import Foundationfunc solution(_ a:Int, _ b:Int, _ c:Int) -&gt; Int {        var answer : Int = 0        if a != b &amp;&amp; b != c &amp;&amp; c != a {                answer = a + b + c            } else if a == b &amp;&amp; b == c {                answer = (a + b + c) * (a*a + b*b + c*c) * (a*a*a + b*b*b + c*c*c)            } else {                answer = (a + b + c) * (a*a + b*b + c*c)            }        return answer}이렇게 생각한 이유.단순히 if 조건을 통해서 해결하였다.모두 다를때, 모두 같을때 만 if조건에 명시를 하면, 2번째 조건은 굳이 서술할 이유가 없기에 위와 같이 표현하였다.처음에는 제곱수라서 pow를 사용해서 해결하려고 했는데 Decimal이 들어가야하는 컴파일 에러가 발생하여 aa / aa*a 이런식으로 그냥 표현하였다."
  },
  
  {
    "title": "22. 등차수열의 특정한 항만 더하기",
    "url": "/posts/22.-%EB%93%B1%EC%B0%A8%EC%88%98%EC%97%B4%EC%9D%98-%ED%8A%B9%EC%A0%95%ED%95%9C-%ED%95%AD%EB%A7%8C-%EB%8D%94%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ a:Int, _ d:Int, _ included:[Bool]) -&gt; Int {        var arr : [Int] = []    var answer : Int = 0        for i in 0 ... included.count-1 {                arr....",
    "content": "나의 코드import Foundationfunc solution(_ a:Int, _ d:Int, _ included:[Bool]) -&gt; Int {        var arr : [Int] = []    var answer : Int = 0        for i in 0 ... included.count-1 {                arr.append(a + i*d)            }        for i in 0 ... included.count-1 {        if included[i] == true {            answer += arr[i]        }    }    return answer}이렇게 생각한 이유.먼저 Int타입을 가지는 배열 arr을 생성하여, 해당 배열에 등차수열의 값을 집어넣었다.어차피 included의 길이 만큼 arr이 생성되기에, arr.count와 included.count가 같고그에 해당하는 index 또한 같기때문에 또다른 for문을 생성하여 included를 중심으로 true일때 더해서 해결을 하려고하였다."
  },
  
  {
    "title": "21. 코드 처리하기 (fin)",
    "url": "/posts/21.-%EC%BD%94%EB%93%9C-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0-(fin)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류했던문제",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "import Foundationfunc solution(_ code:String) -&gt; String {        var mode : Int = 0    var ret : String = \"\"    var count : Int = 0    var arr = code.map{String($0)}.enumerated().map{$0}        ...",
    "content": "import Foundationfunc solution(_ code:String) -&gt; String {        var mode : Int = 0    var ret : String = \"\"    var count : Int = 0    var arr = code.map{String($0)}.enumerated().map{$0}        var i : Int = 0        count = arr.count-1        while i &lt;= count {        if mode == 0 {            if arr[i].element != \"1\" &amp;&amp; arr[i].offset%2 == 0{                ret += arr[i].element            } else if arr[i].element == \"1\" {                mode = 1            }         } else {            if arr[i].element != \"1\" &amp;&amp; arr[i].offset%2 != 0{                ret += arr[i].element            } else if arr[i].element == \"1\" {                mode = 0            }        }        i+=1    }        if ret == \"\" {        ret=\"EMPTY\"    }       return ret}처음에는 이걸 어떻게 풀어야하나 멍했는데, 일단 보류를 하고 다시 하나하나 생각을 해보았다.일단 mode가 0/1 이라는 큰 조건아래 세부조건사항이 있었다.그리고 code의 index가 필요하여, string의 index보다 dictionary형식으로 만들어 처리하는게 나한테는 더 편해서 enumerated를 써서 offset,element 형식의 딕셔너리로 만들어 주었다.그리고나서 큰틀로 0,1일때를 설정하고그다음 o인상태에서 1일때 그리고 홀수 인덱스일때를 하여 문자열을 추가, 모드 변경등 내용을 넣었다.마지막에 if 문을 추가하지않았을때 12,13케이스가 계속 실패가 떴다. 알고보니이부분에 대한 조건을 하지 않았다.빈문자열이라고해서 “ “ 라고 생각했는데,”” 인 경우였다.그래서 그냥 if문을 써서 해결했는데.isEmpty로 정리하는게 더 이쁜거같다."
  },
  
  {
    "title": "20. flag에 따라 다른 값 반환하기.",
    "url": "/posts/20.-flag%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%8B%A4%EB%A5%B8-%EA%B0%92-%EB%B0%98%ED%99%98%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ a:Int, _ b:Int, _ flag:Bool) -&gt; Int {        var answer = 0        answer = flag == true ? a + b : a - b        return answer}이렇게 생각한 이유.flag가 Bool 타입이어서 삼항...",
    "content": "나의 코드import Foundationfunc solution(_ a:Int, _ b:Int, _ flag:Bool) -&gt; Int {        var answer = 0        answer = flag == true ? a + b : a - b        return answer}이렇게 생각한 이유.flag가 Bool 타입이어서 삼항연산자를 통해 간락하게 표현을 해보았다.그래서 flag가 true일때는 + false일 때는 -로 표현하여 답을 구하였다.요새 간단한 if문을 삼항연산자로 해결하려고 하는데 확실히 자주 쓰다보니 익숙해지는듯하다."
  },
  
  {
    "title": "19. 조건 문자열 (fin)",
    "url": "/posts/19.-%EC%A1%B0%EA%B1%B4-%EB%AC%B8%EC%9E%90%EC%97%B4-(fin)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류했던문제",
    "date": "2024-02-11 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ ineq:String, _ eq:String, _ n:Int, _ m:Int) -&gt; Int {        var sent : String = \"\"    var answer : Int = 0        if ineq == \"&gt;\"{       if eq == \"=\" {   ...",
    "content": "나의 코드import Foundationfunc solution(_ ineq:String, _ eq:String, _ n:Int, _ m:Int) -&gt; Int {        var sent : String = \"\"    var answer : Int = 0        if ineq == \"&gt;\"{       if eq == \"=\" {           if n &gt;= m {               answer = 1           } else {               answer = 0           }       } else {           if  n &gt; m {               answer = 1           } else {               answer = 0           }       }    } else {         if eq == \"=\" {           if n &lt;= m {               answer = 1           } else {               answer = 0           }       } else {           if  n &lt; m {               answer = 1           } else {               answer = 0           }       }           }               return answer}이렇게 생각한 이유.처음에는 문자열 그대로 받아서 string으로 해서 해보려고했으나 생각보다 절차가 어려운것 같아다중 if문을 사용하게 되었다.(해결)대부분 에러가 났던이유. if문의 매개변수를 ineq가 아니라 eq를 기준으로 했었다.그랬더니 반례 2,3 일때 결과를 잘못 리턴하는것을 보았다.그래서 어느 인자를 먼저 받아서 처리를 하나 매개변수 순서를 보니.ineq가 먼저 들어왔다. 그래서 if 문의 매개변수를 ineq로 먼저 하였고 푸니 해결이 되었다.해당문제를 삼항연산자로 간단하게 하려고 했을때 더 오히려 안되었다보니 기본으로 돌아가서 확실하게 풀어보자라는 생각으로 if문을 쭉 나열하여 풀었다.if문으로 문제를 풀었으니 해당문제를 삼항연산자로 한번 해봐야겠다.아래는 삼항연산자로 코드를 적어보았다.확실히 if문으로 먼저 풀어쓴다음, 삼항연산자로 정리를 해보니 에러가 안나고 깔끔했다.import Foundationfunc solution(_ ineq:String, _ eq:String, _ n:Int, _ m:Int) -&gt; Int {        var answer : Int = 0        answer = ineq == \"&gt;\" ? (eq == \"=\" ? (n &gt;= m ? 1: 0) : (n &gt; m ? 1: 0)): (eq == \"=\" ? (n &lt;= m ? 1: 0 ) : (n &lt; m ? 1 : 0 ))        return answer}다른코드르 보니 switch case로 아주 간단하게 했다.왜 이렇게 생각을 못했는지 좀 한심하게 느껴지긴한다.import Foundationfunc solution(_ ineq:String, _ eq:String, _ n:Int, _ m:Int) -&gt; Int {    switch ineq+eq {        case \"&gt;=\": return n &gt;= m ? 1 : 0        case \"&lt;=\": return n &lt;= m ? 1 : 0        case \"&gt;!\": return n &gt; m ? 1 : 0        case \"&lt;!\": return n &lt; m ? 1 : 0        default: return 0    }}"
  },
  
  {
    "title": "18. 홀짝에 따라 다른 값 반환하기",
    "url": "/posts/18.-%ED%99%80%EC%A7%9D%EC%97%90-%EB%94%B0%EB%9D%BC-%EB%8B%A4%EB%A5%B8-%EA%B0%92-%EB%B0%98%ED%99%98%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-10 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer = 0       if n % 2 == 0 {            for i in 1 ... n {                if i % 2 == 0 {                    print (i)       ...",
    "content": "나의 코드import Foundationfunc solution(_ n:Int) -&gt; Int {        var answer = 0       if n % 2 == 0 {            for i in 1 ... n {                if i % 2 == 0 {                    print (i)                    answer += i * i                                   }            }        } else {            for i in 1 ... n {                if i % 2 != 0 {                     print (i)                    answer += i                 }            }        }        return answer}이렇게 생각한 이유.일단 if문을 통해서 풀었다.swich case문으로도 가능한데 일단은 이렇게 풀었다.나중에 내가 다시 이문제를 리마인드할땐 swich case로 풀어봐야겠다."
  },
  
  {
    "title": "17. 공배수",
    "url": "/posts/17.-%EA%B3%B5%EB%B0%B0%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-09 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ number:Int, _ n:Int, _ m:Int) -&gt; Int {        var answer = 0        answer = number % n == 0 &amp;&amp; number % m == 0 ? 1 : 0        return answer}이렇게 생각한...",
    "content": "나의 코드import Foundationfunc solution(_ number:Int, _ n:Int, _ m:Int) -&gt; Int {        var answer = 0        answer = number % n == 0 &amp;&amp; number % m == 0 ? 1 : 0        return answer}이렇게 생각한 이유.16번과 유사하지만 m의 배수도 만족해야하는 조건이었기에, 삼항연산자의 조건에서  and인 &amp;&amp;를 붙였다."
  },
  
  {
    "title": "16. n의 배수",
    "url": "/posts/16.-n%EC%9D%98-%EB%B0%B0%EC%88%98/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-09 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ num:Int, _ n:Int) -&gt; Int {        var answer = 0        answer = num % n == 0 ? 1 : 0        return answer}이렇게 생각한 이유.n의 배수이므로 num을 n으로 나눴을때 무조건 나머지가 0이 되어야...",
    "content": "나의 코드import Foundationfunc solution(_ num:Int, _ n:Int) -&gt; Int {        var answer = 0        answer = num % n == 0 ? 1 : 0        return answer}이렇게 생각한 이유.n의 배수이므로 num을 n으로 나눴을때 무조건 나머지가 0이 되어야 한다.그래서 삼항연산자를 통해 간략하게 표현을 했다."
  },
  
  {
    "title": "15. 두 수의 연산값 비교하기",
    "url": "/posts/15.-%EB%91%90-%EC%88%98%EC%9D%98-%EC%97%B0%EC%82%B0%EA%B0%92-%EB%B9%84%EA%B5%90%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-09 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ a:Int, _ b:Int) -&gt; Int {        var answer : Int = 0        answer = Int(String(a) + String(b))! &gt; 2*a*b ? Int(String(a) + String(b))! : 2*a*b        ret...",
    "content": "나의 코드import Foundationfunc solution(_ a:Int, _ b:Int) -&gt; Int {        var answer : Int = 0        answer = Int(String(a) + String(b))! &gt; 2*a*b ? Int(String(a) + String(b))! : 2*a*b        return answer}이렇게 생각한 이유.14번 문제와 너무 같아서 생략하겠다."
  },
  
  {
    "title": "14. 더 크게 합치기",
    "url": "/posts/14.-%EB%8D%94-%ED%81%AC%EA%B2%8C-%ED%95%A9%EC%B9%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-09 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ a:Int, _ b:Int) -&gt; Int {            var answer : Int = 0        answer = Int(String(a)+String(b))! &gt; Int(String(b)+String(a))! ? Int(String(a)+String(b))...",
    "content": "나의 코드import Foundationfunc solution(_ a:Int, _ b:Int) -&gt; Int {            var answer : Int = 0        answer = Int(String(a)+String(b))! &gt; Int(String(b)+String(a))! ? Int(String(a)+String(b))! : Int(String(b)+String(a))!        return answer}이렇게 생각한 이유.일단 연산 ⊕ 이 두 정수를 붙여서 쓴다는 것을 알고 a,b를 String으로 변환 후 붙인다음 다시 Int로 변형하였다.그리고 실행을 하였을때 아래와 같은 optional 이 있을 수 있다는 컴파일 에러가 나오므로 !를 통해 Unwrapping을 하였다.그리고 if문을 쓰려다가, 삼항연산자를 다시 Remind하기 위해 삼항연산자로 해당문제를 풀었다."
  },
  
  {
    "title": "13. 문자열 곱하기",
    "url": "/posts/13.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B3%B1%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-09 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ my_string:String, _ k:Int) -&gt; String {        var answer : String = \"\"        for i in 0 ... k-1 {        answer += my_string    }        return answer}이렇게 ...",
    "content": "나의 코드import Foundationfunc solution(_ my_string:String, _ k:Int) -&gt; String {        var answer : String = \"\"        for i in 0 ... k-1 {        answer += my_string    }        return answer}이렇게 생각한 이유.12번과 거의 같은 문제라고 판단했다.다만 12번은 반복문에서 i값을 answer에 누적시켜서 했다면, 이번에는 반복문 안에서 그냥 my_string이라는 외부의 변수로 가져왔다는 차이 밖에 없다."
  },
  
  {
    "title": "12. 문자 리스트를 문자열로 반환하기",
    "url": "/posts/12.-%EB%AC%B8%EC%9E%90-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EB%AC%B8%EC%9E%90%EC%97%B4%EB%A1%9C-%EB%B0%98%ED%99%98%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-09 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ arr:[String]) -&gt; String {        var answer : String = \"\"        for i in arr {        answer += i    }        return answer}이렇게 생각한 이유.반복문을 돌려서 answer라는 변수...",
    "content": "나의 코드import Foundationfunc solution(_ arr:[String]) -&gt; String {        var answer : String = \"\"        for i in arr {        answer += i    }        return answer}이렇게 생각한 이유.반복문을 돌려서 answer라는 변수에 누적하였다.정수는 계속 더해지지만 문자는 이어서 붙이게 된다."
  },
  
  {
    "title": "11. 문자열 섞기 (fin)",
    "url": "/posts/11.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%84%9E%EA%B8%B0-(fin)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류했던문제",
    "date": "2024-02-08 00:00:00 +0900",
    





    
    "snippet": "나의 코드 beforeimport Foundationfunc solution(_ str1:String, _ str2:String) -&gt; String {            var answer : String = \"\"        var string : String = \"\"        string = String(str1[str1.startInd...",
    "content": "나의 코드 beforeimport Foundationfunc solution(_ str1:String, _ str2:String) -&gt; String {            var answer : String = \"\"        var string : String = \"\"        string = String(str1[str1.startIndex]) + String(str2[str2.startIndex])        for i in 0 ... str1.count-1 {        answer += string    }        return answer}이렇게 생각한 이유.각 문자열의 첫번째를 추출해서 반복문을 통해 더했다. 하지만 채점하니 대부분이 틀렸다.반례가 있었다.너무 단순하게 1글자가 반복된다고 생각을 해버렸다.개선 한 코드import Foundationfunc solution(_ str1:String, _ str2:String) -&gt; String {            var answer : String = \"\"    var ansarr : [String] = []    var arr : [String] = []    var arr1 : [String] = []        arr = str1.map{String($0)}    arr1 = str2.map{String($0)}        for i in arr.indices{        ansarr.append(arr[i])        ansarr.append(arr1[i])    }        answer = ansarr.joined()        return answer}결국 배열로 접근하여 문제를 풀었다.아마 이당시에는 배열로 전환하는 생각을 아예 못했던거같다.import Foundationfunc solution(_ str1:String, _ str2:String) -&gt; String {    return zip(str1, str2).map { String($0) + String($1) }.joined()}//import Foundationfunc solution(_ str1:String, _ str2:String) -&gt; String {    var result: String = \"\"    for (one, two) in zip(str1, str2) {        result.append(one)        result.append(two)    }    return result}zip으로 간단하게 한걸 볼수있었다. zip은 아예생각지도 못했다.서술하지 않은 다른 코드들도 대부분 배열로 접근하여 풀었다."
  },
  
  {
    "title": "10. 문자열 겹쳐쓰기 (fin)",
    "url": "/posts/10.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B2%B9%EC%B3%90%EC%93%B0%EA%B8%B0-(fin)/",
    "categories": "코딩테스트",
    "tags": "코딩테스트, 보류했던문제",
    "date": "2024-02-08 00:00:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ my_string:String, _ overwrite_string:String, _ s:Int) -&gt; String {        var answer : String = \"\"    var arr : [String] = []    var arr1 : [String] = []    ...",
    "content": "나의 코드import Foundationfunc solution(_ my_string:String, _ overwrite_string:String, _ s:Int) -&gt; String {        var answer : String = \"\"    var arr : [String] = []    var arr1 : [String] = []    var n : Int = 0        arr = my_string.map{String($0)}    arr1 = overwrite_string.map{String($0)}        n = arr1.count + s-1        for i in s ... n {        arr[i] = arr1[i-s]    }        answer = arr.joined()    return answer}뒤로 미뤘던.문자열에 index로 간단하게 접근을 해보려고 했으나 그게 되지 않아서 이것저것 찾아보게 되었다.index는 별도로 정리 하였음.Retry어떻게 풀어볼것인가?  정수 s 부터 overwrite_string.count 까지의 범위로 접근.1-1. string자체를 slicing하여 가능한지 도전-&gt; 검색해보니 replacingOccurrences(of:with:)를 사용하여 간단하게 해결이 가능해보인다. 최근에 이런 메서드를 사용해서 푼 코드를 본것같은데 이번참에 한번 써봐야겠다.    let sampleStr = \"12345\"let newStr = sampleStr.replacingOccurrences(of: \"2\", with: \"vv\")print(newStr) // 1vv345        -&gt; 해당문제가 3번같은 예시일때 에러가 생겼다.```swiftimport Foundation  func solution(_ my_string:String, _ overwrite_string:String, _ s:Int) -&gt; String {var answer : String = \"\"var o : String = \"\"var start = my_string.index(my_string.startIndex, offsetBy:s) var end = my_string.index(my_string.startIndex, offsetBy:overwrite_string.count+s) o = my_string.substring(with: start..&lt;end)answer = my_string.replacingOccurrences(of:o, with: overwrite_string)return answer}그게안될경우.2. my_string과 overwrite_string을 배열로 바꾸어서 치환결국 배열로 접근하여 문제를 풀었다.---다른코드```swiftimport Foundationfunc solution(_ myString: String, _ overwriteString: String, _ s: Int) -&gt; String {    var myString = Array(myString)    myString.replaceSubrange(s...(overwriteString.count+s-1), with: Array(overwriteString))    return String(myString)}//import Foundationfunc solution(_ my_string:String, _ overwrite_string:String, _ s:Int) -&gt; String {    let a = my_string.prefix(s)    let b = overwrite_string    let c = my_string.suffix(my_string.count - overwrite_string.count - s)    return a + b + c}//import Foundationfunc solution(_ my_string:String, _ overwrite_string:String, _ s:Int) -&gt; String {    return String(my_string.prefix(s))+overwrite_string+String(my_string.suffix(my_string.count-overwrite_string.count-s))}"
  },
  
  {
    "title": "35. 배열 만들기 4",
    "url": "/posts/35.-%EB%B0%B0%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0-4/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-07 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ arr:[Int]) -&gt; [Int] {        var i : Int = 0    var stk : [Int] = []        while i &lt; arr.count {                if stk.count == 0 {                     ...",
    "content": "나의 코드import Foundationfunc solution(_ arr:[Int]) -&gt; [Int] {        var i : Int = 0    var stk : [Int] = []        while i &lt; arr.count {                if stk.count == 0 {                        stk.append(arr[i])            i = i+1             } else if stk.count != 0 &amp;&amp; stk[stk.count-1] &lt; arr[i] {            stk.append(arr[i])            i = i+1        } else {            stk.removeLast()        }            }        return stk}이렇게 생각한 이유i가 arr의 길이보다 작을때 까지 계속 돌아가야하기에 while문을 사용하였다.그다음 if 조건으로 stk 배열에 값을 추가를 하였다.배열의 마지막값을 비교해야 하는데 lastIndex를 그대로 썼다가 에러가 발생하여 그냥 count를 통하여 에러를 수정했다."
  },
  
  {
    "title": "34. 콜라츠 수열 만들기",
    "url": "/posts/34.-%EC%BD%9C%EB%9D%BC%EC%B8%A0-%EC%88%98%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-07 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationfunc solution(_ n:Int) -&gt; [Int] {        var N : Int = 0    var answer : [Int] = []    N = n        answer.append(N)        while N != 1 {        if N % 2 == 0 {           ...",
    "content": "나의 코드import Foundationfunc solution(_ n:Int) -&gt; [Int] {        var N : Int = 0    var answer : [Int] = []    N = n        answer.append(N)        while N != 1 {        if N % 2 == 0 {            N = N/2            answer.append(N)        } else {            N = (3*N)+1            answer.append(N)        }    }        return answer}이렇게 한 이유while문을 통해 N값이 1이 될때까지 무한 반복을 하게끔했다.그러면서 N값을 주어진 조건에따라 변화하고 배열에 추가하면서 풀었다.처음에 오답이나와서 내답과 결과값을 비교해보니, 초기값을 추가하지 않아서 발생한 오답이었다.그래서 위에 초기값을 추가하고서 해결을 하였다."
  },
  
  {
    "title": "9. 홀짝 구분하기",
    "url": "/posts/9.-%ED%99%80%EC%A7%9D-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-07 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationlet a = Int(readLine()!)!var str : String = \"\"if a % 2 == 0 {    str = \"is even\"} else {    str = \"is odd\"}print(\"\\(a) \\(str)\")이렇게 했지만 삼항연산자로도 될것같다.import Foundationlet a = In...",
    "content": "나의 코드import Foundationlet a = Int(readLine()!)!var str : String = \"\"if a % 2 == 0 {    str = \"is even\"} else {    str = \"is odd\"}print(\"\\(a) \\(str)\")이렇게 했지만 삼항연산자로도 될것같다.import Foundationlet a = Int(readLine()!)!var str : String = \"\"str = a % 2 == 0 ? \"is even\" : \"is odd\"print(\"\\(a) \\(str)\")"
  },
  
  {
    "title": "8. 문자열 돌리기",
    "url": "/posts/8.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8F%8C%EB%A6%AC%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-07 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationlet s1 = readLine()!for s in s1 {    print(s)}적을 내용이 없다. 이것도 다른 표현이 있어 적어둔다.import Foundationprint(readLine()!.map { String($0) }.joined(separator: \"\\n\"))//import Foundationgu...",
    "content": "나의 코드import Foundationlet s1 = readLine()!for s in s1 {    print(s)}적을 내용이 없다. 이것도 다른 표현이 있어 적어둔다.import Foundationprint(readLine()!.map { String($0) }.joined(separator: \"\\n\"))//import Foundationguard let s1 = readLine() else { fatalError() }s1.forEach { print($0) }//import Foundationlet s1 = readLine()!s1.map { print($0) }//Array(readLine()!).forEach{ print($0) }//import Foundationlet s1 = readLine()!for i in 0...s1.length - 1  {    print(\"\\(s1[String.Index(encodedOffset: i)])\")}"
  },
  
  {
    "title": "7. 문자열 붙여서 출력하기",
    "url": "/posts/7.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%B6%99%EC%97%AC%EC%84%9C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-07 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationlet inp = readLine()!.components(separatedBy: [\" \"]).map { $0 }let (s1, s2) = (inp[0], inp[1])var answer : String = \"\"answer = s1+s2print(answer)딱히 적을건 없다.다만 역시 이것도 다른 표현이 있어 ...",
    "content": "나의 코드import Foundationlet inp = readLine()!.components(separatedBy: [\" \"]).map { $0 }let (s1, s2) = (inp[0], inp[1])var answer : String = \"\"answer = s1+s2print(answer)딱히 적을건 없다.다만 역시 이것도 다른 표현이 있어 적어둔다.import Foundationprint(readLine()!.split(separator: \" \").map { String($0) }.joined())"
  },
  
  {
    "title": "6. 덧셈식 출력하기",
    "url": "/posts/6.-%EB%8D%A7%EC%85%88%EC%8B%9D-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-07 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationlet n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! }let (a, b) = (n[0], n[1])print(\"\\(a) + \\(b) = \\(a+b)\")해당내용은 딱히 적을것이 없어 pass",
    "content": "나의 코드import Foundationlet n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! }let (a, b) = (n[0], n[1])print(\"\\(a) + \\(b) = \\(a+b)\")해당내용은 딱히 적을것이 없어 pass"
  },
  
  {
    "title": "5. 특수문자 출력하기",
    "url": "/posts/5.-%ED%8A%B9%EC%88%98%EB%AC%B8%EC%9E%90-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-07 05:13:00 +0900",
    





    
    "snippet": "import Foundationprint(\"!@#$%^&amp;*(\"+\"\\\\'\"+\"\\\"\"+\"&lt;&gt;?:;\")      ",
    "content": "import Foundationprint(\"!@#$%^&amp;*(\"+\"\\\\'\"+\"\\\"\"+\"&lt;&gt;?:;\")      "
  },
  
  {
    "title": "4. 대소문자 바꿔서 출력하기",
    "url": "/posts/4.-%EB%8C%80%EC%86%8C%EB%AC%B8%EC%9E%90-%EB%B0%94%EA%BF%94%EC%84%9C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-07 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationlet s1 = readLine()!var answer : String = \"\"for i in s1 {    if i.isLowercase == false {        answer += i.lowercased()    } else if i.isUppercase == false {        answer +=...",
    "content": "나의 코드import Foundationlet s1 = readLine()!var answer : String = \"\"for i in s1 {    if i.isLowercase == false {        answer += i.lowercased()    } else if i.isUppercase == false {        answer += i.uppercased()    }}print(answer)이렇게 생각한 이유스위프트는 문자열로 for문이 가능하므로 for문으로 접근을 했다.if문을 통해 대문자가 아니라면 대문자로 전환하고소문자가 아니라면 소문자로 전환하여 누적하게 하여 출력했다.  대문자 소문자 변환          uppercased() : 대문자로 변환      lowercased() : 소문자로 변환        대문자 소문자인지 확인          isLowercase : 소문자인지?      isUppercase : 대문자인지?            각각 반환타입은 Bool이다.    이것도 역시 다른 풀이를 보니 간단하게 한것이 많다.  import Foundationprint(readLine()!.map { $0.isLowercase ? $0.uppercased() : $0.lowercased() }.joined())//import Foundationlet s1 = readLine()!var answer = \"\"for s in Array(s1) {    answer += s.isUppercase ? s.lowercased() : s.uppercased()}print(answer)//import Foundationlet s1 = readLine()!print(String(s1.map{ $0.isLowercase ? Character($0.uppercased()) : Character($0.lowercased()) }))//"
  },
  
  {
    "title": "3. 문자열 반복해서 출력하기",
    "url": "/posts/3.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%B0%98%EB%B3%B5%ED%95%B4%EC%84%9C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-07 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationlet inp = readLine()!.components(separatedBy: [\" \"]).map { $0 }let (s1, a) = (inp[0], Int(inp[1])!)var answer : String = \"\"for i in 0 ... a-1 {    answer += s1}print(answer)이렇...",
    "content": "나의 코드import Foundationlet inp = readLine()!.components(separatedBy: [\" \"]).map { $0 }let (s1, a) = (inp[0], Int(inp[1])!)var answer : String = \"\"for i in 0 ... a-1 {    answer += s1}print(answer)이렇게 생각한 이유.반복문을 이용하여 풀어야한다고 생각을 했으며, 단순히 print()를 하게되면 아래와 같이 나온다는것을 생각하였다.stringstringstringstringstring그래서 새로운 변수 answer를 하나 만들어 string을 누적으로 붙이게 하였다.다른 풀이를 보니 여러 방법으로 한 것을 알았다.일단 아래에 복사를 해두고 나중에 개념을 찾아보면서 내것으로 만들어야겠다.import Foundationlet inp = readLine()!.components(separatedBy: [\" \"]).map { $0 }let (s1, a) = (inp[0], Int(inp[1])!)print(String(repeating: s1, count: a))//let inputValue = readLine()!.split(separator: \" \").map {String($0) }print(String(repeating: inputValue[0], count: Int(inputValue[1])! ))//import Foundationlet inp = readLine()!.components(separatedBy: [\" \"]).map { $0 }let (s1, a) = (inp[0], Int(inp[1])!)for i in 0 ..&lt; a {    print(s1, terminator: \"\")}"
  },
  
  {
    "title": "2. a와 b 출력하기",
    "url": "/posts/2.-_a%EC%99%80-b-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-07 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationlet n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! }let (a, b) = (n[0], n[1])print(\"a =\",a,\"\\nb =\",b)이렇게 생각한 이유.문자 보간법을 사용하여 한줄에 표기하였다.다른 코드를 보니 아래처럼 그냥 한줄에 이어서...",
    "content": "나의 코드import Foundationlet n = readLine()!.components(separatedBy: [\" \"]).map { Int($0)! }let (a, b) = (n[0], n[1])print(\"a =\",a,\"\\nb =\",b)이렇게 생각한 이유.문자 보간법을 사용하여 한줄에 표기하였다.다른 코드를 보니 아래처럼 그냥 한줄에 이어서 했다.나도 저렇게 하는게 더 이뻤을 것 같다.print(\"a = \\(a)\\nb = \\(b)\")문자보간법.  문자열 내부에 변수 var를 배치하여 더 유용하게 만드는 기능이다.  문자열 안에 모든 유형의 변수를 넣을 수 있다.  \\를 쓰고 괄호() 안에 변수이름을 입력하면 된다 ()var score = 85var str = \"Your score was \\(score)\" // Your score was 85var city = \"서울\"var message = \"Welcome to \\(city)!\" // Welcome to 서울!  문자열 보간 안에서 연산자를 사용 할 수 있다.    var age = 25\"You are \\(age) years old. In another \\(age) years you will be \\(age * 2).\"             트리플 쿼우팅          트리플 쿼우팅 혹은 멀티 라인 쿼우팅 이라고 호칭 되는 이 문법은 개행 문자를 넣지않고도, 개행을 할 수 있게 도와주는 문법이다.      print(\"hello \\n world\")// 'hello //  world'      \\n 을 사용하여 간단하게 문자열 개행을 할 수있다.        여러번 쓰게 될 때는 코드를 깔끔하게 보이기 위해 여러줄에 문자열을 나열해서 사용  let intro = \"hello !\\n\" +     \"my name is lee\\n\" +    \"nice to meet you !\"  트리플 쿼우팅은 말 그대로 “”” “”” 큰 따옴표 세개를 사용해서 우리가 코드를 읽는 그대로 개행되는 문자열을 의미한다.    let intro = \"\"\"안녕하세요 !만나서 반가워요 .잘부탁드립니다.\"\"\"print(intro)// 결과 // 안녕하세요 !// 만나서 반가워요 .// 잘부탁드립니다.      "
  },
  
  {
    "title": "1. 문자열 출력하기",
    "url": "/posts/1.-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/",
    "categories": "코딩테스트",
    "tags": "코딩테스트",
    "date": "2024-02-07 05:13:00 +0900",
    





    
    "snippet": "나의 코드import Foundationlet s1 = readLine()!print(s1)이렇게 생각한 이유.입력을 readLine으로 받기에 그것을 가지고 있는 변수 s1을 출력하였다.그렇다면readLine() 이란?  표준 입력에서 현재 줄의 끝 또는 EOF (End Of File)에 도달할 때까지 읽은 문자열을 반환한다.",
    "content": "나의 코드import Foundationlet s1 = readLine()!print(s1)이렇게 생각한 이유.입력을 readLine으로 받기에 그것을 가지고 있는 변수 s1을 출력하였다.그렇다면readLine() 이란?  표준 입력에서 현재 줄의 끝 또는 EOF (End Of File)에 도달할 때까지 읽은 문자열을 반환한다."
  },
  
  {
    "title": "4일차(끝)",
    "url": "/posts/Day4_fin/",
    "categories": "캠프, 사전학습정리",
    "tags": "",
    "date": "2024-02-05 05:13:00 +0900",
    





    
    "snippet": "테이블 뷰 구현  테이블 뷰 만들기          스토리 보드에서 드래그 앤 드롭        테이블 뷰 셀 추가하기          스토리 보드에서 드래그 앤 드롭      테이블 뷰 안에 사용되는 셀이다.        테이블 뷰 바꾸기화살표가 있는 viewController는 시작할때 해당 화면을 보여준다.Is Initial View Contro...",
    "content": "테이블 뷰 구현  테이블 뷰 만들기          스토리 보드에서 드래그 앤 드롭        테이블 뷰 셀 추가하기          스토리 보드에서 드래그 앤 드롭      테이블 뷰 안에 사용되는 셀이다.        테이블 뷰 바꾸기화살표가 있는 viewController는 시작할때 해당 화면을 보여준다.Is Initial View Controller를 체크하면 해당 view Controller를 메인 화면으로 한다.새로운 viewController 생성.      우클릭 후 New File        Cocoa Touch Class 클릭        원하는 이름의 viewController 생성.  코드를 작성후, 해당 class를 view Controller에 연결.우측 상단의 Class에서 방금 전 생성한 MyTableViewController를 연결시켜 준다.수업 코드import UIKitclass MyTableViewController: UIViewController {    @IBOutlet weak var myTableView: UITableView!        let friendsNames : [String] = [\"Henry\", \"Leeo\", \"Jay\", \"Key\"]        override func viewDidLoad() {        super.viewDidLoad()        myTableView.backgroundColor = .red        myTableView.delegate = self        // self는 여기서 MyTableViewController이다.        // delegate는 위임하는 의미.        // 즉 위의 코드는 Table와 Controller를 서로 연결해주는것.        myTableView.dataSource = self    }    }extension MyTableViewController: UITableViewDelegate, UITableViewDataSource {        // 몇줄을 보여주는지?    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {        return friendsNames.count    }        // 각 줄마다 어떤걸 넣을지?    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {        let cell = myTableView.dequeueReusableCell(withIdentifier: \"MyFirstCell\", for: indexPath)        cell.textLabel?.text = friendsNames[indexPath.row]         //각각의 셀에 FriendNames 배열에 있는 이름을 하나씩 넣는다.        // for 문을 사용하지 않아도 됨.        return cell    }}  네비게이션 및 화면 전환  하나 이상의 화면          Control누른 상태에서 Drag &amp; Drop      segue        아래 방식으로 하면 명확하게 어디가 연결되어있는지 모른다.  아래와 같이 새로운 화살표로 각 view Controller 끼리 연결 되어있는 것을 알 수 있다.실행 결과      네비게이션          우리가 어디로 가야할 지 알려주는 장치      자동으로 뒤로가기 버튼이 생긴다      네비게이션 컨트롤러   ![]   (https://velog.velcdn.com/images/haroldfromk/post/94770b39-fcc6-410a-929e-f0d30d12fc7c/image.png)            Command + Shift + L을 누르지 않고도 아래와 같은 방법으로 생성이 가능.    Command + Shift + L을 눌러서 생성하는 방법          일일이 연결을 해줘야 하므로 위의 방법을 추천한다.        실행결과          아까와는 달라진것을 알 수 있다.      show detail로 modal을 만들었다면 그다음에 show로 연결을 하더라도 modal이 뜬다.예시"
  },
  
  {
    "title": "3일차",
    "url": "/posts/Day3/",
    "categories": "캠프, 사전학습정리",
    "tags": "",
    "date": "2024-01-26 05:13:00 +0900",
    





    
    "snippet": "문제풀고 이것저것 적느라 이틀만에 수강을 한거같다.  데이터 관리          배열과 딕셔너리의 사용              배열과 딕셔너리는 비슷하면서도 굉장히 다른 컬렉션      배열 \t- 같은 형태의 데이터를 그리는데 사용                  인덱스로 접근          반복하기가 쉬움                    딕셔너리...",
    "content": "문제풀고 이것저것 적느라 이틀만에 수강을 한거같다.  데이터 관리          배열과 딕셔너리의 사용              배열과 딕셔너리는 비슷하면서도 굉장히 다른 컬렉션      배열 \t- 같은 형태의 데이터를 그리는데 사용                  인덱스로 접근          반복하기가 쉬움                    딕셔너리  \t- 키와 밸류 형태                  키 값으로 접근          반복이 아닌 접근                      데이터 모델링          데이터의 그룹 \t - 설계를 하고 개발을 하다보면 만나는 데이터들                  데이터의 틀을 만드는 작업인 모델링          의미를 부여하는 작업                    시작할때 Main인 상태에서 option을 누른채로 ViewController를 클릭하여 Main과 viewController 두 화면을 Xcode에 띄워둔다.그상태에서 view.backgroundColor = .색상을 통해 현재 main과 viewController가 잘 연결 되어있는지 확인을 해두자.아래 사진과 같다.수업 전체 코드.import UIKit// 데이터의 그룹화 중 가장 쉬운 방법은 구조체 즉 class를 쓰는것이다.struct Family {    let myName : String    let bestFriendName : String    let nextFriendName : String    let myBrother : String}class ViewController: UIViewController {        let friendsNames : [String] = [\"Henry\", \"Leeo\", \"Jay\", \"Key\"]    // index로 접근하던것을        let koreanNames : [String : String] = [\"Henry\" : \"헨리\", \"Leeo\" : \"리오\", \"Jay\" : \"제이\"]    // Key값으로 접근.        var count : Int = 0    let friend = Family(myName: \"Henry1\", bestFriendName: \"Leeo1\", nextFriendName: \"Jay1\", myBrother: \"Key1\")            @IBOutlet weak var nameLabel: UILabel!    @IBOutlet weak var bestFriendNameLabel: UILabel!    @IBOutlet weak var nextFriendNameLabel: UILabel!          override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.    }    @IBAction func didTapButton(_ sender: Any) {                nameLabel.text = friend.myName        bestFriendNameLabel.text = friend.bestFriendName        nextFriendNameLabel.text = friend.nextFriendName        //friend.myBrother                // 이 코드에서는 내가 누군지 등 누구인지는 명확하지 않다//        nameLabel.text = friendsNames[0]//        bestFriendNameLabel.text = friendsNames[1]//        nextFriendNameLabel.text = friendsNames[2]                //        let friendName = friendsNames[count]//        //        nameLabel.text = koreanNames[friendName]//        //        count = count + 1//        //        if count &gt; 2 {//            count = 0//        }    }    }주석부분은 데이터를 그룹화 하기전이다.그룹화하기전에는 배열의 인덱스 값으로 접근하였고, 그러면서 각각의 레이블에 대입을 하는 방식으로 진행이 되었다.그러다보니 실제로는 이 배열값으로 예시를 든다면, 내가 누군지, bestfriend는 누군지, nextfriend는 누군지는 정확하게 알수가 없다. 그래서 데이터를 그룹화 하기위해 class를 만들었고 struct라는 명령어를 통해 큰 틀인 Family를 만들고 그 하위에 myname, bestfriendname, nextfriendname, mybroter를 만들었다. 이렇게 되면 각각의 변수에 데이터를 대입함으로써, 각각의 데이터가 뭔지 명확하게 지정이 된다.아래는 전체 코드에서 데이터의 그룹화 관련부분만 따로 빼왔다.struct Family {    let myName : String    let bestFriendName : String    let nextFriendName : String    let myBrother : String}let friend = Family(myName: \"Henry1\", bestFriendName: \"Leeo1\", nextFriendName: \"Jay1\", myBrother: \"Key1\")"
  },
  
  {
    "title": "I Am Rich (1)",
    "url": "/posts/I-Am-Rich-(1)/",
    "categories": "Udemy, I Am Rich",
    "tags": "",
    "date": "2024-01-25 05:13:00 +0900",
    





    
    "snippet": "Label의 text를 변경하고 싶다면 해당부분을 수정해서 바꾼다.색깔은 Colorhunt 사이트를 참고하면 좋다https://colorhunt.co/맘에드는 색깔을 찾아 hex Color를 바꾸면 된다.위치와 사이즈 변경위쪽의 124, 156는 위치를 조절아래쪽의 173,48은 사이즈를 조절한다.Challenge!Add an Image ViewX p...",
    "content": "Label의 text를 변경하고 싶다면 해당부분을 수정해서 바꾼다.색깔은 Colorhunt 사이트를 참고하면 좋다https://colorhunt.co/맘에드는 색깔을 찾아 hex Color를 바꾸면 된다.위치와 사이즈 변경위쪽의 124, 156는 위치를 조절아래쪽의 173,48은 사이즈를 조절한다.Challenge!Add an Image ViewX position = 72Y position = 313Width = 270Height = 270크기가 다른 화면의 값을 알고싶다면,https://www.paintcodeapp.com/news를 참조하자."
  },
  
  {
    "title": "2일차",
    "url": "/posts/Day2/",
    "categories": "캠프, 사전학습정리",
    "tags": "",
    "date": "2024-01-23 05:13:00 +0900",
    





    
    "snippet": "사용자 인터페이스와 로직 연결IBAction 및 IBOutlet 소개  컨셉          UI를 그리는 방법 중 하나                  SwfitUI vs UIKit          Storyboard vs Code          Storyboard에서 화면과 코드를 연결하는 방법                    IBAction  ...",
    "content": "사용자 인터페이스와 로직 연결IBAction 및 IBOutlet 소개  컨셉          UI를 그리는 방법 중 하나                  SwfitUI vs UIKit          Storyboard vs Code          Storyboard에서 화면과 코드를 연결하는 방법                    IBAction  연결 방법은 드래그 앤 드롭  액션을 연결 함  우리가 어떤 액션을 했을 때, 동작 하는 트리거IBOutlet  연결 방법은 드래그 앤 드롭  컴포넌트를 연결 함      화면에 있는 뷰와 코드를 연결할 때 사용    버튼 클릭과 화면 업데이트          버튼을 눌렀을 때 동작하게      버튼 누름을 트리거로 화면이 업데이트 되는 것      코딩을 최소한으로 구현      위의 화면에서 option을 누른 채로 main을 클릭하게되면이렇게 창을 하나 더 추가 할 수 있다.Component를 클릭하고 Control을 누르고 드래그를 하여 코드쪽에 넣으면 아래 사진처럼 나온다.연결이 잘 되어있는 지 확인을 하려면 11번, 13번 사이에 12대신 새로운게 생기는데 그곳으로 포인터를 갖다 대보자.Action은 보통 override 아래에 추가한다.버튼을 눌렀을때 작동하는 코드를 작성하였다.(IBAction을 만들었다.)실제로 시뮬레이터에서 Tab을 터치하면 오른쪽 아래와 같이 안녕이 라는 단어가 출력이 되는 것을 확인 할 수 있다.command를 누른 상태에서 component같은걸 클릭하면세부 속성을 볼 수 있다.응용 문제.-&gt; Hello를 I’m Harold로 바꿔보자.import UIKitclass ViewController: UIViewController {    @IBOutlet weak var myButton: UIButton!        @IBOutlet weak var helloLabel: UILabel!        override func viewDidLoad() {        super.viewDidLoad()        // Do any additional setup after loading the view.    }        @IBAction func didTapMyButton(_ sender: Any) {        print(\"배경색을 노란색으로!\")//        view.backgroundColor = .yellow        helloLabel.text = \"I'm Harold\"    }    }option키를 누르고 변수를 클릭하면 이렇게 정보를 볼 수 있다."
  },
  
  {
    "title": "1일차 (4)",
    "url": "/posts/Day1-4/",
    "categories": "캠프, 사전학습정리",
    "tags": "",
    "date": "2024-01-22 05:13:00 +0900",
    





    
    "snippet": "조건문, 제어문  컨셉          특정 조건에 다라서 다른 상태를 만들어 주는 문법      코드의 실행 흐름을 관리하는 핵심적인 구성 요소      문법 - if  if 문은 주어진 조건이 true 일때 코드 블록을 실행  else 문은 주어진 조건이 false 일때 코드 블록을 실행    if condition {  // 조건이 true일 때...",
    "content": "조건문, 제어문  컨셉          특정 조건에 다라서 다른 상태를 만들어 주는 문법      코드의 실행 흐름을 관리하는 핵심적인 구성 요소      문법 - if  if 문은 주어진 조건이 true 일때 코드 블록을 실행  else 문은 주어진 조건이 false 일때 코드 블록을 실행    if condition {  // 조건이 true일 때 실행됩니다.} else if anotherCondition {  // 다른 조건이 true일 때 실행됩니다.} else {  // 위의 모든 조건이 false일 때 실행됩니다.}      문법 - switch  switch 문은 여러 조건을 비교할 때 사용  각각의 case는 특정 조건에 해당할 때의 코드 블록을 실행    switch value {case value1:  // value가 value1일 때 실행됩니다.case value2:  // value가 value2일 때 실행됩니다.default:  // 위의 모든 case에 해당하지 않을 때 실행됩니다.}      반복문  컨셉          같은 코드를 여러번 반복해주는 방법      코드를 간결하게 만들어 주는 방법        for item in [\"Apple\", \"Banana\", \"Cherry\"] {  // 각 아이템에 대해 실행됩니다.}for index in 1...5 {  // 1부터 5까지 실행됩니다.}                    "
  },
  
  {
    "title": "1일차 (3)",
    "url": "/posts/Day1-3/",
    "categories": "캠프, 사전학습정리",
    "tags": "",
    "date": "2024-01-22 05:13:00 +0900",
    





    
    "snippet": "Swift 기본 문법.변수와 상수  컨셉          데이터를 담아두는 공간              불러오기 위한 데이터        문법              변수(Variable) : 데이터를 저장하고 이후에 변경할 수 있는 저장 공간. var 키워드를 사용하여 선언      상수(Constant) : 한번 값이 저장되면 변경할 수 없는 저장...",
    "content": "Swift 기본 문법.변수와 상수  컨셉          데이터를 담아두는 공간              불러오기 위한 데이터        문법              변수(Variable) : 데이터를 저장하고 이후에 변경할 수 있는 저장 공간. var 키워드를 사용하여 선언      상수(Constant) : 한번 값이 저장되면 변경할 수 없는 저장 공간. let 키워드를 사용하여 선언    코드      var welcome = \"Hello World!\"  let abc = \"Welcome to my world\"            데이터 타입    컨셉          저장한데이터에는 타입이 존재      다양한 타입들에 다양한 쓰임새                  데이터의 종류만큼 존재하는 타입                      해롤 -&gt; 문자열    let name : String = \"해롤\"        20 -&gt; 정수    var age : Int = 20        3.14 -&gt; 실수    var pi : double = 3.14        true / false    var isLoggedIn: Bool = true        컬렉션          같은 타입의 여러개의 변수를 하나로 묶음.      방법에 따라 여러가지 존재.        배열(Array)          같은 데이터를 하나의 변수에 넣는 방법      code        var fruits : [String] = [\"Apple\", \"Banana\", \"Cherry\"]fruits.append(\"Date\")let firstFruit = fruits[0]. // Apple                      사전(Dictionary)          키로 밸류에 접근하는 방법      이 세상의 사전과 같은 방법        var captals: [String: String] = [\"Korea\" : \"Seoul\", \"Japan\" : \"Tokyo\"]capitals[\"China\"] = \"Beijing\"let koreanCapital = capitals.[\"korea\"] // Seoul                      집합 (Set)          순서가 없는 고유한 값들        var colors: Set&lt;String&gt; = [\"Red\", \"Green\", \"Blue\"]colors.insert(\"Yellow\")let isContainsRed = colors.contains(\"Red\")  // true                     "
  },
  
  {
    "title": "1일차 (2)",
    "url": "/posts/Day1-2/",
    "categories": "캠프, 사전학습정리",
    "tags": "",
    "date": "2024-01-22 05:13:00 +0900",
    





    
    "snippet": "Main StoryBoardNavigator가 보이지 않는다면 아래 사진처럼 하자.View Controller 는 View를 Control한다.사진처럼 View안에 View가 있지만 최하위에 있는 View역시 ViewController가 Control 한다.처음엔 여러 Component를 배치하여 inspector를 통해 조작하면서 기초를 쌓아두는게 좋다.",
    "content": "Main StoryBoardNavigator가 보이지 않는다면 아래 사진처럼 하자.View Controller 는 View를 Control한다.사진처럼 View안에 View가 있지만 최하위에 있는 View역시 ViewController가 Control 한다.처음엔 여러 Component를 배치하여 inspector를 통해 조작하면서 기초를 쌓아두는게 좋다."
  },
  
  {
    "title": "1일차 (1)",
    "url": "/posts/Day1-1/",
    "categories": "캠프, 사전학습정리",
    "tags": "",
    "date": "2024-01-22 05:13:00 +0900",
    





    
    "snippet": "#1 XCode 시작할때시작부분의 Product Name은 프로젝트 명을 의미를 한다. 보통은 CamelCase를 사용.-&gt; CamelCase : 이름을 만드는 방법 중 하나\tex) HelloWorld, ExportDefault, UsingAxeTeam은 비어있어도 됨.Organization Identifier : Webpage 주소와 비슷, 프...",
    "content": "#1 XCode 시작할때시작부분의 Product Name은 프로젝트 명을 의미를 한다. 보통은 CamelCase를 사용.-&gt; CamelCase : 이름을 만드는 방법 중 하나\tex) HelloWorld, ExportDefault, UsingAxeTeam은 비어있어도 됨.Organization Identifier : Webpage 주소와 비슷, 프로젝트의 고유 주소값이 됨. 신중하게 정해야 하나 추후 변경이 가능.보통은 com.그룹명.프로젝트명 으로 됨.ViewController &amp; design      검색  cmd+shift+L    button, image 등 표시하고 싶은 내용 검색  Drag &amp; Drop  속성 변경 (text, color, alignment 등)"
  }
  
]

