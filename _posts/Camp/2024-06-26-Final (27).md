---
title: Final (27)
writer: Harold
date: 2024-06-26 01:00
categories: [캠프, TheLast]
tags: []
toc: true
toc_sticky: true
---

## 프로필 수정에서 닉네임 중복 확인

### 주요 변경 사항
- `Combine`을 이용한 닉네임 중복 확인 로직 추가
- `ManageViewModel`과 `ManageManager`를 통해 사용자 목록을 조회
- `checkNickname()` 내에서 닉네임이 비어 있을 경우, 중복 검사를 거쳐 `updateUserName()` 호출
- `viewWillAppear` 시점에서 `checkNickname()` 실행되도록 이동
- `cancellables`와 `viewModel` 프로퍼티 추가

### 코드 변경 요약

#### 닉네임 중복 검사 로직 추가

```swift
private func validateNickname(nickName: String, completion: @escaping ((Bool) -> Void)) {
    let manageManager = ManageManager()
    self.viewModel = ManageViewModel(manageManager: manageManager)

    self.viewModel?.getUsers {
        if self.viewModel?.userArray.contains(where: { $0.nickName == nickName }) == false {
            completion(true)
        } else {
            completion(false)
        }
    }
}
```

#### showNameAlert 수정 (중복 처리 포함)

```swift
self?.validateNickname(nickName: newName) { result in
    switch result {
    case true:
        self?.updateUserName(uid: uid, newName: newName)
    case false:
        self?.showMessage(title: "중복 확인", message: "현재 닉네임은 이미 존재합니다.") {
            self?.showNameAlert(uid: uid)
        }
    }
}
```
#### viewWillAppear 내 checkNickname 호출 위치 변경

- 기존에는 viewDidLoad에서만 호출
- → `viewWillAppear` 내로 이동하여 뷰가 다시 나타날 때마다 검사하도록 개선

---

### 변경 이유
- 사용자 최초 접속 시 닉네임이 비어 있거나 중복될 가능성을 차단하기 위함
- 채팅 채널 접속 전 사용자 정보의 신뢰성을 보장
- Combine과 MVVM 구조를 활용해 뷰컨트롤러의 책임을 분산시킴

## ManageViewModel 함수 추가

```swift
func getUsers() {
        manageManager.fetchUsers { [weak self] error, dataSnapshot in
            self?.userArray.removeAll()
            if let error = error {
                self?.managePublisher.send(completion: .failure(error))
            }
            guard let dictionary = dataSnapshot?.value as? [String: [String: Any]] else { return }
            
            for (uid, userDict) in dictionary {
                let email = userDict[db_email] as? String ?? ""
                let nickName = userDict[db_nickName] as? String ?? ""
                let profileImageUrl = userDict[db_profileImageUrl] as? String ?? ""
                let isBlockInt = userDict[db_isBlock] as? Int ?? 0
                let isBlock = isBlockInt != 0
                
                let model = UserModel(uid: uid, email: email, isBlock: isBlock, nickName: nickName, profileImageUrl: profileImageUrl)
                self?.userArray.append(model)
            }
            self?.managePublisher.send(())
        }
    }
```

- 정리
    - `fetchUsers()` 메서드를 통해 Firebase에서 사용자 데이터를 가져옴
    - `UserModel`로 파싱하여 배열에 저장
    - 완료 후 `managePublisher`를 통해 성공 여부 알림 (`Void`, `.failure(error)` 형태)
- 목적
    - 닉네임 중복 검사 등 사용자 정보를 참조해야 하는 ViewModel 로직에서 사용
    - 주로 ChannelVC에서 닉네임 입력 시 중복 확인 용도로 활용


## 예외처리

### 핵심 변경 사항

- **currentUser / customUser 조건 처리**
  - `ChatVC` 전환 시 `User` 또는 `CustomUser` 타입에 따라 ViewController를 다르게 초기화함
  - 인증된 유저일 경우 닉네임 유효성(`isValidate`) 검사 후 채팅 가능

- **닉네임 중복 검증 기능 추가**
  - `ManageViewModel`을 사용하여 Firebase RealtimeDatabase에서 유저 목록을 조회
  - 동일 닉네임이 존재할 경우 다시 입력을 요구하는 알림창 반복 표시

- **예외 처리 강화**
  - 닉네임이 설정되지 않았을 경우 채팅 진입을 막고 Alert을 통해 입력을 유도
  - Combine을 통해 닉네임 유효 여부를 비동기로 처리

### 주요 코드 설명

닉네임 유효성 검증 로직:

```swift
validateNickname(nickName:completion:) {
  viewModel.getUsers {
    if 중복 없음 {
      completion(true)
    } else {
      completion(false)
    }
  }
}
```
채팅방 진입 전 조건 처리:

```swift
if let user = currentUser {
  if isValidate {
    viewController = ChatVC(user: user, channel: channel)
    viewController?.isLocation = isLocation
  } else {
    showNameAlert(uid: uid)
    return
  }
} else if let customUser = customUser {
  viewController = ChatVC(customUser: customUser, channel: channel)
}
```
닉네임 입력 유도 Alert:

```swift
showNameAlert(uid:) {
  UIAlertController(title: "Enter Name", ...)
  닉네임이 중복되면 showNameAlert 재호출
}
```

- 인증 유저 여부 및 닉네임 상태에 따라 채팅 진입 흐름을 엄격히 관리
- UIKit 환경에서 Combine과 MVVM 패턴을 적절히 활용하여 안정적인 흐름 구현